(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("@angular/core"), require("@angular/common"), require("rxjs/ReplaySubject"), require("@angular/router"), require("@angular/platform-browser"), require("rxjs/BehaviorSubject"), require("rxjs/observable/of"), require("rxjs/observable/fromPromise"), require("rxjs/observable/combineLatest"), require("rxjs/operator/switchMap"), require("rxjs/operator/map"), require("rxjs/operator/concat"), require("rxjs/add/operator/mergeMap"), require("rxjs/add/operator/map"), require("rxjs/add/operator/filter"));
	else if(typeof define === 'function' && define.amd)
		define(["@angular/core", "@angular/common", "rxjs/ReplaySubject", "@angular/router", "@angular/platform-browser", "rxjs/BehaviorSubject", "rxjs/observable/of", "rxjs/observable/fromPromise", "rxjs/observable/combineLatest", "rxjs/operator/switchMap", "rxjs/operator/map", "rxjs/operator/concat", "rxjs/add/operator/mergeMap", "rxjs/add/operator/map", "rxjs/add/operator/filter"], factory);
	else if(typeof exports === 'object')
		exports["ngx-translate-core"] = factory(require("@angular/core"), require("@angular/common"), require("rxjs/ReplaySubject"), require("@angular/router"), require("@angular/platform-browser"), require("rxjs/BehaviorSubject"), require("rxjs/observable/of"), require("rxjs/observable/fromPromise"), require("rxjs/observable/combineLatest"), require("rxjs/operator/switchMap"), require("rxjs/operator/map"), require("rxjs/operator/concat"), require("rxjs/add/operator/mergeMap"), require("rxjs/add/operator/map"), require("rxjs/add/operator/filter"));
	else
		root["ngx-translate-core"] = factory(root["@angular/core"], root["@angular/common"], root["rxjs/ReplaySubject"], root["@angular/router"], root["@angular/platform-browser"], root["rxjs/BehaviorSubject"], root["rxjs/observable/of"], root["rxjs/observable/fromPromise"], root["rxjs/observable/combineLatest"], root["rxjs/operator/switchMap"], root["rxjs/operator/map"], root["rxjs/operator/concat"], root["rxjs/add/operator/mergeMap"], root["rxjs/add/operator/map"], root["rxjs/add/operator/filter"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_10__, __WEBPACK_EXTERNAL_MODULE_24__, __WEBPACK_EXTERNAL_MODULE_25__, __WEBPACK_EXTERNAL_MODULE_70__, __WEBPACK_EXTERNAL_MODULE_95__, __WEBPACK_EXTERNAL_MODULE_96__, __WEBPACK_EXTERNAL_MODULE_97__, __WEBPACK_EXTERNAL_MODULE_98__, __WEBPACK_EXTERNAL_MODULE_99__, __WEBPACK_EXTERNAL_MODULE_100__, __WEBPACK_EXTERNAL_MODULE_101__, __WEBPACK_EXTERNAL_MODULE_104__, __WEBPACK_EXTERNAL_MODULE_105__, __WEBPACK_EXTERNAL_MODULE_108__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 71);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Random utility functions used in the UI-Router code
 *
 * These functions are exported, but are subject to change without notice.
 *
 * @preferred
 * @module common
 */
/** for typedoc */
var predicates_1 = __webpack_require__(1);
var hof_1 = __webpack_require__(2);
var coreservices_1 = __webpack_require__(5);
exports.root = (typeof self === 'object' && self.self === self && self) ||
    (typeof global === 'object' && global.global === global && global) || this;
var angular = exports.root.angular || {};
exports.fromJson = angular.fromJson || JSON.parse.bind(JSON);
exports.toJson = angular.toJson || JSON.stringify.bind(JSON);
exports.forEach = angular.forEach || _forEach;
exports.extend = Object.assign || _extend;
exports.equals = angular.equals || _equals;
function identity(x) { return x; }
exports.identity = identity;
function noop() { }
exports.noop = noop;
/**
 * Builds proxy functions on the `to` object which pass through to the `from` object.
 *
 * For each key in `fnNames`, creates a proxy function on the `to` object.
 * The proxy function calls the real function on the `from` object.
 *
 *
 * #### Example:
 * This example creates an new class instance whose functions are prebound to the new'd object.
 * ```js
 * class Foo {
 *   constructor(data) {
 *     // Binds all functions from Foo.prototype to 'this',
 *     // then copies them to 'this'
 *     bindFunctions(Foo.prototype, this, this);
 *     this.data = data;
 *   }
 *
 *   log() {
 *     console.log(this.data);
 *   }
 * }
 *
 * let myFoo = new Foo([1,2,3]);
 * var logit = myFoo.log;
 * logit(); // logs [1, 2, 3] from the myFoo 'this' instance
 * ```
 *
 * #### Example:
 * This example creates a bound version of a service function, and copies it to another object
 * ```
 *
 * var SomeService = {
 *   this.data = [3, 4, 5];
 *   this.log = function() {
 *     console.log(this.data);
 *   }
 * }
 *
 * // Constructor fn
 * function OtherThing() {
 *   // Binds all functions from SomeService to SomeService,
 *   // then copies them to 'this'
 *   bindFunctions(SomeService, this, SomeService);
 * }
 *
 * let myOtherThing = new OtherThing();
 * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'
 * ```
 *
 * @param source A function that returns the source object which contains the original functions to be bound
 * @param target A function that returns the target object which will receive the bound functions
 * @param bind A function that returns the object which the functions will be bound to
 * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)
 * @param latebind If true, the binding of the function is delayed until the first time it's invoked
 */
function createProxyFunctions(source, target, bind, fnNames, latebind) {
    if (latebind === void 0) { latebind = false; }
    var bindFunction = function (fnName) {
        return source()[fnName].bind(bind());
    };
    var makeLateRebindFn = function (fnName) { return function lateRebindFunction() {
        target[fnName] = bindFunction(fnName);
        return target[fnName].apply(null, arguments);
    }; };
    fnNames = fnNames || Object.keys(source());
    return fnNames.reduce(function (acc, name) {
        acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);
        return acc;
    }, target);
}
exports.createProxyFunctions = createProxyFunctions;
/**
 * prototypal inheritance helper.
 * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it
 */
exports.inherit = function (parent, extra) {
    return exports.extend(Object.create(parent), extra);
};
/** Given an array, returns true if the object is found in the array, (using indexOf) */
exports.inArray = hof_1.curry(_inArray);
function _inArray(array, obj) {
    return array.indexOf(obj) !== -1;
}
exports._inArray = _inArray;
/**
 * Given an array, and an item, if the item is found in the array, it removes it (in-place).
 * The same array is returned
 */
exports.removeFrom = hof_1.curry(_removeFrom);
function _removeFrom(array, obj) {
    var idx = array.indexOf(obj);
    if (idx >= 0)
        array.splice(idx, 1);
    return array;
}
exports._removeFrom = _removeFrom;
/** pushes a values to an array and returns the value */
exports.pushTo = hof_1.curry(_pushTo);
function _pushTo(arr, val) {
    return (arr.push(val), val);
}
exports._pushTo = _pushTo;
/** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */
exports.deregAll = function (functions) {
    return functions.slice().forEach(function (fn) {
        typeof fn === 'function' && fn();
        exports.removeFrom(functions, fn);
    });
};
/**
 * Applies a set of defaults to an options object.  The options object is filtered
 * to only those properties of the objects in the defaultsList.
 * Earlier objects in the defaultsList take precedence when applying defaults.
 */
function defaults(opts) {
    var defaultsList = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        defaultsList[_i - 1] = arguments[_i];
    }
    var _defaultsList = defaultsList.concat({}).reverse();
    var defaultVals = exports.extend.apply(null, _defaultsList);
    return exports.extend({}, defaultVals, pick(opts || {}, Object.keys(defaultVals)));
}
exports.defaults = defaults;
/** Reduce function that merges each element of the list into a single object, using extend */
exports.mergeR = function (memo, item) { return exports.extend(memo, item); };
/**
 * Finds the common ancestor path between two states.
 *
 * @param {Object} first The first state.
 * @param {Object} second The second state.
 * @return {Array} Returns an array of state names in descending order, not including the root.
 */
function ancestors(first, second) {
    var path = [];
    for (var n in first.path) {
        if (first.path[n] !== second.path[n])
            break;
        path.push(first.path[n]);
    }
    return path;
}
exports.ancestors = ancestors;
/**
 * Return a copy of the object only containing the whitelisted properties.
 *
 * #### Example:
 * ```
 * var foo = { a: 1, b: 2, c: 3 };
 * var ab = pick(foo, ['a', 'b']); // { a: 1, b: 2 }
 * ```
 * @param obj the source object
 * @param propNames an Array of strings, which are the whitelisted property names
 */
function pick(obj, propNames) {
    var objCopy = {};
    for (var prop_1 in obj) {
        if (propNames.indexOf(prop_1) !== -1) {
            objCopy[prop_1] = obj[prop_1];
        }
    }
    return objCopy;
}
exports.pick = pick;
/**
 * Return a copy of the object omitting the blacklisted properties.
 *
 * @example
 * ```
 *
 * var foo = { a: 1, b: 2, c: 3 };
 * var ab = omit(foo, ['a', 'b']); // { c: 3 }
 * ```
 * @param obj the source object
 * @param propNames an Array of strings, which are the blacklisted property names
 */
function omit(obj, propNames) {
    return Object.keys(obj)
        .filter(hof_1.not(exports.inArray(propNames)))
        .reduce(function (acc, key) { return (acc[key] = obj[key], acc); }, {});
}
exports.omit = omit;
/**
 * Maps an array, or object to a property (by name)
 */
function pluck(collection, propName) {
    return map(collection, hof_1.prop(propName));
}
exports.pluck = pluck;
/** Filters an Array or an Object's properties based on a predicate */
function filter(collection, callback) {
    var arr = predicates_1.isArray(collection), result = arr ? [] : {};
    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };
    exports.forEach(collection, function (item, i) {
        if (callback(item, i))
            accept(item, i);
    });
    return result;
}
exports.filter = filter;
/** Finds an object from an array, or a property of an object, that matches a predicate */
function find(collection, callback) {
    var result;
    exports.forEach(collection, function (item, i) {
        if (result)
            return;
        if (callback(item, i))
            result = item;
    });
    return result;
}
exports.find = find;
/** Given an object, returns a new object, where each property is transformed by the callback function */
exports.mapObj = map;
/** Maps an array or object properties using a callback function */
function map(collection, callback) {
    var result = predicates_1.isArray(collection) ? [] : {};
    exports.forEach(collection, function (item, i) { return result[i] = callback(item, i); });
    return result;
}
exports.map = map;
/**
 * Given an object, return its enumerable property values
 *
 * @example
 * ```
 *
 * let foo = { a: 1, b: 2, c: 3 }
 * let vals = values(foo); // [ 1, 2, 3 ]
 * ```
 */
exports.values = function (obj) {
    return Object.keys(obj).map(function (key) { return obj[key]; });
};
/**
 * Reduce function that returns true if all of the values are truthy.
 *
 * @example
 * ```
 *
 * let vals = [ 1, true, {}, "hello world"];
 * vals.reduce(allTrueR, true); // true
 *
 * vals.push(0);
 * vals.reduce(allTrueR, true); // false
 * ```
 */
exports.allTrueR = function (memo, elem) { return memo && elem; };
/**
 * Reduce function that returns true if any of the values are truthy.
 *
 *  * @example
 * ```
 *
 * let vals = [ 0, null, undefined ];
 * vals.reduce(anyTrueR, true); // false
 *
 * vals.push("hello world");
 * vals.reduce(anyTrueR, true); // true
 * ```
 */
exports.anyTrueR = function (memo, elem) { return memo || elem; };
/**
 * Reduce function which un-nests a single level of arrays
 * @example
 * ```
 *
 * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
 * input.reduce(unnestR, []) // [ "a", "b", "c", "d", [ "double, "nested" ] ]
 * ```
 */
exports.unnestR = function (memo, elem) { return memo.concat(elem); };
/**
 * Reduce function which recursively un-nests all arrays
 *
 * @example
 * ```
 *
 * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
 * input.reduce(unnestR, []) // [ "a", "b", "c", "d", "double, "nested" ]
 * ```
 */
exports.flattenR = function (memo, elem) {
    return predicates_1.isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : pushR(memo, elem);
};
/**
 * Reduce function that pushes an object to an array, then returns the array.
 * Mostly just for [[flattenR]] and [[uniqR]]
 */
function pushR(arr, obj) {
    arr.push(obj);
    return arr;
}
exports.pushR = pushR;
/** Reduce function that filters out duplicates */
exports.uniqR = function (acc, token) {
    return exports.inArray(acc, token) ? acc : pushR(acc, token);
};
/**
 * Return a new array with a single level of arrays unnested.
 *
 * @example
 * ```
 *
 * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
 * unnest(input) // [ "a", "b", "c", "d", [ "double, "nested" ] ]
 * ```
 */
exports.unnest = function (arr) { return arr.reduce(exports.unnestR, []); };
/**
 * Return a completely flattened version of an array.
 *
 * @example
 * ```
 *
 * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
 * flatten(input) // [ "a", "b", "c", "d", "double, "nested" ]
 * ```
 */
exports.flatten = function (arr) { return arr.reduce(exports.flattenR, []); };
/**
 * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.
 * @example
 * ```
 *
 * let isNumber = (obj) => typeof(obj) === 'number';
 * let allNumbers = [ 1, 2, 3, 4, 5 ];
 * allNumbers.filter(assertPredicate(isNumber)); //OK
 *
 * let oneString = [ 1, 2, 3, 4, "5" ];
 * oneString.filter(assertPredicate(isNumber, "Not all numbers")); // throws Error(""Not all numbers"");
 * ```
 */
exports.assertPredicate = assertFn;
/**
 * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.
 * @example
 * ```
 *
 * var data = { foo: 1, bar: 2 };
 *
 * let keys = [ 'foo', 'bar' ]
 * let values = keys.map(assertMap(key => data[key], "Key not found"));
 * // values is [1, 2]
 *
 * let keys = [ 'foo', 'bar', 'baz' ]
 * let values = keys.map(assertMap(key => data[key], "Key not found"));
 * // throws Error("Key not found")
 * ```
 */
exports.assertMap = assertFn;
function assertFn(predicateOrMap, errMsg) {
    if (errMsg === void 0) { errMsg = "assert failure"; }
    return function (obj) {
        var result = predicateOrMap(obj);
        if (!result) {
            throw new Error(predicates_1.isFunction(errMsg) ? errMsg(obj) : errMsg);
        }
        return result;
    };
}
exports.assertFn = assertFn;
/**
 * Like _.pairs: Given an object, returns an array of key/value pairs
 *
 * @example
 * ```
 *
 * pairs({ foo: "FOO", bar: "BAR }) // [ [ "foo", "FOO" ], [ "bar": "BAR" ] ]
 * ```
 */
exports.pairs = function (obj) {
    return Object.keys(obj).map(function (key) { return [key, obj[key]]; });
};
/**
 * Given two or more parallel arrays, returns an array of tuples where
 * each tuple is composed of [ a[i], b[i], ... z[i] ]
 *
 * @example
 * ```
 *
 * let foo = [ 0, 2, 4, 6 ];
 * let bar = [ 1, 3, 5, 7 ];
 * let baz = [ 10, 30, 50, 70 ];
 * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]
 * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]
 * ```
 */
function arrayTuples() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (args.length === 0)
        return [];
    var maxArrayLen = args.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53 − 1 aka Number.MAX_SAFE_INTEGER
    var i, result = [];
    for (i = 0; i < maxArrayLen; i++) {
        // This is a hot function
        // Unroll when there are 1-4 arguments
        switch (args.length) {
            case 1:
                result.push([args[0][i]]);
                break;
            case 2:
                result.push([args[0][i], args[1][i]]);
                break;
            case 3:
                result.push([args[0][i], args[1][i], args[2][i]]);
                break;
            case 4:
                result.push([args[0][i], args[1][i], args[2][i], args[3][i]]);
                break;
            default:
                result.push(args.map(function (array) { return array[i]; }));
                break;
        }
    }
    return result;
}
exports.arrayTuples = arrayTuples;
/**
 * Reduce function which builds an object from an array of [key, value] pairs.
 *
 * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.
 *
 * Each keyValueTuple should be an array with values [ key: string, value: any ]
 *
 * @example
 * ```
 *
 * var pairs = [ ["fookey", "fooval"], ["barkey", "barval"] ]
 *
 * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})
 * // pairsToObj == { fookey: "fooval", barkey: "barval" }
 *
 * // Or, more simply:
 * var pairsToObj = pairs.reduce(applyPairs, {})
 * // pairsToObj == { fookey: "fooval", barkey: "barval" }
 * ```
 */
function applyPairs(memo, keyValTuple) {
    var key, value;
    if (predicates_1.isArray(keyValTuple))
        key = keyValTuple[0], value = keyValTuple[1];
    if (!predicates_1.isString(key))
        throw new Error("invalid parameters to applyPairs");
    memo[key] = value;
    return memo;
}
exports.applyPairs = applyPairs;
/** Get the last element of an array */
function tail(arr) {
    return arr.length && arr[arr.length - 1] || undefined;
}
exports.tail = tail;
/**
 * shallow copy from src to dest
 */
function copy(src, dest) {
    if (dest)
        Object.keys(dest).forEach(function (key) { return delete dest[key]; });
    if (!dest)
        dest = {};
    return exports.extend(dest, src);
}
exports.copy = copy;
/** Naive forEach implementation works with Objects or Arrays */
function _forEach(obj, cb, _this) {
    if (predicates_1.isArray(obj))
        return obj.forEach(cb, _this);
    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });
}
function _extend(toObj) {
    for (var i = 1; i < arguments.length; i++) {
        var obj = arguments[i];
        if (!obj)
            continue;
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; j++) {
            toObj[keys[j]] = obj[keys[j]];
        }
    }
    return toObj;
}
exports._extend = _extend;
function _equals(o1, o2) {
    if (o1 === o2)
        return true;
    if (o1 === null || o2 === null)
        return false;
    if (o1 !== o1 && o2 !== o2)
        return true; // NaN === NaN
    var t1 = typeof o1, t2 = typeof o2;
    if (t1 !== t2 || t1 !== 'object')
        return false;
    var tup = [o1, o2];
    if (hof_1.all(predicates_1.isArray)(tup))
        return _arraysEq(o1, o2);
    if (hof_1.all(predicates_1.isDate)(tup))
        return o1.getTime() === o2.getTime();
    if (hof_1.all(predicates_1.isRegExp)(tup))
        return o1.toString() === o2.toString();
    if (hof_1.all(predicates_1.isFunction)(tup))
        return true; // meh
    var predicates = [predicates_1.isFunction, predicates_1.isArray, predicates_1.isDate, predicates_1.isRegExp];
    if (predicates.map(hof_1.any).reduce(function (b, fn) { return b || !!fn(tup); }, false))
        return false;
    var key, keys = {};
    for (key in o1) {
        if (!_equals(o1[key], o2[key]))
            return false;
        keys[key] = true;
    }
    for (key in o2) {
        if (!keys[key])
            return false;
    }
    return true;
}
function _arraysEq(a1, a2) {
    if (a1.length !== a2.length)
        return false;
    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);
}
// issue #2676
exports.silenceUncaughtInPromise = function (promise) {
    return promise.catch(function (e) { return 0; }) && promise;
};
exports.silentRejection = function (error) {
    return exports.silenceUncaughtInPromise(coreservices_1.services.$q.reject(error));
};
//# sourceMappingURL=common.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(73)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** Predicates
 *
 * These predicates return true/false based on the input.
 * Although these functions are exported, they are subject to change without notice.
 *
 * @module common_predicates
 */
/** */
var hof_1 = __webpack_require__(2);
var stateObject_1 = __webpack_require__(26);
var toStr = Object.prototype.toString;
var tis = function (t) { return function (x) { return typeof (x) === t; }; };
exports.isUndefined = tis('undefined');
exports.isDefined = hof_1.not(exports.isUndefined);
exports.isNull = function (o) { return o === null; };
exports.isNullOrUndefined = hof_1.or(exports.isNull, exports.isUndefined);
exports.isFunction = tis('function');
exports.isNumber = tis('number');
exports.isString = tis('string');
exports.isObject = function (x) { return x !== null && typeof x === 'object'; };
exports.isArray = Array.isArray;
exports.isDate = (function (x) { return toStr.call(x) === '[object Date]'; });
exports.isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });
exports.isState = stateObject_1.StateObject.isState;
/**
 * Predicate which checks if a value is injectable
 *
 * A value is "injectable" if it is a function, or if it is an ng1 array-notation-style array
 * where all the elements in the array are Strings, except the last one, which is a Function
 */
function isInjectable(val) {
    if (exports.isArray(val) && val.length) {
        var head = val.slice(0, -1), tail = val.slice(-1);
        return !(head.filter(hof_1.not(exports.isString)).length || tail.filter(hof_1.not(exports.isFunction)).length);
    }
    return exports.isFunction(val);
}
exports.isInjectable = isInjectable;
/**
 * Predicate which checks if a value looks like a Promise
 *
 * It is probably a Promise if it's an object, and it has a `then` property which is a Function
 */
exports.isPromise = hof_1.and(exports.isObject, hof_1.pipe(hof_1.prop('then'), exports.isFunction));
//# sourceMappingURL=predicates.js.map

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Higher order functions
 *
 * These utility functions are exported, but are subject to change without notice.
 *
 * @module common_hof
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.
 *
 * Given a function with N parameters, returns a new function that supports partial application.
 * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,
 * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to
 * accept more parameters until all N parameters have been supplied.
 *
 *
 * This contrived example uses a partially applied function as an predicate, which returns true
 * if an object is found in both arrays.
 * @example
 * ```
 * // returns true if an object is in both of the two arrays
 * function inBoth(array1, array2, object) {
 *   return array1.indexOf(object) !== -1 &&
 *          array2.indexOf(object) !== 1;
 * }
 * let obj1, obj2, obj3, obj4, obj5, obj6, obj7
 * let foos = [obj1, obj3]
 * let bars = [obj3, obj4, obj5]
 *
 * // A curried "copy" of inBoth
 * let curriedInBoth = curry(inBoth);
 * // Partially apply both the array1 and array2
 * let inFoosAndBars = curriedInBoth(foos, bars);
 *
 * // Supply the final argument; since all arguments are
 * // supplied, the original inBoth function is then called.
 * let obj1InBoth = inFoosAndBars(obj1); // false
 *
 * // Use the inFoosAndBars as a predicate.
 * // Filter, on each iteration, supplies the final argument
 * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];
 * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]
 *
 * ```
 *
 * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function
 *
 * @param fn
 * @returns {*|function(): (*|any)}
 */
function curry(fn) {
    var initial_args = [].slice.apply(arguments, [1]);
    var func_args_length = fn.length;
    function curried(args) {
        if (args.length >= func_args_length)
            return fn.apply(null, args);
        return function () {
            return curried(args.concat([].slice.apply(arguments)));
        };
    }
    return curried(initial_args);
}
exports.curry = curry;
/**
 * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left
 * given: f(x), g(x), h(x)
 * let composed = compose(f,g,h)
 * then, composed is: f(g(h(x)))
 */
function compose() {
    var args = arguments;
    var start = args.length - 1;
    return function () {
        var i = start, result = args[start].apply(this, arguments);
        while (i--)
            result = args[i].call(this, result);
        return result;
    };
}
exports.compose = compose;
/**
 * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right
 * given: f(x), g(x), h(x)
 * let piped = pipe(f,g,h);
 * then, piped is: h(g(f(x)))
 */
function pipe() {
    var funcs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        funcs[_i] = arguments[_i];
    }
    return compose.apply(null, [].slice.call(arguments).reverse());
}
exports.pipe = pipe;
/**
 * Given a property name, returns a function that returns that property from an object
 * let obj = { foo: 1, name: "blarg" };
 * let getName = prop("name");
 * getName(obj) === "blarg"
 */
exports.prop = function (name) {
    return function (obj) { return obj && obj[name]; };
};
/**
 * Given a property name and a value, returns a function that returns a boolean based on whether
 * the passed object has a property that matches the value
 * let obj = { foo: 1, name: "blarg" };
 * let getName = propEq("name", "blarg");
 * getName(obj) === true
 */
exports.propEq = curry(function (name, val, obj) { return obj && obj[name] === val; });
/**
 * Given a dotted property name, returns a function that returns a nested property from an object, or undefined
 * let obj = { id: 1, nestedObj: { foo: 1, name: "blarg" }, };
 * let getName = prop("nestedObj.name");
 * getName(obj) === "blarg"
 * let propNotFound = prop("this.property.doesnt.exist");
 * propNotFound(obj) === undefined
 */
exports.parse = function (name) {
    return pipe.apply(null, name.split(".").map(exports.prop));
};
/**
 * Given a function that returns a truthy or falsey value, returns a
 * function that returns the opposite (falsey or truthy) value given the same inputs
 */
exports.not = function (fn) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return !fn.apply(null, args);
    };
};
/**
 * Given two functions that return truthy or falsey values, returns a function that returns truthy
 * if both functions return truthy for the given arguments
 */
function and(fn1, fn2) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return fn1.apply(null, args) && fn2.apply(null, args);
    };
}
exports.and = and;
/**
 * Given two functions that return truthy or falsey values, returns a function that returns truthy
 * if at least one of the functions returns truthy for the given arguments
 */
function or(fn1, fn2) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return fn1.apply(null, args) || fn2.apply(null, args);
    };
}
exports.or = or;
/**
 * Check if all the elements of an array match a predicate function
 *
 * @param fn1 a predicate function `fn1`
 * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array
 */
exports.all = function (fn1) {
    return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); };
};
exports.any = function (fn1) {
    return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); };
};
/** Given a class, returns a Predicate function that returns true if the object is of that class */
exports.is = function (ctor) {
    return function (obj) {
        return (obj != null && obj.constructor === ctor || obj instanceof ctor);
    };
};
/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */
exports.eq = function (val) { return function (other) {
    return val === other;
}; };
/** Given a value, returns a function which returns the value */
exports.val = function (v) { return function () { return v; }; };
function invoke(fnName, args) {
    return function (obj) {
        return obj[fnName].apply(obj, args);
    };
}
exports.invoke = invoke;
/**
 * Sorta like Pattern Matching (a functional programming conditional construct)
 *
 * See http://c2.com/cgi/wiki?PatternMatching
 *
 * This is a conditional construct which allows a series of predicates and output functions
 * to be checked and then applied.  Each predicate receives the input.  If the predicate
 * returns truthy, then its matching output function (mapping function) is provided with
 * the input and, then the result is returned.
 *
 * Each combination (2-tuple) of predicate + output function should be placed in an array
 * of size 2: [ predicate, mapFn ]
 *
 * These 2-tuples should be put in an outer array.
 *
 * @example
 * ```
 *
 * // Here's a 2-tuple where the first element is the isString predicate
 * // and the second element is a function that returns a description of the input
 * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];
 *
 * // Second tuple: predicate "isNumber", mapfn returns a description
 * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];
 *
 * let third = [ (input) => input === null,  (input) => `Oh, null...` ];
 *
 * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];
 *
 * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);
 *
 * console.log(descriptionOf(undefined)); // 'notdefined'
 * console.log(descriptionOf(55)); // '(55) That's a number!'
 * console.log(descriptionOf("foo")); // 'Here's your string foo'
 * ```
 *
 * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,
 * with a Predicate and a mapping/output function
 * @returns {function(any): *}
 */
function pattern(struct) {
    return function (x) {
        for (var i = 0; i < struct.length; i++) {
            if (struct[i][0](x))
                return struct[i][1](x);
        }
    };
}
exports.pattern = pattern;
//# sourceMappingURL=hof.js.map

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @coreapi
 * @module common
 */ /** */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(7));
__export(__webpack_require__(74));
__export(__webpack_require__(75));
__export(__webpack_require__(76));
__export(__webpack_require__(77));
__export(__webpack_require__(87));
__export(__webpack_require__(88));
__export(__webpack_require__(89));
__export(__webpack_require__(53));
__export(__webpack_require__(48));
__export(__webpack_require__(90));
__export(__webpack_require__(93));
//# sourceMappingURL=index.js.map

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.notImplemented = function (fnname) { return function () {
    throw new Error(fnname + "(): No coreservices implementation for UI-Router is loaded.");
}; };
var services = {
    $q: undefined,
    $injector: undefined,
};
exports.services = services;
//# sourceMappingURL=coreservices.js.map

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var ReplaySubject_1 = __webpack_require__(24);
var common_1 = __webpack_require__(10);
var router_1 = __webpack_require__(25);
var angular_1 = __webpack_require__(72);
__webpack_require__(108);
var Angulartics2 = /** @class */ (function () {
    function Angulartics2(location, router, transitionService, urlService) {
        this.settings = {
            pageTracking: {
                autoTrackVirtualPages: true,
                basePath: '',
                excludedRoutes: []
            },
            eventTracking: {},
            developerMode: false
        };
        /*
          @Param: ({url: string, location: Location})
         */
        this.pageTrack = new ReplaySubject_1.ReplaySubject(10);
        /*
          @Param: ({action: any, properties: any})
         */
        this.eventTrack = new ReplaySubject_1.ReplaySubject(10);
        /*
          @Param: (properties: any)
         */
        this.exceptionTrack = new ReplaySubject_1.ReplaySubject(10);
        /*
          @Param: (alias: string)
         */
        this.setAlias = new ReplaySubject_1.ReplaySubject(10);
        /*
          @Param: (userId: string)
         */
        this.setUsername = new ReplaySubject_1.ReplaySubject(10);
        /*
          @Param: ({action: any, properties: any})
         */
        this.setUserProperties = new ReplaySubject_1.ReplaySubject(10);
        /*
          @Param: (properties: any)
         */
        this.setUserPropertiesOnce = new ReplaySubject_1.ReplaySubject(10);
        /*
          @Param: (properties: any)
         */
        this.setSuperProperties = new ReplaySubject_1.ReplaySubject(10);
        /*
          @Param: (properties: any)
         */
        this.setSuperPropertiesOnce = new ReplaySubject_1.ReplaySubject(10);
        /*
          @Param: (properties: any)
         */
        this.userTimings = new ReplaySubject_1.ReplaySubject(10);
        if (router) {
            this.trackLocationWithRouter(location, router);
        }
        if (transitionService && urlService) {
            this.trackLocationWithTransition(location, transitionService, urlService);
        }
    }
    Angulartics2.prototype.trackLocationWithRouter = function (location, router) {
        var _this = this;
        router.events
            .filter(function (event) { return event instanceof router_1.NavigationEnd; })
            .subscribe(function (event) {
            if (!_this.settings.developerMode) {
                _this.trackUrlChange(event.urlAfterRedirects, location);
            }
        });
    };
    Angulartics2.prototype.trackLocationWithTransition = function (location, transitionService, urlService) {
        var _this = this;
        transitionService.onFinish({}, function (transition) {
            if (!_this.settings.developerMode) {
                _this.trackUrlChange(urlService.path(), location);
            }
        });
    };
    Angulartics2.prototype.virtualPageviews = function (value) {
        this.settings.pageTracking.autoTrackVirtualPages = value;
    };
    Angulartics2.prototype.excludeRoutes = function (routes) {
        this.settings.pageTracking.excludedRoutes = routes;
    };
    Angulartics2.prototype.firstPageview = function (value) {
        this.settings.pageTracking.autoTrackFirstPage = value;
    };
    Angulartics2.prototype.withBase = function (value) {
        this.settings.pageTracking.basePath = (value);
    };
    Angulartics2.prototype.developerMode = function (value) {
        this.settings.developerMode = value;
    };
    Angulartics2.prototype.trackUrlChange = function (url, location) {
        if (!this.settings.developerMode) {
            if (this.settings.pageTracking.autoTrackVirtualPages && !this.matchesExcludedRoute(url)) {
                this.pageTrack.next({
                    path: this.settings.pageTracking.basePath.length ? this.settings.pageTracking.basePath + url : location.prepareExternalUrl(url),
                    location: location
                });
            }
        }
    };
    Angulartics2.prototype.matchesExcludedRoute = function (url) {
        for (var _i = 0, _a = this.settings.pageTracking.excludedRoutes; _i < _a.length; _i++) {
            var excludedRoute = _a[_i];
            if ((excludedRoute instanceof RegExp && excludedRoute.test(url)) || url.indexOf(excludedRoute) > -1) {
                return true;
            }
        }
        return false;
    };
    Angulartics2 = __decorate([
        core_1.Injectable(),
        __param(1, core_1.Optional()), __param(2, core_1.Optional()), __param(3, core_1.Optional()),
        __metadata("design:paramtypes", [common_1.Location, router_1.Router, angular_1.TransitionService, angular_1.UrlService])
    ], Angulartics2);
    return Angulartics2;
}());
exports.Angulartics2 = Angulartics2;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/** @module common */ /** for typedoc */
__export(__webpack_require__(0));
__export(__webpack_require__(5));
__export(__webpack_require__(18));
__export(__webpack_require__(2));
__export(__webpack_require__(1));
__export(__webpack_require__(27));
__export(__webpack_require__(8));
__export(__webpack_require__(9));
//# sourceMappingURL=index.js.map

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Functions that manipulate strings
 *
 * Although these functions are exported, they are subject to change without notice.
 *
 * @module common_strings
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
var predicates_1 = __webpack_require__(1);
var rejectFactory_1 = __webpack_require__(14);
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var transition_1 = __webpack_require__(19);
var resolvable_1 = __webpack_require__(16);
/**
 * Returns a string shortened to a maximum length
 *
 * If the string is already less than the `max` length, return the string.
 * Else return the string, shortened to `max - 3` and append three dots ("...").
 *
 * @param max the maximum length of the string to return
 * @param str the input string
 */
function maxLength(max, str) {
    if (str.length <= max)
        return str;
    return str.substr(0, max - 3) + "...";
}
exports.maxLength = maxLength;
/**
 * Returns a string, with spaces added to the end, up to a desired str length
 *
 * If the string is already longer than the desired length, return the string.
 * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.
 *
 * @param length the desired length of the string to return
 * @param str the input string
 */
function padString(length, str) {
    while (str.length < length)
        str += " ";
    return str;
}
exports.padString = padString;
function kebobString(camelCase) {
    return camelCase
        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char
        .replace(/([A-Z])/g, function ($1) { return "-" + $1.toLowerCase(); }); // replace rest
}
exports.kebobString = kebobString;
function _toJson(obj) {
    return JSON.stringify(obj);
}
function _fromJson(json) {
    return predicates_1.isString(json) ? JSON.parse(json) : json;
}
function promiseToString(p) {
    return "Promise(" + JSON.stringify(p) + ")";
}
function functionToString(fn) {
    var fnStr = fnToString(fn);
    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\([^)]*\))/);
    var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;
    var fnName = fn['name'] || "";
    if (fnName && toStr.match(/function \(/)) {
        return 'function ' + fnName + toStr.substr(9);
    }
    return toStr;
}
exports.functionToString = functionToString;
function fnToString(fn) {
    var _fn = predicates_1.isArray(fn) ? fn.slice(-1)[0] : fn;
    return _fn && _fn.toString() || "undefined";
}
exports.fnToString = fnToString;
var stringifyPatternFn = null;
var stringifyPattern = function (value) {
    var isRejection = rejectFactory_1.Rejection.isRejectionPromise;
    stringifyPatternFn = stringifyPatternFn || hof_1.pattern([
        [hof_1.not(predicates_1.isDefined), hof_1.val("undefined")],
        [predicates_1.isNull, hof_1.val("null")],
        [predicates_1.isPromise, hof_1.val("[Promise]")],
        [isRejection, function (x) { return x._transitionRejection.toString(); }],
        [hof_1.is(rejectFactory_1.Rejection), hof_1.invoke("toString")],
        [hof_1.is(transition_1.Transition), hof_1.invoke("toString")],
        [hof_1.is(resolvable_1.Resolvable), hof_1.invoke("toString")],
        [predicates_1.isInjectable, functionToString],
        [hof_1.val(true), common_1.identity]
    ]);
    return stringifyPatternFn(value);
};
function stringify(o) {
    var seen = [];
    function format(val) {
        if (predicates_1.isObject(val)) {
            if (seen.indexOf(val) !== -1)
                return '[circular ref]';
            seen.push(val);
        }
        return stringifyPattern(val);
    }
    return JSON.stringify(o, function (key, val) { return format(val); }).replace(/\\"/g, '"');
}
exports.stringify = stringify;
/** Returns a function that splits a string on a character or substring */
exports.beforeAfterSubstr = function (char) { return function (str) {
    if (!str)
        return ["", ""];
    var idx = str.indexOf(char);
    if (idx === -1)
        return [str, ""];
    return [str.substr(0, idx), str.substr(idx + 1)];
}; };
exports.hostRegex = new RegExp('^(?:[a-z]+:)?//[^/]+/');
exports.stripFile = function (str) { return str.replace(/\/[^/]*$/, ''); };
exports.splitHash = exports.beforeAfterSubstr("#");
exports.splitQuery = exports.beforeAfterSubstr("?");
exports.splitEqual = exports.beforeAfterSubstr("=");
exports.trimHashVal = function (str) { return str ? str.replace(/^#/, "") : ""; };
/**
 * Splits on a delimiter, but returns the delimiters in the array
 *
 * #### Example:
 * ```js
 * var splitOnSlashes = splitOnDelim('/');
 * splitOnSlashes("/foo"); // ["/", "foo"]
 * splitOnSlashes("/foo/"); // ["/", "foo", "/"]
 * ```
 */
function splitOnDelim(delim) {
    var re = new RegExp("(" + delim + ")", "g");
    return function (str) {
        return str.split(re).filter(common_1.identity);
    };
}
exports.splitOnDelim = splitOnDelim;
;
/**
 * Reduce fn that joins neighboring strings
 *
 * Given an array of strings, returns a new array
 * where all neighboring strings have been joined.
 *
 * #### Example:
 * ```js
 * let arr = ["foo", "bar", 1, "baz", "", "qux" ];
 * arr.reduce(joinNeighborsR, []) // ["foobar", 1, "bazqux" ]
 * ```
 */
function joinNeighborsR(acc, x) {
    if (predicates_1.isString(common_1.tail(acc)) && predicates_1.isString(x))
        return acc.slice(0, -1).concat(common_1.tail(acc) + x);
    return common_1.pushR(acc, x);
}
exports.joinNeighborsR = joinNeighborsR;
;
//# sourceMappingURL=strings.js.map

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * # Transition tracing (debug)
 *
 * Enable transition tracing to print transition information to the console,
 * in order to help debug your application.
 * Tracing logs detailed information about each Transition to your console.
 *
 * To enable tracing, import the [[Trace]] singleton and enable one or more categories.
 *
 * ### ES6
 * ```js
 * import {trace} from "ui-router-ng2"; // or "angular-ui-router"
 * trace.enable(1, 5); // TRANSITION and VIEWCONFIG
 * ```
 *
 * ### CJS
 * ```js
 * let trace = require("angular-ui-router").trace; // or "ui-router-ng2"
 * trace.enable("TRANSITION", "VIEWCONFIG");
 * ```
 *
 * ### Globals
 * ```js
 * let trace = window["angular-ui-router"].trace; // or "ui-router-ng2"
 * trace.enable(); // Trace everything (very verbose)
 * ```
 *
 * ### Angular 1:
 * ```js
 * app.run($trace => $trace.enable());
 * ```
 *
 * @coreapi
 * @module trace
 */ /** for typedoc */
var hof_1 = __webpack_require__(2);
var predicates_1 = __webpack_require__(1);
var strings_1 = __webpack_require__(8);
/** @hidden */
function uiViewString(uiview) {
    if (!uiview)
        return 'ui-view (defunct)';
    var state = uiview.creationContext ? uiview.creationContext.name || '(root)' : '(none)';
    return "[ui-view#" + uiview.id + " " + uiview.$type + ":" + uiview.fqn + " (" + uiview.name + "@" + state + ")]";
}
/** @hidden */
var viewConfigString = function (viewConfig) {
    var view = viewConfig.viewDecl;
    var state = view.$context.name || '(root)';
    return "[View#" + viewConfig.$id + " from '" + state + "' state]: target ui-view: '" + view.$uiViewName + "@" + view.$uiViewContextAnchor + "'";
};
/** @hidden */
function normalizedCat(input) {
    return predicates_1.isNumber(input) ? Category[input] : Category[Category[input]];
}
/** @hidden */
var consoletable = predicates_1.isFunction(console.table) ? console.table.bind(console) : console.log.bind(console);
/**
 * Trace categories Enum
 *
 * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]
 *
 * `trace.enable(Category.TRANSITION)`
 *
 * These can also be provided using a matching string, or position ordinal
 *
 * `trace.enable("TRANSITION")`
 *
 * `trace.enable(1)`
 */
var Category;
(function (Category) {
    Category[Category["RESOLVE"] = 0] = "RESOLVE";
    Category[Category["TRANSITION"] = 1] = "TRANSITION";
    Category[Category["HOOK"] = 2] = "HOOK";
    Category[Category["UIVIEW"] = 3] = "UIVIEW";
    Category[Category["VIEWCONFIG"] = 4] = "VIEWCONFIG";
})(Category = exports.Category || (exports.Category = {}));
/** @hidden */ var _tid = hof_1.parse("$id");
/** @hidden */ var _rid = hof_1.parse("router.$id");
/** @hidden */ var transLbl = function (trans) { return "Transition #" + _tid(trans) + "-" + _rid(trans); };
/**
 * Prints UI-Router Transition trace information to the console.
 */
var Trace = /** @class */ (function () {
    /** @hidden */
    function Trace() {
        /** @hidden */
        this._enabled = {};
        this.approximateDigests = 0;
    }
    /** @hidden */
    Trace.prototype._set = function (enabled, categories) {
        var _this = this;
        if (!categories.length) {
            categories = Object.keys(Category)
                .map(function (k) { return parseInt(k, 10); })
                .filter(function (k) { return !isNaN(k); })
                .map(function (key) { return Category[key]; });
        }
        categories.map(normalizedCat).forEach(function (category) { return _this._enabled[category] = enabled; });
    };
    Trace.prototype.enable = function () {
        var categories = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            categories[_i] = arguments[_i];
        }
        this._set(true, categories);
    };
    Trace.prototype.disable = function () {
        var categories = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            categories[_i] = arguments[_i];
        }
        this._set(false, categories);
    };
    /**
     * Retrieves the enabled stateus of a [[Category]]
     *
     * ```js
     * trace.enabled("VIEWCONFIG"); // true or false
     * ```
     *
     * @returns boolean true if the category is enabled
     */
    Trace.prototype.enabled = function (category) {
        return !!this._enabled[normalizedCat(category)];
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceTransitionStart = function (trans) {
        if (!this.enabled(Category.TRANSITION))
            return;
        console.log(transLbl(trans) + ": Started  -> " + strings_1.stringify(trans));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceTransitionIgnored = function (trans) {
        if (!this.enabled(Category.TRANSITION))
            return;
        console.log(transLbl(trans) + ": Ignored  <> " + strings_1.stringify(trans));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceHookInvocation = function (step, trans, options) {
        if (!this.enabled(Category.HOOK))
            return;
        var event = hof_1.parse("traceData.hookType")(options) || "internal", context = hof_1.parse("traceData.context.state.name")(options) || hof_1.parse("traceData.context")(options) || "unknown", name = strings_1.functionToString(step.registeredHook.callback);
        console.log(transLbl(trans) + ":   Hook -> " + event + " context: " + context + ", " + strings_1.maxLength(200, name));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {
        if (!this.enabled(Category.HOOK))
            return;
        console.log(transLbl(trans) + ":   <- Hook returned: " + strings_1.maxLength(200, strings_1.stringify(hookResult)));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceResolvePath = function (path, when, trans) {
        if (!this.enabled(Category.RESOLVE))
            return;
        console.log(transLbl(trans) + ":         Resolving " + path + " (" + when + ")");
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceResolvableResolved = function (resolvable, trans) {
        if (!this.enabled(Category.RESOLVE))
            return;
        console.log(transLbl(trans) + ":               <- Resolved  " + resolvable + " to: " + strings_1.maxLength(200, strings_1.stringify(resolvable.data)));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceError = function (reason, trans) {
        if (!this.enabled(Category.TRANSITION))
            return;
        console.log(transLbl(trans) + ": <- Rejected " + strings_1.stringify(trans) + ", reason: " + reason);
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceSuccess = function (finalState, trans) {
        if (!this.enabled(Category.TRANSITION))
            return;
        console.log(transLbl(trans) + ": <- Success  " + strings_1.stringify(trans) + ", final state: " + finalState.name);
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {
        if (extra === void 0) { extra = ""; }
        if (!this.enabled(Category.UIVIEW))
            return;
        console.log("ui-view: " + strings_1.padString(30, event) + " " + uiViewString(viewData) + extra);
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {
        if (!this.enabled(Category.UIVIEW))
            return;
        this.traceUIViewEvent("Updating", viewData, " with ViewConfig from context='" + context + "'");
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceUIViewFill = function (viewData, html) {
        if (!this.enabled(Category.UIVIEW))
            return;
        this.traceUIViewEvent("Fill", viewData, " with: " + strings_1.maxLength(200, html));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceViewSync = function (pairs) {
        if (!this.enabled(Category.VIEWCONFIG))
            return;
        var mapping = pairs.map(function (_a) {
            var uiViewData = _a[0], config = _a[1];
            var uiView = uiViewData.$type + ":" + uiViewData.fqn;
            var view = config && config.viewDecl.$context.name + ": " + config.viewDecl.$name + " (" + config.viewDecl.$type + ")";
            return { 'ui-view fqn': uiView, 'state: view name': view };
        }).sort(function (a, b) { return a['ui-view fqn'].localeCompare(b['ui-view fqn']); });
        consoletable(mapping);
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {
        if (!this.enabled(Category.VIEWCONFIG))
            return;
        console.log("VIEWCONFIG: " + event + " " + viewConfigString(viewConfig));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {
        if (!this.enabled(Category.VIEWCONFIG))
            return;
        console.log("VIEWCONFIG: " + event + " " + uiViewString(viewData));
    };
    return Trace;
}());
exports.Trace = Trace;
/**
 * The [[Trace]] singleton
 *
 * #### Example:
 * ```js
 * import {trace} from "angular-ui-router";
 * trace.enable(1, 5);
 * ```
 */
var trace = new Trace();
exports.trace = trace;
//# sourceMappingURL=trace.js.map

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_10__;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var TransitionHookPhase;
(function (TransitionHookPhase) {
    TransitionHookPhase[TransitionHookPhase["CREATE"] = 0] = "CREATE";
    TransitionHookPhase[TransitionHookPhase["BEFORE"] = 1] = "BEFORE";
    TransitionHookPhase[TransitionHookPhase["RUN"] = 2] = "RUN";
    TransitionHookPhase[TransitionHookPhase["SUCCESS"] = 3] = "SUCCESS";
    TransitionHookPhase[TransitionHookPhase["ERROR"] = 4] = "ERROR";
})(TransitionHookPhase = exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));
var TransitionHookScope;
(function (TransitionHookScope) {
    TransitionHookScope[TransitionHookScope["TRANSITION"] = 0] = "TRANSITION";
    TransitionHookScope[TransitionHookScope["STATE"] = 1] = "STATE";
})(TransitionHookScope = exports.TransitionHookScope || (exports.TransitionHookScope = {}));
//# sourceMappingURL=interface.js.map

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @coreapi
 * @module state
 */ /** for typedoc */
Object.defineProperty(exports, "__esModule", { value: true });
var predicates_1 = __webpack_require__(1);
var strings_1 = __webpack_require__(8);
var common_1 = __webpack_require__(7);
/**
 * Encapsulate the target (destination) state/params/options of a [[Transition]].
 *
 * This class is frequently used to redirect a transition to a new destination.
 *
 * See:
 *
 * - [[HookResult]]
 * - [[TransitionHookFn]]
 * - [[TransitionService.onStart]]
 *
 * To create a `TargetState`, use [[StateService.target]].
 *
 * ---
 *
 * This class wraps:
 *
 * 1) an identifier for a state
 * 2) a set of parameters
 * 3) and transition options
 * 4) the registered state object (the [[StateDeclaration]])
 *
 * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can
 * either be a *state object* (a [[StateDeclaration]] or [[StateObject]]) or a *state name* (a string).
 * The `TargetState` class normalizes those options.
 *
 * A `TargetState` may be valid (the state being targeted exists in the registry)
 * or invalid (the state being targeted is not registered).
 */
var TargetState = /** @class */ (function () {
    /**
     * The TargetState constructor
     *
     * Note: Do not construct a `TargetState` manually.
     * To create a `TargetState`, use the [[StateService.target]] factory method.
     *
     * @param _stateRegistry The StateRegistry to use to look up the _definition
     * @param _identifier An identifier for a state.
     *    Either a fully-qualified state name, or the object used to define the state.
     * @param _params Parameters for the target state
     * @param _options Transition options.
     *
     * @internalapi
     */
    function TargetState(_stateRegistry, _identifier, _params, _options) {
        this._stateRegistry = _stateRegistry;
        this._identifier = _identifier;
        this._identifier = _identifier;
        this._params = common_1.extend({}, _params || {});
        this._options = common_1.extend({}, _options || {});
        this._definition = _stateRegistry.matcher.find(_identifier, this._options.relative);
    }
    /** The name of the state this object targets */
    TargetState.prototype.name = function () {
        return this._definition && this._definition.name || this._identifier;
    };
    /** The identifier used when creating this TargetState */
    TargetState.prototype.identifier = function () {
        return this._identifier;
    };
    /** The target parameter values */
    TargetState.prototype.params = function () {
        return this._params;
    };
    /** The internal state object (if it was found) */
    TargetState.prototype.$state = function () {
        return this._definition;
    };
    /** The internal state declaration (if it was found) */
    TargetState.prototype.state = function () {
        return this._definition && this._definition.self;
    };
    /** The target options */
    TargetState.prototype.options = function () {
        return this._options;
    };
    /** True if the target state was found */
    TargetState.prototype.exists = function () {
        return !!(this._definition && this._definition.self);
    };
    /** True if the object is valid */
    TargetState.prototype.valid = function () {
        return !this.error();
    };
    /** If the object is invalid, returns the reason why */
    TargetState.prototype.error = function () {
        var base = this.options().relative;
        if (!this._definition && !!base) {
            var stateName = base.name ? base.name : base;
            return "Could not resolve '" + this.name() + "' from state '" + stateName + "'";
        }
        if (!this._definition)
            return "No such state '" + this.name() + "'";
        if (!this._definition.self)
            return "State '" + this.name() + "' has an invalid definition";
    };
    TargetState.prototype.toString = function () {
        return "'" + this.name() + "'" + strings_1.stringify(this.params());
    };
    /**
     * Returns a copy of this TargetState which targets a different state.
     * The new TargetState has the same parameter values and transition options.
     *
     * @param state The new state that should be targeted
     */
    TargetState.prototype.withState = function (state) {
        return new TargetState(this._stateRegistry, state, this._params, this._options);
    };
    /**
     * Returns a copy of this TargetState, using the specified parameter values.
     *
     * @param params the new parameter values to use
     * @param replace When false (default) the new parameter values will be merged with the current values.
     *                When true the parameter values will be used instead of the current values.
     */
    TargetState.prototype.withParams = function (params, replace) {
        if (replace === void 0) { replace = false; }
        var newParams = replace ? params : common_1.extend({}, this._params, params);
        return new TargetState(this._stateRegistry, this._identifier, newParams, this._options);
    };
    /**
     * Returns a copy of this TargetState, using the specified Transition Options.
     *
     * @param options the new options to use
     * @param replace When false (default) the new options will be merged with the current options.
     *                When true the options will be used instead of the current options.
     */
    TargetState.prototype.withOptions = function (options, replace) {
        if (replace === void 0) { replace = false; }
        var newOpts = replace ? options : common_1.extend({}, this._options, options);
        return new TargetState(this._stateRegistry, this._identifier, this._params, newOpts);
    };
    /** Returns true if the object has a state property that might be a state or state name */
    TargetState.isDef = function (obj) {
        return obj && obj.state && (predicates_1.isString(obj.state) || predicates_1.isString(obj.state.name));
    };
    return TargetState;
}());
exports.TargetState = TargetState;
//# sourceMappingURL=targetState.js.map

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module params
 */ /** for typedoc */
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var predicates_1 = __webpack_require__(1);
var coreservices_1 = __webpack_require__(5);
var paramType_1 = __webpack_require__(30);
/** @hidden */ var hasOwn = Object.prototype.hasOwnProperty;
/** @hidden */ var isShorthand = function (cfg) {
    return ["value", "type", "squash", "array", "dynamic"].filter(hasOwn.bind(cfg || {})).length === 0;
};
/** @internalapi */
var DefType;
(function (DefType) {
    DefType[DefType["PATH"] = 0] = "PATH";
    DefType[DefType["SEARCH"] = 1] = "SEARCH";
    DefType[DefType["CONFIG"] = 2] = "CONFIG";
})(DefType = exports.DefType || (exports.DefType = {}));
/** @hidden */
function unwrapShorthand(cfg) {
    cfg = isShorthand(cfg) && { value: cfg } || cfg;
    getStaticDefaultValue['__cacheable'] = true;
    function getStaticDefaultValue() {
        return cfg.value;
    }
    return common_1.extend(cfg, {
        $$fn: predicates_1.isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue,
    });
}
/** @hidden */
function getType(cfg, urlType, location, id, paramTypes) {
    if (cfg.type && urlType && urlType.name !== 'string')
        throw new Error("Param '" + id + "' has two type configurations.");
    if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))
        return paramTypes.type(cfg.type);
    if (urlType)
        return urlType;
    if (!cfg.type) {
        var type = location === DefType.CONFIG ? "any" :
            location === DefType.PATH ? "path" :
                location === DefType.SEARCH ? "query" : "string";
        return paramTypes.type(type);
    }
    return cfg.type instanceof paramType_1.ParamType ? cfg.type : paramTypes.type(cfg.type);
}
/**
 * @internalapi
 * returns false, true, or the squash value to indicate the "default parameter url squash policy".
 */
function getSquashPolicy(config, isOptional, defaultPolicy) {
    var squash = config.squash;
    if (!isOptional || squash === false)
        return false;
    if (!predicates_1.isDefined(squash) || squash == null)
        return defaultPolicy;
    if (squash === true || predicates_1.isString(squash))
        return squash;
    throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
}
/** @internalapi */
function getReplace(config, arrayMode, isOptional, squash) {
    var replace, configuredKeys, defaultPolicy = [
        { from: "", to: (isOptional || arrayMode ? undefined : "") },
        { from: null, to: (isOptional || arrayMode ? undefined : "") },
    ];
    replace = predicates_1.isArray(config.replace) ? config.replace : [];
    if (predicates_1.isString(squash))
        replace.push({ from: squash, to: undefined });
    configuredKeys = common_1.map(replace, hof_1.prop("from"));
    return common_1.filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);
}
/** @internalapi */
var Param = /** @class */ (function () {
    function Param(id, type, config, location, urlMatcherFactory) {
        config = unwrapShorthand(config);
        type = getType(config, type, location, id, urlMatcherFactory.paramTypes);
        var arrayMode = getArrayMode();
        type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;
        var isOptional = config.value !== undefined || location === DefType.SEARCH;
        var dynamic = predicates_1.isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;
        var raw = predicates_1.isDefined(config.raw) ? !!config.raw : !!type.raw;
        var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());
        var replace = getReplace(config, arrayMode, isOptional, squash);
        var inherit = predicates_1.isDefined(config.inherit) ? !!config.inherit : !!type.inherit;
        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.
        function getArrayMode() {
            var arrayDefaults = { array: (location === DefType.SEARCH ? "auto" : false) };
            var arrayParamNomenclature = id.match(/\[\]$/) ? { array: true } : {};
            return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;
        }
        common_1.extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit, array: arrayMode, config: config });
    }
    Param.prototype.isDefaultValue = function (value) {
        return this.isOptional && this.type.equals(this.value(), value);
    };
    /**
     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the
     * default value, which may be the result of an injectable function.
     */
    Param.prototype.value = function (value) {
        var _this = this;
        /**
         * [Internal] Get the default value of a parameter, which may be an injectable function.
         */
        var getDefaultValue = function () {
            if (_this._defaultValueCache)
                return _this._defaultValueCache.defaultValue;
            if (!coreservices_1.services.$injector)
                throw new Error("Injectable functions cannot be called at configuration time");
            var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);
            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))
                throw new Error("Default value (" + defaultValue + ") for parameter '" + _this.id + "' is not an instance of ParamType (" + _this.type.name + ")");
            if (_this.config.$$fn['__cacheable']) {
                _this._defaultValueCache = { defaultValue: defaultValue };
            }
            return defaultValue;
        };
        var replaceSpecialValues = function (val) {
            for (var _i = 0, _a = _this.replace; _i < _a.length; _i++) {
                var tuple = _a[_i];
                if (tuple.from === val)
                    return tuple.to;
            }
            return val;
        };
        value = replaceSpecialValues(value);
        return predicates_1.isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);
    };
    Param.prototype.isSearch = function () {
        return this.location === DefType.SEARCH;
    };
    Param.prototype.validates = function (value) {
        // There was no parameter value, but the param is optional
        if ((predicates_1.isUndefined(value) || value === null) && this.isOptional)
            return true;
        // The value was not of the correct ParamType, and could not be decoded to the correct ParamType
        var normalized = this.type.$normalize(value);
        if (!this.type.is(normalized))
            return false;
        // The value was of the correct type, but when encoded, did not match the ParamType's regexp
        var encoded = this.type.encode(normalized);
        return !(predicates_1.isString(encoded) && !this.type.pattern.exec(encoded));
    };
    Param.prototype.toString = function () {
        return "{Param:" + this.id + " " + this.type + " squash: '" + this.squash + "' optional: " + this.isOptional + "}";
    };
    Param.values = function (params, values) {
        if (values === void 0) { values = {}; }
        var paramValues = {};
        for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {
            var param = params_1[_i];
            paramValues[param.id] = param.value(values[param.id]);
        }
        return paramValues;
    };
    /**
     * Finds [[Param]] objects which have different param values
     *
     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects
     *
     * @param params: The list of Param objects to filter
     * @param values1: The first set of parameter values
     * @param values2: the second set of parameter values
     *
     * @returns any Param objects whose values were different between values1 and values2
     */
    Param.changed = function (params, values1, values2) {
        if (values1 === void 0) { values1 = {}; }
        if (values2 === void 0) { values2 = {}; }
        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });
    };
    /**
     * Checks if two param value objects are equal (for a set of [[Param]] objects)
     *
     * @param params The list of [[Param]] objects to check
     * @param values1 The first set of param values
     * @param values2 The second set of param values
     *
     * @returns true if the param values in values1 and values2 are equal
     */
    Param.equals = function (params, values1, values2) {
        if (values1 === void 0) { values1 = {}; }
        if (values2 === void 0) { values2 = {}; }
        return Param.changed(params, values1, values2).length === 0;
    };
    /** Returns true if a the parameter values are valid, according to the Param definitions */
    Param.validates = function (params, values) {
        if (values === void 0) { values = {}; }
        return params.map(function (param) { return param.validates(values[param.id]); }).reduce(common_1.allTrueR, true);
    };
    return Param;
}());
exports.Param = Param;
//# sourceMappingURL=param.js.map

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @coreapi
 * @module transition
 */ /** for typedoc */

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(0);
var strings_1 = __webpack_require__(8);
var hof_1 = __webpack_require__(2);
var RejectType;
(function (RejectType) {
    RejectType[RejectType["SUPERSEDED"] = 2] = "SUPERSEDED";
    RejectType[RejectType["ABORTED"] = 3] = "ABORTED";
    RejectType[RejectType["INVALID"] = 4] = "INVALID";
    RejectType[RejectType["IGNORED"] = 5] = "IGNORED";
    RejectType[RejectType["ERROR"] = 6] = "ERROR";
})(RejectType = exports.RejectType || (exports.RejectType = {}));
/** @hidden */ var id = 0;
var Rejection = /** @class */ (function () {
    function Rejection(type, message, detail) {
        this.$id = id++;
        this.type = type;
        this.message = message;
        this.detail = detail;
    }
    Rejection.prototype.toString = function () {
        var detailString = function (d) {
            return d && d.toString !== Object.prototype.toString ? d.toString() : strings_1.stringify(d);
        };
        var detail = detailString(this.detail);
        var _a = this, $id = _a.$id, type = _a.type, message = _a.message;
        return "Transition Rejection($id: " + $id + " type: " + type + ", message: " + message + ", detail: " + detail + ")";
    };
    Rejection.prototype.toPromise = function () {
        return common_1.extend(common_1.silentRejection(this), { _transitionRejection: this });
    };
    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */
    Rejection.isRejectionPromise = function (obj) {
        return obj && (typeof obj.then === 'function') && hof_1.is(Rejection)(obj._transitionRejection);
    };
    /** Returns a Rejection due to transition superseded */
    Rejection.superseded = function (detail, options) {
        var message = "The transition has been superseded by a different transition";
        var rejection = new Rejection(RejectType.SUPERSEDED, message, detail);
        if (options && options.redirected) {
            rejection.redirected = true;
        }
        return rejection;
    };
    /** Returns a Rejection due to redirected transition */
    Rejection.redirected = function (detail) {
        return Rejection.superseded(detail, { redirected: true });
    };
    /** Returns a Rejection due to invalid transition */
    Rejection.invalid = function (detail) {
        var message = "This transition is invalid";
        return new Rejection(RejectType.INVALID, message, detail);
    };
    /** Returns a Rejection due to ignored transition */
    Rejection.ignored = function (detail) {
        var message = "The transition was ignored";
        return new Rejection(RejectType.IGNORED, message, detail);
    };
    /** Returns a Rejection due to aborted transition */
    Rejection.aborted = function (detail) {
        var message = "The transition has been aborted";
        return new Rejection(RejectType.ABORTED, message, detail);
    };
    /** Returns a Rejection due to aborted transition */
    Rejection.errored = function (detail) {
        var message = "The transition errored";
        return new Rejection(RejectType.ERROR, message, detail);
    };
    /**
     * Returns a Rejection
     *
     * Normalizes a value as a Rejection.
     * If the value is already a Rejection, returns it.
     * Otherwise, wraps and returns the value as a Rejection (Rejection type: ERROR).
     *
     * @returns `detail` if it is already a `Rejection`, else returns an ERROR Rejection.
     */
    Rejection.normalize = function (detail) {
        return hof_1.is(Rejection)(detail) ? detail : Rejection.errored(detail);
    };
    return Rejection;
}());
exports.Rejection = Rejection;
//# sourceMappingURL=rejectFactory.js.map

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module transition
 */
/** for typedoc */
var interface_1 = __webpack_require__(11);
var common_1 = __webpack_require__(0);
var strings_1 = __webpack_require__(8);
var predicates_1 = __webpack_require__(1);
var hof_1 = __webpack_require__(2);
var trace_1 = __webpack_require__(9);
var coreservices_1 = __webpack_require__(5);
var rejectFactory_1 = __webpack_require__(14);
var targetState_1 = __webpack_require__(12);
var defaultOptions = {
    current: common_1.noop,
    transition: null,
    traceData: {},
    bind: null,
};
/** @hidden */
var TransitionHook = /** @class */ (function () {
    function TransitionHook(transition, stateContext, registeredHook, options) {
        var _this = this;
        this.transition = transition;
        this.stateContext = stateContext;
        this.registeredHook = registeredHook;
        this.options = options;
        this.isSuperseded = function () {
            return _this.type.hookPhase === interface_1.TransitionHookPhase.RUN && !_this.options.transition.isActive();
        };
        this.options = common_1.defaults(options, defaultOptions);
        this.type = registeredHook.eventType;
    }
    TransitionHook.prototype.logError = function (err) {
        this.transition.router.stateService.defaultErrorHandler()(err);
    };
    TransitionHook.prototype.invokeHook = function () {
        var _this = this;
        var hook = this.registeredHook;
        if (hook._deregistered)
            return;
        var notCurrent = this.getNotCurrentRejection();
        if (notCurrent)
            return notCurrent;
        var options = this.options;
        trace_1.trace.traceHookInvocation(this, this.transition, options);
        var invokeCallback = function () {
            return hook.callback.call(options.bind, _this.transition, _this.stateContext);
        };
        var normalizeErr = function (err) {
            return rejectFactory_1.Rejection.normalize(err).toPromise();
        };
        var handleError = function (err) {
            return hook.eventType.getErrorHandler(_this)(err);
        };
        var handleResult = function (result) {
            return hook.eventType.getResultHandler(_this)(result);
        };
        try {
            var result = invokeCallback();
            if (!this.type.synchronous && predicates_1.isPromise(result)) {
                return result.catch(normalizeErr)
                    .then(handleResult, handleError);
            }
            else {
                return handleResult(result);
            }
        }
        catch (err) {
            // If callback throws (synchronously)
            return handleError(rejectFactory_1.Rejection.normalize(err));
        }
        finally {
            if (hook.invokeLimit && ++hook.invokeCount >= hook.invokeLimit) {
                hook.deregister();
            }
        }
    };
    /**
     * This method handles the return value of a Transition Hook.
     *
     * A hook can return false (cancel), a TargetState (redirect),
     * or a promise (which may later resolve to false or a redirect)
     *
     * This also handles "transition superseded" -- when a new transition
     * was started while the hook was still running
     */
    TransitionHook.prototype.handleHookResult = function (result) {
        var _this = this;
        var notCurrent = this.getNotCurrentRejection();
        if (notCurrent)
            return notCurrent;
        // Hook returned a promise
        if (predicates_1.isPromise(result)) {
            // Wait for the promise, then reprocess with the resulting value
            return result.then(function (val) { return _this.handleHookResult(val); });
        }
        trace_1.trace.traceHookResult(result, this.transition, this.options);
        // Hook returned false
        if (result === false) {
            // Abort this Transition
            return rejectFactory_1.Rejection.aborted("Hook aborted transition").toPromise();
        }
        var isTargetState = hof_1.is(targetState_1.TargetState);
        // hook returned a TargetState
        if (isTargetState(result)) {
            // Halt the current Transition and redirect (a new Transition) to the TargetState.
            return rejectFactory_1.Rejection.redirected(result).toPromise();
        }
    };
    /**
     * Return a Rejection promise if the transition is no longer current due
     * to a stopped router (disposed), or a new transition has started and superseded this one.
     */
    TransitionHook.prototype.getNotCurrentRejection = function () {
        var router = this.transition.router;
        // The router is stopped
        if (router._disposed) {
            return rejectFactory_1.Rejection.aborted("UIRouter instance #" + router.$id + " has been stopped (disposed)").toPromise();
        }
        if (this.transition._aborted) {
            return rejectFactory_1.Rejection.aborted().toPromise();
        }
        // This transition is no longer current.
        // Another transition started while this hook was still running.
        if (this.isSuperseded()) {
            // Abort this transition
            return rejectFactory_1.Rejection.superseded(this.options.current()).toPromise();
        }
    };
    TransitionHook.prototype.toString = function () {
        var _a = this, options = _a.options, registeredHook = _a.registeredHook;
        var event = hof_1.parse("traceData.hookType")(options) || "internal", context = hof_1.parse("traceData.context.state.name")(options) || hof_1.parse("traceData.context")(options) || "unknown", name = strings_1.fnToString(registeredHook.callback);
        return event + " context: " + context + ", " + strings_1.maxLength(200, name);
    };
    /**
     * Chains together an array of TransitionHooks.
     *
     * Given a list of [[TransitionHook]] objects, chains them together.
     * Each hook is invoked after the previous one completes.
     *
     * #### Example:
     * ```js
     * var hooks: TransitionHook[] = getHooks();
     * let promise: Promise<any> = TransitionHook.chain(hooks);
     *
     * promise.then(handleSuccess, handleError);
     * ```
     *
     * @param hooks the list of hooks to chain together
     * @param waitFor if provided, the chain is `.then()`'ed off this promise
     * @returns a `Promise` for sequentially invoking the hooks (in order)
     */
    TransitionHook.chain = function (hooks, waitFor) {
        // Chain the next hook off the previous
        var createHookChainR = function (prev, nextHook) {
            return prev.then(function () { return nextHook.invokeHook(); });
        };
        return hooks.reduce(createHookChainR, waitFor || coreservices_1.services.$q.when());
    };
    /**
     * Invokes all the provided TransitionHooks, in order.
     * Each hook's return value is checked.
     * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.
     * If no hook returns a promise, then all hooks are processed synchronously.
     *
     * @param hooks the list of TransitionHooks to invoke
     * @param doneCallback a callback that is invoked after all the hooks have successfully completed
     *
     * @returns a promise for the async result, or the result of the callback
     */
    TransitionHook.invokeHooks = function (hooks, doneCallback) {
        for (var idx = 0; idx < hooks.length; idx++) {
            var hookResult = hooks[idx].invokeHook();
            if (predicates_1.isPromise(hookResult)) {
                var remainingHooks = hooks.slice(idx + 1);
                return TransitionHook.chain(remainingHooks, hookResult)
                    .then(doneCallback);
            }
        }
        return doneCallback();
    };
    /**
     * Run all TransitionHooks, ignoring their return value.
     */
    TransitionHook.runAllHooks = function (hooks) {
        hooks.forEach(function (hook) { return hook.invokeHook(); });
    };
    /**
     * These GetResultHandler(s) are used by [[invokeHook]] below
     * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])
     */
    TransitionHook.HANDLE_RESULT = function (hook) { return function (result) {
        return hook.handleHookResult(result);
    }; };
    /**
     * If the result is a promise rejection, log it.
     * Otherwise, ignore the result.
     */
    TransitionHook.LOG_REJECTED_RESULT = function (hook) { return function (result) {
        predicates_1.isPromise(result) && result.catch(function (err) {
            return hook.logError(rejectFactory_1.Rejection.normalize(err));
        });
        return undefined;
    }; };
    /**
     * These GetErrorHandler(s) are used by [[invokeHook]] below
     * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])
     */
    TransitionHook.LOG_ERROR = function (hook) { return function (error) {
        return hook.logError(error);
    }; };
    TransitionHook.REJECT_ERROR = function (hook) { return function (error) {
        return common_1.silentRejection(error);
    }; };
    TransitionHook.THROW_ERROR = function (hook) { return function (error) {
        throw error;
    }; };
    return TransitionHook;
}());
exports.TransitionHook = TransitionHook;
//# sourceMappingURL=transitionHook.js.map

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module resolve
 */ /** for typedoc */
var common_1 = __webpack_require__(0);
var coreservices_1 = __webpack_require__(5);
var trace_1 = __webpack_require__(9);
var strings_1 = __webpack_require__(8);
var predicates_1 = __webpack_require__(1);
var common_2 = __webpack_require__(7);
// TODO: explicitly make this user configurable
exports.defaultResolvePolicy = {
    when: "LAZY",
    async: "WAIT"
};
/**
 * The basic building block for the resolve system.
 *
 * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),
 * and the unwrapped-when-complete (.data) result of the resolveFn.
 *
 * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the
 * resolveFn) and returns the resulting promise.
 *
 * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first
 * parameter to those fns.
 */
var Resolvable = /** @class */ (function () {
    function Resolvable(arg1, resolveFn, deps, policy, data) {
        this.resolved = false;
        this.promise = undefined;
        if (arg1 instanceof Resolvable) {
            common_1.extend(this, arg1);
        }
        else if (predicates_1.isFunction(resolveFn)) {
            if (common_2.isNullOrUndefined(arg1))
                throw new Error("new Resolvable(): token argument is required");
            if (!predicates_1.isFunction(resolveFn))
                throw new Error("new Resolvable(): resolveFn argument must be a function");
            this.token = arg1;
            this.policy = policy;
            this.resolveFn = resolveFn;
            this.deps = deps || [];
            this.data = data;
            this.resolved = data !== undefined;
            this.promise = this.resolved ? coreservices_1.services.$q.when(this.data) : undefined;
        }
        else if (predicates_1.isObject(arg1) && arg1.token && predicates_1.isFunction(arg1.resolveFn)) {
            var literal = arg1;
            return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);
        }
    }
    Resolvable.prototype.getPolicy = function (state) {
        var thisPolicy = this.policy || {};
        var statePolicy = state && state.resolvePolicy || {};
        return {
            when: thisPolicy.when || statePolicy.when || exports.defaultResolvePolicy.when,
            async: thisPolicy.async || statePolicy.async || exports.defaultResolvePolicy.async,
        };
    };
    /**
     * Asynchronously resolve this Resolvable's data
     *
     * Given a ResolveContext that this Resolvable is found in:
     * Wait for this Resolvable's dependencies, then invoke this Resolvable's function
     * and update the Resolvable's state
     */
    Resolvable.prototype.resolve = function (resolveContext, trans) {
        var _this = this;
        var $q = coreservices_1.services.$q;
        // Gets all dependencies from ResolveContext and wait for them to be resolved
        var getResolvableDependencies = function () {
            return $q.all(resolveContext.getDependencies(_this).map(function (resolvable) {
                return resolvable.get(resolveContext, trans);
            }));
        };
        // Invokes the resolve function passing the resolved dependencies as arguments
        var invokeResolveFn = function (resolvedDeps) {
            return _this.resolveFn.apply(null, resolvedDeps);
        };
        /**
         * For RXWAIT policy:
         *
         * Given an observable returned from a resolve function:
         * - enables .cache() mode (this allows multicast subscribers)
         * - then calls toPromise() (this triggers subscribe() and thus fetches)
         * - Waits for the promise, then return the cached observable (not the first emitted value).
         */
        var waitForRx = function (observable$) {
            var cached = observable$.cache(1);
            return cached.take(1).toPromise().then(function () { return cached; });
        };
        // If the resolve policy is RXWAIT, wait for the observable to emit something. otherwise pass through.
        var node = resolveContext.findNode(this);
        var state = node && node.state;
        var maybeWaitForRx = this.getPolicy(state).async === "RXWAIT" ? waitForRx : common_1.identity;
        // After the final value has been resolved, update the state of the Resolvable
        var applyResolvedValue = function (resolvedValue) {
            _this.data = resolvedValue;
            _this.resolved = true;
            trace_1.trace.traceResolvableResolved(_this, trans);
            return _this.data;
        };
        // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.
        return this.promise = $q.when()
            .then(getResolvableDependencies)
            .then(invokeResolveFn)
            .then(maybeWaitForRx)
            .then(applyResolvedValue);
    };
    /**
     * Gets a promise for this Resolvable's data.
     *
     * Fetches the data and returns a promise.
     * Returns the existing promise if it has already been fetched once.
     */
    Resolvable.prototype.get = function (resolveContext, trans) {
        return this.promise || this.resolve(resolveContext, trans);
    };
    Resolvable.prototype.toString = function () {
        return "Resolvable(token: " + strings_1.stringify(this.token) + ", requires: [" + this.deps.map(strings_1.stringify) + "])";
    };
    Resolvable.prototype.clone = function () {
        return new Resolvable(this);
    };
    Resolvable.fromData = function (token, data) {
        return new Resolvable(token, function () { return data; }, null, null, data);
    };
    return Resolvable;
}());
exports.Resolvable = Resolvable;
//# sourceMappingURL=resolvable.js.map

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UIView; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__uirouter_core__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__uirouter_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__statebuilders_views__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mergeInjector__ = __webpack_require__(94);
/** @ng2api @module directives */
/** */




/** @hidden */
var id = 0;
/**
 * Given a component class, gets the inputs of styles:
 *
 * - @Input('foo') _foo
 * - `inputs: ['foo']`
 *
 * @internalapi
 */
var ng2ComponentInputs = function (factory) {
    return factory.inputs.map(function (input) { return ({ prop: input.propName, token: input.templateName }); });
};
/**
 * A UI-Router viewport directive, which is filled in by a view (component) on a state.
 *
 * ### Selector
 *
 * A `ui-view` directive can be created as an element: `<ui-view></ui-view>` or as an attribute: `<div ui-view></div>`.
 *
 * ### Purpose
 *
 * This directive is used in a Component template (or as the root component) to create a viewport.  The viewport
 * is filled in by a view (as defined by a [[Ng2ViewDeclaration]] inside a [[Ng2StateDeclaration]]) when the view's
 * state has been activated.
 *
 * #### Example:
 * ```js
 * // This app has two states, 'foo' and 'bar'
 * stateRegistry.register({ name: 'foo', url: '/foo', component: FooComponent });
 * stateRegistry.register({ name: 'bar', url: '/bar', component: BarComponent });
 * ```
 * ```html
 * <!-- This ui-view will be filled in by the foo state's component or
 *      the bar state's component when the foo or bar state is activated -->
 * <ui-view></ui-view>
 * ```
 *
 * ### Named ui-views
 *
 * A `ui-view` may optionally be given a name via the attribute value: `<div ui-view='header'></div>`.  *Note:
 * an unnamed `ui-view` is internally named `$default`*.   When a `ui-view` has a name, it will be filled in
 * by a matching named view.
 *
 * #### Example:
 * ```js
 * stateRegistry.register({
 *   name: 'foo',
 *   url: '/foo',
 *   views: { header: HeaderComponent, $default: FooComponent });
 * ```
 * ```html
 * <!-- When 'foo' state is active, filled by HeaderComponent -->
 * <div ui-view="header"></div>
 *
 * <!-- When 'foo' state is active, filled by FooComponent -->
 * <ui-view></ui-view>
 * ```
 */
var UIView = (function () {
    function UIView(router, parent, viewContainerRef) {
        this.router = router;
        this.viewContainerRef = viewContainerRef;
        /** Data about the this UIView */
        this.uiViewData = {};
        this.parent = parent;
    }
    Object.defineProperty(UIView.prototype, "_name", {
        set: function (val) { this.name = val; },
        enumerable: true,
        configurable: true
    });
    UIView.prototype.ngOnInit = function () {
        var _this = this;
        var router = this.router;
        var parentFqn = this.parent.fqn;
        var name = this.name || '$default';
        this.uiViewData = {
            $type: 'ng2',
            id: id++,
            name: name,
            fqn: parentFqn ? parentFqn + "." + name : name,
            creationContext: this.parent.context,
            configUpdated: this.viewConfigUpdated.bind(this),
            config: undefined
        };
        this.deregisterHook = router.transitionService.onBefore({}, function (trans) { return _this.applyUiCanExitHook(trans); });
        this.deregisterUIView = router.viewService.registerUIView(this.uiViewData);
    };
    /**
     * For each transition, checks the component loaded in the ui-view for:
     *
     * - has a uiCanExit() component hook
     * - is being exited
     *
     * If both are true, adds the uiCanExit component function as a hook to that singular Transition.
     */
    UIView.prototype.applyUiCanExitHook = function (trans) {
        var instance = this.componentRef && this.componentRef.instance;
        var uiCanExitFn = instance && instance.uiCanExit;
        if (Object(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__["isFunction"])(uiCanExitFn)) {
            var state = Object(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__["parse"])("uiViewData.config.viewDecl.$context.self")(this);
            if (trans.exiting().indexOf(state) !== -1) {
                trans.onStart({}, function () {
                    return uiCanExitFn.call(instance, trans);
                });
            }
        }
    };
    UIView.prototype.disposeLast = function () {
        if (this.componentRef)
            this.componentRef.destroy();
        this.componentRef = null;
    };
    UIView.prototype.ngOnDestroy = function () {
        if (this.deregisterUIView)
            this.deregisterUIView();
        if (this.deregisterHook)
            this.deregisterHook();
        this.disposeLast();
    };
    /**
     * The view service is informing us of an updated ViewConfig
     * (usually because a transition activated some state and its views)
     */
    UIView.prototype.viewConfigUpdated = function (config) {
        // The config may be undefined if there is nothing currently targeting this UIView.
        // Dispose the current component, if there is one
        if (!config)
            return this.disposeLast();
        // Only care about Ng2 configs
        if (!(config instanceof __WEBPACK_IMPORTED_MODULE_2__statebuilders_views__["a" /* Ng2ViewConfig */]))
            return;
        // The "new" viewconfig is already applied, so exit early
        if (this.uiViewData.config === config)
            return;
        // This is a new ViewConfig.  Dispose the previous component
        this.disposeLast();
        __WEBPACK_IMPORTED_MODULE_1__uirouter_core__["trace"].traceUIViewConfigUpdated(this.uiViewData, config && config.viewDecl.$context);
        this.applyUpdatedConfig(config);
    };
    UIView.prototype.applyUpdatedConfig = function (config) {
        this.uiViewData.config = config;
        // Create the Injector for the routed component
        var context = new __WEBPACK_IMPORTED_MODULE_1__uirouter_core__["ResolveContext"](config.path);
        var componentInjector = this.getComponentInjector(context);
        // Get the component class from the view declaration. TODO: allow promises?
        var componentClass = config.viewDecl.component;
        // Create the component
        var compFactoryResolver = componentInjector.get(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ComponentFactoryResolver"]);
        var compFactory = compFactoryResolver.resolveComponentFactory(componentClass);
        this.componentRef = this.componentTarget.createComponent(compFactory, undefined, componentInjector);
        // Wire resolves to @Input()s
        this.applyInputBindings(compFactory, this.componentRef, context, componentClass);
    };
    /**
     * Creates a new Injector for a routed component.
     *
     * Adds resolve values to the Injector
     * Adds providers from the NgModule for the state
     * Adds providers from the parent Component in the component tree
     * Adds a PARENT_INJECT view context object
     *
     * @returns an Injector
     */
    UIView.prototype.getComponentInjector = function (context) {
        // Map resolves to "useValue: providers"
        var resolvables = context.getTokens().map(function (token) { return context.getResolvable(token); }).filter(function (r) { return r.resolved; });
        var newProviders = resolvables.map(function (r) { return ({ provide: r.token, useValue: r.data }); });
        var parentInject = { context: this.uiViewData.config.viewDecl.$context, fqn: this.uiViewData.fqn };
        newProviders.push({ provide: UIView.PARENT_INJECT, useValue: parentInject });
        var parentComponentInjector = this.viewContainerRef.injector;
        var moduleInjector = context.getResolvable(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__["NATIVE_INJECTOR_TOKEN"]).data;
        var mergedParentInjector = new __WEBPACK_IMPORTED_MODULE_3__mergeInjector__["a" /* MergeInjector */](moduleInjector, parentComponentInjector);
        return __WEBPACK_IMPORTED_MODULE_0__angular_core__["ReflectiveInjector"].resolveAndCreate(newProviders, mergedParentInjector);
    };
    /**
     * Supplies component inputs with resolve data
     *
     * Finds component inputs which match resolves (by name) and sets the input value
     * to the resolve data.
     */
    UIView.prototype.applyInputBindings = function (factory, ref, context, componentClass) {
        var component = ref.instance;
        var bindings = this.uiViewData.config.viewDecl['bindings'] || {};
        var explicitBoundProps = Object.keys(bindings);
        // Returns the actual component property for a renamed an input renamed using `@Input('foo') _foo`.
        // return the `_foo` property
        var renamedInputProp = function (prop) {
            var input = factory.inputs.find(function (i) { return i.templateName === prop; });
            return input && input.propName || prop;
        };
        // Supply resolve data to component as specified in the state's `bindings: {}`
        var explicitInputTuples = explicitBoundProps
            .reduce(function (acc, key) { return acc.concat([{ prop: renamedInputProp(key), token: bindings[key] }]); }, []);
        // Supply resolve data to matching @Input('prop') or inputs: ['prop']
        var implicitInputTuples = ng2ComponentInputs(factory)
            .filter(function (tuple) { return !Object(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__["inArray"])(explicitBoundProps, tuple.prop); });
        var addResolvable = function (tuple) { return ({
            prop: tuple.prop,
            resolvable: context.getResolvable(tuple.token),
        }); };
        explicitInputTuples.concat(implicitInputTuples)
            .map(addResolvable)
            .filter(function (tuple) { return tuple.resolvable && tuple.resolvable.resolved; })
            .forEach(function (tuple) { component[tuple.prop] = tuple.resolvable.data; });
        // Initiate change detection for the newly created component
        ref.changeDetectorRef.detectChanges();
    };
    return UIView;
}());

UIView.PARENT_INJECT = "UIView.PARENT_INJECT";
UIView.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"], args: [{
                selector: 'ui-view, [ui-view]',
                template: "\n    <ng-template #componentTarget></ng-template>\n    <ng-content *ngIf=\"!componentRef\"></ng-content>\n  "
                // styles: [`
                //   .done-true {
                //     text-decoration: line-through;
                //     color: grey;
                //   }`
                // ],
                // template: `
                // <div style="padding: 1em; border: 1px solid lightgrey;">
                //
                //   <div #content style="color: lightgrey; font-size: smaller;">
                //     <div>ui-view #{{uiViewData?.id}} created by '{{ parentContext?.name || "(root)" }}' state</div>
                //     <div>name: (absolute) '{{uiViewData?.fqn}}' (contextual) '{{uiViewData?.name}}@{{parentContext?.name}}' </div>
                //     <div>currently filled by: '{{(uiViewData?.config && uiViewData?.config?.viewDecl?.$context) || 'empty...'}}'</div>
                //   </div>
                //
                // </div>`
            },] },
];
/** @nocollapse */
UIView.ctorParameters = function () { return [
    { type: __WEBPACK_IMPORTED_MODULE_1__uirouter_core__["UIRouter"], },
    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__["Inject"], args: [UIView.PARENT_INJECT,] },] },
    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewContainerRef"], },
]; };
UIView.propDecorators = {
    'componentTarget': [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"], args: ['componentTarget', { read: __WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewContainerRef"] },] },],
    'name': [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"], args: ['name',] },],
    '_name': [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"], args: ['ui-view',] },],
};
//# sourceMappingURL=uiView.js.map

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module core
 */
/**
 * Matches state names using glob-like pattern strings.
 *
 * Globs can be used in specific APIs including:
 *
 * - [[StateService.is]]
 * - [[StateService.includes]]
 * - The first argument to Hook Registration functions like [[TransitionService.onStart]]
 *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]
 *
 * A `Glob` string is a pattern which matches state names.
 * Nested state names are split into segments (separated by a dot) when processing.
 * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']
 *
 * Globs work according to the following rules:
 *
 * ### Exact match:
 *
 * The glob `'A.B'` matches the state named exactly `'A.B'`.
 *
 * | Glob        |Matches states named|Does not match state named|
 * |:------------|:--------------------|:---------------------|
 * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |
 * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |
 * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|
 *
 * ### Single star (`*`)
 *
 * A single star (`*`) is a wildcard that matches exactly one segment.
 *
 * | Glob        |Matches states named  |Does not match state named |
 * |:------------|:---------------------|:--------------------------|
 * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |
 * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |
 * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|
 *
 * ### Double star (`**`)
 *
 * A double star (`'**'`) is a wildcard that matches *zero or more segments*
 *
 * | Glob        |Matches states named                           |Does not match state named         |
 * |:------------|:----------------------------------------------|:----------------------------------|
 * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |
 * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |
 * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |
 * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |
 *
 */
var Glob = /** @class */ (function () {
    function Glob(text) {
        this.text = text;
        this.glob = text.split('.');
        var regexpString = this.text.split('.')
            .map(function (seg) {
            if (seg === '**')
                return '(?:|(?:\\.[^.]*)*)';
            if (seg === '*')
                return '\\.[^.]*';
            return '\\.' + seg;
        }).join('');
        this.regexp = new RegExp("^" + regexpString + "$");
    }
    Glob.prototype.matches = function (name) {
        return this.regexp.test('.' + name);
    };
    /** Returns true if the string has glob-like characters in it */
    Glob.is = function (text) {
        return !!/[!,*]+/.exec(text);
    };
    /** Returns a glob from the string, or null if the string isn't Glob-like */
    Glob.fromString = function (text) {
        return Glob.is(text) ? new Glob(text) : null;
    };
    return Glob;
}());
exports.Glob = Glob;
//# sourceMappingURL=glob.js.map

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module transition
 */
/** for typedoc */
var trace_1 = __webpack_require__(9);
var coreservices_1 = __webpack_require__(5);
var strings_1 = __webpack_require__(8);
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var hof_1 = __webpack_require__(2);
var interface_1 = __webpack_require__(11); // has or is using
var transitionHook_1 = __webpack_require__(15);
var hookRegistry_1 = __webpack_require__(28);
var hookBuilder_1 = __webpack_require__(39);
var pathFactory_1 = __webpack_require__(20);
var param_1 = __webpack_require__(13);
var resolvable_1 = __webpack_require__(16);
var resolveContext_1 = __webpack_require__(21);
/** @hidden */
var stateSelf = hof_1.prop("self");
/**
 * Represents a transition between two states.
 *
 * When navigating to a state, we are transitioning **from** the current state **to** the new state.
 *
 * This object contains all contextual information about the to/from states, parameters, resolves.
 * It has information about all states being entered and exited as a result of the transition.
 */
var Transition = /** @class */ (function () {
    /**
     * Creates a new Transition object.
     *
     * If the target state is not valid, an error is thrown.
     *
     * @internalapi
     *
     * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`
     *        encapsulates the "from state".
     * @param targetState The target state and parameters being transitioned to (also, the transition options)
     * @param router The [[UIRouter]] instance
     */
    function Transition(fromPath, targetState, router) {
        var _this = this;
        /** @hidden */
        this._deferred = coreservices_1.services.$q.defer();
        /**
         * This promise is resolved or rejected based on the outcome of the Transition.
         *
         * When the transition is successful, the promise is resolved
         * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error
         */
        this.promise = this._deferred.promise;
        /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */
        this._registeredHooks = {};
        /** @hidden */
        this._hookBuilder = new hookBuilder_1.HookBuilder(this);
        /** Checks if this transition is currently active/running. */
        this.isActive = function () {
            return _this.router.globals.transition === _this;
        };
        this.router = router;
        this._targetState = targetState;
        if (!targetState.valid()) {
            throw new Error(targetState.error());
        }
        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.
        this._options = common_1.extend({ current: hof_1.val(this) }, targetState.options());
        this.$id = router.transitionService._transitionCount++;
        var toPath = pathFactory_1.PathUtils.buildToPath(fromPath, targetState);
        this._treeChanges = pathFactory_1.PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);
        this.createTransitionHookRegFns();
        var onCreateHooks = this._hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.CREATE);
        transitionHook_1.TransitionHook.invokeHooks(onCreateHooks, function () { return null; });
        this.applyViewConfigs(router);
    }
    /** @hidden */
    Transition.prototype.onBefore = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    Transition.prototype.onStart = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    Transition.prototype.onExit = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    Transition.prototype.onRetain = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    Transition.prototype.onEnter = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    Transition.prototype.onFinish = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    Transition.prototype.onSuccess = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    Transition.prototype.onError = function (criteria, callback, options) { return; };
    /** @hidden
     * Creates the transition-level hook registration functions
     * (which can then be used to register hooks)
     */
    Transition.prototype.createTransitionHookRegFns = function () {
        var _this = this;
        this.router.transitionService._pluginapi._getEvents()
            .filter(function (type) { return type.hookPhase !== interface_1.TransitionHookPhase.CREATE; })
            .forEach(function (type) { return hookRegistry_1.makeEvent(_this, _this.router.transitionService, type); });
    };
    /** @internalapi */
    Transition.prototype.getHooks = function (hookName) {
        return this._registeredHooks[hookName];
    };
    Transition.prototype.applyViewConfigs = function (router) {
        var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });
        pathFactory_1.PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);
    };
    /**
     * @internalapi
     *
     * @returns the internal from [State] object
     */
    Transition.prototype.$from = function () {
        return common_1.tail(this._treeChanges.from).state;
    };
    /**
     * @internalapi
     *
     * @returns the internal to [State] object
     */
    Transition.prototype.$to = function () {
        return common_1.tail(this._treeChanges.to).state;
    };
    /**
     * Returns the "from state"
     *
     * Returns the state that the transition is coming *from*.
     *
     * @returns The state declaration object for the Transition's ("from state").
     */
    Transition.prototype.from = function () {
        return this.$from().self;
    };
    /**
     * Returns the "to state"
     *
     * Returns the state that the transition is going *to*.
     *
     * @returns The state declaration object for the Transition's target state ("to state").
     */
    Transition.prototype.to = function () {
        return this.$to().self;
    };
    /**
     * Gets the Target State
     *
     * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.
     *
     * @returns the [[TargetState]] of this Transition
     */
    Transition.prototype.targetState = function () {
        return this._targetState;
    };
    /**
     * Determines whether two transitions are equivalent.
     * @deprecated
     */
    Transition.prototype.is = function (compare) {
        if (compare instanceof Transition) {
            // TODO: Also compare parameters
            return this.is({ to: compare.$to().name, from: compare.$from().name });
        }
        return !((compare.to && !hookRegistry_1.matchState(this.$to(), compare.to)) ||
            (compare.from && !hookRegistry_1.matchState(this.$from(), compare.from)));
    };
    Transition.prototype.params = function (pathname) {
        if (pathname === void 0) { pathname = "to"; }
        return Object.freeze(this._treeChanges[pathname].map(hof_1.prop("paramValues")).reduce(common_1.mergeR, {}));
    };
    /**
     * Creates a [[UIInjector]] Dependency Injector
     *
     * Returns a Dependency Injector for the Transition's target state (to state).
     * The injector provides resolve values which the target state has access to.
     *
     * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).
     *
     * #### Example:
     * ```js
     * .onEnter({ entering: 'myState' }, trans => {
     *   var myResolveValue = trans.injector().get('myResolve');
     *   // Inject a global service from the global/native injector (if it exists)
     *   var MyService = trans.injector().get('MyService');
     * })
     * ```
     *
     * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.
     * You can use [[UIInjector.getAsync]] to get a promise for the data.
     * #### Example:
     * ```js
     * .onBefore({}, trans => {
     *   return trans.injector().getAsync('myResolve').then(myResolveValue =>
     *     return myResolveValue !== 'ABORT';
     *   });
     * });
     * ```
     *
     * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.
     * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.
     * #### Example:
     * ```js
     * .onEnter({ to: 'foo.bar' }, trans => {
     *   // returns result of `foo` state's `data` resolve
     *   // even though `foo.bar` also has a `data` resolve
     *   var fooData = trans.injector('foo').get('data');
     * });
     * ```
     *
     * If you need resolve data from the exiting states, pass `'from'` as `pathName`.
     * The resolve data from the `from` path will be returned.
     * #### Example:
     * ```js
     * .onExit({ exiting: 'foo.bar' }, trans => {
     *   // Gets the resolve value of `data` from the exiting state.
     *   var fooData = trans.injector(null, 'foo.bar').get('data');
     * });
     * ```
     *
     *
     * @param state Limits the resolves provided to only the resolves the provided state has access to.
     * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.
     *
     * @returns a [[UIInjector]]
     */
    Transition.prototype.injector = function (state, pathName) {
        if (pathName === void 0) { pathName = "to"; }
        var path = this._treeChanges[pathName];
        if (state)
            path = pathFactory_1.PathUtils.subPath(path, function (node) { return node.state === state || node.state.name === state; });
        return new resolveContext_1.ResolveContext(path).injector();
    };
    /**
     * Gets all available resolve tokens (keys)
     *
     * This method can be used in conjunction with [[injector]] to inspect the resolve values
     * available to the Transition.
     *
     * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states
     * in the Transition's [[TreeChanges.to]] path.
     *
     * #### Example:
     * This example logs all resolve values
     * ```js
     * let tokens = trans.getResolveTokens();
     * tokens.forEach(token => console.log(token + " = " + trans.injector().get(token)));
     * ```
     *
     * #### Example:
     * This example creates promises for each resolve value.
     * This triggers fetches of resolves (if any have not yet been fetched).
     * When all promises have all settled, it logs the resolve values.
     * ```js
     * let tokens = trans.getResolveTokens();
     * let promise = tokens.map(token => trans.injector().getAsync(token));
     * Promise.all(promises).then(values => console.log("Resolved values: " + values));
     * ```
     *
     * Note: Angular 1 users whould use `$q.all()`
     *
     * @param pathname resolve context's path name (e.g., `to` or `from`)
     *
     * @returns an array of resolve tokens (keys)
     */
    Transition.prototype.getResolveTokens = function (pathname) {
        if (pathname === void 0) { pathname = "to"; }
        return new resolveContext_1.ResolveContext(this._treeChanges[pathname]).getTokens();
    };
    /**
     * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.
     *
     * #### Example:
     * ```js
     * transitionService.onBefore({}, transition => {
     *   transition.addResolvable({
     *     token: 'myResolve',
     *     deps: ['MyService'],
     *     resolveFn: myService => myService.getData()
     *   });
     * });
     * ```
     *
     * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])
     * @param state the state in the "to path" which should receive the new resolve (otherwise, the root state)
     */
    Transition.prototype.addResolvable = function (resolvable, state) {
        if (state === void 0) { state = ""; }
        resolvable = hof_1.is(resolvable_1.Resolvable)(resolvable) ? resolvable : new resolvable_1.Resolvable(resolvable);
        var stateName = (typeof state === "string") ? state : state.name;
        var topath = this._treeChanges.to;
        var targetNode = common_1.find(topath, function (node) { return node.state.name === stateName; });
        var resolveContext = new resolveContext_1.ResolveContext(topath);
        resolveContext.addResolvables([resolvable], targetNode.state);
    };
    /**
     * Gets the transition from which this transition was redirected.
     *
     * If the current transition is a redirect, this method returns the transition that was redirected.
     *
     * #### Example:
     * ```js
     * let transitionA = $state.go('A').transition
     * transitionA.onStart({}, () => $state.target('B'));
     * $transitions.onSuccess({ to: 'B' }, (trans) => {
     *   trans.to().name === 'B'; // true
     *   trans.redirectedFrom() === transitionA; // true
     * });
     * ```
     *
     * @returns The previous Transition, or null if this Transition is not the result of a redirection
     */
    Transition.prototype.redirectedFrom = function () {
        return this._options.redirectedFrom || null;
    };
    /**
     * Gets the original transition in a redirect chain
     *
     * A transition might belong to a long chain of multiple redirects.
     * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.
     *
     * #### Example:
     * ```js
     * // states
     * registry.register({ name: 'A', redirectTo: 'B' });
     * registry.register({ name: 'B', redirectTo: 'C' });
     * registry.register({ name: 'C', redirectTo: 'D' });
     * registry.register({ name: 'D' });
     *
     * let transitionA = $state.go('A').transition
     *
     * $transitions.onSuccess({ to: 'D' }, (trans) => {
     *   trans.to().name === 'D'; // true
     *   trans.redirectedFrom().to().name === 'C'; // true
     *   trans.originalTransition() === transitionA; // true
     *   trans.originalTransition().to().name === 'A'; // true
     * });
     * ```
     *
     * @returns The original Transition that started a redirect chain
     */
    Transition.prototype.originalTransition = function () {
        var rf = this.redirectedFrom();
        return (rf && rf.originalTransition()) || this;
    };
    /**
     * Get the transition options
     *
     * @returns the options for this Transition.
     */
    Transition.prototype.options = function () {
        return this._options;
    };
    /**
     * Gets the states being entered.
     *
     * @returns an array of states that will be entered during this transition.
     */
    Transition.prototype.entering = function () {
        return common_1.map(this._treeChanges.entering, hof_1.prop('state')).map(stateSelf);
    };
    /**
     * Gets the states being exited.
     *
     * @returns an array of states that will be exited during this transition.
     */
    Transition.prototype.exiting = function () {
        return common_1.map(this._treeChanges.exiting, hof_1.prop('state')).map(stateSelf).reverse();
    };
    /**
     * Gets the states being retained.
     *
     * @returns an array of states that are already entered from a previous Transition, that will not be
     *    exited during this Transition
     */
    Transition.prototype.retained = function () {
        return common_1.map(this._treeChanges.retained, hof_1.prop('state')).map(stateSelf);
    };
    /**
     * Get the [[ViewConfig]]s associated with this Transition
     *
     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.
     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., "to" or "entering").
     *
     * @param pathname the name of the path to fetch views for:
     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)
     * @param state If provided, only returns the `ViewConfig`s for a single state in the path
     *
     * @returns a list of ViewConfig objects for the given path.
     */
    Transition.prototype.views = function (pathname, state) {
        if (pathname === void 0) { pathname = "entering"; }
        var path = this._treeChanges[pathname];
        path = !state ? path : path.filter(hof_1.propEq('state', state));
        return path.map(hof_1.prop("views")).filter(common_1.identity).reduce(common_1.unnestR, []);
    };
    Transition.prototype.treeChanges = function (pathname) {
        return pathname ? this._treeChanges[pathname] : this._treeChanges;
    };
    /**
     * Creates a new transition that is a redirection of the current one.
     *
     * This transition can be returned from a [[TransitionService]] hook to
     * redirect a transition to a new state and/or set of parameters.
     *
     * @internalapi
     *
     * @returns Returns a new [[Transition]] instance.
     */
    Transition.prototype.redirect = function (targetState) {
        var redirects = 1, trans = this;
        while ((trans = trans.redirectedFrom()) != null) {
            if (++redirects > 20)
                throw new Error("Too many consecutive Transition redirects (20+)");
        }
        var redirectOpts = { redirectedFrom: this, source: "redirect" };
        // If the original transition was caused by URL sync, then use { location: 'replace' }
        // on the new transition (unless the target state explicitly specifies location: false).
        // This causes the original url to be replaced with the url for the redirect target
        // so the original url disappears from the browser history.
        if (this.options().source === 'url' && targetState.options().location !== false) {
            redirectOpts.location = 'replace';
        }
        var newOptions = common_1.extend({}, this.options(), targetState.options(), redirectOpts);
        targetState = targetState.withOptions(newOptions, true);
        var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);
        var originalEnteringNodes = this._treeChanges.entering;
        var redirectEnteringNodes = newTransition._treeChanges.entering;
        // --- Re-use resolve data from original transition ---
        // When redirecting from a parent state to a child state where the parent parameter values haven't changed
        // (because of the redirect), the resolves fetched by the original transition are still valid in the
        // redirected transition.
        //
        // This allows you to define a redirect on a parent state which depends on an async resolve value.
        // You can wait for the resolve, then redirect to a child state based on the result.
        // The redirected transition does not have to re-fetch the resolve.
        // ---------------------------------------------------------
        var nodeIsReloading = function (reloadState) { return function (node) {
            return reloadState && node.state.includes[reloadState.name];
        }; };
        // Find any "entering" nodes in the redirect path that match the original path and aren't being reloaded
        var matchingEnteringNodes = pathFactory_1.PathUtils.matching(redirectEnteringNodes, originalEnteringNodes, pathFactory_1.PathUtils.nonDynamicParams)
            .filter(hof_1.not(nodeIsReloading(targetState.options().reloadState)));
        // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.
        matchingEnteringNodes.forEach(function (node, idx) {
            node.resolvables = originalEnteringNodes[idx].resolvables;
        });
        return newTransition;
    };
    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */
    Transition.prototype._changedParams = function () {
        var tc = this._treeChanges;
        /** Return undefined if it's not a "dynamic" transition, for the following reasons */
        // If user explicitly wants a reload
        if (this._options.reload)
            return undefined;
        // If any states are exiting or entering
        if (tc.exiting.length || tc.entering.length)
            return undefined;
        // If to/from path lengths differ
        if (tc.to.length !== tc.from.length)
            return undefined;
        // If the to/from paths are different
        var pathsDiffer = common_1.arrayTuples(tc.to, tc.from)
            .map(function (tuple) { return tuple[0].state !== tuple[1].state; })
            .reduce(common_1.anyTrueR, false);
        if (pathsDiffer)
            return undefined;
        // Find any parameter values that differ
        var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });
        var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];
        var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);
        return tuples.map(function (_a) {
            var schema = _a[0], toVals = _a[1], fromVals = _a[2];
            return param_1.Param.changed(schema, toVals, fromVals);
        }).reduce(common_1.unnestR, []);
    };
    /**
     * Returns true if the transition is dynamic.
     *
     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.
     *
     * @returns true if the Transition is dynamic
     */
    Transition.prototype.dynamic = function () {
        var changes = this._changedParams();
        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(common_1.anyTrueR, false);
    };
    /**
     * Returns true if the transition is ignored.
     *
     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.
     *
     * @returns true if the Transition is ignored.
     */
    Transition.prototype.ignored = function () {
        return !!this._ignoredReason();
    };
    /** @hidden */
    Transition.prototype._ignoredReason = function () {
        var pending = this.router.globals.transition;
        var reloadState = this._options.reloadState;
        var same = function (pathA, pathB) {
            if (pathA.length !== pathB.length)
                return false;
            var matching = pathFactory_1.PathUtils.matching(pathA, pathB);
            return pathA.length === matching.filter(function (node) { return !reloadState || !node.state.includes[reloadState.name]; }).length;
        };
        var newTC = this.treeChanges();
        var pendTC = pending && pending.treeChanges();
        if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting))
            return "SameAsPending";
        if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to))
            return "SameAsCurrent";
    };
    /**
     * Runs the transition
     *
     * This method is generally called from the [[StateService.transitionTo]]
     *
     * @internalapi
     *
     * @returns a promise for a successful transition.
     */
    Transition.prototype.run = function () {
        var _this = this;
        var runAllHooks = transitionHook_1.TransitionHook.runAllHooks;
        // Gets transition hooks array for the given phase
        var getHooksFor = function (phase) {
            return _this._hookBuilder.buildHooksForPhase(phase);
        };
        // When the chain is complete, then resolve or reject the deferred
        var transitionSuccess = function () {
            trace_1.trace.traceSuccess(_this.$to(), _this);
            _this.success = true;
            _this._deferred.resolve(_this.to());
            runAllHooks(getHooksFor(interface_1.TransitionHookPhase.SUCCESS));
        };
        var transitionError = function (reason) {
            trace_1.trace.traceError(reason, _this);
            _this.success = false;
            _this._deferred.reject(reason);
            _this._error = reason;
            runAllHooks(getHooksFor(interface_1.TransitionHookPhase.ERROR));
        };
        var runTransition = function () {
            // Wait to build the RUN hook chain until the BEFORE hooks are done
            // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.
            var allRunHooks = getHooksFor(interface_1.TransitionHookPhase.RUN);
            var done = function () { return coreservices_1.services.$q.when(undefined); };
            return transitionHook_1.TransitionHook.invokeHooks(allRunHooks, done);
        };
        var startTransition = function () {
            var globals = _this.router.globals;
            globals.lastStartedTransitionId = _this.$id;
            globals.transition = _this;
            globals.transitionHistory.enqueue(_this);
            trace_1.trace.traceTransitionStart(_this);
            return coreservices_1.services.$q.when(undefined);
        };
        var allBeforeHooks = getHooksFor(interface_1.TransitionHookPhase.BEFORE);
        transitionHook_1.TransitionHook.invokeHooks(allBeforeHooks, startTransition)
            .then(runTransition)
            .then(transitionSuccess, transitionError);
        return this.promise;
    };
    /**
     * Checks if the Transition is valid
     *
     * @returns true if the Transition is valid
     */
    Transition.prototype.valid = function () {
        return !this.error() || this.success !== undefined;
    };
    /**
     * Aborts this transition
     *
     * Imperative API to abort a Transition.
     * This only applies to Transitions that are not yet complete.
     */
    Transition.prototype.abort = function () {
        // Do not set flag if the transition is already complete
        if (predicates_1.isUndefined(this.success)) {
            this._aborted = true;
        }
    };
    /**
     * The Transition error reason.
     *
     * If the transition is invalid (and could not be run), returns the reason the transition is invalid.
     * If the transition was valid and ran, but was not successful, returns the reason the transition failed.
     *
     * @returns an error message explaining why the transition is invalid, or the reason the transition failed.
     */
    Transition.prototype.error = function () {
        var state = this.$to();
        if (state.self.abstract)
            return "Cannot transition to abstract state '" + state.name + "'";
        var paramDefs = state.parameters(), values = this.params();
        var invalidParams = paramDefs.filter(function (param) { return !param.validates(values[param.id]); });
        if (invalidParams.length) {
            return "Param values not valid for state '" + state.name + "'. Invalid params: [ " + invalidParams.map(function (param) { return param.id; }).join(', ') + " ]";
        }
        if (this.success === false)
            return this._error;
    };
    /**
     * A string representation of the Transition
     *
     * @returns A string representation of the Transition
     */
    Transition.prototype.toString = function () {
        var fromStateOrName = this.from();
        var toStateOrName = this.to();
        var avoidEmptyHash = function (params) {
            return (params["#"] !== null && params["#"] !== undefined) ? params : common_1.omit(params, ["#"]);
        };
        // (X) means the to state is invalid.
        var id = this.$id, from = predicates_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = strings_1.stringify(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}))), toValid = this.valid() ? "" : "(X) ", to = predicates_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = strings_1.stringify(avoidEmptyHash(this.params()));
        return "Transition#" + id + "( '" + from + "'" + fromParams + " -> " + toValid + "'" + to + "'" + toParams + " )";
    };
    /** @hidden */
    Transition.diToken = Transition;
    return Transition;
}());
exports.Transition = Transition;
//# sourceMappingURL=transition.js.map

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** @module path */ /** for typedoc */
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var targetState_1 = __webpack_require__(12);
var pathNode_1 = __webpack_require__(29);
/**
 * This class contains functions which convert TargetStates, Nodes and paths from one type to another.
 */
var PathUtils = /** @class */ (function () {
    function PathUtils() {
    }
    /** Given a PathNode[], create an TargetState */
    PathUtils.makeTargetState = function (registry, path) {
        var state = common_1.tail(path).state;
        return new targetState_1.TargetState(registry, state, path.map(hof_1.prop("paramValues")).reduce(common_1.mergeR, {}), {});
    };
    PathUtils.buildPath = function (targetState) {
        var toParams = targetState.params();
        return targetState.$state().path.map(function (state) { return new pathNode_1.PathNode(state).applyRawParams(toParams); });
    };
    /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */
    PathUtils.buildToPath = function (fromPath, targetState) {
        var toPath = PathUtils.buildPath(targetState);
        if (targetState.options().inherit) {
            return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));
        }
        return toPath;
    };
    /**
     * Creates ViewConfig objects and adds to nodes.
     *
     * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state
     */
    PathUtils.applyViewConfigs = function ($view, path, states) {
        // Only apply the viewConfigs to the nodes for the given states
        path.filter(function (node) { return common_1.inArray(states, node.state); }).forEach(function (node) {
            var viewDecls = common_1.values(node.state.views || {});
            var subPath = PathUtils.subPath(path, function (n) { return n === node; });
            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });
            node.views = viewConfigs.reduce(common_1.unnestR, []);
        });
    };
    /**
     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath
     *
     * For a parameter in a node to be inherited from the from path:
     * - The toPath's node must have a matching node in the fromPath (by state).
     * - The parameter name must not be found in the toKeys parameter array.
     *
     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some
     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,
     * it is not inherited from the fromPath.
     */
    PathUtils.inheritParams = function (fromPath, toPath, toKeys) {
        if (toKeys === void 0) { toKeys = []; }
        function nodeParamVals(path, state) {
            var node = common_1.find(path, hof_1.propEq('state', state));
            return common_1.extend({}, node && node.paramValues);
        }
        var noInherit = fromPath.map(function (node) { return node.paramSchema; })
            .reduce(common_1.unnestR, [])
            .filter(function (param) { return !param.inherit; })
            .map(hof_1.prop('id'));
        /**
         * Given an [[PathNode]] "toNode", return a new [[PathNode]] with param values inherited from the
         * matching node in fromPath.  Only inherit keys that aren't found in "toKeys" from the node in "fromPath""
         */
        function makeInheritedParamsNode(toNode) {
            // All param values for the node (may include default key/vals, when key was not found in toParams)
            var toParamVals = common_1.extend({}, toNode && toNode.paramValues);
            // limited to only those keys found in toParams
            var incomingParamVals = common_1.pick(toParamVals, toKeys);
            toParamVals = common_1.omit(toParamVals, toKeys);
            var fromParamVals = common_1.omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);
            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals
            var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);
            return new pathNode_1.PathNode(toNode.state).applyRawParams(ownParamVals);
        }
        // The param keys specified by the incoming toParams
        return toPath.map(makeInheritedParamsNode);
    };
    /**
     * Computes the tree changes (entering, exiting) between a fromPath and toPath.
     */
    PathUtils.treeChanges = function (fromPath, toPath, reloadState) {
        var keep = 0, max = Math.min(fromPath.length, toPath.length);
        var nodesMatch = function (node1, node2) {
            return node1.equals(node2, PathUtils.nonDynamicParams);
        };
        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {
            keep++;
        }
        /** Given a retained node, return a new node which uses the to node's param values */
        function applyToParams(retainedNode, idx) {
            var cloned = pathNode_1.PathNode.clone(retainedNode);
            cloned.paramValues = toPath[idx].paramValues;
            return cloned;
        }
        var from, retained, exiting, entering, to;
        from = fromPath;
        retained = from.slice(0, keep);
        exiting = from.slice(keep);
        // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped
        var retainedWithToParams = retained.map(applyToParams);
        entering = toPath.slice(keep);
        to = (retainedWithToParams).concat(entering);
        return { from: from, to: to, retained: retained, exiting: exiting, entering: entering };
    };
    /**
     * Returns a new path which is: the subpath of the first path which matches the second path.
     *
     * The new path starts from root and contains any nodes that match the nodes in the second path.
     * It stops before the first non-matching node.
     *
     * Nodes are compared using their state property and their parameter values.
     * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.
     *
     * @param pathA the first path
     * @param pathB the second path
     * @param paramsFn a function which returns the parameters to consider when comparing
     *
     * @returns an array of PathNodes from the first path which match the nodes in the second path
     */
    PathUtils.matching = function (pathA, pathB, paramsFn) {
        var done = false;
        var tuples = common_1.arrayTuples(pathA, pathB);
        return tuples.reduce(function (matching, _a) {
            var nodeA = _a[0], nodeB = _a[1];
            done = done || !nodeA.equals(nodeB, paramsFn);
            return done ? matching : matching.concat(nodeA);
        }, []);
    };
    /**
     * Returns true if two paths are identical.
     *
     * @param pathA
     * @param pathB
     * @param paramsFn a function which returns the parameters to consider when comparing
     * @returns true if the the states and parameter values for both paths are identical
     */
    PathUtils.equals = function (pathA, pathB, paramsFn) {
        return pathA.length === pathB.length &&
            PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;
    };
    /**
     * Return a subpath of a path, which stops at the first matching node
     *
     * Given an array of nodes, returns a subset of the array starting from the first node,
     * stopping when the first node matches the predicate.
     *
     * @param path a path of [[PathNode]]s
     * @param predicate a [[Predicate]] fn that matches [[PathNode]]s
     * @returns a subpath up to the matching node, or undefined if no match is found
     */
    PathUtils.subPath = function (path, predicate) {
        var node = common_1.find(path, predicate);
        var elementIdx = path.indexOf(node);
        return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);
    };
    PathUtils.nonDynamicParams = function (node) {
        return node.state.parameters({ inherit: false })
            .filter(function (param) { return !param.dynamic; });
    };
    /** Gets the raw parameter values from a path */
    PathUtils.paramValues = function (path) {
        return path.reduce(function (acc, node) { return common_1.extend(acc, node.paramValues); }, {});
    };
    return PathUtils;
}());
exports.PathUtils = PathUtils;
//# sourceMappingURL=pathFactory.js.map

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module resolve */
/** for typedoc */
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var trace_1 = __webpack_require__(9);
var coreservices_1 = __webpack_require__(5);
var interface_1 = __webpack_require__(40);
var resolvable_1 = __webpack_require__(16);
var pathFactory_1 = __webpack_require__(20);
var strings_1 = __webpack_require__(8);
var common_2 = __webpack_require__(7);
var whens = interface_1.resolvePolicies.when;
var ALL_WHENS = [whens.EAGER, whens.LAZY];
var EAGER_WHENS = [whens.EAGER];
exports.NATIVE_INJECTOR_TOKEN = "Native Injector";
/**
 * Encapsulates Dependency Injection for a path of nodes
 *
 * UI-Router states are organized as a tree.
 * A nested state has a path of ancestors to the root of the tree.
 * When a state is being activated, each element in the path is wrapped as a [[PathNode]].
 * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.
 *
 * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.
 */
var ResolveContext = /** @class */ (function () {
    function ResolveContext(_path) {
        this._path = _path;
    }
    /** Gets all the tokens found in the resolve context, de-duplicated */
    ResolveContext.prototype.getTokens = function () {
        return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(common_1.uniqR, []);
    };
    /**
     * Gets the Resolvable that matches the token
     *
     * Gets the last Resolvable that matches the token in this context, or undefined.
     * Throws an error if it doesn't exist in the ResolveContext
     */
    ResolveContext.prototype.getResolvable = function (token) {
        var matching = this._path.map(function (node) { return node.resolvables; })
            .reduce(common_1.unnestR, [])
            .filter(function (r) { return r.token === token; });
        return common_1.tail(matching);
    };
    /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */
    ResolveContext.prototype.getPolicy = function (resolvable) {
        var node = this.findNode(resolvable);
        return resolvable.getPolicy(node.state);
    };
    /**
     * Returns a ResolveContext that includes a portion of this one
     *
     * Given a state, this method creates a new ResolveContext from this one.
     * The new context starts at the first node (root) and stops at the node for the `state` parameter.
     *
     * #### Why
     *
     * When a transition is created, the nodes in the "To Path" are injected from a ResolveContext.
     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.
     * The "To State" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).
     * This method is used to create a narrower context when injecting ancestor nodes.
     *
     * @example
     * `let ABCD = new ResolveContext([A, B, C, D]);`
     *
     * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:
     * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.
     * However, `B` should only be able to access resolvables from `A`, `B`.
     *
     * When resolving for the `B` node, first take the full "To Path" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.
     * `let AB = ABCD.subcontext(a)`
     */
    ResolveContext.prototype.subContext = function (state) {
        return new ResolveContext(pathFactory_1.PathUtils.subPath(this._path, function (node) { return node.state === state; }));
    };
    /**
     * Adds Resolvables to the node that matches the state
     *
     * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).
     * The resolvable is added to the node matching the `state` parameter.
     *
     * These new resolvables are not automatically fetched.
     * The calling code should either fetch them, fetch something that depends on them,
     * or rely on [[resolvePath]] being called when some state is being entered.
     *
     * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.
     *
     * @param newResolvables the new Resolvables
     * @param state Used to find the node to put the resolvable on
     */
    ResolveContext.prototype.addResolvables = function (newResolvables, state) {
        var node = common_1.find(this._path, hof_1.propEq('state', state));
        var keys = newResolvables.map(function (r) { return r.token; });
        node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);
    };
    /**
     * Returns a promise for an array of resolved path Element promises
     *
     * @param when
     * @param trans
     * @returns {Promise<any>|any}
     */
    ResolveContext.prototype.resolvePath = function (when, trans) {
        var _this = this;
        if (when === void 0) { when = "LAZY"; }
        // This option determines which 'when' policy Resolvables we are about to fetch.
        var whenOption = common_1.inArray(ALL_WHENS, when) ? when : "LAZY";
        // If the caller specified EAGER, only the EAGER Resolvables are fetched.
        // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`
        var matchedWhens = whenOption === interface_1.resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;
        // get the subpath to the state argument, if provided
        trace_1.trace.traceResolvePath(this._path, when, trans);
        var matchesPolicy = function (acceptedVals, whenOrAsync) {
            return function (resolvable) {
                return common_1.inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);
            };
        };
        // Trigger all the (matching) Resolvables in the path
        // Reduce all the "WAIT" Resolvables into an array
        var promises = this._path.reduce(function (acc, node) {
            var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));
            var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));
            var wait = nodeResolvables.filter(hof_1.not(matchesPolicy(['NOWAIT'], 'async')));
            // For the matching Resolvables, start their async fetch process.
            var subContext = _this.subContext(node.state);
            var getResult = function (r) { return r.get(subContext, trans)
                .then(function (value) { return ({ token: r.token, value: value }); }); };
            nowait.forEach(getResult);
            return acc.concat(wait.map(getResult));
        }, []);
        // Wait for all the "WAIT" resolvables
        return coreservices_1.services.$q.all(promises);
    };
    ResolveContext.prototype.injector = function () {
        return this._injector || (this._injector = new UIInjectorImpl(this));
    };
    ResolveContext.prototype.findNode = function (resolvable) {
        return common_1.find(this._path, function (node) { return common_1.inArray(node.resolvables, resolvable); });
    };
    /**
     * Gets the async dependencies of a Resolvable
     *
     * Given a Resolvable, returns its dependencies as a Resolvable[]
     */
    ResolveContext.prototype.getDependencies = function (resolvable) {
        var _this = this;
        var node = this.findNode(resolvable);
        // Find which other resolvables are "visible" to the `resolvable` argument
        // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)
        var subPath = pathFactory_1.PathUtils.subPath(this._path, function (x) { return x === node; }) || this._path;
        var availableResolvables = subPath
            .reduce(function (acc, _node) { return acc.concat(_node.resolvables); }, []) //all of subpath's resolvables
            .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument
        var getDependency = function (token) {
            var matching = availableResolvables.filter(function (r) { return r.token === token; });
            if (matching.length)
                return common_1.tail(matching);
            var fromInjector = _this.injector().getNative(token);
            if (common_2.isUndefined(fromInjector)) {
                throw new Error("Could not find Dependency Injection token: " + strings_1.stringify(token));
            }
            return new resolvable_1.Resolvable(token, function () { return fromInjector; }, [], fromInjector);
        };
        return resolvable.deps.map(getDependency);
    };
    return ResolveContext;
}());
exports.ResolveContext = ResolveContext;
var UIInjectorImpl = /** @class */ (function () {
    function UIInjectorImpl(context) {
        this.context = context;
        this.native = this.get(exports.NATIVE_INJECTOR_TOKEN) || coreservices_1.services.$injector;
    }
    UIInjectorImpl.prototype.get = function (token) {
        var resolvable = this.context.getResolvable(token);
        if (resolvable) {
            if (this.context.getPolicy(resolvable).async === 'NOWAIT') {
                return resolvable.get(this.context);
            }
            if (!resolvable.resolved) {
                throw new Error("Resolvable async .get() not complete:" + strings_1.stringify(resolvable.token));
            }
            return resolvable.data;
        }
        return this.getNative(token);
    };
    UIInjectorImpl.prototype.getAsync = function (token) {
        var resolvable = this.context.getResolvable(token);
        if (resolvable)
            return resolvable.get(this.context);
        return coreservices_1.services.$q.when(this.native.get(token));
    };
    UIInjectorImpl.prototype.getNative = function (token) {
        return this.native && this.native.get(token);
    };
    return UIInjectorImpl;
}());
//# sourceMappingURL=resolveContext.js.map

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module url
 */
/** for typedoc */
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var predicates_1 = __webpack_require__(1);
var param_1 = __webpack_require__(13);
var strings_1 = __webpack_require__(8);
/** @hidden */
function quoteRegExp(string, param) {
    var surroundPattern = ['', ''], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
    if (!param)
        return result;
    switch (param.squash) {
        case false:
            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];
            break;
        case true:
            result = result.replace(/\/$/, '');
            surroundPattern = ['(?:\/(', ')|\/)?'];
            break;
        default:
            surroundPattern = ["(" + param.squash + "|", ')?'];
            break;
    }
    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];
}
/** @hidden */
var memoizeTo = function (obj, prop, fn) {
    return obj[prop] = obj[prop] || fn();
};
/** @hidden */
var splitOnSlash = strings_1.splitOnDelim('/');
/**
 * Matches URLs against patterns.
 *
 * Matches URLs against patterns and extracts named parameters from the path or the search
 * part of the URL.
 *
 * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)
 * parameters. Multiple search parameter names are separated by '&'. Search parameters
 * do not influence whether or not a URL is matched, but their values are passed through into
 * the matched parameters returned by [[UrlMatcher.exec]].
 *
 * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)
 * or colon placeholders (`/somePath/:param`).
 *
 * - *A parameter RegExp* may be defined for a param after a colon
 * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.
 * The regexp must match for the url to be matched.
 * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.
 *
 * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].
 *
 * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.
 *   See [[UrlMatcherFactory.type]] for more information.
 *
 * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).
 *   A catch-all * parameter value will contain the remainder of the URL.
 *
 * ---
 *
 * Parameter names may contain only word characters (latin letters, digits, and underscore) and
 * must be unique within the pattern (across both path and search parameters).
 * A path parameter matches any number of characters other than '/'. For catch-all
 * placeholders the path parameter matches any number of characters.
 *
 * Examples:
 *
 * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for
 *   trailing slashes, and patterns have to match the entire path, not just a prefix.
 * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or
 *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.
 * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.
 * * `'/user/{id:[^/]*}'` - Same as the previous example.
 * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id
 *   parameter consists of 1 to 8 hex digits.
 * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the
 *   path into the parameter 'path'.
 * * `'/files/*path'` - ditto.
 * * `'/calendar/{start:date}'` - Matches "/calendar/2014-11-12" (because the pattern defined
 *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start
 *
 */
var UrlMatcher = /** @class */ (function () {
    /**
     * @param pattern The pattern to compile into a matcher.
     * @param paramTypes The [[ParamTypes]] registry
     * @param config  A configuration object
     * - `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.
     * - `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.
     */
    function UrlMatcher(pattern, paramTypes, paramFactory, config) {
        var _this = this;
        this.config = config;
        /** @hidden */
        this._cache = { path: [this] };
        /** @hidden */
        this._children = [];
        /** @hidden */
        this._params = [];
        /** @hidden */
        this._segments = [];
        /** @hidden */
        this._compiled = [];
        this.pattern = pattern;
        this.config = common_1.defaults(this.config, {
            params: {},
            strict: true,
            caseInsensitive: false,
            paramMap: common_1.identity
        });
        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:
        //   '*' name
        //   ':' name
        //   '{' name '}'
        //   '{' name ':' regexp '}'
        // The regular expression is somewhat complicated due to the need to allow curly braces
        // inside the regular expression. The placeholder regexp breaks down as follows:
        //    ([:*])([\w\[\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)
        //    \{([\w\[\]]+)(?:\:\s*( ... ))?\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case
        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either
        //    [^{}\\]+                       - anything other than curly braces or backslash
        //    \\.                            - a backslash escape
        //    \{(?:[^{}\\]+|\\.)*\}          - a matched set of curly braces containing other atoms
        var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, last = 0, m, patterns = [];
        var checkParamErrors = function (id) {
            if (!UrlMatcher.nameValidator.test(id))
                throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
            if (common_1.find(_this._params, hof_1.propEq('id', id)))
                throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
        };
        // Split into static segments separated by path parameter placeholders.
        // The number of segments is always 1 more than the number of parameters.
        var matchDetails = function (m, isSearch) {
            // IE[78] returns '' for unmatched groups instead of null
            var id = m[2] || m[3];
            var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '[\\s\\S]*' : null);
            var makeRegexpType = function (regexp) { return common_1.inherit(paramTypes.type(isSearch ? "query" : "path"), {
                pattern: new RegExp(regexp, _this.config.caseInsensitive ? 'i' : undefined)
            }); };
            return {
                id: id,
                regexp: regexp,
                cfg: _this.config.params[id],
                segment: pattern.substring(last, m.index),
                type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)
            };
        };
        var p, segment;
        while ((m = placeholder.exec(pattern))) {
            p = matchDetails(m, false);
            if (p.segment.indexOf('?') >= 0)
                break; // we're into the search part
            checkParamErrors(p.id);
            this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));
            this._segments.push(p.segment);
            patterns.push([p.segment, common_1.tail(this._params)]);
            last = placeholder.lastIndex;
        }
        segment = pattern.substring(last);
        // Find any search parameter names and remove them from the last segment
        var i = segment.indexOf('?');
        if (i >= 0) {
            var search = segment.substring(i);
            segment = segment.substring(0, i);
            if (search.length > 0) {
                last = 0;
                while ((m = searchPlaceholder.exec(search))) {
                    p = matchDetails(m, true);
                    checkParamErrors(p.id);
                    this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));
                    last = placeholder.lastIndex;
                    // check if ?&
                }
            }
        }
        this._segments.push(segment);
        this._compiled = patterns.map(function (pattern) { return quoteRegExp.apply(null, pattern); }).concat(quoteRegExp(segment));
    }
    /**
     * Creates a new concatenated UrlMatcher
     *
     * Builds a new UrlMatcher by appending another UrlMatcher to this one.
     *
     * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.
     */
    UrlMatcher.prototype.append = function (url) {
        this._children.push(url);
        url._cache = {
            path: this._cache.path.concat(url),
            parent: this,
            pattern: null,
        };
        return url;
    };
    /** @hidden */
    UrlMatcher.prototype.isRoot = function () {
        return this._cache.path[0] === this;
    };
    /** Returns the input pattern string */
    UrlMatcher.prototype.toString = function () {
        return this.pattern;
    };
    /**
     * Tests the specified url/path against this matcher.
     *
     * Tests if the given url matches this matcher's pattern, and returns an object containing the captured
     * parameter values.  Returns null if the path does not match.
     *
     * The returned object contains the values
     * of any search parameters that are mentioned in the pattern, but their value may be null if
     * they are not present in `search`. This means that search parameters are always treated
     * as optional.
     *
     * #### Example:
     * ```js
     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {
     *   x: '1', q: 'hello'
     * });
     * // returns { id: 'bob', q: 'hello', r: null }
     * ```
     *
     * @param path    The URL path to match, e.g. `$location.path()`.
     * @param search  URL search parameters, e.g. `$location.search()`.
     * @param hash    URL hash e.g. `$location.hash()`.
     * @param options
     *
     * @returns The captured parameter values.
     */
    UrlMatcher.prototype.exec = function (path, search, hash, options) {
        var _this = this;
        if (search === void 0) { search = {}; }
        if (options === void 0) { options = {}; }
        var match = memoizeTo(this._cache, 'pattern', function () {
            return new RegExp([
                '^',
                common_1.unnest(_this._cache.path.map(hof_1.prop('_compiled'))).join(''),
                _this.config.strict === false ? '\/?' : '',
                '$'
            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);
        }).exec(path);
        if (!match)
            return null;
        //options = defaults(options, { isolate: false });
        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};
        if (nPathSegments !== match.length - 1)
            throw new Error("Unbalanced capture group in route '" + this.pattern + "'");
        function decodePathArray(string) {
            var reverseString = function (str) { return str.split("").reverse().join(""); };
            var unquoteDashes = function (str) { return str.replace(/\\-/g, "-"); };
            var split = reverseString(string).split(/-(?!\\)/);
            var allReversed = common_1.map(split, reverseString);
            return common_1.map(allReversed, unquoteDashes).reverse();
        }
        for (var i = 0; i < nPathSegments; i++) {
            var param = pathParams[i];
            var value = match[i + 1];
            // if the param value matches a pre-replace pair, replace the value before decoding.
            for (var j = 0; j < param.replace.length; j++) {
                if (param.replace[j].from === value)
                    value = param.replace[j].to;
            }
            if (value && param.array === true)
                value = decodePathArray(value);
            if (predicates_1.isDefined(value))
                value = param.type.decode(value);
            values[param.id] = param.value(value);
        }
        searchParams.forEach(function (param) {
            var value = search[param.id];
            for (var j = 0; j < param.replace.length; j++) {
                if (param.replace[j].from === value)
                    value = param.replace[j].to;
            }
            if (predicates_1.isDefined(value))
                value = param.type.decode(value);
            values[param.id] = param.value(value);
        });
        if (hash)
            values["#"] = hash;
        return values;
    };
    /**
     * @hidden
     * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.
     *
     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the
     *    pattern has no parameters, an empty array is returned.
     */
    UrlMatcher.prototype.parameters = function (opts) {
        if (opts === void 0) { opts = {}; }
        if (opts.inherit === false)
            return this._params;
        return common_1.unnest(this._cache.path.map(function (matcher) { return matcher._params; }));
    };
    /**
     * @hidden
     * Returns a single parameter from this UrlMatcher by id
     *
     * @param id
     * @param opts
     * @returns {T|Param|any|boolean|UrlMatcher|null}
     */
    UrlMatcher.prototype.parameter = function (id, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var findParam = function () {
            for (var _i = 0, _a = _this._params; _i < _a.length; _i++) {
                var param = _a[_i];
                if (param.id === id)
                    return param;
            }
        };
        var parent = this._cache.parent;
        return findParam() || (opts.inherit !== false && parent && parent.parameter(id, opts)) || null;
    };
    /**
     * Validates the input parameter values against this UrlMatcher
     *
     * Checks an object hash of parameters to validate their correctness according to the parameter
     * types of this `UrlMatcher`.
     *
     * @param params The object hash of parameters to validate.
     * @returns Returns `true` if `params` validates, otherwise `false`.
     */
    UrlMatcher.prototype.validates = function (params) {
        var validParamVal = function (param, val) {
            return !param || param.validates(val);
        };
        params = params || {};
        // I'm not sure why this checks only the param keys passed in, and not all the params known to the matcher
        var paramSchema = this.parameters().filter(function (paramDef) { return params.hasOwnProperty(paramDef.id); });
        return paramSchema.map(function (paramDef) { return validParamVal(paramDef, params[paramDef.id]); }).reduce(common_1.allTrueR, true);
    };
    /**
     * Given a set of parameter values, creates a URL from this UrlMatcher.
     *
     * Creates a URL that matches this pattern by substituting the specified values
     * for the path and search parameters.
     *
     * #### Example:
     * ```js
     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });
     * // returns '/user/bob?q=yes'
     * ```
     *
     * @param values  the values to substitute for the parameters in this pattern.
     * @returns the formatted URL (path and optionally search part).
     */
    UrlMatcher.prototype.format = function (values) {
        if (values === void 0) { values = {}; }
        // Build the full path of UrlMatchers (including all parent UrlMatchers)
        var urlMatchers = this._cache.path;
        // Extract all the static segments and Params (processed as ParamDetails)
        // into an ordered array
        var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams)
            .reduce(common_1.unnestR, [])
            .map(function (x) { return predicates_1.isString(x) ? x : getDetails(x); });
        // Extract the query params into a separate array
        var queryParams = urlMatchers.map(UrlMatcher.queryParams)
            .reduce(common_1.unnestR, [])
            .map(getDetails);
        var isInvalid = function (param) { return param.isValid === false; };
        if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {
            return null;
        }
        /**
         * Given a Param, applies the parameter value, then returns detailed information about it
         */
        function getDetails(param) {
            // Normalize to typed value
            var value = param.value(values[param.id]);
            var isValid = param.validates(value);
            var isDefaultValue = param.isDefaultValue(value);
            // Check if we're in squash mode for the parameter
            var squash = isDefaultValue ? param.squash : false;
            // Allow the Parameter's Type to encode the value
            var encoded = param.type.encode(value);
            return { param: param, value: value, isValid: isValid, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };
        }
        // Build up the path-portion from the list of static segments and parameters
        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {
            // The element is a static segment (a raw string); just append it
            if (predicates_1.isString(x))
                return acc + x;
            // Otherwise, it's a ParamDetails.
            var squash = x.squash, encoded = x.encoded, param = x.param;
            // If squash is === true, try to remove a slash from the path
            if (squash === true)
                return (acc.match(/\/$/)) ? acc.slice(0, -1) : acc;
            // If squash is a string, use the string for the param value
            if (predicates_1.isString(squash))
                return acc + squash;
            if (squash !== false)
                return acc; // ?
            if (encoded == null)
                return acc;
            // If this parameter value is an array, encode the value using encodeDashes
            if (predicates_1.isArray(encoded))
                return acc + common_1.map(encoded, UrlMatcher.encodeDashes).join("-");
            // If the parameter type is "raw", then do not encodeURIComponent
            if (param.raw)
                return acc + encoded;
            // Encode the value
            return acc + encodeURIComponent(encoded);
        }, "");
        // Build the query string by applying parameter values (array or regular)
        // then mapping to key=value, then flattening and joining using "&"
        var queryString = queryParams.map(function (paramDetails) {
            var param = paramDetails.param, squash = paramDetails.squash, encoded = paramDetails.encoded, isDefaultValue = paramDetails.isDefaultValue;
            if (encoded == null || (isDefaultValue && squash !== false))
                return;
            if (!predicates_1.isArray(encoded))
                encoded = [encoded];
            if (encoded.length === 0)
                return;
            if (!param.raw)
                encoded = common_1.map(encoded, encodeURIComponent);
            return encoded.map(function (val) { return param.id + "=" + val; });
        }).filter(common_1.identity).reduce(common_1.unnestR, []).join("&");
        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)
        return pathString + (queryString ? "?" + queryString : "") + (values["#"] ? "#" + values["#"] : "");
    };
    /** @hidden */
    UrlMatcher.encodeDashes = function (str) {
        return encodeURIComponent(str).replace(/-/g, function (c) { return "%5C%" + c.charCodeAt(0).toString(16).toUpperCase(); });
    };
    /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */
    UrlMatcher.pathSegmentsAndParams = function (matcher) {
        var staticSegments = matcher._segments;
        var pathParams = matcher._params.filter(function (p) { return p.location === param_1.DefType.PATH; });
        return common_1.arrayTuples(staticSegments, pathParams.concat(undefined))
            .reduce(common_1.unnestR, [])
            .filter(function (x) { return x !== "" && predicates_1.isDefined(x); });
    };
    /** @hidden Given a matcher, return an array with the matcher's query params */
    UrlMatcher.queryParams = function (matcher) {
        return matcher._params.filter(function (p) { return p.location === param_1.DefType.SEARCH; });
    };
    /**
     * Compare two UrlMatchers
     *
     * This comparison function converts a UrlMatcher into static and dynamic path segments.
     * Each static path segment is a static string between a path separator (slash character).
     * Each dynamic segment is a path parameter.
     *
     * The comparison function sorts static segments before dynamic ones.
     */
    UrlMatcher.compare = function (a, b) {
        /**
         * Turn a UrlMatcher and all its parent matchers into an array
         * of slash literals '/', string literals, and Param objects
         *
         * This example matcher matches strings like "/foo/:param/tail":
         * var matcher = $umf.compile("/foo").append($umf.compile("/:param")).append($umf.compile("/")).append($umf.compile("tail"));
         * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]
         *
         * Caches the result as `matcher._cache.segments`
         */
        var segments = function (matcher) {
            return matcher._cache.segments = matcher._cache.segments ||
                matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams)
                    .reduce(common_1.unnestR, [])
                    .reduce(strings_1.joinNeighborsR, [])
                    .map(function (x) { return predicates_1.isString(x) ? splitOnSlash(x) : x; })
                    .reduce(common_1.unnestR, []);
        };
        /**
         * Gets the sort weight for each segment of a UrlMatcher
         *
         * Caches the result as `matcher._cache.weights`
         */
        var weights = function (matcher) {
            return matcher._cache.weights = matcher._cache.weights ||
                segments(matcher).map(function (segment) {
                    // Sort slashes first, then static strings, the Params
                    if (segment === '/')
                        return 1;
                    if (predicates_1.isString(segment))
                        return 2;
                    if (segment instanceof param_1.Param)
                        return 3;
                });
        };
        /**
         * Pads shorter array in-place (mutates)
         */
        var padArrays = function (l, r, padVal) {
            var len = Math.max(l.length, r.length);
            while (l.length < len)
                l.push(padVal);
            while (r.length < len)
                r.push(padVal);
        };
        var weightsA = weights(a), weightsB = weights(b);
        padArrays(weightsA, weightsB, 0);
        var cmp, i, pairs = common_1.arrayTuples(weightsA, weightsB);
        for (i = 0; i < pairs.length; i++) {
            cmp = pairs[i][0] - pairs[i][1];
            if (cmp !== 0)
                return cmp;
        }
        return 0;
    };
    /** @hidden */
    UrlMatcher.nameValidator = /^\w+([-.]+\w+)*(?:\[\])?$/;
    return UrlMatcher;
}());
exports.UrlMatcher = UrlMatcher;
//# sourceMappingURL=urlMatcher.js.map

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @internalapi
 * @module vanilla
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(7);
var utils_1 = __webpack_require__(32);
/** A base `LocationServices` */
var BaseLocationServices = /** @class */ (function () {
    function BaseLocationServices(router, fireAfterUpdate) {
        var _this = this;
        this.fireAfterUpdate = fireAfterUpdate;
        this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };
        this._listeners = [];
        this.hash = function () { return utils_1.parseUrl(_this._get()).hash; };
        this.path = function () { return utils_1.parseUrl(_this._get()).path; };
        this.search = function () { return utils_1.getParams(utils_1.parseUrl(_this._get()).search); };
        this._location = common_1.root.location;
        this._history = common_1.root.history;
    }
    BaseLocationServices.prototype.url = function (url, replace) {
        if (replace === void 0) { replace = true; }
        if (common_1.isDefined(url) && url !== this._get()) {
            this._set(null, null, url, replace);
            if (this.fireAfterUpdate) {
                this._listeners.forEach(function (cb) { return cb({ url: url }); });
            }
        }
        return utils_1.buildUrl(this);
    };
    BaseLocationServices.prototype.onChange = function (cb) {
        var _this = this;
        this._listeners.push(cb);
        return function () { return common_1.removeFrom(_this._listeners, cb); };
    };
    BaseLocationServices.prototype.dispose = function (router) {
        common_1.deregAll(this._listeners);
    };
    return BaseLocationServices;
}());
exports.BaseLocationServices = BaseLocationServices;
//# sourceMappingURL=baseLocationService.js.map

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_24__;

/***/ }),
/* 25 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_25__;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var glob_1 = __webpack_require__(18);
var predicates_1 = __webpack_require__(1);
/**
 * Internal representation of a UI-Router state.
 *
 * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].
 *
 * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[StateObject]] object.
 *
 * This class prototypally inherits from the corresponding [[StateDeclaration]].
 * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].
 */
var StateObject = /** @class */ (function () {
    /** @deprecated use State.create() */
    function StateObject(config) {
        return StateObject.create(config || {});
    }
    /**
     * Create a state object to put the private/internal implementation details onto.
     * The object's prototype chain looks like:
     * (Internal State Object) -> (Copy of State.prototype) -> (State Declaration object) -> (State Declaration's prototype...)
     *
     * @param stateDecl the user-supplied State Declaration
     * @returns {StateObject} an internal State object
     */
    StateObject.create = function (stateDecl) {
        stateDecl = StateObject.isStateClass(stateDecl) ? new stateDecl() : stateDecl;
        var state = common_1.inherit(common_1.inherit(stateDecl, StateObject.prototype));
        stateDecl.$$state = function () { return state; };
        state.self = stateDecl;
        state.__stateObjectCache = {
            nameGlob: glob_1.Glob.fromString(state.name) // might return null
        };
        return state;
    };
    /**
     * Returns true if the provided parameter is the same state.
     *
     * Compares the identity of the state against the passed value, which is either an object
     * reference to the actual `State` instance, the original definition object passed to
     * `$stateProvider.state()`, or the fully-qualified name.
     *
     * @param ref Can be one of (a) a `State` instance, (b) an object that was passed
     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.
     * @returns Returns `true` if `ref` matches the current `State` instance.
     */
    StateObject.prototype.is = function (ref) {
        return this === ref || this.self === ref || this.fqn() === ref;
    };
    /**
     * @deprecated this does not properly handle dot notation
     * @returns Returns a dot-separated name of the state.
     */
    StateObject.prototype.fqn = function () {
        if (!this.parent || !(this.parent instanceof this.constructor))
            return this.name;
        var name = this.parent.fqn();
        return name ? name + "." + this.name : this.name;
    };
    /**
     * Returns the root node of this state's tree.
     *
     * @returns The root of this state's tree.
     */
    StateObject.prototype.root = function () {
        return this.parent && this.parent.root() || this;
    };
    /**
     * Gets the state's `Param` objects
     *
     * Gets the list of [[Param]] objects owned by the state.
     * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] objects.
     * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object
     *
     * @param opts options
     */
    StateObject.prototype.parameters = function (opts) {
        opts = common_1.defaults(opts, { inherit: true, matchingKeys: null });
        var inherited = opts.inherit && this.parent && this.parent.parameters() || [];
        return inherited.concat(common_1.values(this.params))
            .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });
    };
    /**
     * Returns a single [[Param]] that is owned by the state
     *
     * If `opts.inherit` is true, it also searches the ancestor states` [[Param]]s.
     * @param id the name of the [[Param]] to return
     * @param opts options
     */
    StateObject.prototype.parameter = function (id, opts) {
        if (opts === void 0) { opts = {}; }
        return (this.url && this.url.parameter(id, opts) ||
            common_1.find(common_1.values(this.params), hof_1.propEq('id', id)) ||
            opts.inherit && this.parent && this.parent.parameter(id));
    };
    StateObject.prototype.toString = function () {
        return this.fqn();
    };
    /** Predicate which returns true if the object is an class with @State() decorator */
    StateObject.isStateClass = function (stateDecl) {
        return predicates_1.isFunction(stateDecl) && stateDecl['__uiRouterState'] === true;
    };
    /** Predicate which returns true if the object is an internal [[StateObject]] object */
    StateObject.isState = function (obj) {
        return predicates_1.isObject(obj['__stateObjectCache']);
    };
    return StateObject;
}());
exports.StateObject = StateObject;
//# sourceMappingURL=stateObject.js.map

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @module common
 */ /** for typedoc */
Object.defineProperty(exports, "__esModule", { value: true });
var Queue = /** @class */ (function () {
    function Queue(_items, _limit) {
        if (_items === void 0) { _items = []; }
        if (_limit === void 0) { _limit = null; }
        this._items = _items;
        this._limit = _limit;
    }
    Queue.prototype.enqueue = function (item) {
        var items = this._items;
        items.push(item);
        if (this._limit && items.length > this._limit)
            items.shift();
        return item;
    };
    Queue.prototype.dequeue = function () {
        if (this.size())
            return this._items.splice(0, 1)[0];
    };
    Queue.prototype.clear = function () {
        var current = this._items;
        this._items = [];
        return current;
    };
    Queue.prototype.size = function () {
        return this._items.length;
    };
    Queue.prototype.remove = function (item) {
        var idx = this._items.indexOf(item);
        return idx > -1 && this._items.splice(idx, 1)[0];
    };
    Queue.prototype.peekTail = function () {
        return this._items[this._items.length - 1];
    };
    Queue.prototype.peekHead = function () {
        if (this.size())
            return this._items[0];
    };
    return Queue;
}());
exports.Queue = Queue;
//# sourceMappingURL=queue.js.map

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module transition
 */ /** for typedoc */
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var interface_1 = __webpack_require__(11); // has or is using
var glob_1 = __webpack_require__(18);
/**
 * Determines if the given state matches the matchCriteria
 *
 * @hidden
 *
 * @param state a State Object to test against
 * @param criterion
 * - If a string, matchState uses the string as a glob-matcher against the state name
 * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name
 *   and returns a positive match if any of the globs match.
 * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.
 * @returns {boolean}
 */
function matchState(state, criterion) {
    var toMatch = predicates_1.isString(criterion) ? [criterion] : criterion;
    function matchGlobs(_state) {
        var globStrings = toMatch;
        for (var i = 0; i < globStrings.length; i++) {
            var glob = new glob_1.Glob(globStrings[i]);
            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {
                return true;
            }
        }
        return false;
    }
    var matchFn = (predicates_1.isFunction(toMatch) ? toMatch : matchGlobs);
    return !!matchFn(state);
}
exports.matchState = matchState;
/**
 * @internalapi
 * The registration data for a registered transition hook
 */
var RegisteredHook = /** @class */ (function () {
    function RegisteredHook(tranSvc, eventType, callback, matchCriteria, removeHookFromRegistry, options) {
        if (options === void 0) { options = {}; }
        this.tranSvc = tranSvc;
        this.eventType = eventType;
        this.callback = callback;
        this.matchCriteria = matchCriteria;
        this.removeHookFromRegistry = removeHookFromRegistry;
        this.invokeCount = 0;
        this._deregistered = false;
        this.priority = options.priority || 0;
        this.bind = options.bind || null;
        this.invokeLimit = options.invokeLimit;
    }
    /**
     * Gets the matching [[PathNode]]s
     *
     * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing
     * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.
     *
     * Returning `null` is significant to distinguish between the default
     * "match-all criterion value" of `true` compared to a `() => true` function,
     * when the nodes is an empty array.
     *
     * This is useful to allow a transition match criteria of `entering: true`
     * to still match a transition, even when `entering === []`.  Contrast that
     * with `entering: (state) => true` which only matches when a state is actually
     * being entered.
     */
    RegisteredHook.prototype._matchingNodes = function (nodes, criterion) {
        if (criterion === true)
            return nodes;
        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });
        return matching.length ? matching : null;
    };
    /**
     * Gets the default match criteria (all `true`)
     *
     * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:
     *
     * ```js
     * {
     *   to: true,
     *   from: true,
     *   entering: true,
     *   exiting: true,
     *   retained: true,
     * }
     */
    RegisteredHook.prototype._getDefaultMatchCriteria = function () {
        return common_1.map(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });
    };
    /**
     * Gets matching nodes as [[IMatchingNodes]]
     *
     * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:
     *
     * ```js
     * let matches: IMatchingNodes = {
     *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),
     *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),
     *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),
     *   retained: _matchingNodes(treeChanges.retained,     mc.retained),
     *   entering: _matchingNodes(treeChanges.entering,     mc.entering),
     * };
     * ```
     */
    RegisteredHook.prototype._getMatchingNodes = function (treeChanges) {
        var _this = this;
        var criteria = common_1.extend(this._getDefaultMatchCriteria(), this.matchCriteria);
        var paths = common_1.values(this.tranSvc._pluginapi._getPathTypes());
        return paths.reduce(function (mn, pathtype) {
            // STATE scope criteria matches against every node in the path.
            // TRANSITION scope criteria matches against only the last node in the path
            var isStateHook = pathtype.scope === interface_1.TransitionHookScope.STATE;
            var path = treeChanges[pathtype.name] || [];
            var nodes = isStateHook ? path : [common_1.tail(path)];
            mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);
            return mn;
        }, {});
    };
    /**
     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]
     *
     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values
     * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)
     */
    RegisteredHook.prototype.matches = function (treeChanges) {
        var matches = this._getMatchingNodes(treeChanges);
        // Check if all the criteria matched the TreeChanges object
        var allMatched = common_1.values(matches).every(common_1.identity);
        return allMatched ? matches : null;
    };
    RegisteredHook.prototype.deregister = function () {
        this.removeHookFromRegistry(this);
        this._deregistered = true;
    };
    return RegisteredHook;
}());
exports.RegisteredHook = RegisteredHook;
/** @hidden Return a registration function of the requested type. */
function makeEvent(registry, transitionService, eventType) {
    // Create the object which holds the registered transition hooks.
    var _registeredHooks = registry._registeredHooks = (registry._registeredHooks || {});
    var hooks = _registeredHooks[eventType.name] = [];
    var removeHookFn = common_1.removeFrom(hooks);
    // Create hook registration function on the IHookRegistry for the event
    registry[eventType.name] = hookRegistrationFn;
    function hookRegistrationFn(matchObject, callback, options) {
        if (options === void 0) { options = {}; }
        var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, removeHookFn, options);
        hooks.push(registeredHook);
        return registeredHook.deregister.bind(registeredHook);
    }
    return hookRegistrationFn;
}
exports.makeEvent = makeEvent;
//# sourceMappingURL=hookRegistry.js.map

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module path */ /** for typedoc */
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var param_1 = __webpack_require__(13);
/**
 * @internalapi
 *
 * A node in a [[TreeChanges]] path
 *
 * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.
 * Each PathNode corresponds to a state being entered, exited, or retained.
 * The stateful information includes parameter values and resolve data.
 */
var PathNode = /** @class */ (function () {
    function PathNode(stateOrNode) {
        if (stateOrNode instanceof PathNode) {
            var node = stateOrNode;
            this.state = node.state;
            this.paramSchema = node.paramSchema.slice();
            this.paramValues = common_1.extend({}, node.paramValues);
            this.resolvables = node.resolvables.slice();
            this.views = node.views && node.views.slice();
        }
        else {
            var state = stateOrNode;
            this.state = state;
            this.paramSchema = state.parameters({ inherit: false });
            this.paramValues = {};
            this.resolvables = state.resolvables.map(function (res) { return res.clone(); });
        }
    }
    /** Sets [[paramValues]] for the node, from the values of an object hash */
    PathNode.prototype.applyRawParams = function (params) {
        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };
        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return common_1.applyPairs(memo, getParamVal(pDef)); }, {});
        return this;
    };
    /** Gets a specific [[Param]] metadata that belongs to the node */
    PathNode.prototype.parameter = function (name) {
        return common_1.find(this.paramSchema, hof_1.propEq("id", name));
    };
    /**
     * @returns true if the state and parameter values for another PathNode are
     * equal to the state and param values for this PathNode
     */
    PathNode.prototype.equals = function (node, paramsFn) {
        var diff = this.diff(node, paramsFn);
        return diff && diff.length === 0;
    };
    /**
     * Finds Params with different parameter values on another PathNode.
     *
     * Given another node (of the same state), finds the parameter values which differ.
     * Returns the [[Param]] (schema objects) whose parameter values differ.
     *
     * Given another node for a different state, returns `false`
     *
     * @param node The node to compare to
     * @param paramsFn A function that returns which parameters should be compared.
     * @returns The [[Param]]s which differ, or null if the two nodes are for different states
     */
    PathNode.prototype.diff = function (node, paramsFn) {
        if (this.state !== node.state)
            return false;
        var params = paramsFn ? paramsFn(this) : this.paramSchema;
        return param_1.Param.changed(params, this.paramValues, node.paramValues);
    };
    /** Returns a clone of the PathNode */
    PathNode.clone = function (node) {
        return new PathNode(node);
    };
    return PathNode;
}());
exports.PathNode = PathNode;
//# sourceMappingURL=pathNode.js.map

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module params
 */
/** */
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
/**
 * An internal class which implements [[ParamTypeDefinition]].
 *
 * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.
 * When a param type definition is registered, an instance of this class is created internally.
 *
 * This class has naive implementations for all the [[ParamTypeDefinition]] methods.
 *
 * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.
 *
 * #### Example:
 * ```js
 * var paramTypeDef = {
 *   decode: function(val) { return parseInt(val, 10); },
 *   encode: function(val) { return val && val.toString(); },
 *   equals: function(a, b) { return this.is(a) && a === b; },
 *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },
 *   pattern: /\d+/
 * }
 *
 * var paramType = new ParamType(paramTypeDef);
 * ```
 * @internalapi
 */
var ParamType = /** @class */ (function () {
    /**
     * @param def  A configuration object which contains the custom type definition.  The object's
     *        properties will override the default methods and/or pattern in `ParamType`'s public interface.
     * @returns a new ParamType object
     */
    function ParamType(def) {
        /** @inheritdoc */
        this.pattern = /.*/;
        /** @inheritdoc */
        this.inherit = true;
        common_1.extend(this, def);
    }
    // consider these four methods to be "abstract methods" that should be overridden
    /** @inheritdoc */
    ParamType.prototype.is = function (val, key) { return true; };
    /** @inheritdoc */
    ParamType.prototype.encode = function (val, key) { return val; };
    /** @inheritdoc */
    ParamType.prototype.decode = function (val, key) { return val; };
    /** @inheritdoc */
    ParamType.prototype.equals = function (a, b) { return a == b; };
    ParamType.prototype.$subPattern = function () {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
    };
    ParamType.prototype.toString = function () {
        return "{ParamType:" + this.name + "}";
    };
    /** Given an encoded string, or a decoded object, returns a decoded object */
    ParamType.prototype.$normalize = function (val) {
        return this.is(val) ? val : this.decode(val);
    };
    /**
     * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.
     * e.g.:
     * - urlmatcher pattern "/path?{queryParam[]:int}"
     * - url: "/path?queryParam=1&queryParam=2
     * - $stateParams.queryParam will be [1, 2]
     * if `mode` is "auto", then
     * - url: "/path?queryParam=1 will create $stateParams.queryParam: 1
     * - url: "/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]
     */
    ParamType.prototype.$asArray = function (mode, isSearch) {
        if (!mode)
            return this;
        if (mode === "auto" && !isSearch)
            throw new Error("'auto' array mode is for query parameters only");
        return new ArrayType(this, mode);
    };
    return ParamType;
}());
exports.ParamType = ParamType;
/**
 * Wraps up a `ParamType` object to handle array values.
 * @internalapi
 */
function ArrayType(type, mode) {
    var _this = this;
    // Wrap non-array value as array
    function arrayWrap(val) {
        return predicates_1.isArray(val) ? val : (predicates_1.isDefined(val) ? [val] : []);
    }
    // Unwrap array value for "auto" mode. Return undefined for empty array.
    function arrayUnwrap(val) {
        switch (val.length) {
            case 0: return undefined;
            case 1: return mode === "auto" ? val[0] : val;
            default: return val;
        }
    }
    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array
    function arrayHandler(callback, allTruthyMode) {
        return function handleArray(val) {
            if (predicates_1.isArray(val) && val.length === 0)
                return val;
            var arr = arrayWrap(val);
            var result = common_1.map(arr, callback);
            return (allTruthyMode === true) ? common_1.filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);
        };
    }
    // Wraps type (.equals) functions to operate on each value of an array
    function arrayEqualsHandler(callback) {
        return function handleArray(val1, val2) {
            var left = arrayWrap(val1), right = arrayWrap(val2);
            if (left.length !== right.length)
                return false;
            for (var i = 0; i < left.length; i++) {
                if (!callback(left[i], right[i]))
                    return false;
            }
            return true;
        };
    }
    ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {
        var paramTypeFn = type[name].bind(type);
        var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;
        _this[name] = wrapperFn(paramTypeFn);
    });
    common_1.extend(this, {
        dynamic: type.dynamic,
        name: type.name,
        pattern: type.pattern,
        inherit: type.inherit,
        is: arrayHandler(type.is.bind(type), true),
        $arrayMode: mode
    });
}
//# sourceMappingURL=paramType.js.map

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module transition
 */
/** for typedoc */
var interface_1 = __webpack_require__(11);
var transition_1 = __webpack_require__(19);
var hookRegistry_1 = __webpack_require__(28);
var coreResolvables_1 = __webpack_require__(78);
var redirectTo_1 = __webpack_require__(79);
var onEnterExitRetain_1 = __webpack_require__(80);
var resolve_1 = __webpack_require__(81);
var views_1 = __webpack_require__(82);
var updateGlobals_1 = __webpack_require__(83);
var url_1 = __webpack_require__(84);
var lazyLoad_1 = __webpack_require__(55);
var transitionEventType_1 = __webpack_require__(56);
var transitionHook_1 = __webpack_require__(15);
var predicates_1 = __webpack_require__(1);
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var ignoredTransition_1 = __webpack_require__(85);
var invalidTransition_1 = __webpack_require__(86);
/**
 * The default [[Transition]] options.
 *
 * Include this object when applying custom defaults:
 * let reloadOpts = { reload: true, notify: true }
 * let options = defaults(theirOpts, customDefaults, defaultOptions);
 */
exports.defaultTransOpts = {
    location: true,
    relative: null,
    inherit: false,
    notify: true,
    reload: false,
    custom: {},
    current: function () { return null; },
    source: "unknown"
};
/**
 * This class provides services related to Transitions.
 *
 * - Most importantly, it allows global Transition Hooks to be registered.
 * - It allows the default transition error handler to be set.
 * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).
 *
 * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.
 */
var TransitionService = /** @class */ (function () {
    /** @hidden */
    function TransitionService(_router) {
        /** @hidden */
        this._transitionCount = 0;
        /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */
        this._eventTypes = [];
        /** @hidden The registered transition hooks */
        this._registeredHooks = {};
        /** @hidden The  paths on a criteria object */
        this._criteriaPaths = {};
        this._router = _router;
        this.$view = _router.viewService;
        this._deregisterHookFns = {};
        this._pluginapi = common_1.createProxyFunctions(hof_1.val(this), {}, hof_1.val(this), [
            '_definePathType',
            '_defineEvent',
            '_getPathTypes',
            '_getEvents',
            'getHooks',
        ]);
        this._defineCorePaths();
        this._defineCoreEvents();
        this._registerCoreTransitionHooks();
    }
    /**
     * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.
     *
     * Registers a transition lifecycle hook, which is invoked during transition construction.
     *
     * This low level hook should only be used by plugins.
     * This can be a useful time for plugins to add resolves or mutate the transition as needed.
     * The Sticky States plugin uses this hook to modify the treechanges.
     *
     * ### Lifecycle
     *
     * `onCreate` hooks are invoked *while a transition is being constructed*.
     *
     * ### Return value
     *
     * The hook's return value is ignored
     *
     * @internalapi
     * @param criteria defines which Transitions the Hook should be invoked for.
     * @param callback the hook function which will be invoked.
     * @param options the registration options
     * @returns a function which deregisters the hook.
     */
    TransitionService.prototype.onCreate = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    TransitionService.prototype.onBefore = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    TransitionService.prototype.onStart = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    TransitionService.prototype.onExit = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    TransitionService.prototype.onRetain = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    TransitionService.prototype.onEnter = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    TransitionService.prototype.onFinish = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    TransitionService.prototype.onSuccess = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    TransitionService.prototype.onError = function (criteria, callback, options) { return; };
    /**
     * dispose
     * @internalapi
     */
    TransitionService.prototype.dispose = function (router) {
        common_1.values(this._registeredHooks).forEach(function (hooksArray) { return hooksArray.forEach(function (hook) {
            hook._deregistered = true;
            common_1.removeFrom(hooksArray, hook);
        }); });
    };
    /**
     * Creates a new [[Transition]] object
     *
     * This is a factory function for creating new Transition objects.
     * It is used internally by the [[StateService]] and should generally not be called by application code.
     *
     * @param fromPath the path to the current state (the from state)
     * @param targetState the target state (destination)
     * @returns a Transition
     */
    TransitionService.prototype.create = function (fromPath, targetState) {
        return new transition_1.Transition(fromPath, targetState, this._router);
    };
    /** @hidden */
    TransitionService.prototype._defineCoreEvents = function () {
        var Phase = interface_1.TransitionHookPhase;
        var TH = transitionHook_1.TransitionHook;
        var paths = this._criteriaPaths;
        var NORMAL_SORT = false, REVERSE_SORT = true;
        var ASYNCHRONOUS = false, SYNCHRONOUS = true;
        this._defineEvent("onCreate", Phase.CREATE, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.THROW_ERROR, SYNCHRONOUS);
        this._defineEvent("onBefore", Phase.BEFORE, 0, paths.to);
        this._defineEvent("onStart", Phase.RUN, 0, paths.to);
        this._defineEvent("onExit", Phase.RUN, 100, paths.exiting, REVERSE_SORT);
        this._defineEvent("onRetain", Phase.RUN, 200, paths.retained);
        this._defineEvent("onEnter", Phase.RUN, 300, paths.entering);
        this._defineEvent("onFinish", Phase.RUN, 400, paths.to);
        this._defineEvent("onSuccess", Phase.SUCCESS, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);
        this._defineEvent("onError", Phase.ERROR, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);
    };
    /** @hidden */
    TransitionService.prototype._defineCorePaths = function () {
        var STATE = interface_1.TransitionHookScope.STATE, TRANSITION = interface_1.TransitionHookScope.TRANSITION;
        this._definePathType("to", TRANSITION);
        this._definePathType("from", TRANSITION);
        this._definePathType("exiting", STATE);
        this._definePathType("retained", STATE);
        this._definePathType("entering", STATE);
    };
    /** @hidden */
    TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {
        if (reverseSort === void 0) { reverseSort = false; }
        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }
        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }
        if (synchronous === void 0) { synchronous = false; }
        var eventType = new transitionEventType_1.TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous);
        this._eventTypes.push(eventType);
        hookRegistry_1.makeEvent(this, this, eventType);
    };
    ;
    /** @hidden */
    TransitionService.prototype._getEvents = function (phase) {
        var transitionHookTypes = predicates_1.isDefined(phase) ?
            this._eventTypes.filter(function (type) { return type.hookPhase === phase; }) :
            this._eventTypes.slice();
        return transitionHookTypes.sort(function (l, r) {
            var cmpByPhase = l.hookPhase - r.hookPhase;
            return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;
        });
    };
    /**
     * Adds a Path to be used as a criterion against a TreeChanges path
     *
     * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.
     * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`
     * Each state in the exiting path is checked against the criteria and returned as part of the match.
     *
     * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.
     * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`
     * Only the tail of the `to` path is checked against the criteria and returned as part of the match.
     *
     * @hidden
     */
    TransitionService.prototype._definePathType = function (name, hookScope) {
        this._criteriaPaths[name] = { name: name, scope: hookScope };
    };
    /** * @hidden */
    TransitionService.prototype._getPathTypes = function () {
        return this._criteriaPaths;
    };
    /** @hidden */
    TransitionService.prototype.getHooks = function (hookName) {
        return this._registeredHooks[hookName];
    };
    /** @hidden */
    TransitionService.prototype._registerCoreTransitionHooks = function () {
        var fns = this._deregisterHookFns;
        fns.addCoreResolves = coreResolvables_1.registerAddCoreResolvables(this);
        fns.ignored = ignoredTransition_1.registerIgnoredTransitionHook(this);
        fns.invalid = invalidTransition_1.registerInvalidTransitionHook(this);
        // Wire up redirectTo hook
        fns.redirectTo = redirectTo_1.registerRedirectToHook(this);
        // Wire up onExit/Retain/Enter state hooks
        fns.onExit = onEnterExitRetain_1.registerOnExitHook(this);
        fns.onRetain = onEnterExitRetain_1.registerOnRetainHook(this);
        fns.onEnter = onEnterExitRetain_1.registerOnEnterHook(this);
        // Wire up Resolve hooks
        fns.eagerResolve = resolve_1.registerEagerResolvePath(this);
        fns.lazyResolve = resolve_1.registerLazyResolveState(this);
        // Wire up the View management hooks
        fns.loadViews = views_1.registerLoadEnteringViews(this);
        fns.activateViews = views_1.registerActivateViews(this);
        // Updates global state after a transition
        fns.updateGlobals = updateGlobals_1.registerUpdateGlobalState(this);
        // After globals.current is updated at priority: 10000
        fns.updateUrl = url_1.registerUpdateUrl(this);
        // Lazy load state trees
        fns.lazyLoad = lazyLoad_1.registerLazyLoadHook(this);
    };
    return TransitionService;
}());
exports.TransitionService = TransitionService;
//# sourceMappingURL=transitionService.js.map

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var common_1 = __webpack_require__(7);
exports.keyValsToObjectR = function (accum, _a) {
    var key = _a[0], val = _a[1];
    if (!accum.hasOwnProperty(key)) {
        accum[key] = val;
    }
    else if (common_1.isArray(accum[key])) {
        accum[key].push(val);
    }
    else {
        accum[key] = [accum[key], val];
    }
    return accum;
};
exports.getParams = function (queryString) {
    return queryString.split("&").filter(common_1.identity).map(common_1.splitEqual).reduce(exports.keyValsToObjectR, {});
};
function parseUrl(url) {
    var orEmptyString = function (x) { return x || ""; };
    var _a = common_1.splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];
    var _b = common_1.splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];
    return { path: path, search: search, hash: hash, url: url };
}
exports.parseUrl = parseUrl;
exports.buildUrl = function (loc) {
    var path = loc.path();
    var searchObject = loc.search();
    var hash = loc.hash();
    var search = Object.keys(searchObject).map(function (key) {
        var param = searchObject[key];
        var vals = common_1.isArray(param) ? param : [param];
        return vals.map(function (val) { return key + "=" + val; });
    }).reduce(common_1.unnestR, []).join("&");
    return path + (search ? "?" + search : "") + (hash ? "#" + hash : "");
};
function locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {
    return function (router) {
        var service = router.locationService = new serviceClass(router);
        var configuration = router.locationConfig = new configurationClass(router, isHtml5);
        function dispose(router) {
            router.dispose(service);
            router.dispose(configuration);
        }
        return { name: name, service: service, configuration: configuration, dispose: dispose };
    };
}
exports.locationPluginFactory = locationPluginFactory;
//# sourceMappingURL=utils.js.map

/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = ng2ViewsBuilder;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Ng2ViewConfig; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__uirouter_core__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__uirouter_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__uirouter_core__);
/** @module ng2 */ /** */




/**
 * This is a [[StateBuilder.builder]] function for Angular `views`.
 *
 * When the [[StateBuilder]] builds a [[State]] object from a raw [[StateDeclaration]], this builder
 * handles the `views` property with logic specific to @uirouter/angular.
 *
 * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object and
 * applies the state-level configuration to a view named `$default`.
 */
function ng2ViewsBuilder(state) {
    var views = {}, viewsObject = state.views || { "$default": Object(__WEBPACK_IMPORTED_MODULE_0__uirouter_core__["pick"])(state, ["component", "bindings"]) };
    Object(__WEBPACK_IMPORTED_MODULE_0__uirouter_core__["forEach"])(viewsObject, function (config, name) {
        name = name || "$default"; // Account for views: { "": { template... } }
        if (Object(__WEBPACK_IMPORTED_MODULE_0__uirouter_core__["isFunction"])(config))
            config = { component: config };
        if (Object.keys(config).length == 0)
            return;
        config.$type = "ng2";
        config.$context = state;
        config.$name = name;
        var normalized = __WEBPACK_IMPORTED_MODULE_0__uirouter_core__["ViewService"].normalizeUIViewTarget(config.$context, config.$name);
        config.$uiViewName = normalized.uiViewName;
        config.$uiViewContextAnchor = normalized.uiViewContextAnchor;
        views[name] = config;
    });
    return views;
}
var id = 0;
var Ng2ViewConfig = (function () {
    function Ng2ViewConfig(path, viewDecl) {
        this.path = path;
        this.viewDecl = viewDecl;
        this.$id = id++;
        this.loaded = true;
    }
    Ng2ViewConfig.prototype.load = function () {
        return __WEBPACK_IMPORTED_MODULE_0__uirouter_core__["services"].$q.when(this);
    };
    return Ng2ViewConfig;
}());

//# sourceMappingURL=views.js.map

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = applyModuleConfig;
/* harmony export (immutable) */ __webpack_exports__["b"] = applyRootModuleConfig;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__uirouter_core__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__uirouter_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__uirouter_core__);
/** @module ng2 */ /** */


function applyModuleConfig(uiRouter, injector, module) {
    if (module === void 0) { module = {}; }
    if (Object(__WEBPACK_IMPORTED_MODULE_0__uirouter_core__["isFunction"])(module.config)) {
        module.config(uiRouter, injector, module);
    }
    var states = module.states || [];
    return states.map(function (state) { return uiRouter.stateRegistry.register(state); });
}
function applyRootModuleConfig(uiRouter, injector, module) {
    Object(__WEBPACK_IMPORTED_MODULE_0__uirouter_core__["isDefined"])(module.deferIntercept) && uiRouter.urlService.deferIntercept(module.deferIntercept);
    Object(__WEBPACK_IMPORTED_MODULE_0__uirouter_core__["isDefined"])(module.otherwise) && uiRouter.urlService.rules.otherwise(module.otherwise);
}
//# sourceMappingURL=uiRouterConfig.js.map

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return UIROUTER_ROOT_MODULE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UIROUTER_MODULE_TOKEN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return UIROUTER_STATES; });
/* harmony export (immutable) */ __webpack_exports__["h"] = onTransitionReady;
/* harmony export (immutable) */ __webpack_exports__["g"] = makeRootProviders;
/* harmony export (immutable) */ __webpack_exports__["f"] = makeChildProviders;
/* harmony export (immutable) */ __webpack_exports__["e"] = locationStrategy;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return UIRouterModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_common__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__directives_directives__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__directives_uiView__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__uirouter_core__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__uirouter_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__uirouter_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__angular_router__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__angular_router___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__angular_router__);







/** @hidden */ var UIROUTER_ROOT_MODULE = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["InjectionToken"]("UIRouter Root Module");
/** @hidden */ var UIROUTER_MODULE_TOKEN = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["InjectionToken"]("UIRouter Module");
/** @hidden */ var UIROUTER_STATES = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["InjectionToken"]("UIRouter States");
// /** @hidden */ export const ROUTES = UIROUTER_STATES;
// Delay angular bootstrap until first transition is successful, for SSR.
// See https://github.com/ui-router/angular/pull/127
function onTransitionReady(transitionService, root) {
    var mod = root[0];
    if (!mod || !mod.deferInitialRender) {
        return function () { return Promise.resolve(); };
    }
    return function () { return new Promise(function (resolve) {
        var hook = function (trans) { trans.promise.then(resolve, resolve); };
        transitionService.onStart({}, hook, { invokeLimit: 1 });
    }); };
}
function makeRootProviders(module) {
    return [
        { provide: UIROUTER_ROOT_MODULE, useValue: module, multi: true },
        { provide: UIROUTER_MODULE_TOKEN, useValue: module, multi: true },
        { provide: __WEBPACK_IMPORTED_MODULE_6__angular_router__["ROUTES"], useValue: module.states || [], multi: true },
        { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__["ANALYZE_FOR_ENTRY_COMPONENTS"], useValue: module.states || [], multi: true },
        { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__["APP_INITIALIZER"], useFactory: onTransitionReady, deps: [__WEBPACK_IMPORTED_MODULE_4__uirouter_core__["TransitionService"], UIROUTER_ROOT_MODULE], multi: true },
    ];
}
function makeChildProviders(module) {
    return [
        { provide: UIROUTER_MODULE_TOKEN, useValue: module, multi: true },
        { provide: __WEBPACK_IMPORTED_MODULE_6__angular_router__["ROUTES"], useValue: module.states || [], multi: true },
        { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__["ANALYZE_FOR_ENTRY_COMPONENTS"], useValue: module.states || [], multi: true },
    ];
}
function locationStrategy(useHash) {
    return { provide: __WEBPACK_IMPORTED_MODULE_1__angular_common__["LocationStrategy"], useClass: useHash ? __WEBPACK_IMPORTED_MODULE_1__angular_common__["HashLocationStrategy"] : __WEBPACK_IMPORTED_MODULE_1__angular_common__["PathLocationStrategy"] };
}
/**
 * Creates UI-Router Modules
 *
 * This class has two static factory methods which create UIRouter Modules.
 * A UI-Router Module is an [Angular NgModule](https://angular.io/docs/ts/latest/guide/ngmodule.html)
 * with support for UI-Router.
 *
 * ### UIRouter Directives
 *
 * When a UI-Router Module is imported into a `NgModule`, that module's components
 * can use the UIRouter Directives such as [[UIView]], [[UISref]], [[UISrefActive]].
 *
 * ### State Definitions
 *
 * State definitions found in the `states:` property are provided to the Dependency Injector.
 * This enables UI-Router to automatically register the states with the [[StateRegistry]] at bootstrap (and during lazy load).
 *
 * ### Entry Components
 *
 * Any routed components are added as `entryComponents:` so they will get compiled.
 */
var UIRouterModule = (function () {
    function UIRouterModule() {
    }
    /**
     * Creates a UI-Router Module for the root (bootstrapped) application module to import
     *
     * This factory function creates an [Angular NgModule](https://angular.io/docs/ts/latest/guide/ngmodule.html)
     * with UI-Router support.
     *
     * The `forRoot` module should be added to the `imports:` of the `NgModule` being bootstrapped.
     * An application should only create and import a single `NgModule` using `forRoot()`.
     * All other modules should be created using [[UIRouterModule.forChild]].
     *
     * Unlike `forChild`, an `NgModule` returned by this factory provides the [[UIRouter]] singleton object.
     * This factory also accepts root-level router configuration.
     * These are the only differences between `forRoot` and `forChild`.
     *
     * Example:
     * ```js
     * let routerConfig = {
     *   otherwise: '/home',
     *   states: [homeState, aboutState]
     * };
     *
     * @ NgModule({
     *   imports: [
     *     BrowserModule,
     *     UIRouterModule.forRoot(routerConfig),
     *     FeatureModule1
     *   ]
     * })
     * class MyRootAppModule {}
     *
     * browserPlatformDynamic.bootstrapModule(MyRootAppModule);
     * ```
     *
     * @param config declarative UI-Router configuration
     * @returns an `NgModule` which provides the [[UIRouter]] singleton instance
     */
    UIRouterModule.forRoot = function (config) {
        if (config === void 0) { config = {}; }
        return {
            ngModule: UIRouterModule,
            providers: [
                __WEBPACK_IMPORTED_MODULE_5__providers__["b" /* _UIROUTER_INSTANCE_PROVIDERS */],
                __WEBPACK_IMPORTED_MODULE_5__providers__["c" /* _UIROUTER_SERVICE_PROVIDERS */],
                locationStrategy(config.useHash)
            ].concat(makeRootProviders(config))
        };
    };
    /**
     * Creates an `NgModule` for a UIRouter module
     *
     * This function creates an [Angular NgModule](https://angular.io/docs/ts/latest/guide/ngmodule.html)
     * with UI-Router support.
     *
     * #### Example:
     * ```js
     * var homeState = { name: 'home', url: '/home', component: Home };
     * var aboutState = { name: 'about', url: '/about', component: About };
     *
     * @ NgModule({
     *   imports: [
     *     UIRouterModule.forChild({ states: [ homeState, aboutState ] }),
     *     SharedModule,
     *   ],
     *   declarations: [ Home, About ],
     * })
     * export class AppModule {};
     * ```
     *
     * @param module UI-Router module options
     * @returns an `NgModule`
     */
    UIRouterModule.forChild = function (module) {
        if (module === void 0) { module = {}; }
        return {
            ngModule: UIRouterModule,
            providers: makeChildProviders(module),
        };
    };
    return UIRouterModule;
}());

UIRouterModule.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__["NgModule"], args: [{
                imports: [__WEBPACK_IMPORTED_MODULE_1__angular_common__["CommonModule"]],
                declarations: [__WEBPACK_IMPORTED_MODULE_2__directives_directives__["g" /* _UIROUTER_DIRECTIVES */]],
                exports: [__WEBPACK_IMPORTED_MODULE_2__directives_directives__["g" /* _UIROUTER_DIRECTIVES */]],
                entryComponents: [__WEBPACK_IMPORTED_MODULE_3__directives_uiView__["a" /* UIView */]],
            },] },
];
/** @nocollapse */
UIRouterModule.ctorParameters = function () { return []; };
//# sourceMappingURL=uiRouterNgModule.js.map

/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AnchorUISref; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return UISref; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__uirouter_core__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__uirouter_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__uirouter_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__uiView__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_ReplaySubject__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_ReplaySubject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs_ReplaySubject__);
/** @ng2api @module directives */
/** */




/**
 * @internalapi
 * # blah blah blah
 */
var AnchorUISref = (function () {
    function AnchorUISref(_el, _renderer) {
        this._el = _el;
        this._renderer = _renderer;
    }
    AnchorUISref.prototype.openInNewTab = function () {
        return this._el.nativeElement.target === '_blank';
    };
    AnchorUISref.prototype.update = function (href) {
        if (href && href !== '') {
            this._renderer.setProperty(this._el.nativeElement, 'href', href);
        }
        else {
            this._renderer.removeAttribute(this._el.nativeElement, 'href');
        }
    };
    return AnchorUISref;
}());

AnchorUISref.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{ selector: 'a[uiSref]' },] },
];
/** @nocollapse */
AnchorUISref.ctorParameters = function () { return [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["ElementRef"], },
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Renderer2"], },
]; };
/**
 * A directive when clicked, initiates a [[Transition]] to a [[TargetState]].
 *
 * ### Purpose
 *
 * This directive is applied to anchor tags (`<a>`) or any other clickable element.  It is a state reference (or sref --
 * similar to an href).  When clicked, the directive will transition to that state by calling [[StateService.go]],
 * and optionally supply state parameter values and transition options.
 *
 * When this directive is on an anchor tag, it will also add an `href` attribute to the anchor.
 *
 * ### Selector
 *
 * - `[uiSref]`: The directive is created as an attribute on an element, e.g., `<a uiSref></a>`
 *
 * ### Inputs
 *
 * - `uiSref`: the target state's name, e.g., `uiSref="foostate"`.  If a component template uses a relative `uiSref`,
 * e.g., `uiSref=".child"`, the reference is relative to that component's state.
 *
 * - `uiParams`: any target state parameter values, as an object, e.g., `[uiParams]="{ fooId: bar.fooId }"`
 *
 * - `uiOptions`: [[TransitionOptions]], e.g., `[uiOptions]="{ inherit: false }"`
 *
 * @example
 * ```html
 *
 * <!-- Targets bar state' -->
 * <a uiSref="bar">Bar</a>
 *
 * <!-- Assume this component's state is "foo".
 *      Relatively targets "foo.child" -->
 * <a uiSref=".child">Foo Child</a>
 *
 * <!-- Targets "bar" state and supplies parameter value -->
 * <a uiSref="bar" [uiParams]="{ barId: foo.barId }">Bar {{foo.barId}}</a>
 *
 * <!-- Targets "bar" state and parameter, doesn't inherit existing parameters-->
 * <a uiSref="bar" [uiParams]="{ barId: foo.barId }" [uiOptions]="{ inherit: false }">Bar {{foo.barId}}</a>
 * ```
 */
var UISref = (function () {
    function UISref(_router, _anchorUISref, parent) {
        var _this = this;
        /**
         * An observable (ReplaySubject) of the state this UISref is targeting.
         * When the UISref is clicked, it will transition to this [[TargetState]].
         */
        this.targetState$ = new __WEBPACK_IMPORTED_MODULE_3_rxjs_ReplaySubject__["ReplaySubject"](1);
        /** @internalapi */ this._emit = false;
        this._router = _router;
        this._anchorUISref = _anchorUISref;
        this.parent = parent;
        this._statesSub = _router.globals.states$.subscribe(function () { return _this.update(); });
    }
    Object.defineProperty(UISref.prototype, "uiSref", {
        /** @internalapi */
        set: function (val) { this.state = val; this.update(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UISref.prototype, "uiParams", {
        /** @internalapi */
        set: function (val) { this.params = val; this.update(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UISref.prototype, "uiOptions", {
        /** @internalapi */
        set: function (val) { this.options = val; this.update(); },
        enumerable: true,
        configurable: true
    });
    UISref.prototype.ngOnInit = function () {
        this._emit = true;
        this.update();
    };
    UISref.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    UISref.prototype.ngOnDestroy = function () {
        this._emit = false;
        this._statesSub.unsubscribe();
        this.targetState$.unsubscribe();
    };
    UISref.prototype.update = function () {
        var $state = this._router.stateService;
        if (this._emit) {
            var newTarget = $state.target(this.state, this.params, this.getOptions());
            this.targetState$.next(newTarget);
        }
        if (this._anchorUISref) {
            var href = $state.href(this.state, this.params, this.getOptions());
            this._anchorUISref.update(href);
        }
    };
    UISref.prototype.getOptions = function () {
        var defaultOpts = {
            relative: this.parent && this.parent.context && this.parent.context.name,
            inherit: true,
            source: "sref"
        };
        return Object(__WEBPACK_IMPORTED_MODULE_0__uirouter_core__["extend"])(defaultOpts, this.options || {});
    };
    /** When triggered by a (click) event, this function transitions to the UISref's target state */
    UISref.prototype.go = function () {
        if (this._anchorUISref && this._anchorUISref.openInNewTab()) {
            return;
        }
        this._router.stateService.go(this.state, this.params, this.getOptions());
        return false;
    };
    return UISref;
}());

UISref.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Directive"], args: [{
                selector: '[uiSref]',
                host: { '(click)': 'go()' }
            },] },
];
/** @nocollapse */
UISref.ctorParameters = function () { return [
    { type: __WEBPACK_IMPORTED_MODULE_0__uirouter_core__["UIRouter"], },
    { type: AnchorUISref, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Optional"] },] },
    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Inject"], args: [__WEBPACK_IMPORTED_MODULE_2__uiView__["a" /* UIView */].PARENT_INJECT,] },] },
]; };
UISref.propDecorators = {
    'state': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['uiSref',] },],
    'params': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['uiParams',] },],
    'options': [{ type: __WEBPACK_IMPORTED_MODULE_1__angular_core__["Input"], args: ['uiOptions',] },],
};
//# sourceMappingURL=uiSref.js.map

/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UISrefStatus; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__uiSref__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__uirouter_core__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__uirouter_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__uirouter_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_observable_of__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_observable_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_rxjs_observable_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_observable_fromPromise__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_observable_fromPromise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_fromPromise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_observable_combineLatest__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_observable_combineLatest___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_combineLatest__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_switchMap__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_switchMap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_rxjs_operator_switchMap__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_map__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_rxjs_operator_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_operator_concat__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_rxjs_operator_concat___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_rxjs_operator_concat__);
/** @ng2api @module directives */
/** */










/** @internalapi */
var inactiveStatus = {
    active: false,
    exact: false,
    entering: false,
    exiting: false,
    targetStates: [],
};
/**
 * Returns a Predicate<PathNode[]>
 *
 * The predicate returns true when the target state (and param values)
 * match the (tail of) the path, and the path's param values
 *
 * @internalapi
 */
var pathMatches = function (target) {
    if (!target.exists())
        return function () { return false; };
    var state = target.$state();
    var targetParamVals = target.params();
    var targetPath = __WEBPACK_IMPORTED_MODULE_2__uirouter_core__["PathUtils"].buildPath(target);
    var paramSchema = targetPath.map(function (node) { return node.paramSchema; })
        .reduce(__WEBPACK_IMPORTED_MODULE_2__uirouter_core__["unnestR"], [])
        .filter(function (param) { return targetParamVals.hasOwnProperty(param.id); });
    return function (path) {
        var tailNode = Object(__WEBPACK_IMPORTED_MODULE_2__uirouter_core__["tail"])(path);
        if (!tailNode || tailNode.state !== state)
            return false;
        var paramValues = __WEBPACK_IMPORTED_MODULE_2__uirouter_core__["PathUtils"].paramValues(path);
        return __WEBPACK_IMPORTED_MODULE_2__uirouter_core__["Param"].equals(paramSchema, paramValues, targetParamVals);
    };
};
/**
 * Given basePath: [a, b], appendPath: [c, d]),
 * Expands the path to [c], [c, d]
 * Then appends each to [a,b,] and returns: [a, b, c], [a, b, c, d]
 *
 * @internalapi
 */
function spreadToSubPaths(basePath, appendPath) {
    return appendPath.map(function (node) { return basePath.concat(__WEBPACK_IMPORTED_MODULE_2__uirouter_core__["PathUtils"].subPath(appendPath, function (n) { return n.state === node.state; })); });
}
/**
 * Given a TransEvt (Transition event: started, success, error)
 * and a UISref Target State, return a SrefStatus object
 * which represents the current status of that Sref:
 * active, activeEq (exact match), entering, exiting
 *
 * @internalapi
 */
function getSrefStatus(event, srefTarget) {
    var pathMatchesTarget = pathMatches(srefTarget);
    var tc = event.trans.treeChanges();
    var isStartEvent = event.evt === 'start';
    var isSuccessEvent = event.evt === 'success';
    var activePath = isSuccessEvent ? tc.to : tc.from;
    var isActive = function () {
        return spreadToSubPaths([], activePath)
            .map(pathMatchesTarget)
            .reduce(__WEBPACK_IMPORTED_MODULE_2__uirouter_core__["anyTrueR"], false);
    };
    var isExact = function () {
        return pathMatchesTarget(activePath);
    };
    var isEntering = function () {
        return spreadToSubPaths(tc.retained, tc.entering)
            .map(pathMatchesTarget)
            .reduce(__WEBPACK_IMPORTED_MODULE_2__uirouter_core__["anyTrueR"], false);
    };
    var isExiting = function () {
        return spreadToSubPaths(tc.retained, tc.exiting)
            .map(pathMatchesTarget)
            .reduce(__WEBPACK_IMPORTED_MODULE_2__uirouter_core__["anyTrueR"], false);
    };
    return {
        active: isActive(),
        exact: isExact(),
        entering: isStartEvent ? isEntering() : false,
        exiting: isStartEvent ? isExiting() : false,
        targetStates: [srefTarget],
    };
}
/** @internalapi */
function mergeSrefStatus(left, right) {
    return {
        active: left.active || right.active,
        exact: left.exact || right.exact,
        entering: left.entering || right.entering,
        exiting: left.exiting || right.exiting,
        targetStates: left.targetStates.concat(right.targetStates),
    };
}
/**
 * A directive which emits events when a paired [[UISref]] status changes.
 *
 * This directive is primarily used by the [[UISrefActive]] directives to monitor `UISref`(s).
 *
 * This directive shares two attribute selectors with `UISrefActive`:
 *
 * - `[uiSrefActive]`
 * - `[uiSrefActiveEq]`.
 *
 * Thus, whenever a `UISrefActive` directive is created, a `UISrefStatus` directive is also created.
 *
 * Most apps should simply use `UISrefActive`, but some advanced components may want to process the
 * [[SrefStatus]] events directly.
 *
 * ```js
 * <li (uiSrefStatus)="onSrefStatusChanged($event)">
 *   <a uiSref="book" [uiParams]="{ bookId: book.id }">Book {{ book.name }}</a>
 * </li>
 * ```
 *
 * The `uiSrefStatus` event is emitted whenever an enclosed `uiSref`'s status changes.
 * The event emitted is of type [[SrefStatus]], and has boolean values for `active`, `exact`, `entering`, and `exiting`; also has a [[StateOrName]] `identifier`value.
 *
 * The values from this event can be captured and stored on a component (then applied, e.g., using ngClass).
 *
 * ---
 *
 * A single `uiSrefStatus` can enclose multiple `uiSref`.
 * Each status boolean (`active`, `exact`, `entering`, `exiting`) will be true if *any of the enclosed `uiSref` status is true*.
 * In other words, all enclosed `uiSref` statuses  are merged to a single status using `||` (logical or).
 *
 * ```js
 * <li (uiSrefStatus)="onSrefStatus($event)" uiSref="admin">
 *   Home
 *   <ul>
 *     <li> <a uiSref="admin.users">Users</a> </li>
 *     <li> <a uiSref="admin.groups">Groups</a> </li>
 *   </ul>
 * </li>
 * ```
 *
 * In the above example, `$event.active === true` when either `admin.users` or `admin.groups` is active.
 *
 * ---
 *
 * This API is subject to change.
 */
var UISrefStatus = (function () {
    function UISrefStatus(_globals) {
        /** current statuses of the state/params the uiSref directive is linking to */
        this.uiSrefStatus = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["EventEmitter"](false);
        this._globals = _globals;
        this.status = Object.assign({}, inactiveStatus);
    }
    UISrefStatus.prototype.ngAfterContentInit = function () {
        var _this = this;
        // Map each transition start event to a stream of:
        // start -> (success|error)
        var transEvents$ = __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_switchMap__["switchMap"].call(this._globals.start$, function (trans) {
            var event = function (evt) { return ({ evt: evt, trans: trans }); };
            var transStart$ = Object(__WEBPACK_IMPORTED_MODULE_4_rxjs_observable_of__["of"])(event("start"));
            var transResult = trans.promise.then(function () { return event("success"); }, function () { return event("error"); });
            var transFinish$ = Object(__WEBPACK_IMPORTED_MODULE_5_rxjs_observable_fromPromise__["fromPromise"])(transResult);
            return __WEBPACK_IMPORTED_MODULE_9_rxjs_operator_concat__["concat"].call(transStart$, transFinish$);
        });
        // Watch the @ContentChildren UISref[] components and get their target states
        // let srefs$: Observable<UISref[]> = of(this.srefs.toArray()).concat(this.srefs.changes);
        this._srefs$ = new __WEBPACK_IMPORTED_MODULE_3_rxjs_BehaviorSubject__["BehaviorSubject"](this.srefs.toArray());
        this._srefChangesSub = this.srefs.changes.subscribe(function (srefs) { return _this._srefs$.next(srefs); });
        var targetStates$ = __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_switchMap__["switchMap"].call(this._srefs$, function (srefs) {
            return Object(__WEBPACK_IMPORTED_MODULE_6_rxjs_observable_combineLatest__["combineLatest"])(srefs.map(function (sref) { return sref.targetState$; }));
        });
        // Calculate the status of each UISref based on the transition event.
        // Reduce the statuses (if multiple) by or-ing each flag.
        this._subscription = __WEBPACK_IMPORTED_MODULE_7_rxjs_operator_switchMap__["switchMap"].call(transEvents$, function (evt) {
            return __WEBPACK_IMPORTED_MODULE_8_rxjs_operator_map__["map"].call(targetStates$, function (targets) {
                var statuses = targets.map(function (target) { return getSrefStatus(evt, target); });
                return statuses.reduce(mergeSrefStatus);
            });
        }).subscribe(this._setStatus.bind(this));
    };
    UISrefStatus.prototype.ngOnDestroy = function () {
        if (this._subscription)
            this._subscription.unsubscribe();
        if (this._srefChangesSub)
            this._srefChangesSub.unsubscribe();
        if (this._srefs$)
            this._srefs$.unsubscribe();
        this._subscription = this._srefChangesSub = this._srefs$ = undefined;
    };
    UISrefStatus.prototype._setStatus = function (status) {
        this.status = status;
        this.uiSrefStatus.emit(status);
    };
    return UISrefStatus;
}());

UISrefStatus.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__["Directive"], args: [{ selector: '[uiSrefStatus],[uiSrefActive],[uiSrefActiveEq]' },] },
];
/** @nocollapse */
UISrefStatus.ctorParameters = function () { return [
    { type: __WEBPACK_IMPORTED_MODULE_2__uirouter_core__["UIRouterGlobals"], },
]; };
UISrefStatus.propDecorators = {
    'uiSrefStatus': [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__["Output"], args: ["uiSrefStatus",] },],
    'srefs': [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__["ContentChildren"], args: [__WEBPACK_IMPORTED_MODULE_1__uiSref__["b" /* UISref */], { descendants: true },] },],
};
//# sourceMappingURL=uiSrefStatus.js.map

/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["m"] = uiRouterFactory;
/* harmony export (immutable) */ __webpack_exports__["l"] = parentUIViewInjectFactory;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return _UIROUTER_INSTANCE_PROVIDERS; });
/* harmony export (immutable) */ __webpack_exports__["f"] = fnStateService;
/* harmony export (immutable) */ __webpack_exports__["g"] = fnTransitionService;
/* harmony export (immutable) */ __webpack_exports__["h"] = fnUrlMatcherFactory;
/* harmony export (immutable) */ __webpack_exports__["i"] = fnUrlRouter;
/* harmony export (immutable) */ __webpack_exports__["j"] = fnUrlService;
/* harmony export (immutable) */ __webpack_exports__["k"] = fnViewService;
/* harmony export (immutable) */ __webpack_exports__["e"] = fnStateRegistry;
/* harmony export (immutable) */ __webpack_exports__["d"] = fnGlobals;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return _UIROUTER_SERVICE_PROVIDERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UIROUTER_PROVIDERS; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_common__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__uirouter_core__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__uirouter_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__uirouter_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__directives_uiView__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__statebuilders_views__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__uiRouterConfig__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__uiRouterNgModule__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__statebuilders_lazyLoad__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__uirouter_rx__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__location_locationService__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__location_locationConfig__ = __webpack_require__(107);
/**
 * # UI-Router for Angular (v2+)
 *
 * - [@uirouter/angular home page](https://ui-router.github.io/ng2)
 * - [tutorials](https://ui-router.github.io/tutorial/ng2/helloworld)
 * - [quick start repository](http://github.com/ui-router/quickstart-ng2)
 *
 * Getting started:
 *
 * - Use npm. Add a dependency on latest `@uirouter/angular`
 * - Import UI-Router classes directly from `"@uirouter/angular"`
 *
 * ```js
 * import {StateRegistry} from "@uirouter/angular";
 * ```
 *
 * - Create application states (as defined by [[Ng2StateDeclaration]]).
 *
 * ```js
 * export let state1: Ng2StateDeclaration = {
 *   name: 'state1',
 *   component: State1Component,
 *   url: '/one'
 * }
 *
 * export let state2: Ng2StateDeclaration = {
 *   name: 'state2',
 *   component: State2Component,
 *   url: '/two'
 * }
 * ```
 *
 * - Import a [[UIRouterModule.forChild]] module into your feature `NgModule`s.
 *
 * ```js
 * @ NgModule({
 *   imports: [
 *     SharedModule,
 *     UIRouterModule.forChild({ states: [state1, state2 ] })
 *   ],
 *   declarations: [
 *     State1Component,
 *     State2Component,
 *   ]
 * })
 * export class MyFeatureModule {}
 * ```
 *
 * - Import a [[UIRouterModule.forRoot]] module into your application root `NgModule`
 * - Either bootstrap a [[UIView]] component, or add a `<ui-view></ui-view>` viewport to your root component.
 *
 * ```js
 * @ NgModule({
 *   imports: [
 *     BrowserModule,
 *     UIRouterModule.forRoot({ states: [ homeState ] }),
 *     MyFeatureModule,
 *   ],
 *   declarations: [
 *     HomeComponent
 *   ]
 *   bootstrap: [ UIView ]
 * })
 * class RootAppModule {}
 *
 * browserPlatformDynamic.bootstrapModule(RootAppModule);
 * ```
 *
 * - Optionally specify a configuration class [[ChildModule.configClass]] for any module
 * to perform any router configuration during bootstrap or lazyload.
 * Pass the class to [[UIRouterModule.forRoot]] or [[UIRouterModule.forChild]].
 *
 * ```js
 * import {UIRouter} from "@uirouter/angular";
 *
 * @ Injectable()
 * export class MyUIRouterConfig {
 *   // Constructor is injectable
 *   constructor(uiRouter: UIRouter) {
 *     uiRouter.urlMatcherFactory.type('datetime', myDateTimeParamType);
 *   }
 * }
 * ```
 *
 * @preferred @module ng2
 */
/** */













/**
 * This is a factory function for a UIRouter instance
 *
 * Creates a UIRouter instance and configures it for Angular, then invokes router bootstrap.
 * This function is used as an Angular `useFactory` Provider.
 */
function uiRouterFactory(locationStrategy, rootModules, modules, injector) {
    if (rootModules.length !== 1) {
        throw new Error("Exactly one UIRouterModule.forRoot() should be in the bootstrapped app module's imports: []");
    }
    // ----------------- Create router -----------------
    // Create a new ng2 UIRouter and configure it for ng2
    var router = new __WEBPACK_IMPORTED_MODULE_2__uirouter_core__["UIRouter"]();
    // Add RxJS plugin
    router.plugin(__WEBPACK_IMPORTED_MODULE_8__uirouter_rx__["a" /* UIRouterRx */]);
    // Add $q-like and $injector-like service APIs
    router.plugin(__WEBPACK_IMPORTED_MODULE_2__uirouter_core__["servicesPlugin"]);
    // ----------------- Monkey Patches ----------------
    // Monkey patch the services.$injector to use the root ng2 Injector
    __WEBPACK_IMPORTED_MODULE_2__uirouter_core__["services"].$injector.get = injector.get.bind(injector);
    // ----------------- Configure for ng2 -------------
    router.locationService = new __WEBPACK_IMPORTED_MODULE_9__location_locationService__["a" /* Ng2LocationServices */](router, locationStrategy, Object(__WEBPACK_IMPORTED_MODULE_1__angular_common__["isPlatformBrowser"])(injector.get(__WEBPACK_IMPORTED_MODULE_0__angular_core__["PLATFORM_ID"])));
    router.locationConfig = new __WEBPACK_IMPORTED_MODULE_10__location_locationConfig__["a" /* Ng2LocationConfig */](router, locationStrategy);
    // Apply ng2 ui-view handling code
    var viewConfigFactory = function (path, config) { return new __WEBPACK_IMPORTED_MODULE_4__statebuilders_views__["a" /* Ng2ViewConfig */](path, config); };
    router.viewService._pluginapi._viewConfigFactory("ng2", viewConfigFactory);
    // Apply statebuilder decorator for ng2 NgModule registration
    var registry = router.stateRegistry;
    registry.decorator('views', __WEBPACK_IMPORTED_MODULE_4__statebuilders_views__["b" /* ng2ViewsBuilder */]);
    registry.decorator('lazyLoad', __WEBPACK_IMPORTED_MODULE_7__statebuilders_lazyLoad__["a" /* ng2LazyLoadBuilder */]);
    // Prep the tree of NgModule by placing the root NgModule's Injector on the root state.
    var ng2InjectorResolvable = __WEBPACK_IMPORTED_MODULE_2__uirouter_core__["Resolvable"].fromData(__WEBPACK_IMPORTED_MODULE_2__uirouter_core__["NATIVE_INJECTOR_TOKEN"], injector);
    registry.root().resolvables.push(ng2InjectorResolvable);
    // Auto-flush the parameter type queue
    router.urlMatcherFactory.$get();
    // ----------------- Initialize router -------------
    rootModules.forEach(function (moduleConfig) { return Object(__WEBPACK_IMPORTED_MODULE_5__uiRouterConfig__["b" /* applyRootModuleConfig */])(router, injector, moduleConfig); });
    modules.forEach(function (moduleConfig) { return Object(__WEBPACK_IMPORTED_MODULE_5__uiRouterConfig__["a" /* applyModuleConfig */])(router, injector, moduleConfig); });
    // Start monitoring the URL
    if (!router.urlRouter.interceptDeferred) {
        router.urlService.listen();
        router.urlService.sync();
    }
    return router;
}
function parentUIViewInjectFactory(r) { return { fqn: null, context: r.root() }; }
var _UIROUTER_INSTANCE_PROVIDERS = [
    { provide: __WEBPACK_IMPORTED_MODULE_2__uirouter_core__["UIRouter"], useFactory: uiRouterFactory, deps: [__WEBPACK_IMPORTED_MODULE_1__angular_common__["LocationStrategy"], __WEBPACK_IMPORTED_MODULE_6__uiRouterNgModule__["b" /* UIROUTER_ROOT_MODULE */], __WEBPACK_IMPORTED_MODULE_6__uiRouterNgModule__["a" /* UIROUTER_MODULE_TOKEN */], __WEBPACK_IMPORTED_MODULE_0__angular_core__["Injector"]] },
    { provide: __WEBPACK_IMPORTED_MODULE_3__directives_uiView__["a" /* UIView */].PARENT_INJECT, useFactory: parentUIViewInjectFactory, deps: [__WEBPACK_IMPORTED_MODULE_2__uirouter_core__["StateRegistry"]] },
];
function fnStateService(r) { return r.stateService; }
function fnTransitionService(r) { return r.transitionService; }
function fnUrlMatcherFactory(r) { return r.urlMatcherFactory; }
function fnUrlRouter(r) { return r.urlRouter; }
function fnUrlService(r) { return r.urlService; }
function fnViewService(r) { return r.viewService; }
function fnStateRegistry(r) { return r.stateRegistry; }
function fnGlobals(r) { return r.globals; }
var _UIROUTER_SERVICE_PROVIDERS = [
    { provide: __WEBPACK_IMPORTED_MODULE_2__uirouter_core__["StateService"], useFactory: fnStateService, deps: [__WEBPACK_IMPORTED_MODULE_2__uirouter_core__["UIRouter"]] },
    { provide: __WEBPACK_IMPORTED_MODULE_2__uirouter_core__["TransitionService"], useFactory: fnTransitionService, deps: [__WEBPACK_IMPORTED_MODULE_2__uirouter_core__["UIRouter"]] },
    { provide: __WEBPACK_IMPORTED_MODULE_2__uirouter_core__["UrlMatcherFactory"], useFactory: fnUrlMatcherFactory, deps: [__WEBPACK_IMPORTED_MODULE_2__uirouter_core__["UIRouter"]] },
    { provide: __WEBPACK_IMPORTED_MODULE_2__uirouter_core__["UrlRouter"], useFactory: fnUrlRouter, deps: [__WEBPACK_IMPORTED_MODULE_2__uirouter_core__["UIRouter"]] },
    { provide: __WEBPACK_IMPORTED_MODULE_2__uirouter_core__["UrlService"], useFactory: fnUrlService, deps: [__WEBPACK_IMPORTED_MODULE_2__uirouter_core__["UIRouter"]] },
    { provide: __WEBPACK_IMPORTED_MODULE_2__uirouter_core__["ViewService"], useFactory: fnViewService, deps: [__WEBPACK_IMPORTED_MODULE_2__uirouter_core__["UIRouter"]] },
    { provide: __WEBPACK_IMPORTED_MODULE_2__uirouter_core__["StateRegistry"], useFactory: fnStateRegistry, deps: [__WEBPACK_IMPORTED_MODULE_2__uirouter_core__["UIRouter"]] },
    { provide: __WEBPACK_IMPORTED_MODULE_2__uirouter_core__["UIRouterGlobals"], useFactory: fnGlobals, deps: [__WEBPACK_IMPORTED_MODULE_2__uirouter_core__["UIRouter"]] },
];
/**
 * The UI-Router providers, for use in your application bootstrap
 *
 * @deprecated use [[UIRouterModule.forRoot]]
 */
var UIROUTER_PROVIDERS = _UIROUTER_INSTANCE_PROVIDERS.concat(_UIROUTER_SERVICE_PROVIDERS);
//# sourceMappingURL=providers.js.map

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @coreapi
 * @module transition
 */ /** for typedoc */
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var interface_1 = __webpack_require__(11);
var transitionHook_1 = __webpack_require__(15);
/**
 * This class returns applicable TransitionHooks for a specific Transition instance.
 *
 * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.
 * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is
 * determined by the type of hook)
 *
 * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.
 *
 * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder
 * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private
 * in the Transition class, so we must also provide the Transition's _treeChanges)
 *
 */
var HookBuilder = /** @class */ (function () {
    function HookBuilder(transition) {
        this.transition = transition;
    }
    HookBuilder.prototype.buildHooksForPhase = function (phase) {
        var _this = this;
        var $transitions = this.transition.router.transitionService;
        return $transitions._pluginapi._getEvents(phase)
            .map(function (type) { return _this.buildHooks(type); })
            .reduce(common_1.unnestR, [])
            .filter(common_1.identity);
    };
    /**
     * Returns an array of newly built TransitionHook objects.
     *
     * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].
     * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)
     * - For each of the [[PathNode]]s, creates a TransitionHook
     *
     * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.
     */
    HookBuilder.prototype.buildHooks = function (hookType) {
        var transition = this.transition;
        var treeChanges = transition.treeChanges();
        // Find all the matching registered hooks for a given hook type
        var matchingHooks = this.getMatchingHooks(hookType, treeChanges);
        if (!matchingHooks)
            return [];
        var baseHookOptions = {
            transition: transition,
            current: transition.options().current
        };
        var makeTransitionHooks = function (hook) {
            // Fetch the Nodes that caused this hook to match.
            var matches = hook.matches(treeChanges);
            // Select the PathNode[] that will be used as TransitionHook context objects
            var matchingNodes = matches[hookType.criteriaMatchPath.name];
            // Return an array of HookTuples
            return matchingNodes.map(function (node) {
                var _options = common_1.extend({
                    bind: hook.bind,
                    traceData: { hookType: hookType.name, context: node }
                }, baseHookOptions);
                var state = hookType.criteriaMatchPath.scope === interface_1.TransitionHookScope.STATE ? node.state.self : null;
                var transitionHook = new transitionHook_1.TransitionHook(transition, state, hook, _options);
                return { hook: hook, node: node, transitionHook: transitionHook };
            });
        };
        return matchingHooks.map(makeTransitionHooks)
            .reduce(common_1.unnestR, [])
            .sort(tupleSort(hookType.reverseSort))
            .map(function (tuple) { return tuple.transitionHook; });
    };
    /**
     * Finds all RegisteredHooks from:
     * - The Transition object instance hook registry
     * - The TransitionService ($transitions) global hook registry
     *
     * which matched:
     * - the eventType
     * - the matchCriteria (to, from, exiting, retained, entering)
     *
     * @returns an array of matched [[RegisteredHook]]s
     */
    HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges) {
        var isCreate = hookType.hookPhase === interface_1.TransitionHookPhase.CREATE;
        // Instance and Global hook registries
        var $transitions = this.transition.router.transitionService;
        var registries = isCreate ? [$transitions] : [this.transition, $transitions];
        return registries.map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries
            .filter(common_1.assertPredicate(predicates_1.isArray, "broken event named: " + hookType.name)) // Sanity check
            .reduce(common_1.unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array
            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria
    };
    return HookBuilder;
}());
exports.HookBuilder = HookBuilder;
/**
 * A factory for a sort function for HookTuples.
 *
 * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares
 * the EventHook priority.
 *
 * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth
 * @returns a tuple sort function
 */
function tupleSort(reverseDepthSort) {
    if (reverseDepthSort === void 0) { reverseDepthSort = false; }
    return function nodeDepthThenPriority(l, r) {
        var factor = reverseDepthSort ? -1 : 1;
        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;
        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;
    };
}
//# sourceMappingURL=hookBuilder.js.map

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @internalapi */
exports.resolvePolicies = {
    when: {
        LAZY: "LAZY",
        EAGER: "EAGER"
    },
    async: {
        WAIT: "WAIT",
        NOWAIT: "NOWAIT",
        RXWAIT: "RXWAIT"
    }
};
//# sourceMappingURL=interface.js.map

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module params
 */
/** */
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var hof_1 = __webpack_require__(2);
var coreservices_1 = __webpack_require__(5);
var paramType_1 = __webpack_require__(30);
/**
 * A registry for parameter types.
 *
 * This registry manages the built-in (and custom) parameter types.
 *
 * The built-in parameter types are:
 *
 * - [[string]]
 * - [[path]]
 * - [[query]]
 * - [[hash]]
 * - [[int]]
 * - [[bool]]
 * - [[date]]
 * - [[json]]
 * - [[any]]
 */
var ParamTypes = /** @class */ (function () {
    /** @internalapi */
    function ParamTypes() {
        /** @hidden */
        this.enqueue = true;
        /** @hidden */
        this.typeQueue = [];
        /** @internalapi */
        this.defaultTypes = common_1.pick(ParamTypes.prototype, ["hash", "string", "query", "path", "int", "bool", "date", "json", "any"]);
        // Register default types. Store them in the prototype of this.types.
        var makeType = function (definition, name) {
            return new paramType_1.ParamType(common_1.extend({ name: name }, definition));
        };
        this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});
    }
    /** @internalapi */
    ParamTypes.prototype.dispose = function () {
        this.types = {};
    };
    /**
     * Registers a parameter type
     *
     * End users should call [[UrlMatcherFactory.type]], which delegates to this method.
     */
    ParamTypes.prototype.type = function (name, definition, definitionFn) {
        if (!predicates_1.isDefined(definition))
            return this.types[name];
        if (this.types.hasOwnProperty(name))
            throw new Error("A type named '" + name + "' has already been defined.");
        this.types[name] = new paramType_1.ParamType(common_1.extend({ name: name }, definition));
        if (definitionFn) {
            this.typeQueue.push({ name: name, def: definitionFn });
            if (!this.enqueue)
                this._flushTypeQueue();
        }
        return this;
    };
    /** @internalapi */
    ParamTypes.prototype._flushTypeQueue = function () {
        while (this.typeQueue.length) {
            var type = this.typeQueue.shift();
            if (type.pattern)
                throw new Error("You cannot override a type's .pattern at runtime.");
            common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));
        }
    };
    return ParamTypes;
}());
exports.ParamTypes = ParamTypes;
/** @hidden */
function initDefaultTypes() {
    var makeDefaultType = function (def) {
        var valToString = function (val) {
            return val != null ? val.toString() : val;
        };
        var defaultTypeBase = {
            encode: valToString,
            decode: valToString,
            is: hof_1.is(String),
            pattern: /.*/,
            equals: function (a, b) { return a == b; },
        };
        return common_1.extend({}, defaultTypeBase, def);
    };
    // Default Parameter Type Definitions
    common_1.extend(ParamTypes.prototype, {
        string: makeDefaultType({}),
        path: makeDefaultType({
            pattern: /[^/]*/,
        }),
        query: makeDefaultType({}),
        hash: makeDefaultType({
            inherit: false,
        }),
        int: makeDefaultType({
            decode: function (val) { return parseInt(val, 10); },
            is: function (val) {
                return !predicates_1.isNullOrUndefined(val) && this.decode(val.toString()) === val;
            },
            pattern: /-?\d+/,
        }),
        bool: makeDefaultType({
            encode: function (val) { return val && 1 || 0; },
            decode: function (val) { return parseInt(val, 10) !== 0; },
            is: hof_1.is(Boolean),
            pattern: /0|1/,
        }),
        date: makeDefaultType({
            encode: function (val) {
                return !this.is(val) ? undefined : [
                    val.getFullYear(),
                    ('0' + (val.getMonth() + 1)).slice(-2),
                    ('0' + val.getDate()).slice(-2),
                ].join("-");
            },
            decode: function (val) {
                if (this.is(val))
                    return val;
                var match = this.capture.exec(val);
                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
            },
            is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },
            equals: function (l, r) {
                return ['getFullYear', 'getMonth', 'getDate']
                    .reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);
            },
            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/,
        }),
        json: makeDefaultType({
            encode: common_1.toJson,
            decode: common_1.fromJson,
            is: hof_1.is(Object),
            equals: common_1.equals,
            pattern: /[^/]*/,
        }),
        // does not encode/decode
        any: makeDefaultType({
            encode: common_1.identity,
            decode: common_1.identity,
            is: function () { return true; },
            equals: common_1.equals,
        }),
    });
}
initDefaultTypes();
//# sourceMappingURL=paramTypes.js.map

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module params
 */
/** */
var common_1 = __webpack_require__(0);
/** @internalapi */
var StateParams = /** @class */ (function () {
    function StateParams(params) {
        if (params === void 0) { params = {}; }
        common_1.extend(this, params);
    }
    /**
     * Merges a set of parameters with all parameters inherited between the common parents of the
     * current state and a given destination state.
     *
     * @param {Object} newParams The set of parameters which will be composited with inherited params.
     * @param {Object} $current Internal definition of object representing the current state.
     * @param {Object} $to Internal definition of object representing state to transition to.
     */
    StateParams.prototype.$inherit = function (newParams, $current, $to) {
        var parents = common_1.ancestors($current, $to), parentParams, inherited = {}, inheritList = [];
        for (var i in parents) {
            if (!parents[i] || !parents[i].params)
                continue;
            parentParams = Object.keys(parents[i].params);
            if (!parentParams.length)
                continue;
            for (var j in parentParams) {
                if (inheritList.indexOf(parentParams[j]) >= 0)
                    continue;
                inheritList.push(parentParams[j]);
                inherited[parentParams[j]] = this[parentParams[j]];
            }
        }
        return common_1.extend({}, inherited, newParams);
    };
    ;
    return StateParams;
}());
exports.StateParams = StateParams;
//# sourceMappingURL=stateParams.js.map

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module state */ /** for typedoc */
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var strings_1 = __webpack_require__(8);
var hof_1 = __webpack_require__(2);
var resolvable_1 = __webpack_require__(16);
var coreservices_1 = __webpack_require__(5);
var parseUrl = function (url) {
    if (!predicates_1.isString(url))
        return false;
    var root = url.charAt(0) === '^';
    return { val: root ? url.substring(1) : url, root: root };
};
function nameBuilder(state) {
    return state.name;
}
function selfBuilder(state) {
    state.self.$$state = function () { return state; };
    return state.self;
}
function dataBuilder(state) {
    if (state.parent && state.parent.data) {
        state.data = state.self.data = common_1.inherit(state.parent.data, state.data);
    }
    return state.data;
}
var getUrlBuilder = function ($urlMatcherFactoryProvider, root) {
    return function urlBuilder(state) {
        var stateDec = state;
        // For future states, i.e., states whose name ends with `.**`,
        // match anything that starts with the url prefix
        if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\.\*\*$/)) {
            stateDec.url += "{remainder:any}"; // match any path (.*)
        }
        var parsed = parseUrl(stateDec.url), parent = state.parent;
        var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {
            params: state.params || {},
            paramMap: function (paramConfig, isSearch) {
                if (stateDec.reloadOnSearch === false && isSearch)
                    paramConfig = common_1.extend(paramConfig || {}, { dynamic: true });
                return paramConfig;
            }
        });
        if (!url)
            return null;
        if (!$urlMatcherFactoryProvider.isMatcher(url))
            throw new Error("Invalid url '" + url + "' in state '" + state + "'");
        return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);
    };
};
var getNavigableBuilder = function (isRoot) {
    return function navigableBuilder(state) {
        return !isRoot(state) && state.url ? state : (state.parent ? state.parent.navigable : null);
    };
};
var getParamsBuilder = function (paramFactory) {
    return function paramsBuilder(state) {
        var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, config); };
        var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];
        var nonUrlParams = common_1.values(common_1.mapObj(common_1.omit(state.params || {}, urlParams.map(hof_1.prop('id'))), makeConfigParam));
        return urlParams.concat(nonUrlParams).map(function (p) { return [p.id, p]; }).reduce(common_1.applyPairs, {});
    };
};
function pathBuilder(state) {
    return state.parent ? state.parent.path.concat(state) : /*root*/ [state];
}
function includesBuilder(state) {
    var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};
    includes[state.name] = true;
    return includes;
}
/**
 * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].
 *
 * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
 * validates the `resolve` property and converts it to a [[Resolvable]] array.
 *
 * resolve: input value can be:
 *
 * {
 *   // analyzed but not injected
 *   myFooResolve: function() { return "myFooData"; },
 *
 *   // function.toString() parsed, "DependencyName" dep as string (not min-safe)
 *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },
 *
 *   // Array split; "DependencyName" dep as string
 *   myBazResolve: [ "DependencyName", function(dep) { return dep.fetchSomethingAsPromise() },
 *
 *   // Array split; DependencyType dep as token (compared using ===)
 *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },
 *
 *   // val.$inject used as deps
 *   // where:
 *   //     corgeResolve.$inject = ["DependencyName"];
 *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }
 *   // then "DependencyName" dep as string
 *   myCorgeResolve: corgeResolve,
 *
 *  // inject service by name
 *  // When a string is found, desugar creating a resolve that injects the named service
 *   myGraultResolve: "SomeService"
 * }
 *
 * or:
 *
 * [
 *   new Resolvable("myFooResolve", function() { return "myFooData" }),
 *   new Resolvable("myBarResolve", function(dep) { return dep.fetchSomethingAsPromise() }, [ "DependencyName" ]),
 *   { provide: "myBazResolve", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ "DependencyName" ] }
 * ]
 */
function resolvablesBuilder(state) {
    /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */
    var objects2Tuples = function (resolveObj, resolvePolicies) {
        return Object.keys(resolveObj || {}).map(function (token) { return ({ token: token, val: resolveObj[token], deps: undefined, policy: resolvePolicies[token] }); });
    };
    /** fetch DI annotations from a function or ng1-style array */
    var annotate = function (fn) {
        var $injector = coreservices_1.services.$injector;
        // ng1 doesn't have an $injector until runtime.
        // If the $injector doesn't exist, use "deferred" literal as a
        // marker indicating they should be annotated when runtime starts
        return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || "deferred";
    };
    /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */
    var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };
    /** true if the object looks like a provide literal, or a ng2 Provider */
    var isLikeNg2Provider = function (obj) { return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass)); };
    /** true if the object looks like a tuple from obj2Tuples */
    var isTupleFromObj = function (obj) { return !!(obj && obj.val && (predicates_1.isString(obj.val) || predicates_1.isArray(obj.val) || predicates_1.isFunction(obj.val))); };
    /** extracts the token from a Provider or provide literal */
    var token = function (p) { return p.provide || p.token; };
    /** Given a literal resolve or provider object, returns a Resolvable */
    var literal2Resolvable = hof_1.pattern([
        [hof_1.prop('resolveFn'), function (p) { return new resolvable_1.Resolvable(token(p), p.resolveFn, p.deps, p.policy); }],
        [hof_1.prop('useFactory'), function (p) { return new resolvable_1.Resolvable(token(p), p.useFactory, (p.deps || p.dependencies), p.policy); }],
        [hof_1.prop('useClass'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return new p.useClass(); }, [], p.policy); }],
        [hof_1.prop('useValue'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],
        [hof_1.prop('useExisting'), function (p) { return new resolvable_1.Resolvable(token(p), common_1.identity, [p.useExisting], p.policy); }],
    ]);
    var tuple2Resolvable = hof_1.pattern([
        [hof_1.pipe(hof_1.prop("val"), predicates_1.isString), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.identity, [tuple.val], tuple.policy); }],
        [hof_1.pipe(hof_1.prop("val"), predicates_1.isArray), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); }],
        [hof_1.pipe(hof_1.prop("val"), predicates_1.isFunction), function (tuple) { return new resolvable_1.Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); }],
    ]);
    var item2Resolvable = hof_1.pattern([
        [hof_1.is(resolvable_1.Resolvable), function (r) { return r; }],
        [isResolveLiteral, literal2Resolvable],
        [isLikeNg2Provider, literal2Resolvable],
        [isTupleFromObj, tuple2Resolvable],
        [hof_1.val(true), function (obj) { throw new Error("Invalid resolve value: " + strings_1.stringify(obj)); }]
    ]);
    // If resolveBlock is already an array, use it as-is.
    // Otherwise, assume it's an object and convert to an Array of tuples
    var decl = state.resolve;
    var items = predicates_1.isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});
    return items.map(item2Resolvable);
}
exports.resolvablesBuilder = resolvablesBuilder;
/**
 * @internalapi A internal global service
 *
 * StateBuilder is a factory for the internal [[StateObject]] objects.
 *
 * When you register a state with the [[StateRegistry]], you register a plain old javascript object which
 * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding
 * [[StateObject]] object, which has an API and is used internally.
 *
 * Custom properties or API may be added to the internal [[StateObject]] object by registering a decorator function
 * using the [[builder]] method.
 */
var StateBuilder = /** @class */ (function () {
    function StateBuilder(matcher, urlMatcherFactory) {
        this.matcher = matcher;
        var self = this;
        var root = function () { return matcher.find(""); };
        var isRoot = function (state) { return state.name === ""; };
        function parentBuilder(state) {
            if (isRoot(state))
                return null;
            return matcher.find(self.parentName(state)) || root();
        }
        this.builders = {
            name: [nameBuilder],
            self: [selfBuilder],
            parent: [parentBuilder],
            data: [dataBuilder],
            // Build a URLMatcher if necessary, either via a relative or absolute URL
            url: [getUrlBuilder(urlMatcherFactory, root)],
            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
            navigable: [getNavigableBuilder(isRoot)],
            params: [getParamsBuilder(urlMatcherFactory.paramFactory)],
            // Each framework-specific ui-router implementation should define its own `views` builder
            // e.g., src/ng1/statebuilders/views.ts
            views: [],
            // Keep a full path from the root down to this state as this is needed for state activation.
            path: [pathBuilder],
            // Speed up $state.includes() as it's used a lot
            includes: [includesBuilder],
            resolvables: [resolvablesBuilder]
        };
    }
    /**
     * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).
     * More than one BuilderFunction can be registered for a given property.
     *
     * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.
     *
     * @param name The name of the State property being registered for.
     * @param fn The BuilderFunction which will be used to build the State property
     * @returns a function which deregisters the BuilderFunction
     */
    StateBuilder.prototype.builder = function (name, fn) {
        var builders = this.builders;
        var array = builders[name] || [];
        // Backwards compat: if only one builder exists, return it, else return whole arary.
        if (predicates_1.isString(name) && !predicates_1.isDefined(fn))
            return array.length > 1 ? array : array[0];
        if (!predicates_1.isString(name) || !predicates_1.isFunction(fn))
            return;
        builders[name] = array;
        builders[name].push(fn);
        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };
    };
    /**
     * Builds all of the properties on an essentially blank State object, returning a State object which has all its
     * properties and API built.
     *
     * @param state an uninitialized State object
     * @returns the built State object
     */
    StateBuilder.prototype.build = function (state) {
        var _a = this, matcher = _a.matcher, builders = _a.builders;
        var parent = this.parentName(state);
        if (parent && !matcher.find(parent, undefined, false)) {
            return null;
        }
        for (var key in builders) {
            if (!builders.hasOwnProperty(key))
                continue;
            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, common_1.noop);
            state[key] = chain(state);
        }
        return state;
    };
    StateBuilder.prototype.parentName = function (state) {
        // name = 'foo.bar.baz.**'
        var name = state.name || "";
        // segments = ['foo', 'bar', 'baz', '.**']
        var segments = name.split('.');
        // segments = ['foo', 'bar', 'baz']
        var lastSegment = segments.pop();
        // segments = ['foo', 'bar'] (ignore .** segment for future states)
        if (lastSegment === '**')
            segments.pop();
        if (segments.length) {
            if (state.parent) {
                throw new Error("States that specify the 'parent:' property should not have a '.' in their name (" + name + ")");
            }
            // 'foo.bar'
            return segments.join(".");
        }
        if (!state.parent)
            return "";
        return predicates_1.isString(state.parent) ? state.parent : state.parent.name;
    };
    StateBuilder.prototype.name = function (state) {
        var name = state.name;
        if (name.indexOf('.') !== -1 || !state.parent)
            return name;
        var parentName = predicates_1.isString(state.parent) ? state.parent : state.parent.name;
        return parentName ? parentName + "." + name : name;
    };
    return StateBuilder;
}());
exports.StateBuilder = StateBuilder;
//# sourceMappingURL=stateBuilder.js.map

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module state */ /** for typedoc */
var predicates_1 = __webpack_require__(1);
var common_1 = __webpack_require__(0);
var StateMatcher = /** @class */ (function () {
    function StateMatcher(_states) {
        this._states = _states;
    }
    StateMatcher.prototype.isRelative = function (stateName) {
        stateName = stateName || "";
        return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
    };
    StateMatcher.prototype.find = function (stateOrName, base, matchGlob) {
        if (matchGlob === void 0) { matchGlob = true; }
        if (!stateOrName && stateOrName !== "")
            return undefined;
        var isStr = predicates_1.isString(stateOrName);
        var name = isStr ? stateOrName : stateOrName.name;
        if (this.isRelative(name))
            name = this.resolvePath(name, base);
        var state = this._states[name];
        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
            return state;
        }
        else if (isStr && matchGlob) {
            var _states = common_1.values(this._states);
            var matches = _states.filter(function (state) {
                return state.__stateObjectCache.nameGlob &&
                    state.__stateObjectCache.nameGlob.matches(name);
            });
            if (matches.length > 1) {
                console.log("stateMatcher.find: Found multiple matches for " + name + " using glob: ", matches.map(function (match) { return match.name; }));
            }
            return matches[0];
        }
        return undefined;
    };
    StateMatcher.prototype.resolvePath = function (name, base) {
        if (!base)
            throw new Error("No reference point given for path '" + name + "'");
        var baseState = this.find(base);
        var splitName = name.split("."), i = 0, pathLength = splitName.length, current = baseState;
        for (; i < pathLength; i++) {
            if (splitName[i] === "" && i === 0) {
                current = baseState;
                continue;
            }
            if (splitName[i] === "^") {
                if (!current.parent)
                    throw new Error("Path '" + name + "' not valid for state '" + baseState.name + "'");
                current = current.parent;
                continue;
            }
            break;
        }
        var relName = splitName.slice(i).join(".");
        return current.name + (current.name && relName ? "." : "") + relName;
    };
    return StateMatcher;
}());
exports.StateMatcher = StateMatcher;
//# sourceMappingURL=stateMatcher.js.map

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module state */ /** for typedoc */
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var stateObject_1 = __webpack_require__(26);
var hof_1 = __webpack_require__(2);
/** @internalapi */
var StateQueueManager = /** @class */ (function () {
    function StateQueueManager($registry, $urlRouter, states, builder, listeners) {
        this.$registry = $registry;
        this.$urlRouter = $urlRouter;
        this.states = states;
        this.builder = builder;
        this.listeners = listeners;
        this.queue = [];
        this.matcher = $registry.matcher;
    }
    /** @internalapi */
    StateQueueManager.prototype.dispose = function () {
        this.queue = [];
    };
    StateQueueManager.prototype.register = function (stateDecl) {
        var queue = this.queue;
        var state = stateObject_1.StateObject.create(stateDecl);
        var name = state.name;
        if (!predicates_1.isString(name))
            throw new Error("State must have a valid name");
        if (this.states.hasOwnProperty(name) || common_1.inArray(queue.map(hof_1.prop('name')), name))
            throw new Error("State '" + name + "' is already defined");
        queue.push(state);
        this.flush();
        return state;
    };
    StateQueueManager.prototype.flush = function () {
        var _this = this;
        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;
        var registered = [], // states that got registered
        orphans = [], // states that don't yet have a parent registered
        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered
        var getState = function (name) {
            return _this.states.hasOwnProperty(name) && _this.states[name];
        };
        while (queue.length > 0) {
            var state = queue.shift();
            var name_1 = state.name;
            var result = builder.build(state);
            var orphanIdx = orphans.indexOf(state);
            if (result) {
                var existingState = getState(name_1);
                if (existingState && existingState.name === name_1) {
                    throw new Error("State '" + name_1 + "' is already defined");
                }
                var existingFutureState = getState(name_1 + ".**");
                if (existingFutureState) {
                    // Remove future state of the same name
                    this.$registry.deregister(existingFutureState);
                }
                states[name_1] = state;
                this.attachRoute(state);
                if (orphanIdx >= 0)
                    orphans.splice(orphanIdx, 1);
                registered.push(state);
                continue;
            }
            var prev = previousQueueLength[name_1];
            previousQueueLength[name_1] = queue.length;
            if (orphanIdx >= 0 && prev === queue.length) {
                // Wait until two consecutive iterations where no additional states were dequeued successfully.
                // throw new Error(`Cannot register orphaned state '${name}'`);
                queue.push(state);
                return states;
            }
            else if (orphanIdx < 0) {
                orphans.push(state);
            }
            queue.push(state);
        }
        if (registered.length) {
            this.listeners.forEach(function (listener) { return listener("registered", registered.map(function (s) { return s.self; })); });
        }
        return states;
    };
    StateQueueManager.prototype.attachRoute = function (state) {
        if (state.abstract || !state.url)
            return;
        this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));
    };
    return StateQueueManager;
}());
exports.StateQueueManager = StateQueueManager;
//# sourceMappingURL=stateQueueManager.js.map

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @coreapi
 * @module state
 */ /** for typedoc */
Object.defineProperty(exports, "__esModule", { value: true });
var stateMatcher_1 = __webpack_require__(44);
var stateBuilder_1 = __webpack_require__(43);
var stateQueueManager_1 = __webpack_require__(45);
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var StateRegistry = /** @class */ (function () {
    /** @internalapi */
    function StateRegistry(_router) {
        this._router = _router;
        this.states = {};
        this.listeners = [];
        this.matcher = new stateMatcher_1.StateMatcher(this.states);
        this.builder = new stateBuilder_1.StateBuilder(this.matcher, _router.urlMatcherFactory);
        this.stateQueue = new stateQueueManager_1.StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);
        this._registerRoot();
    }
    /** @internalapi */
    StateRegistry.prototype._registerRoot = function () {
        var rootStateDef = {
            name: '',
            url: '^',
            views: null,
            params: {
                '#': { value: null, type: 'hash', dynamic: true }
            },
            abstract: true
        };
        var _root = this._root = this.stateQueue.register(rootStateDef);
        _root.navigable = null;
    };
    /** @internalapi */
    StateRegistry.prototype.dispose = function () {
        var _this = this;
        this.stateQueue.dispose();
        this.listeners = [];
        this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });
    };
    /**
     * Listen for a State Registry events
     *
     * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.
     *
     * #### Example:
     * ```js
     * let allStates = registry.get();
     *
     * // Later, invoke deregisterFn() to remove the listener
     * let deregisterFn = registry.onStatesChanged((event, states) => {
     *   switch(event) {
     *     case: 'registered':
     *       states.forEach(state => allStates.push(state));
     *       break;
     *     case: 'deregistered':
     *       states.forEach(state => {
     *         let idx = allStates.indexOf(state);
     *         if (idx !== -1) allStates.splice(idx, 1);
     *       });
     *       break;
     *   }
     * });
     * ```
     *
     * @param listener a callback function invoked when the registered states changes.
     *        The function receives two parameters, `event` and `state`.
     *        See [[StateRegistryListener]]
     * @return a function that deregisters the listener
     */
    StateRegistry.prototype.onStatesChanged = function (listener) {
        this.listeners.push(listener);
        return function deregisterListener() {
            common_1.removeFrom(this.listeners)(listener);
        }.bind(this);
    };
    /**
     * Gets the implicit root state
     *
     * Gets the root of the state tree.
     * The root state is implicitly created by UI-Router.
     * Note: this returns the internal [[StateObject]] representation, not a [[StateDeclaration]]
     *
     * @return the root [[StateObject]]
     */
    StateRegistry.prototype.root = function () {
        return this._root;
    };
    /**
     * Adds a state to the registry
     *
     * Registers a [[StateDeclaration]] or queues it for registration.
     *
     * Note: a state will be queued if the state's parent isn't yet registered.
     *
     * @param stateDefinition the definition of the state to register.
     * @returns the internal [[StateObject]] object.
     *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).
     *          If the state was only queued, then the object is not fully built.
     */
    StateRegistry.prototype.register = function (stateDefinition) {
        return this.stateQueue.register(stateDefinition);
    };
    /** @hidden */
    StateRegistry.prototype._deregisterTree = function (state) {
        var _this = this;
        var all = this.get().map(function (s) { return s.$$state(); });
        var getChildren = function (states) {
            var children = all.filter(function (s) { return states.indexOf(s.parent) !== -1; });
            return children.length === 0 ? children : children.concat(getChildren(children));
        };
        var children = getChildren([state]);
        var deregistered = [state].concat(children).reverse();
        deregistered.forEach(function (state) {
            var $ur = _this._router.urlRouter;
            // Remove URL rule
            $ur.rules().filter(hof_1.propEq("state", state)).forEach($ur.removeRule.bind($ur));
            // Remove state from registry
            delete _this.states[state.name];
        });
        return deregistered;
    };
    /**
     * Removes a state from the registry
     *
     * This removes a state from the registry.
     * If the state has children, they are are also removed from the registry.
     *
     * @param stateOrName the state's name or object representation
     * @returns {StateObject[]} a list of removed states
     */
    StateRegistry.prototype.deregister = function (stateOrName) {
        var _state = this.get(stateOrName);
        if (!_state)
            throw new Error("Can't deregister state; not found: " + stateOrName);
        var deregisteredStates = this._deregisterTree(_state.$$state());
        this.listeners.forEach(function (listener) { return listener("deregistered", deregisteredStates.map(function (s) { return s.self; })); });
        return deregisteredStates;
    };
    StateRegistry.prototype.get = function (stateOrName, base) {
        var _this = this;
        if (arguments.length === 0)
            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });
        var found = this.matcher.find(stateOrName, base);
        return found && found.self || null;
    };
    StateRegistry.prototype.decorator = function (name, func) {
        return this.builder.builder(name, func);
    };
    return StateRegistry;
}());
exports.StateRegistry = StateRegistry;
//# sourceMappingURL=stateRegistry.js.map

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module state
 */
/** */
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var queue_1 = __webpack_require__(27);
var coreservices_1 = __webpack_require__(5);
var pathFactory_1 = __webpack_require__(20);
var pathNode_1 = __webpack_require__(29);
var transitionService_1 = __webpack_require__(31);
var rejectFactory_1 = __webpack_require__(14);
var targetState_1 = __webpack_require__(12);
var param_1 = __webpack_require__(13);
var glob_1 = __webpack_require__(18);
var resolveContext_1 = __webpack_require__(21);
var lazyLoad_1 = __webpack_require__(55);
var hof_1 = __webpack_require__(2);
/**
 * Provides state related service functions
 *
 * This class provides services related to ui-router states.
 * An instance of this class is located on the global [[UIRouter]] object.
 */
var StateService = /** @class */ (function () {
    /** @internalapi */
    function StateService(router) {
        this.router = router;
        /** @internalapi */
        this.invalidCallbacks = [];
        /** @hidden */
        this._defaultErrorHandler = function $defaultErrorHandler($error$) {
            if ($error$ instanceof Error && $error$.stack) {
                console.error($error$);
                console.error($error$.stack);
            }
            else if ($error$ instanceof rejectFactory_1.Rejection) {
                console.error($error$.toString());
                if ($error$.detail && $error$.detail.stack)
                    console.error($error$.detail.stack);
            }
            else {
                console.error($error$);
            }
        };
        var getters = ['current', '$current', 'params', 'transition'];
        var boundFns = Object.keys(StateService.prototype).filter(hof_1.not(common_1.inArray(getters)));
        common_1.createProxyFunctions(hof_1.val(StateService.prototype), this, hof_1.val(this), boundFns);
    }
    Object.defineProperty(StateService.prototype, "transition", {
        /**
         * The [[Transition]] currently in progress (or null)
         *
         * This is a passthrough through to [[UIRouterGlobals.transition]]
         */
        get: function () { return this.router.globals.transition; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateService.prototype, "params", {
        /**
         * The latest successful state parameters
         *
         * This is a passthrough through to [[UIRouterGlobals.params]]
         */
        get: function () { return this.router.globals.params; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateService.prototype, "current", {
        /**
         * The current [[StateDeclaration]]
         *
         * This is a passthrough through to [[UIRouterGlobals.current]]
         */
        get: function () { return this.router.globals.current; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateService.prototype, "$current", {
        /**
         * The current [[StateObject]]
         *
         * This is a passthrough through to [[UIRouterGlobals.$current]]
         */
        get: function () { return this.router.globals.$current; },
        enumerable: true,
        configurable: true
    });
    /** @internalapi */
    StateService.prototype.dispose = function () {
        this.defaultErrorHandler(common_1.noop);
        this.invalidCallbacks = [];
    };
    /**
     * Handler for when [[transitionTo]] is called with an invalid state.
     *
     * Invokes the [[onInvalid]] callbacks, in natural order.
     * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.
     * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.
     *
     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.
     *
     * @internalapi
     */
    StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {
        var _this = this;
        var fromState = pathFactory_1.PathUtils.makeTargetState(this.router.stateRegistry, fromPath);
        var globals = this.router.globals;
        var latestThing = function () { return globals.transitionHistory.peekTail(); };
        var latest = latestThing();
        var callbackQueue = new queue_1.Queue(this.invalidCallbacks.slice());
        var injector = new resolveContext_1.ResolveContext(fromPath).injector();
        var checkForRedirect = function (result) {
            if (!(result instanceof targetState_1.TargetState)) {
                return;
            }
            var target = result;
            // Recreate the TargetState, in case the state is now defined.
            target = _this.target(target.identifier(), target.params(), target.options());
            if (!target.valid()) {
                return rejectFactory_1.Rejection.invalid(target.error()).toPromise();
            }
            if (latestThing() !== latest) {
                return rejectFactory_1.Rejection.superseded().toPromise();
            }
            return _this.transitionTo(target.identifier(), target.params(), target.options());
        };
        function invokeNextCallback() {
            var nextCallback = callbackQueue.dequeue();
            if (nextCallback === undefined)
                return rejectFactory_1.Rejection.invalid(toState.error()).toPromise();
            var callbackResult = coreservices_1.services.$q.when(nextCallback(toState, fromState, injector));
            return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });
        }
        return invokeNextCallback();
    };
    /**
     * Registers an Invalid State handler
     *
     * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]
     * has been called with an invalid state reference parameter
     *
     * Example:
     * ```js
     * stateService.onInvalid(function(to, from, injector) {
     *   if (to.name() === 'foo') {
     *     let lazyLoader = injector.get('LazyLoadService');
     *     return lazyLoader.load('foo')
     *         .then(() => stateService.target('foo'));
     *   }
     * });
     * ```
     *
     * @param {function} callback invoked when the toState is invalid
     *   This function receives the (invalid) toState, the fromState, and an injector.
     *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.
     *   If one is returned, it is treated as a redirect.
     *
     * @returns a function which deregisters the callback
     */
    StateService.prototype.onInvalid = function (callback) {
        this.invalidCallbacks.push(callback);
        return function deregisterListener() {
            common_1.removeFrom(this.invalidCallbacks)(callback);
        }.bind(this);
    };
    /**
     * Reloads the current state
     *
     * A method that force reloads the current state, or a partial state hierarchy.
     * All resolves are re-resolved, and components reinstantiated.
     *
     * #### Example:
     * ```js
     * let app angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.reload = function(){
     *     $state.reload();
     *   }
     * });
     * ```
     *
     * Note: `reload()` is just an alias for:
     *
     * ```js
     * $state.transitionTo($state.current, $state.params, {
     *   reload: true, inherit: false
     * });
     * ```
     *
     * @param reloadState A state name or a state object.
     *    If present, this state and all its children will be reloaded, but ancestors will not reload.
     *
     * #### Example:
     * ```js
     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'
     * //and current state is 'contacts.detail.item'
     * let app angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.reload = function(){
     *     //will reload 'contact.detail' and nested 'contact.detail.item' states
     *     $state.reload('contact.detail');
     *   }
     * });
     * ```
     *
     * @returns A promise representing the state of the new transition. See [[StateService.go]]
     */
    StateService.prototype.reload = function (reloadState) {
        return this.transitionTo(this.current, this.params, {
            reload: predicates_1.isDefined(reloadState) ? reloadState : true,
            inherit: false,
            notify: false,
        });
    };
    ;
    /**
     * Transition to a different state and/or parameters
     *
     * Convenience method for transitioning to a new state.
     *
     * `$state.go` calls `$state.transitionTo` internally but automatically sets options to
     * `{ location: true, inherit: true, relative: router.globals.$current, notify: true }`.
     * This allows you to use either an absolute or relative `to` argument (because of `relative: router.globals.$current`).
     * It also allows you to specify * only the parameters you'd like to update, while letting unspecified parameters
     * inherit from the current parameter values (because of `inherit: true`).
     *
     * #### Example:
     * ```js
     * let app = angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.go('contact.detail');
     *   };
     * });
     * ```
     *
     * @param to Absolute state name, state object, or relative state path (relative to current state).
     *
     * Some examples:
     *
     * - `$state.go('contact.detail')` - will go to the `contact.detail` state
     * - `$state.go('^')` - will go to the parent state
     * - `$state.go('^.sibling')` - if current state is `home.child`, will go to the `home.sibling` state
     * - `$state.go('.child.grandchild')` - if current state is home, will go to the `home.child.grandchild` state
     *
     * @param params A map of the parameters that will be sent to the state, will populate $stateParams.
     *
     *    Any parameters that are not specified will be inherited from current parameter values (because of `inherit: true`).
     *    This allows, for example, going to a sibling state that shares parameters defined by a parent state.
     *
     * @param options Transition options
     *
     * @returns {promise} A promise representing the state of the new transition.
     */
    StateService.prototype.go = function (to, params, options) {
        var defautGoOpts = { relative: this.$current, inherit: true };
        var transOpts = common_1.defaults(options, defautGoOpts, transitionService_1.defaultTransOpts);
        return this.transitionTo(to, params, transOpts);
    };
    ;
    /**
     * Creates a [[TargetState]]
     *
     * This is a factory method for creating a TargetState
     *
     * This may be returned from a Transition Hook to redirect a transition, for example.
     */
    StateService.prototype.target = function (identifier, params, options) {
        if (options === void 0) { options = {}; }
        // If we're reloading, find the state object to reload from
        if (predicates_1.isObject(options.reload) && !options.reload.name)
            throw new Error('Invalid reload state object');
        var reg = this.router.stateRegistry;
        options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);
        if (options.reload && !options.reloadState)
            throw new Error("No such reload state '" + (predicates_1.isString(options.reload) ? options.reload : options.reload.name) + "'");
        return new targetState_1.TargetState(this.router.stateRegistry, identifier, params, options);
    };
    ;
    StateService.prototype.getCurrentPath = function () {
        var _this = this;
        var globals = this.router.globals;
        var latestSuccess = globals.successfulTransitions.peekTail();
        var rootPath = function () { return [new pathNode_1.PathNode(_this.router.stateRegistry.root())]; };
        return latestSuccess ? latestSuccess.treeChanges().to : rootPath();
    };
    /**
     * Low-level method for transitioning to a new state.
     *
     * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.
     *
     * #### Example:
     * ```js
     * let app = angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.transitionTo('contact.detail');
     *   };
     * });
     * ```
     *
     * @param to State name or state object.
     * @param toParams A map of the parameters that will be sent to the state,
     *      will populate $stateParams.
     * @param options Transition options
     *
     * @returns A promise representing the state of the new transition. See [[go]]
     */
    StateService.prototype.transitionTo = function (to, toParams, options) {
        var _this = this;
        if (toParams === void 0) { toParams = {}; }
        if (options === void 0) { options = {}; }
        var router = this.router;
        var globals = router.globals;
        options = common_1.defaults(options, transitionService_1.defaultTransOpts);
        var getCurrent = function () {
            return globals.transition;
        };
        options = common_1.extend(options, { current: getCurrent });
        var ref = this.target(to, toParams, options);
        var currentPath = this.getCurrentPath();
        if (!ref.exists())
            return this._handleInvalidTargetState(currentPath, ref);
        if (!ref.valid())
            return common_1.silentRejection(ref.error());
        /**
         * Special handling for Ignored, Aborted, and Redirected transitions
         *
         * The semantics for the transition.run() promise and the StateService.transitionTo()
         * promise differ. For instance, the run() promise may be rejected because it was
         * IGNORED, but the transitionTo() promise is resolved because from the user perspective
         * no error occurred.  Likewise, the transition.run() promise may be rejected because of
         * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.
         */
        var rejectedTransitionHandler = function (transition) { return function (error) {
            if (error instanceof rejectFactory_1.Rejection) {
                var isLatest = router.globals.lastStartedTransitionId === transition.$id;
                if (error.type === rejectFactory_1.RejectType.IGNORED) {
                    isLatest && router.urlRouter.update();
                    // Consider ignored `Transition.run()` as a successful `transitionTo`
                    return coreservices_1.services.$q.when(globals.current);
                }
                var detail = error.detail;
                if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && detail instanceof targetState_1.TargetState) {
                    // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully
                    // by returning the promise for the new (redirect) `Transition.run()`.
                    var redirect = transition.redirect(detail);
                    return redirect.run().catch(rejectedTransitionHandler(redirect));
                }
                if (error.type === rejectFactory_1.RejectType.ABORTED) {
                    isLatest && router.urlRouter.update();
                    return coreservices_1.services.$q.reject(error);
                }
            }
            var errorHandler = _this.defaultErrorHandler();
            errorHandler(error);
            return coreservices_1.services.$q.reject(error);
        }; };
        var transition = this.router.transitionService.create(currentPath, ref);
        var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));
        common_1.silenceUncaughtInPromise(transitionToPromise); // issue #2676
        // Return a promise for the transition, which also has the transition object on it.
        return common_1.extend(transitionToPromise, { transition: transition });
    };
    ;
    /**
     * Checks if the current state *is* the provided state
     *
     * Similar to [[includes]] but only checks for the full state name.
     * If params is supplied then it will be tested for strict equality against the current
     * active params object, so all params must match with none missing and no extras.
     *
     * #### Example:
     * ```js
     * $state.$current.name = 'contacts.details.item';
     *
     * // absolute name
     * $state.is('contact.details.item'); // returns true
     * $state.is(contactDetailItemStateObject); // returns true
     * ```
     *
     * // relative name (. and ^), typically from a template
     * // E.g. from the 'contacts.details' template
     * ```html
     * <div ng-class="{highlighted: $state.is('.item')}">Item</div>
     * ```
     *
     * @param stateOrName The state name (absolute or relative) or state object you'd like to check.
     * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like
     * to test against the current active state.
     * @param options An options object. The options are:
     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will
     *     test relative to `options.relative` state (or name).
     *
     * @returns Returns true if it is the state.
     */
    StateService.prototype.is = function (stateOrName, params, options) {
        options = common_1.defaults(options, { relative: this.$current });
        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);
        if (!predicates_1.isDefined(state))
            return undefined;
        if (this.$current !== state)
            return false;
        if (!params)
            return true;
        var schema = state.parameters({ inherit: true, matchingKeys: params });
        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);
    };
    ;
    /**
     * Checks if the current state *includes* the provided state
     *
     * A method to determine if the current active state is equal to or is the child of the
     * state stateName. If any params are passed then they will be tested for a match as well.
     * Not all the parameters need to be passed, just the ones you'd like to test for equality.
     *
     * #### Example when `$state.$current.name === 'contacts.details.item'`
     * ```js
     * // Using partial names
     * $state.includes("contacts"); // returns true
     * $state.includes("contacts.details"); // returns true
     * $state.includes("contacts.details.item"); // returns true
     * $state.includes("contacts.list"); // returns false
     * $state.includes("about"); // returns false
     * ```
     *
     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:
     * ```js
     * $state.includes("*.details.*.*"); // returns true
     * $state.includes("*.details.**"); // returns true
     * $state.includes("**.item.**"); // returns true
     * $state.includes("*.details.item.url"); // returns true
     * $state.includes("*.details.*.url"); // returns true
     * $state.includes("*.details.*"); // returns false
     * $state.includes("item.**"); // returns false
     * ```
     *
     * @param stateOrName A partial name, relative name, glob pattern,
     *   or state object to be searched for within the current state name.
     * @param params A param object, e.g. `{sectionId: section.id}`,
     *   that you'd like to test against the current active state.
     * @param options An options object. The options are:
     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will
     *     test relative to `options.relative` state (or name).
     *
     * @returns {boolean} Returns true if it does include the state
     */
    StateService.prototype.includes = function (stateOrName, params, options) {
        options = common_1.defaults(options, { relative: this.$current });
        var glob = predicates_1.isString(stateOrName) && glob_1.Glob.fromString(stateOrName);
        if (glob) {
            if (!glob.matches(this.$current.name))
                return false;
            stateOrName = this.$current.name;
        }
        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;
        if (!predicates_1.isDefined(state))
            return undefined;
        if (!predicates_1.isDefined(include[state.name]))
            return false;
        if (!params)
            return true;
        var schema = state.parameters({ inherit: true, matchingKeys: params });
        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);
    };
    ;
    /**
     * Generates a URL for a state and parameters
     *
     * Returns the url for the given state populated with the given params.
     *
     * #### Example:
     * ```js
     * expect($state.href("about.person", { person: "bob" })).toEqual("/about/bob");
     * ```
     *
     * @param stateOrName The state name or state object you'd like to generate a url from.
     * @param params An object of parameter values to fill the state's required parameters.
     * @param options Options object. The options are:
     *
     * @returns {string} compiled state url
     */
    StateService.prototype.href = function (stateOrName, params, options) {
        var defaultHrefOpts = {
            lossy: true,
            inherit: true,
            absolute: false,
            relative: this.$current,
        };
        options = common_1.defaults(options, defaultHrefOpts);
        params = params || {};
        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);
        if (!predicates_1.isDefined(state))
            return null;
        if (options.inherit)
            params = this.params.$inherit(params, this.$current, state);
        var nav = (state && options.lossy) ? state.navigable : state;
        if (!nav || nav.url === undefined || nav.url === null) {
            return null;
        }
        return this.router.urlRouter.href(nav.url, params, {
            absolute: options.absolute,
        });
    };
    ;
    /**
     * Sets or gets the default [[transitionTo]] error handler.
     *
     * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.
     * This includes errors caused by resolves and transition hooks.
     *
     * Note:
     * This handler does not receive certain Transition rejections.
     * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].
     *
     * The built-in default error handler logs the error to the console.
     *
     * You can provide your own custom handler.
     *
     * #### Example:
     * ```js
     * stateService.defaultErrorHandler(function() {
     *   // Do not log transitionTo errors
     * });
     * ```
     *
     * @param handler a global error handler function
     * @returns the current global error handler
     */
    StateService.prototype.defaultErrorHandler = function (handler) {
        return this._defaultErrorHandler = handler || this._defaultErrorHandler;
    };
    StateService.prototype.get = function (stateOrName, base) {
        var reg = this.router.stateRegistry;
        if (arguments.length === 0)
            return reg.get();
        return reg.get(stateOrName, base || this.$current);
    };
    /**
     * Lazy loads a state
     *
     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.
     *
     * @param stateOrName the state that should be lazy loaded
     * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)
     * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.
     * This noop transition is not actually run.
     *
     * @returns a promise to lazy load
     */
    StateService.prototype.lazyLoad = function (stateOrName, transition) {
        var state = this.get(stateOrName);
        if (!state || !state.lazyLoad)
            throw new Error("Can not lazy load " + stateOrName);
        var currentPath = this.getCurrentPath();
        var target = pathFactory_1.PathUtils.makeTargetState(this.router.stateRegistry, currentPath);
        transition = transition || this.router.transitionService.create(currentPath, target);
        return lazyLoad_1.lazyLoadState(transition, state);
    };
    return StateService;
}());
exports.StateService = StateService;
//# sourceMappingURL=stateService.js.map

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module core
 */ /** */
var urlMatcherFactory_1 = __webpack_require__(49);
var urlRouter_1 = __webpack_require__(50);
var transitionService_1 = __webpack_require__(31);
var view_1 = __webpack_require__(52);
var stateRegistry_1 = __webpack_require__(46);
var stateService_1 = __webpack_require__(47);
var globals_1 = __webpack_require__(53);
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var urlService_1 = __webpack_require__(54);
var trace_1 = __webpack_require__(9);
/** @hidden */
var _routerInstance = 0;
/**
 * The master class used to instantiate an instance of UI-Router.
 *
 * UI-Router (for each specific framework) will create an instance of this class during bootstrap.
 * This class instantiates and wires the UI-Router services together.
 *
 * After a new instance of the UIRouter class is created, it should be configured for your app.
 * For instance, app states should be registered with the [[UIRouter.stateRegistry]].
 *
 * ---
 *
 * Normally the framework code will bootstrap UI-Router.
 * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling
 * [[UrlService.listen]] then [[UrlService.sync]].
 */
var UIRouter = /** @class */ (function () {
    /**
     * Creates a new `UIRouter` object
     *
     * @param locationService a [[LocationServices]] implementation
     * @param locationConfig a [[LocationConfig]] implementation
     * @internalapi
     */
    function UIRouter(locationService, locationConfig) {
        if (locationService === void 0) { locationService = urlService_1.UrlService.locationServiceStub; }
        if (locationConfig === void 0) { locationConfig = urlService_1.UrlService.locationConfigStub; }
        this.locationService = locationService;
        this.locationConfig = locationConfig;
        /** @hidden */ this.$id = _routerInstance++;
        /** @hidden */ this._disposed = false;
        /** @hidden */ this._disposables = [];
        /** Provides trace information to the console */
        this.trace = trace_1.trace;
        /** Provides services related to ui-view synchronization */
        this.viewService = new view_1.ViewService();
        /** Provides services related to Transitions */
        this.transitionService = new transitionService_1.TransitionService(this);
        /** Global router state */
        this.globals = new globals_1.UIRouterGlobals();
        /**
         * Deprecated for public use. Use [[urlService]] instead.
         * @deprecated Use [[urlService]] instead
         */
        this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();
        /**
         * Deprecated for public use. Use [[urlService]] instead.
         * @deprecated Use [[urlService]] instead
         */
        this.urlRouter = new urlRouter_1.UrlRouter(this);
        /** Provides a registry for states, and related registration services */
        this.stateRegistry = new stateRegistry_1.StateRegistry(this);
        /** Provides services related to states */
        this.stateService = new stateService_1.StateService(this);
        /** Provides services related to the URL */
        this.urlService = new urlService_1.UrlService(this);
        /** @hidden */
        this._plugins = {};
        this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());
        this.globals.$current = this.stateRegistry.root();
        this.globals.current = this.globals.$current.self;
        this.disposable(this.globals);
        this.disposable(this.stateService);
        this.disposable(this.stateRegistry);
        this.disposable(this.transitionService);
        this.disposable(this.urlRouter);
        this.disposable(locationService);
        this.disposable(locationConfig);
    }
    /** Registers an object to be notified when the router is disposed */
    UIRouter.prototype.disposable = function (disposable) {
        this._disposables.push(disposable);
    };
    /**
     * Disposes this router instance
     *
     * When called, clears resources retained by the router by calling `dispose(this)` on all
     * registered [[disposable]] objects.
     *
     * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.
     *
     * @param disposable (optional) the disposable to dispose
     */
    UIRouter.prototype.dispose = function (disposable) {
        var _this = this;
        if (disposable && predicates_1.isFunction(disposable.dispose)) {
            disposable.dispose(this);
            return undefined;
        }
        this._disposed = true;
        this._disposables.slice().forEach(function (d) {
            try {
                typeof d.dispose === 'function' && d.dispose(_this);
                common_1.removeFrom(_this._disposables, d);
            }
            catch (ignored) { }
        });
    };
    /**
     * Adds a plugin to UI-Router
     *
     * This method adds a UI-Router Plugin.
     * A plugin can enhance or change UI-Router behavior using any public API.
     *
     * #### Example:
     * ```js
     * import { MyCoolPlugin } from "ui-router-cool-plugin";
     *
     * var plugin = router.addPlugin(MyCoolPlugin);
     * ```
     *
     * ### Plugin authoring
     *
     * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.
     *
     * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].
     * For example, it may configure router options or add a Transition Hook.
     *
     * The plugin can then be published as a separate module.
     *
     * #### Example:
     * ```js
     * export class MyAuthPlugin implements UIRouterPlugin {
     *   constructor(router: UIRouter, options: any) {
     *     this.name = "MyAuthPlugin";
     *     let $transitions = router.transitionService;
     *     let $state = router.stateService;
     *
     *     let authCriteria = {
     *       to: (state) => state.data && state.data.requiresAuth
     *     };
     *
     *     function authHook(transition: Transition) {
     *       let authService = transition.injector().get('AuthService');
     *       if (!authService.isAuthenticated()) {
     *         return $state.target('login');
     *       }
     *     }
     *
     *     $transitions.onStart(authCriteria, authHook);
     *   }
     * }
     * ```
     *
     * @param plugin one of:
     *        - a plugin class which implements [[UIRouterPlugin]]
     *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance
     *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance
     * @param options options to pass to the plugin class/factory
     * @returns the registered plugin instance
     */
    UIRouter.prototype.plugin = function (plugin, options) {
        if (options === void 0) { options = {}; }
        var pluginInstance = new plugin(this, options);
        if (!pluginInstance.name)
            throw new Error("Required property `name` missing on plugin: " + pluginInstance);
        this._disposables.push(pluginInstance);
        return this._plugins[pluginInstance.name] = pluginInstance;
    };
    UIRouter.prototype.getPlugin = function (pluginName) {
        return pluginName ? this._plugins[pluginName] : common_1.values(this._plugins);
    };
    return UIRouter;
}());
exports.UIRouter = UIRouter;
//# sourceMappingURL=router.js.map

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module url
 */ /** for typedoc */
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var urlMatcher_1 = __webpack_require__(22);
var param_1 = __webpack_require__(13);
var paramTypes_1 = __webpack_require__(41);
/**
 * Factory for [[UrlMatcher]] instances.
 *
 * The factory is available to ng1 services as
 * `$urlMatcherFactory` or ng1 providers as `$urlMatcherFactoryProvider`.
 */
var UrlMatcherFactory = /** @class */ (function () {
    function UrlMatcherFactory() {
        var _this = this;
        /** @hidden */ this.paramTypes = new paramTypes_1.ParamTypes();
        /** @hidden */ this._isCaseInsensitive = false;
        /** @hidden */ this._isStrictMode = true;
        /** @hidden */ this._defaultSquashPolicy = false;
        /** @hidden */
        this._getConfig = function (config) {
            return common_1.extend({ strict: _this._isStrictMode, caseInsensitive: _this._isCaseInsensitive }, config);
        };
        /** @internalapi Creates a new [[Param]] for a given location (DefType) */
        this.paramFactory = {
            /** Creates a new [[Param]] from a CONFIG block */
            fromConfig: function (id, type, config) {
                return new param_1.Param(id, type, config, param_1.DefType.CONFIG, _this);
            },
            /** Creates a new [[Param]] from a url PATH */
            fromPath: function (id, type, config) {
                return new param_1.Param(id, type, config, param_1.DefType.PATH, _this);
            },
            /** Creates a new [[Param]] from a url SEARCH */
            fromSearch: function (id, type, config) {
                return new param_1.Param(id, type, config, param_1.DefType.SEARCH, _this);
            },
        };
        common_1.extend(this, { UrlMatcher: urlMatcher_1.UrlMatcher, Param: param_1.Param });
    }
    /** @inheritdoc */
    UrlMatcherFactory.prototype.caseInsensitive = function (value) {
        return this._isCaseInsensitive = predicates_1.isDefined(value) ? value : this._isCaseInsensitive;
    };
    /** @inheritdoc */
    UrlMatcherFactory.prototype.strictMode = function (value) {
        return this._isStrictMode = predicates_1.isDefined(value) ? value : this._isStrictMode;
    };
    /** @inheritdoc */
    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {
        if (predicates_1.isDefined(value) && value !== true && value !== false && !predicates_1.isString(value))
            throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
        return this._defaultSquashPolicy = predicates_1.isDefined(value) ? value : this._defaultSquashPolicy;
    };
    /**
     * Creates a [[UrlMatcher]] for the specified pattern.
     *
     * @param pattern  The URL pattern.
     * @param config  The config object hash.
     * @returns The UrlMatcher.
     */
    UrlMatcherFactory.prototype.compile = function (pattern, config) {
        return new urlMatcher_1.UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));
    };
    /**
     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.
     *
     * @param object  The object to perform the type check against.
     * @returns `true` if the object matches the `UrlMatcher` interface, by
     *          implementing all the same methods.
     */
    UrlMatcherFactory.prototype.isMatcher = function (object) {
        // TODO: typeof?
        if (!predicates_1.isObject(object))
            return false;
        var result = true;
        common_1.forEach(urlMatcher_1.UrlMatcher.prototype, function (val, name) {
            if (predicates_1.isFunction(val))
                result = result && (predicates_1.isDefined(object[name]) && predicates_1.isFunction(object[name]));
        });
        return result;
    };
    ;
    /**
     * Creates and registers a custom [[ParamType]] object
     *
     * A [[ParamType]] can be used to generate URLs with typed parameters.
     *
     * @param name  The type name.
     * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.
     * @param definitionFn A function that is injected before the app runtime starts.
     *        The result of this function should be a [[ParamTypeDefinition]].
     *        The result is merged into the existing `definition`.
     *        See [[ParamType]] for information on the values accepted.
     *
     * @returns - if a type was registered: the [[UrlMatcherFactory]]
     *   - if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined
     *
     * Note: Register custom types *before using them* in a state definition.
     *
     * See [[ParamTypeDefinition]] for examples
     */
    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {
        var type = this.paramTypes.type(name, definition, definitionFn);
        return !predicates_1.isDefined(definition) ? type : this;
    };
    ;
    /** @hidden */
    UrlMatcherFactory.prototype.$get = function () {
        this.paramTypes.enqueue = false;
        this.paramTypes._flushTypeQueue();
        return this;
    };
    ;
    /** @internalapi */
    UrlMatcherFactory.prototype.dispose = function () {
        this.paramTypes.dispose();
    };
    return UrlMatcherFactory;
}());
exports.UrlMatcherFactory = UrlMatcherFactory;
//# sourceMappingURL=urlMatcherFactory.js.map

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module url
 */
/** for typedoc */
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var urlMatcher_1 = __webpack_require__(22);
var hof_1 = __webpack_require__(2);
var urlRule_1 = __webpack_require__(51);
var targetState_1 = __webpack_require__(12);
var common_2 = __webpack_require__(7);
/** @hidden */
function appendBasePath(url, isHtml5, absolute, baseHref) {
    if (baseHref === '/')
        return url;
    if (isHtml5)
        return common_2.stripFile(baseHref) + url;
    if (absolute)
        return baseHref.slice(1) + url;
    return url;
}
/** @hidden */
var prioritySort = function (a, b) {
    return (b.priority || 0) - (a.priority || 0);
};
/** @hidden */
var typeSort = function (a, b) {
    var weights = { "STATE": 4, "URLMATCHER": 4, "REGEXP": 3, "RAW": 2, "OTHER": 1 };
    return (weights[a.type] || 0) - (weights[b.type] || 0);
};
/** @hidden */
var urlMatcherSort = function (a, b) {
    return !a.urlMatcher || !b.urlMatcher ? 0 : urlMatcher_1.UrlMatcher.compare(a.urlMatcher, b.urlMatcher);
};
/** @hidden */
var idSort = function (a, b) {
    // Identically sorted STATE and URLMATCHER best rule will be chosen by `matchPriority` after each rule matches the URL
    var useMatchPriority = { STATE: true, URLMATCHER: true };
    var equal = useMatchPriority[a.type] && useMatchPriority[b.type];
    return equal ? 0 : (a.$id || 0) - (b.$id || 0);
};
/**
 * Default rule priority sorting function.
 *
 * Sorts rules by:
 *
 * - Explicit priority (set rule priority using [[UrlRulesApi.when]])
 * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)
 * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.
 * - Rule registration order (for rule types other than STATE and URLMATCHER)
 *   - Equally sorted State and UrlMatcher rules will each match the URL.
 *     Then, the *best* match is chosen based on how many parameter values were matched.
 *
 * @coreapi
 */
var defaultRuleSortFn;
defaultRuleSortFn = function (a, b) {
    var cmp = prioritySort(a, b);
    if (cmp !== 0)
        return cmp;
    cmp = typeSort(a, b);
    if (cmp !== 0)
        return cmp;
    cmp = urlMatcherSort(a, b);
    if (cmp !== 0)
        return cmp;
    return idSort(a, b);
};
/**
 * Updates URL and responds to URL changes
 *
 * ### Deprecation warning:
 * This class is now considered to be an internal API
 * Use the [[UrlService]] instead.
 * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].
 *
 * This class updates the URL when the state changes.
 * It also responds to changes in the URL.
 */
var UrlRouter = /** @class */ (function () {
    /** @hidden */
    function UrlRouter(router) {
        /** @hidden */ this._sortFn = defaultRuleSortFn;
        /** @hidden */ this._rules = [];
        /** @hidden */ this.interceptDeferred = false;
        /** @hidden */ this._id = 0;
        /** @hidden */ this._sorted = false;
        this._router = router;
        this.urlRuleFactory = new urlRule_1.UrlRuleFactory(router);
        common_1.createProxyFunctions(hof_1.val(UrlRouter.prototype), this, hof_1.val(this));
    }
    /** @internalapi */
    UrlRouter.prototype.dispose = function () {
        this.listen(false);
        this._rules = [];
        delete this._otherwiseFn;
    };
    /** @inheritdoc */
    UrlRouter.prototype.sort = function (compareFn) {
        this._rules = this.stableSort(this._rules, this._sortFn = compareFn || this._sortFn);
        this._sorted = true;
    };
    UrlRouter.prototype.ensureSorted = function () {
        this._sorted || this.sort();
    };
    UrlRouter.prototype.stableSort = function (arr, compareFn) {
        var arrOfWrapper = arr.map(function (elem, idx) { return ({ elem: elem, idx: idx }); });
        arrOfWrapper.sort(function (wrapperA, wrapperB) {
            var cmpDiff = compareFn(wrapperA.elem, wrapperB.elem);
            return cmpDiff === 0
                ? wrapperA.idx - wrapperB.idx
                : cmpDiff;
        });
        return arrOfWrapper.map(function (wrapper) { return wrapper.elem; });
    };
    /**
     * Given a URL, check all rules and return the best [[MatchResult]]
     * @param url
     * @returns {MatchResult}
     */
    UrlRouter.prototype.match = function (url) {
        var _this = this;
        this.ensureSorted();
        url = common_1.extend({ path: '', search: {}, hash: '' }, url);
        var rules = this.rules();
        if (this._otherwiseFn)
            rules.push(this._otherwiseFn);
        // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined
        var checkRule = function (rule) {
            var match = rule.match(url, _this._router);
            return match && { match: match, rule: rule, weight: rule.matchPriority(match) };
        };
        // The rules are pre-sorted.
        // - Find the first matching rule.
        // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.
        // - Choose the rule with the highest match weight.
        var best;
        for (var i = 0; i < rules.length; i++) {
            // Stop when there is a 'best' rule and the next rule sorts differently than it.
            if (best && this._sortFn(rules[i], best.rule) !== 0)
                break;
            var current = checkRule(rules[i]);
            // Pick the best MatchResult
            best = (!best || current && current.weight > best.weight) ? current : best;
        }
        return best;
    };
    /** @inheritdoc */
    UrlRouter.prototype.sync = function (evt) {
        if (evt && evt.defaultPrevented)
            return;
        var router = this._router, $url = router.urlService, $state = router.stateService;
        var url = {
            path: $url.path(), search: $url.search(), hash: $url.hash(),
        };
        var best = this.match(url);
        var applyResult = hof_1.pattern([
            [predicates_1.isString, function (newurl) { return $url.url(newurl, true); }],
            [targetState_1.TargetState.isDef, function (def) { return $state.go(def.state, def.params, def.options); }],
            [hof_1.is(targetState_1.TargetState), function (target) { return $state.go(target.state(), target.params(), target.options()); }],
        ]);
        applyResult(best && best.rule.handler(best.match, url, router));
    };
    /** @inheritdoc */
    UrlRouter.prototype.listen = function (enabled) {
        var _this = this;
        if (enabled === false) {
            this._stopFn && this._stopFn();
            delete this._stopFn;
        }
        else {
            return this._stopFn = this._stopFn || this._router.urlService.onChange(function (evt) { return _this.sync(evt); });
        }
    };
    /**
     * Internal API.
     * @internalapi
     */
    UrlRouter.prototype.update = function (read) {
        var $url = this._router.locationService;
        if (read) {
            this.location = $url.path();
            return;
        }
        if ($url.path() === this.location)
            return;
        $url.url(this.location, true);
    };
    /**
     * Internal API.
     *
     * Pushes a new location to the browser history.
     *
     * @internalapi
     * @param urlMatcher
     * @param params
     * @param options
     */
    UrlRouter.prototype.push = function (urlMatcher, params, options) {
        var replace = options && !!options.replace;
        this._router.urlService.url(urlMatcher.format(params || {}), replace);
    };
    /**
     * Builds and returns a URL with interpolated parameters
     *
     * #### Example:
     * ```js
     * matcher = $umf.compile("/about/:person");
     * params = { person: "bob" };
     * $bob = $urlRouter.href(matcher, params);
     * // $bob == "/about/bob";
     * ```
     *
     * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.
     * @param params An object of parameter values to fill the matcher's required parameters.
     * @param options Options object. The options are:
     *
     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
     *
     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`
     */
    UrlRouter.prototype.href = function (urlMatcher, params, options) {
        var url = urlMatcher.format(params);
        if (url == null)
            return null;
        options = options || { absolute: false };
        var cfg = this._router.urlService.config;
        var isHtml5 = cfg.html5Mode();
        if (!isHtml5 && url !== null) {
            url = "#" + cfg.hashPrefix() + url;
        }
        url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());
        if (!options.absolute || !url) {
            return url;
        }
        var slash = (!isHtml5 && url ? '/' : ''), port = cfg.port();
        port = (port === 80 || port === 443 ? '' : ':' + port);
        return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');
    };
    /**
     * Manually adds a URL Rule.
     *
     * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].
     * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).
     * Rules can be created using [[UrlRouter.urlRuleFactory]], or create manually as simple objects.
     *
     * A rule should have a `match` function which returns truthy if the rule matched.
     * It should also have a `handler` function which is invoked if the rule is the best match.
     *
     * @return a function that deregisters the rule
     */
    UrlRouter.prototype.rule = function (rule) {
        var _this = this;
        if (!urlRule_1.UrlRuleFactory.isUrlRule(rule))
            throw new Error("invalid rule");
        rule.$id = this._id++;
        rule.priority = rule.priority || 0;
        this._rules.push(rule);
        this._sorted = false;
        return function () { return _this.removeRule(rule); };
    };
    /** @inheritdoc */
    UrlRouter.prototype.removeRule = function (rule) {
        common_1.removeFrom(this._rules, rule);
    };
    /** @inheritdoc */
    UrlRouter.prototype.rules = function () {
        this.ensureSorted();
        return this._rules.slice();
    };
    /** @inheritdoc */
    UrlRouter.prototype.otherwise = function (handler) {
        var handlerFn = getHandlerFn(handler);
        this._otherwiseFn = this.urlRuleFactory.create(hof_1.val(true), handlerFn);
        this._sorted = false;
    };
    ;
    /** @inheritdoc */
    UrlRouter.prototype.initial = function (handler) {
        var handlerFn = getHandlerFn(handler);
        var matchFn = function (urlParts, router) {
            return router.globals.transitionHistory.size() === 0 && !!/^\/?$/.exec(urlParts.path);
        };
        this.rule(this.urlRuleFactory.create(matchFn, handlerFn));
    };
    ;
    /** @inheritdoc */
    UrlRouter.prototype.when = function (matcher, handler, options) {
        var rule = this.urlRuleFactory.create(matcher, handler);
        if (predicates_1.isDefined(options && options.priority))
            rule.priority = options.priority;
        this.rule(rule);
        return rule;
    };
    ;
    /** @inheritdoc */
    UrlRouter.prototype.deferIntercept = function (defer) {
        if (defer === undefined)
            defer = true;
        this.interceptDeferred = defer;
    };
    ;
    return UrlRouter;
}());
exports.UrlRouter = UrlRouter;
function getHandlerFn(handler) {
    if (!predicates_1.isFunction(handler) && !predicates_1.isString(handler) && !hof_1.is(targetState_1.TargetState)(handler) && !targetState_1.TargetState.isDef(handler)) {
        throw new Error("'handler' must be a string, function, TargetState, or have a state: 'newtarget' property");
    }
    return predicates_1.isFunction(handler) ? handler : hof_1.val(handler);
}
//# sourceMappingURL=urlRouter.js.map

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module url
 */ /** */
var urlMatcher_1 = __webpack_require__(22);
var predicates_1 = __webpack_require__(1);
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
/**
 * Creates a [[UrlRule]]
 *
 * Creates a [[UrlRule]] from a:
 *
 * - `string`
 * - [[UrlMatcher]]
 * - `RegExp`
 * - [[StateObject]]
 * @internalapi
 */
var UrlRuleFactory = /** @class */ (function () {
    function UrlRuleFactory(router) {
        this.router = router;
    }
    UrlRuleFactory.prototype.compile = function (str) {
        return this.router.urlMatcherFactory.compile(str);
    };
    UrlRuleFactory.prototype.create = function (what, handler) {
        var _this = this;
        var makeRule = hof_1.pattern([
            [predicates_1.isString, function (_what) { return makeRule(_this.compile(_what)); }],
            [hof_1.is(urlMatcher_1.UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],
            [predicates_1.isState, function (_what) { return _this.fromState(_what, _this.router); }],
            [hof_1.is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],
            [predicates_1.isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],
        ]);
        var rule = makeRule(what);
        if (!rule)
            throw new Error("invalid 'what' in when()");
        return rule;
    };
    /**
     * A UrlRule which matches based on a UrlMatcher
     *
     * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]
     *
     * ## Handler as a function
     *
     * If `handler` is a function, the function is invoked with:
     *
     * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])
     * - url: the current Url ([[UrlParts]])
     * - router: the router object ([[UIRouter]])
     *
     * #### Example:
     * ```js
     * var urlMatcher = $umf.compile("/foo/:fooId/:barId");
     * var rule = factory.fromUrlMatcher(urlMatcher, match => "/home/" + match.fooId + "/" + match.barId);
     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
     * var result = rule.handler(match); // '/home/123/456'
     * ```
     *
     * ## Handler as UrlMatcher
     *
     * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.
     * The `handler` UrlMatcher is formatted using the matched param from the first matcher.
     * The url is replaced with the result.
     *
     * #### Example:
     * ```js
     * var urlMatcher = $umf.compile("/foo/:fooId/:barId");
     * var handler = $umf.compile("/home/:fooId/:barId");
     * var rule = factory.fromUrlMatcher(urlMatcher, handler);
     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
     * var result = rule.handler(match); // '/home/123/456'
     * ```
     */
    UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {
        var _handler = handler;
        if (predicates_1.isString(handler))
            handler = this.router.urlMatcherFactory.compile(handler);
        if (hof_1.is(urlMatcher_1.UrlMatcher)(handler))
            _handler = function (match) { return handler.format(match); };
        function match(url) {
            var match = urlMatcher.exec(url.path, url.search, url.hash);
            return urlMatcher.validates(match) && match;
        }
        // Prioritize URLs, lowest to highest:
        // - Some optional URL parameters, but none matched
        // - No optional parameters in URL
        // - Some optional parameters, some matched
        // - Some optional parameters, all matched
        function matchPriority(params) {
            var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });
            if (!optional.length)
                return 0.000001;
            var matched = optional.filter(function (param) { return params[param.id]; });
            return matched.length / optional.length;
        }
        var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: "URLMATCHER" };
        return common_1.extend(new BaseUrlRule(match, _handler), details);
    };
    /**
     * A UrlRule which matches a state by its url
     *
     * #### Example:
     * ```js
     * var rule = factory.fromState($state.get('foo'), router);
     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
     * var result = rule.handler(match);
     * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }
     * ```
     */
    UrlRuleFactory.prototype.fromState = function (state, router) {
        /**
         * Handles match by transitioning to matched state
         *
         * First checks if the router should start a new transition.
         * A new transition is not required if the current state's URL
         * and the new URL are already identical
         */
        var handler = function (match) {
            var $state = router.stateService;
            var globals = router.globals;
            if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {
                $state.transitionTo(state, match, { inherit: true, source: "url" });
            }
        };
        var details = { state: state, type: "STATE" };
        return common_1.extend(this.fromUrlMatcher(state.url, handler), details);
    };
    /**
     * A UrlRule which matches based on a regular expression
     *
     * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.
     *
     * ## Handler as a function
     *
     * If `handler` is a function, the function is invoked with:
     *
     * - regexp match array (from `regexp`)
     * - url: the current Url ([[UrlParts]])
     * - router: the router object ([[UIRouter]])
     *
     * #### Example:
     * ```js
     * var rule = factory.fromRegExp(/^\/foo\/(bar|baz)$/, match => "/home/" + match[1])
     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]
     * var result = rule.handler(match); // '/home/bar'
     * ```
     *
     * ## Handler as string
     *
     * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.
     * The string is first interpolated using `string.replace()` style pattern.
     *
     * #### Example:
     * ```js
     * var rule = factory.fromRegExp(/^\/foo\/(bar|baz)$/, "/home/$1")
     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]
     * var result = rule.handler(match); // '/home/bar'
     * ```
     */
    UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {
        if (regexp.global || regexp.sticky)
            throw new Error("Rule RegExp must not be global or sticky");
        /**
         * If handler is a string, the url will be replaced by the string.
         * If the string has any String.replace() style variables in it (like `$2`),
         * they will be replaced by the captures from [[match]]
         */
        var redirectUrlTo = function (match) {
            // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern
            return handler.replace(/\$(\$|\d{1,2})/, function (m, what) {
                return match[what === '$' ? 0 : Number(what)];
            });
        };
        var _handler = predicates_1.isString(handler) ? redirectUrlTo : handler;
        var match = function (url) {
            return regexp.exec(url.path);
        };
        var details = { regexp: regexp, type: "REGEXP" };
        return common_1.extend(new BaseUrlRule(match, _handler), details);
    };
    UrlRuleFactory.isUrlRule = function (obj) {
        return obj && ['type', 'match', 'handler'].every(function (key) { return predicates_1.isDefined(obj[key]); });
    };
    return UrlRuleFactory;
}());
exports.UrlRuleFactory = UrlRuleFactory;
/**
 * A base rule which calls `match`
 *
 * The value from the `match` function is passed through to the `handler`.
 * @internalapi
 */
var BaseUrlRule = /** @class */ (function () {
    function BaseUrlRule(match, handler) {
        var _this = this;
        this.match = match;
        this.type = "RAW";
        this.matchPriority = function (match) { return 0 - _this.$id; };
        this.handler = handler || common_1.identity;
    }
    return BaseUrlRule;
}());
exports.BaseUrlRule = BaseUrlRule;
//# sourceMappingURL=urlRule.js.map

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module view
 */ /** for typedoc */
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var predicates_1 = __webpack_require__(1);
var trace_1 = __webpack_require__(9);
/**
 * The View service
 *
 * This service pairs existing `ui-view` components (which live in the DOM)
 * with view configs (from the state declaration objects: [[StateDeclaration.views]]).
 *
 * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].
 *   The views from exited states are deactivated via [[deactivateViewConfig]].
 *   (See: the [[registerActivateViews]] Transition Hook)
 *
 * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].
 *
 * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])
 * are configured with the matching [[ViewConfig]](s)
 *
 */
var ViewService = /** @class */ (function () {
    function ViewService() {
        var _this = this;
        this._uiViews = [];
        this._viewConfigs = [];
        this._viewConfigFactories = {};
        this._pluginapi = {
            _rootViewContext: this._rootViewContext.bind(this),
            _viewConfigFactory: this._viewConfigFactory.bind(this),
            _registeredUIViews: function () { return _this._uiViews; },
            _activeViewConfigs: function () { return _this._viewConfigs; },
        };
    }
    ViewService.prototype._rootViewContext = function (context) {
        return this._rootContext = context || this._rootContext;
    };
    ;
    ViewService.prototype._viewConfigFactory = function (viewType, factory) {
        this._viewConfigFactories[viewType] = factory;
    };
    ViewService.prototype.createViewConfig = function (path, decl) {
        var cfgFactory = this._viewConfigFactories[decl.$type];
        if (!cfgFactory)
            throw new Error("ViewService: No view config factory registered for type " + decl.$type);
        var cfgs = cfgFactory(path, decl);
        return predicates_1.isArray(cfgs) ? cfgs : [cfgs];
    };
    /**
     * Deactivates a ViewConfig.
     *
     * This function deactivates a `ViewConfig`.
     * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.
     *
     * @param viewConfig The ViewConfig view to deregister.
     */
    ViewService.prototype.deactivateViewConfig = function (viewConfig) {
        trace_1.trace.traceViewServiceEvent("<- Removing", viewConfig);
        common_1.removeFrom(this._viewConfigs, viewConfig);
    };
    ViewService.prototype.activateViewConfig = function (viewConfig) {
        trace_1.trace.traceViewServiceEvent("-> Registering", viewConfig);
        this._viewConfigs.push(viewConfig);
    };
    ViewService.prototype.sync = function () {
        var _this = this;
        var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(common_1.applyPairs, {});
        // Return a weighted depth value for a uiView.
        // The depth is the nesting depth of ui-views (based on FQN; times 10,000)
        // plus the depth of the state that is populating the uiView
        function uiViewDepth(uiView) {
            var stateDepth = function (context) {
                return context && context.parent ? stateDepth(context.parent) + 1 : 1;
            };
            return (uiView.fqn.split(".").length * 10000) + stateDepth(uiView.creationContext);
        }
        // Return the ViewConfig's context's depth in the context tree.
        function viewConfigDepth(config) {
            var context = config.viewDecl.$context, count = 0;
            while (++count && context.parent)
                context = context.parent;
            return count;
        }
        // Given a depth function, returns a compare function which can return either ascending or descending order
        var depthCompare = hof_1.curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });
        var matchingConfigPair = function (uiView) {
            var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));
            if (matchingConfigs.length > 1) {
                // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)
                // Sort by depth and return the match from the deepest child
                // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);
                matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending
            }
            return [uiView, matchingConfigs[0]];
        };
        var configureUIView = function (_a) {
            var uiView = _a[0], viewConfig = _a[1];
            // If a parent ui-view is reconfigured, it could destroy child ui-views.
            // Before configuring a child ui-view, make sure it's still in the active uiViews array.
            if (_this._uiViews.indexOf(uiView) !== -1)
                uiView.configUpdated(viewConfig);
        };
        // Sort views by FQN and state depth. Process uiviews nearest the root first.
        var pairs = this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair);
        trace_1.trace.traceViewSync(pairs);
        pairs.forEach(configureUIView);
    };
    ;
    /**
     * Registers a `ui-view` component
     *
     * When a `ui-view` component is created, it uses this method to register itself.
     * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].
     *
     * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,
     * and what the view's state context is.
     *
     * Note: There is no corresponding `deregisterUIView`.
     *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.
     *
     * @param uiView The metadata for a UIView
     * @return a de-registration function used when the view is destroyed.
     */
    ViewService.prototype.registerUIView = function (uiView) {
        trace_1.trace.traceViewServiceUIViewEvent("-> Registering", uiView);
        var uiViews = this._uiViews;
        var fqnAndTypeMatches = function (uiv) { return uiv.fqn === uiView.fqn && uiv.$type === uiView.$type; };
        if (uiViews.filter(fqnAndTypeMatches).length)
            trace_1.trace.traceViewServiceUIViewEvent("!!!! duplicate uiView named:", uiView);
        uiViews.push(uiView);
        this.sync();
        return function () {
            var idx = uiViews.indexOf(uiView);
            if (idx === -1) {
                trace_1.trace.traceViewServiceUIViewEvent("Tried removing non-registered uiView", uiView);
                return;
            }
            trace_1.trace.traceViewServiceUIViewEvent("<- Deregistering", uiView);
            common_1.removeFrom(uiViews)(uiView);
        };
    };
    ;
    /**
     * Returns the list of views currently available on the page, by fully-qualified name.
     *
     * @return {Array} Returns an array of fully-qualified view names.
     */
    ViewService.prototype.available = function () {
        return this._uiViews.map(hof_1.prop("fqn"));
    };
    /**
     * Returns the list of views on the page containing loaded content.
     *
     * @return {Array} Returns an array of fully-qualified view names.
     */
    ViewService.prototype.active = function () {
        return this._uiViews.filter(hof_1.prop("$config")).map(hof_1.prop("name"));
    };
    /**
     * Normalizes a view's name from a state.views configuration block.
     *
     * This should be used by a framework implementation to calculate the values for
     * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].
     *
     * @param context the context object (state declaration) that the view belongs to
     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]
     *
     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets
     */
    ViewService.normalizeUIViewTarget = function (context, rawViewName) {
        if (rawViewName === void 0) { rawViewName = ""; }
        // TODO: Validate incoming view name with a regexp to allow:
        // ex: "view.name@foo.bar" , "^.^.view.name" , "view.name@^.^" , "" ,
        // "@" , "$default@^" , "!$default.$default" , "!foo.bar"
        var viewAtContext = rawViewName.split("@");
        var uiViewName = viewAtContext[0] || "$default"; // default to unnamed view
        var uiViewContextAnchor = predicates_1.isString(viewAtContext[1]) ? viewAtContext[1] : "^"; // default to parent context
        // Handle relative view-name sugar syntax.
        // Matches rawViewName "^.^.^.foo.bar" into array: ["^.^.^.foo.bar", "^.^.^", "foo.bar"],
        var relativeViewNameSugar = /^(\^(?:\.\^)*)\.(.*$)/.exec(uiViewName);
        if (relativeViewNameSugar) {
            // Clobbers existing contextAnchor (rawViewName validation will fix this)
            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to "^.^.^"
            uiViewName = relativeViewNameSugar[2]; // set view-name to "foo.bar"
        }
        if (uiViewName.charAt(0) === '!') {
            uiViewName = uiViewName.substr(1);
            uiViewContextAnchor = ""; // target absolutely from root
        }
        // handle parent relative targeting "^.^.^"
        var relativeMatch = /^(\^(?:\.\^)*)$/;
        if (relativeMatch.exec(uiViewContextAnchor)) {
            var anchor = uiViewContextAnchor.split(".").reduce((function (anchor, x) { return anchor.parent; }), context);
            uiViewContextAnchor = anchor.name;
        }
        else if (uiViewContextAnchor === '.') {
            uiViewContextAnchor = context.name;
        }
        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };
    };
    /**
     * Given a ui-view and a ViewConfig, determines if they "match".
     *
     * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in
     * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.
     *
     * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or
     * can be a segmented ui-view path, describing a portion of a ui-view fqn.
     *
     * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type
     *
     * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:
     * - the ui-view's name matches the ViewConfig's target name
     * - the ui-view's context matches the ViewConfig's anchor
     *
     * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:
     * - There exists a parent ui-view where:
     *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name
     *    - the parent ui-view's context matches the ViewConfig's anchor
     * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn
     *
     * Example:
     *
     * DOM:
     * <ui-view>                        <!-- created in the root context (name: "") -->
     *   <ui-view name="foo">                <!-- created in the context named: "A"      -->
     *     <ui-view>                    <!-- created in the context named: "A.B"    -->
     *       <ui-view name="bar">            <!-- created in the context named: "A.B.C"  -->
     *       </ui-view>
     *     </ui-view>
     *   </ui-view>
     * </ui-view>
     *
     * uiViews: [
     *  { fqn: "$default",                  creationContext: { name: "" } },
     *  { fqn: "$default.foo",              creationContext: { name: "A" } },
     *  { fqn: "$default.foo.$default",     creationContext: { name: "A.B" } }
     *  { fqn: "$default.foo.$default.bar", creationContext: { name: "A.B.C" } }
     * ]
     *
     * These four view configs all match the ui-view with the fqn: "$default.foo.$default.bar":
     *
     * - ViewConfig1: { uiViewName: "bar",                       uiViewContextAnchor: "A.B.C" }
     * - ViewConfig2: { uiViewName: "$default.bar",              uiViewContextAnchor: "A.B" }
     * - ViewConfig3: { uiViewName: "foo.$default.bar",          uiViewContextAnchor: "A" }
     * - ViewConfig4: { uiViewName: "$default.foo.$default.bar", uiViewContextAnchor: "" }
     *
     * Using ViewConfig3 as an example, it matches the ui-view with fqn "$default.foo.$default.bar" because:
     * - The ViewConfig's segmented target name is: [ "foo", "$default", "bar" ]
     * - There exists a parent ui-view (which has fqn: "$default.foo") where:
     *    - the parent ui-view's name "foo" matches the first segment "foo" of the ViewConfig's target name
     *    - the parent ui-view's context "A" matches the ViewConfig's anchor context "A"
     * - And the remaining segments [ "$default", "bar" ].join("."_ of the ViewConfig's target name match
     *   the tail of the ui-view's fqn "default.bar"
     *
     * @internalapi
     */
    ViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {
        // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc
        if (uiView.$type !== viewConfig.viewDecl.$type)
            return false;
        // Split names apart from both viewConfig and uiView into segments
        var vc = viewConfig.viewDecl;
        var vcSegments = vc.$uiViewName.split(".");
        var uivSegments = uiView.fqn.split(".");
        // Check if the tails of the segment arrays match. ex, these arrays' tails match:
        // vc: ["foo", "bar"], uiv fqn: ["$default", "foo", "bar"]
        if (!common_1.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))
            return false;
        // Now check if the fqn ending at the first segment of the viewConfig matches the context:
        // ["$default", "foo"].join(".") == "$default.foo", does the ui-view $default.foo context match?
        var negOffset = (1 - vcSegments.length) || undefined;
        var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(".");
        var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;
        return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);
    }; };
    return ViewService;
}());
exports.ViewService = ViewService;
//# sourceMappingURL=view.js.map

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module core
 */ /** */
var stateParams_1 = __webpack_require__(42);
var queue_1 = __webpack_require__(27);
/**
 * Global router state
 *
 * This is where we hold the global mutable state such as current state, current
 * params, current transition, etc.
 */
var UIRouterGlobals = /** @class */ (function () {
    function UIRouterGlobals() {
        /**
         * Current parameter values
         *
         * The parameter values from the latest successful transition
         */
        this.params = new stateParams_1.StateParams();
        /** @internalapi */
        this.lastStartedTransitionId = -1;
        /** @internalapi */
        this.transitionHistory = new queue_1.Queue([], 1);
        /** @internalapi */
        this.successfulTransitions = new queue_1.Queue([], 1);
    }
    UIRouterGlobals.prototype.dispose = function () {
        this.transitionHistory.clear();
        this.successfulTransitions.clear();
        this.transition = null;
    };
    return UIRouterGlobals;
}());
exports.UIRouterGlobals = UIRouterGlobals;
//# sourceMappingURL=globals.js.map

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @coreapi
 * @module url
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
var coreservices_1 = __webpack_require__(5);
var common_1 = __webpack_require__(0);
/** @hidden */
var makeStub = function (keys) {
    return keys.reduce(function (acc, key) { return (acc[key] = coreservices_1.notImplemented(key), acc); }, { dispose: common_1.noop });
};
/** @hidden */ var locationServicesFns = ["url", "path", "search", "hash", "onChange"];
/** @hidden */ var locationConfigFns = ["port", "protocol", "host", "baseHref", "html5Mode", "hashPrefix"];
/** @hidden */ var umfFns = ["type", "caseInsensitive", "strictMode", "defaultSquashPolicy"];
/** @hidden */ var rulesFns = ["sort", "when", "initial", "otherwise", "rules", "rule", "removeRule"];
/** @hidden */ var syncFns = ["deferIntercept", "listen", "sync", "match"];
/**
 * API for URL management
 */
var UrlService = /** @class */ (function () {
    /** @hidden */
    function UrlService(router, lateBind) {
        if (lateBind === void 0) { lateBind = true; }
        this.router = router;
        this.rules = {};
        this.config = {};
        // proxy function calls from UrlService to the LocationService/LocationConfig
        var locationServices = function () { return router.locationService; };
        common_1.createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);
        var locationConfig = function () { return router.locationConfig; };
        common_1.createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);
        var umf = function () { return router.urlMatcherFactory; };
        common_1.createProxyFunctions(umf, this.config, umf, umfFns);
        var urlRouter = function () { return router.urlRouter; };
        common_1.createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);
        common_1.createProxyFunctions(urlRouter, this, urlRouter, syncFns);
    }
    UrlService.prototype.url = function (newurl, replace, state) { return; };
    ;
    /** @inheritdoc */
    UrlService.prototype.path = function () { return; };
    ;
    /** @inheritdoc */
    UrlService.prototype.search = function () { return; };
    ;
    /** @inheritdoc */
    UrlService.prototype.hash = function () { return; };
    ;
    /** @inheritdoc */
    UrlService.prototype.onChange = function (callback) { return; };
    ;
    /**
     * Returns the current URL parts
     *
     * This method returns the current URL components as a [[UrlParts]] object.
     *
     * @returns the current url parts
     */
    UrlService.prototype.parts = function () {
        return { path: this.path(), search: this.search(), hash: this.hash() };
    };
    UrlService.prototype.dispose = function () { };
    /** @inheritdoc */
    UrlService.prototype.sync = function (evt) { return; };
    /** @inheritdoc */
    UrlService.prototype.listen = function (enabled) { return; };
    ;
    /** @inheritdoc */
    UrlService.prototype.deferIntercept = function (defer) { return; };
    /** @inheritdoc */
    UrlService.prototype.match = function (urlParts) { return; };
    /** @hidden */
    UrlService.locationServiceStub = makeStub(locationServicesFns);
    /** @hidden */
    UrlService.locationConfigStub = makeStub(locationConfigFns);
    return UrlService;
}());
exports.UrlService = UrlService;
//# sourceMappingURL=urlService.js.map

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var coreservices_1 = __webpack_require__(5);
/**
 * A [[TransitionHookFn]] that performs lazy loading
 *
 * When entering a state "abc" which has a `lazyLoad` function defined:
 * - Invoke the `lazyLoad` function (unless it is already in process)
 *   - Flag the hook function as "in process"
 *   - The function should return a promise (that resolves when lazy loading is complete)
 * - Wait for the promise to settle
 *   - If the promise resolves to a [[LazyLoadResult]], then register those states
 *   - Flag the hook function as "not in process"
 * - If the hook was successful
 *   - Remove the `lazyLoad` function from the state declaration
 * - If all the hooks were successful
 *   - Retry the transition (by returning a TargetState)
 *
 * ```
 * .state('abc', {
 *   component: 'fooComponent',
 *   lazyLoad: () => System.import('./fooComponent')
 *   });
 * ```
 *
 * See [[StateDeclaration.lazyLoad]]
 */
var lazyLoadHook = function (transition) {
    var router = transition.router;
    function retryTransition() {
        if (transition.originalTransition().options().source !== 'url') {
            // The original transition was not triggered via url sync
            // The lazy state should be loaded now, so re-try the original transition
            var orig = transition.targetState();
            return router.stateService.target(orig.identifier(), orig.params(), orig.options());
        }
        // The original transition was triggered via url sync
        // Run the URL rules and find the best match
        var $url = router.urlService;
        var result = $url.match($url.parts());
        var rule = result && result.rule;
        // If the best match is a state, redirect the transition (instead
        // of calling sync() which supersedes the current transition)
        if (rule && rule.type === "STATE") {
            var state = rule.state;
            var params = result.match;
            return router.stateService.target(state, params, transition.options());
        }
        // No matching state found, so let .sync() choose the best non-state match/otherwise
        router.urlService.sync();
    }
    var promises = transition.entering()
        .filter(function (state) { return !!state.$$state().lazyLoad; })
        .map(function (state) { return lazyLoadState(transition, state); });
    return coreservices_1.services.$q.all(promises).then(retryTransition);
};
exports.registerLazyLoadHook = function (transitionService) {
    return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);
};
/**
 * Invokes a state's lazy load function
 *
 * @param transition a Transition context
 * @param state the state to lazy load
 * @returns A promise for the lazy load result
 */
function lazyLoadState(transition, state) {
    var lazyLoadFn = state.$$state().lazyLoad;
    // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked
    var promise = lazyLoadFn['_promise'];
    if (!promise) {
        var success = function (result) {
            delete state.lazyLoad;
            delete state.$$state().lazyLoad;
            delete lazyLoadFn['_promise'];
            return result;
        };
        var error = function (err) {
            delete lazyLoadFn['_promise'];
            return coreservices_1.services.$q.reject(err);
        };
        promise = lazyLoadFn['_promise'] =
            coreservices_1.services.$q.when(lazyLoadFn(transition, state))
                .then(updateStateRegistry)
                .then(success, error);
    }
    /** Register any lazy loaded state definitions */
    function updateStateRegistry(result) {
        if (result && Array.isArray(result.states)) {
            result.states.forEach(function (state) { return transition.router.stateRegistry.register(state); });
        }
        return result;
    }
    return promise;
}
exports.lazyLoadState = lazyLoadState;
//# sourceMappingURL=lazyLoad.js.map

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var transitionHook_1 = __webpack_require__(15);
/**
 * This class defines a type of hook, such as `onBefore` or `onEnter`.
 * Plugins can define custom hook types, such as sticky states does for `onInactive`.
 *
 * @interalapi
 */
var TransitionEventType = /** @class */ (function () {
    function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {
        if (reverseSort === void 0) { reverseSort = false; }
        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }
        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }
        if (synchronous === void 0) { synchronous = false; }
        this.name = name;
        this.hookPhase = hookPhase;
        this.hookOrder = hookOrder;
        this.criteriaMatchPath = criteriaMatchPath;
        this.reverseSort = reverseSort;
        this.getResultHandler = getResultHandler;
        this.getErrorHandler = getErrorHandler;
        this.synchronous = synchronous;
    }
    return TransitionEventType;
}());
exports.TransitionEventType = TransitionEventType;
//# sourceMappingURL=transitionEventType.js.map

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var index_1 = __webpack_require__(7);
/**
 * An angular1-like promise api
 *
 * This object implements four methods similar to the
 * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)
 *
 * UI-Router evolved from an angular 1 library to a framework agnostic library.
 * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.
 *
 * This API provides native ES6 promise support wrapped as a $q-like API.
 * Internally, UI-Router uses this $q object to perform promise operations.
 * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.
 *
 * $q-like promise api
 */
exports.$q = {
    /** Normalizes a value as a promise */
    when: function (val) { return new Promise(function (resolve, reject) { return resolve(val); }); },
    /** Normalizes a value as a promise rejection */
    reject: function (val) { return new Promise(function (resolve, reject) { reject(val); }); },
    /** @returns a deferred object, which has `resolve` and `reject` functions */
    defer: function () {
        var deferred = {};
        deferred.promise = new Promise(function (resolve, reject) {
            deferred.resolve = resolve;
            deferred.reject = reject;
        });
        return deferred;
    },
    /** Like Promise.all(), but also supports object key/promise notation like $q */
    all: function (promises) {
        if (index_1.isArray(promises)) {
            return Promise.all(promises);
        }
        if (index_1.isObject(promises)) {
            // Convert promises map to promises array.
            // When each promise resolves, map it to a tuple { key: key, val: val }
            var chain = Object.keys(promises)
                .map(function (key) { return promises[key].then(function (val) { return ({ key: key, val: val }); }); });
            // Then wait for all promises to resolve, and convert them back to an object
            return exports.$q.all(chain).then(function (values) {
                return values.reduce(function (acc, tuple) { acc[tuple.key] = tuple.val; return acc; }, {});
            });
        }
    }
};
//# sourceMappingURL=q.js.map

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var index_1 = __webpack_require__(7);
// globally available injectables
var globals = {};
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var ARGUMENT_NAMES = /([^\s,]+)/g;
/**
 * A basic angular1-like injector api
 *
 * This object implements four methods similar to the
 * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)
 *
 * UI-Router evolved from an angular 1 library to a framework agnostic library.
 * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.
 *
 * This object provides a naive implementation of a globally scoped dependency injection system.
 * It supports the following DI approaches:
 *
 * ### Function parameter names
 *
 * A function's `.toString()` is called, and the parameter names are parsed.
 * This only works when the parameter names aren't "mangled" by a minifier such as UglifyJS.
 *
 * ```js
 * function injectedFunction(FooService, BarService) {
 *   // FooService and BarService are injected
 * }
 * ```
 *
 * ### Function annotation
 *
 * A function may be annotated with an array of dependency names as the `$inject` property.
 *
 * ```js
 * injectedFunction.$inject = [ 'FooService', 'BarService' ];
 * function injectedFunction(fs, bs) {
 *   // FooService and BarService are injected as fs and bs parameters
 * }
 * ```
 *
 * ### Array notation
 *
 * An array provides the names of the dependencies to inject (as strings).
 * The function is the last element of the array.
 *
 * ```js
 * [ 'FooService', 'BarService', function (fs, bs) {
 *   // FooService and BarService are injected as fs and bs parameters
 * }]
 * ```
 *
 * @type {$InjectorLike}
 */
exports.$injector = {
    /** Gets an object from DI based on a string token */
    get: function (name) { return globals[name]; },
    /** Returns true if an object named `name` exists in global DI */
    has: function (name) { return exports.$injector.get(name) != null; },
    /**
     * Injects a function
     *
     * @param fn the function to inject
     * @param context the function's `this` binding
     * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`
     */
    invoke: function (fn, context, locals) {
        var all = index_1.extend({}, globals, locals || {});
        var params = exports.$injector.annotate(fn);
        var ensureExist = index_1.assertPredicate(function (key) { return all.hasOwnProperty(key); }, function (key) { return "DI can't find injectable: '" + key + "'"; });
        var args = params.filter(ensureExist).map(function (x) { return all[x]; });
        if (index_1.isFunction(fn))
            return fn.apply(context, args);
        else
            return fn.slice(-1)[0].apply(context, args);
    },
    /**
     * Returns a function's dependencies
     *
     * Analyzes a function (or array) and returns an array of DI tokens that the function requires.
     * @return an array of `string`s
     */
    annotate: function (fn) {
        if (!index_1.isInjectable(fn))
            throw new Error("Not an injectable function: " + fn);
        if (fn && fn.$inject)
            return fn.$inject;
        if (index_1.isArray(fn))
            return fn.slice(0, -1);
        var fnStr = fn.toString().replace(STRIP_COMMENTS, '');
        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
        return result || [];
    }
};
//# sourceMappingURL=injector.js.map

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var common_1 = __webpack_require__(7);
var baseLocationService_1 = __webpack_require__(23);
/** A `LocationServices` that uses the browser hash "#" to get/set the current location */
var HashLocationService = /** @class */ (function (_super) {
    __extends(HashLocationService, _super);
    function HashLocationService(router) {
        var _this = _super.call(this, router, false) || this;
        common_1.root.addEventListener('hashchange', _this._listener, false);
        return _this;
    }
    HashLocationService.prototype._get = function () {
        return common_1.trimHashVal(this._location.hash);
    };
    HashLocationService.prototype._set = function (state, title, url, replace) {
        this._location.hash = url;
    };
    HashLocationService.prototype.dispose = function (router) {
        _super.prototype.dispose.call(this, router);
        common_1.root.removeEventListener('hashchange', this._listener);
    };
    return HashLocationService;
}(baseLocationService_1.BaseLocationServices));
exports.HashLocationService = HashLocationService;
//# sourceMappingURL=hashLocationService.js.map

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var baseLocationService_1 = __webpack_require__(23);
/** A `LocationServices` that gets/sets the current location from an in-memory object */
var MemoryLocationService = /** @class */ (function (_super) {
    __extends(MemoryLocationService, _super);
    function MemoryLocationService(router) {
        return _super.call(this, router, true) || this;
    }
    MemoryLocationService.prototype._get = function () {
        return this._url;
    };
    MemoryLocationService.prototype._set = function (state, title, url, replace) {
        this._url = url;
    };
    return MemoryLocationService;
}(baseLocationService_1.BaseLocationServices));
exports.MemoryLocationService = MemoryLocationService;
//# sourceMappingURL=memoryLocationService.js.map

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var baseLocationService_1 = __webpack_require__(23);
var common_1 = __webpack_require__(7);
/**
 * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis
 *
 * Uses `history.pushState` and `history.replaceState`
 */
var PushStateLocationService = /** @class */ (function (_super) {
    __extends(PushStateLocationService, _super);
    function PushStateLocationService(router) {
        var _this = _super.call(this, router, true) || this;
        _this._config = router.urlService.config;
        common_1.root.addEventListener('popstate', _this._listener, false);
        return _this;
    }
    ;
    /**
     * Gets the base prefix without:
     * - trailing slash
     * - trailing filename
     * - protocol and hostname
     *
     * If <base href='/base/index.html'>, this returns '/base'.
     * If <base href='http://localhost:8080/base/index.html'>, this returns '/base'.
     *
     * See: https://html.spec.whatwg.org/dev/semantics.html#the-base-element
     */
    PushStateLocationService.prototype._getBasePrefix = function () {
        return common_1.stripFile(this._config.baseHref());
    };
    PushStateLocationService.prototype._get = function () {
        var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;
        search = common_1.splitQuery(search)[1]; // strip ? if found
        hash = common_1.splitHash(hash)[1]; // strip # if found
        var basePrefix = this._getBasePrefix();
        var exactMatch = pathname === this._config.baseHref();
        var startsWith = pathname.startsWith(basePrefix);
        pathname = exactMatch ? '/' : startsWith ? pathname.substring(basePrefix.length) : pathname;
        return pathname + (search ? '?' + search : '') + (hash ? '#' + hash : '');
    };
    PushStateLocationService.prototype._set = function (state, title, url, replace) {
        var fullUrl = this._getBasePrefix() + url;
        if (replace) {
            this._history.replaceState(state, title, fullUrl);
        }
        else {
            this._history.pushState(state, title, fullUrl);
        }
    };
    PushStateLocationService.prototype.dispose = function (router) {
        _super.prototype.dispose.call(this, router);
        common_1.root.removeEventListener('popstate', this._listener);
    };
    return PushStateLocationService;
}(baseLocationService_1.BaseLocationServices));
exports.PushStateLocationService = PushStateLocationService;
//# sourceMappingURL=pushStateLocationService.js.map

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var predicates_1 = __webpack_require__(1);
var common_1 = __webpack_require__(0);
/** A `LocationConfig` mock that gets/sets all config from an in-memory object */
var MemoryLocationConfig = /** @class */ (function () {
    function MemoryLocationConfig() {
        var _this = this;
        this._baseHref = '';
        this._port = 80;
        this._protocol = "http";
        this._host = "localhost";
        this._hashPrefix = "";
        this.port = function () { return _this._port; };
        this.protocol = function () { return _this._protocol; };
        this.host = function () { return _this._host; };
        this.baseHref = function () { return _this._baseHref; };
        this.html5Mode = function () { return false; };
        this.hashPrefix = function (newval) { return predicates_1.isDefined(newval) ? _this._hashPrefix = newval : _this._hashPrefix; };
        this.dispose = common_1.noop;
    }
    return MemoryLocationConfig;
}());
exports.MemoryLocationConfig = MemoryLocationConfig;
//# sourceMappingURL=memoryLocationConfig.js.map

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var predicates_1 = __webpack_require__(1);
/** A `LocationConfig` that delegates to the browser's `location` object */
var BrowserLocationConfig = /** @class */ (function () {
    function BrowserLocationConfig(router, _isHtml5) {
        if (_isHtml5 === void 0) { _isHtml5 = false; }
        this._isHtml5 = _isHtml5;
        this._baseHref = undefined;
        this._hashPrefix = "";
    }
    BrowserLocationConfig.prototype.port = function () {
        if (location.port) {
            return Number(location.port);
        }
        return this.protocol() === 'https' ? 443 : 80;
    };
    BrowserLocationConfig.prototype.protocol = function () {
        return location.protocol.replace(/:/g, '');
    };
    BrowserLocationConfig.prototype.host = function () {
        return location.hostname;
    };
    BrowserLocationConfig.prototype.html5Mode = function () {
        return this._isHtml5;
    };
    BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {
        return predicates_1.isDefined(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix;
    };
    ;
    BrowserLocationConfig.prototype.baseHref = function (href) {
        return predicates_1.isDefined(href) ? this._baseHref = href :
            predicates_1.isDefined(this._baseHref) ? this._baseHref : this.applyDocumentBaseHref();
    };
    BrowserLocationConfig.prototype.applyDocumentBaseHref = function () {
        var baseTag = document.getElementsByTagName("base")[0];
        return this._baseHref = baseTag ? baseTag.href.substr(location.origin.length) : "";
    };
    BrowserLocationConfig.prototype.dispose = function () { };
    return BrowserLocationConfig;
}());
exports.BrowserLocationConfig = BrowserLocationConfig;
//# sourceMappingURL=browserLocationConfig.js.map

/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return _UIROUTER_DIRECTIVES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return UIROUTER_DIRECTIVES; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__uiSref__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__uiSrefActive__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__uiView__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__uiSrefStatus__ = __webpack_require__(37);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_2__uiView__["a"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__uiSref__["a"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_0__uiSref__["b"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_3__uiSrefStatus__["a"]; });
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_1__uiSrefActive__["a"]; });
/**
 * The UI-Router for Angular directives:
 *
 * - [[UIView]]: A viewport for routed components
 * - [[UISref]]: A state ref to a target state; navigates when clicked
 * - [[UISrefActive]]: (and `UISrefActiveEq`) Adds a css class when a UISref's target state (or a child state) is active
 *
 * @ng2api
 * @preferred
 * @module directives
 */ /** */








/** @internalapi */
var _UIROUTER_DIRECTIVES = [__WEBPACK_IMPORTED_MODULE_0__uiSref__["b" /* UISref */], __WEBPACK_IMPORTED_MODULE_0__uiSref__["a" /* AnchorUISref */], __WEBPACK_IMPORTED_MODULE_2__uiView__["a" /* UIView */], __WEBPACK_IMPORTED_MODULE_1__uiSrefActive__["a" /* UISrefActive */], __WEBPACK_IMPORTED_MODULE_3__uiSrefStatus__["a" /* UISrefStatus */]];
/**
 * References to the UI-Router directive classes, for use within a @Component's `directives:` property
 * @deprecated use [[UIRouterModule]]
 * @internalapi
 */
var UIROUTER_DIRECTIVES = _UIROUTER_DIRECTIVES;
//# sourceMappingURL=directives.js.map

/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UISrefActive; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__uiSrefStatus__ = __webpack_require__(37);
/** @ng2api @module directives */ /** */


/**
 * A directive that adds a CSS class when its associated `uiSref` link is active.
 *
 * ### Purpose
 *
 * This directive should be paired with one (or more) [[UISref]] directives.
 * It will apply a CSS class to its element when the state the `uiSref` targets is activated.
 *
 * This can be used to create navigation UI where the active link is highlighted.
 *
 * ### Selectors
 *
 * - `[uiSrefActive]`: When this selector is used, the class is added when the target state or any
 * child of the target state is active
 * - `[uiSrefActiveEq]`: When this selector is used, the class is added when the target state is
 * exactly active (the class is not added if a child of the target state is active).
 *
 * ### Inputs
 *
 * - `uiSrefActive`/`uiSrefActiveEq`: one or more CSS classes to add to the element, when the `uiSref` is active
 *
 * #### Example:
 * The anchor tag has the `active` class added when the `foo` state is active.
 * ```html
 * <a uiSref="foo" uiSrefActive="active">Foo</a>
 * ```
 *
 * ### Matching parameters
 *
 * If the `uiSref` includes parameters, the current state must be active, *and* the parameter values must match.
 *
 * #### Example:
 * The first anchor tag has the `active` class added when the `foo.bar` state is active and the `id` parameter
 * equals 25.
 * The second anchor tag has the `active` class added when the `foo.bar` state is active and the `id` parameter
 * equals 32.
 * ```html
 * <a uiSref="foo.bar" [uiParams]="{ id: 25 }" uiSrefActive="active">Bar #25</a>
 * <a uiSref="foo.bar" [uiParams]="{ id: 32 }" uiSrefActive="active">Bar #32</a>
 * ```
 *
 * #### Example:
 * A list of anchor tags are created for a list of `bar` objects.
 * An anchor tag will have the `active` class when `foo.bar` state is active and the `id` parameter matches
 * that object's `id`.
 * ```html
 * <li *ngFor="let bar of bars">
 *   <a uiSref="foo.bar" [uiParams]="{ id: bar.id }" uiSrefActive="active">Bar #{{ bar.id }}</a>
 * </li>
 * ```
 *
 * ### Multiple uiSrefs
 *
 * A single `uiSrefActive` can be used for multiple `uiSref` links.
 * This can be used to create (for example) a drop down navigation menu, where the menui is highlighted
 * if *any* of its inner links are active.
 *
 * The `uiSrefActive` should be placed on an ancestor element of the `uiSref` list.
 * If anyof the `uiSref` links are activated, the class will be added to the ancestor element.
 *
 * #### Example:
 * This is a dropdown nagivation menu for "Admin" states.
 * When any of `admin.users`, `admin.groups`, `admin.settings` are active, the `<li>` for the dropdown
 * has the `dropdown-child-active` class applied.
 * Additionally, the active anchor tag has the `active` class applied.
 * ```html
 * <ul class="dropdown-menu">
 *   <li uiSrefActive="dropdown-child-active" class="dropdown admin">
 *     Admin
 *     <ul>
 *       <li><a uiSref="admin.users" uiSrefActive="active">Users</a></li>
 *       <li><a uiSref="admin.groups" uiSrefActive="active">Groups</a></li>
 *       <li><a uiSref="admin.settings" uiSrefActive="active">Settings</a></li>
 *     </ul>
 *   </li>
 * </ul>
 * ```
 */
var UISrefActive = (function () {
    function UISrefActive(uiSrefStatus, rnd, host) {
        var _this = this;
        this._classes = [];
        this._classesEq = [];
        this._subscription = uiSrefStatus.uiSrefStatus.subscribe(function (next) {
            _this._classes.forEach(function (cls) { return rnd.setElementClass(host.nativeElement, cls, next.active); });
            _this._classesEq.forEach(function (cls) { return rnd.setElementClass(host.nativeElement, cls, next.exact); });
        });
    }
    Object.defineProperty(UISrefActive.prototype, "active", {
        set: function (val) { this._classes = val.split("\s+"); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(UISrefActive.prototype, "activeEq", {
        set: function (val) { this._classesEq = val.split("\s+"); },
        enumerable: true,
        configurable: true
    });
    ;
    UISrefActive.prototype.ngOnDestroy = function () {
        this._subscription.unsubscribe();
    };
    return UISrefActive;
}());

UISrefActive.decorators = [
    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__["Directive"], args: [{
                selector: '[uiSrefActive],[uiSrefActiveEq]'
            },] },
];
/** @nocollapse */
UISrefActive.ctorParameters = function () { return [
    { type: __WEBPACK_IMPORTED_MODULE_1__uiSrefStatus__["a" /* UISrefStatus */], },
    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__["Renderer"], },
    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"], decorators: [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__["Host"] },] },
]; };
UISrefActive.propDecorators = {
    'active': [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"], args: ['uiSrefActive',] },],
    'activeEq': [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"], args: ['uiSrefActiveEq',] },],
};
//# sourceMappingURL=uiSrefActive.js.map

/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = ng2LazyLoadBuilder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lazyLoad_lazyLoadNgModule__ = __webpack_require__(67);

/**
 * This is a [[StateBuilder.builder]] function for ngModule lazy loading in Angular.
 *
 * When the [[StateBuilder]] builds a [[State]] object from a raw [[StateDeclaration]], this builder
 * decorates the `lazyLoad` property for states that have a [[Ng2StateDeclaration.ngModule]] declaration.
 *
 * If the state has a [[Ng2StateDeclaration.ngModule]], it will create a `lazyLoad` function
 * that in turn calls `loadNgModule(loadNgModuleFn)`.
 *
 * #### Example:
 * A state that has a `ngModule`
 * ```js
 * var decl = {
 *   ngModule: () => System.import('./childModule.ts')
 * }
 * ```
 * would build a state with a `lazyLoad` function like:
 * ```js
 * import { loadNgModule } from "@uirouter/angular";
 * var decl = {
 *   lazyLoad: loadNgModule(() => System.import('./childModule.ts')
 * }
 * ```
 *
 * If the state has both a `ngModule:` *and* a `lazyLoad`, then the `lazyLoad` is run first.
 *
 * #### Example:
 * ```js
 * var decl = {
 *   lazyLoad: () => System.import('third-party-library'),
 *   ngModule: () => System.import('./childModule.ts')
 * }
 * ```
 * would build a state with a `lazyLoad` function like:
 * ```js
 * import { loadNgModule } from "@uirouter/angular";
 * var decl = {
 *   lazyLoad: () => System.import('third-party-library')
 *       .then(() => loadNgModule(() => System.import('./childModule.ts'))
 * }
 * ```
 *
 */
function ng2LazyLoadBuilder(state, parent) {
    var loadNgModuleFn = state['loadChildren'];
    return loadNgModuleFn ? Object(__WEBPACK_IMPORTED_MODULE_0__lazyLoad_lazyLoadNgModule__["c" /* loadNgModule */])(loadNgModuleFn) : state.lazyLoad;
}
//# sourceMappingURL=lazyLoad.js.map

/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = loadNgModule;
/* harmony export (immutable) */ __webpack_exports__["b"] = loadModuleFactory;
/* harmony export (immutable) */ __webpack_exports__["a"] = applyNgModule;
/* harmony export (immutable) */ __webpack_exports__["d"] = multiProviderParentChildDelta;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__uirouter_core__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__uirouter_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__uiRouterNgModule__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__uiRouterConfig__ = __webpack_require__(34);
/** @ng2api @module core */
/** */




/**
 * Returns a function which lazy loads a nested module
 *
 * This is primarily used by the [[ng2LazyLoadBuilder]] when processing [[Ng2StateDeclaration.loadChildren]].
 *
 * It could also be used manually as a [[StateDeclaration.lazyLoad]] property to lazy load an `NgModule` and its state(s).
 *
 * #### Example:
 * Using `System.import()` and named export of `HomeModule`
 * ```js
 * declare var System;
 * var futureState = {
 *   name: 'home.**',
 *   url: '/home',
 *   lazyLoad: loadNgModule(() => System.import('./home/home.module').then(result => result.HomeModule))
 * }
 * ```
 *
 * #### Example:
 * Using a path (string) to the module
 * ```js
 * var futureState = {
 *   name: 'home.**',
 *   url: '/home',
 *   lazyLoad: loadNgModule('./home/home.module#HomeModule')
 * }
 * ```
 *
 *
 * @param moduleToLoad a path (string) to the NgModule to load.
 *    Or a function which loads the NgModule code which should
 *    return a reference to  the `NgModule` class being loaded (or a `Promise` for it).
 *
 * @returns A function which takes a transition, which:
 * - Gets the Injector (scoped properly for the destination state)
 * - Loads and creates the NgModule
 * - Finds the "replacement state" for the target state, and adds the new NgModule Injector to it (as a resolve)
 * - Returns the new states array
 */
function loadNgModule(moduleToLoad) {
    return function (transition) {
        var ng2Injector = transition.injector().get(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__["NATIVE_INJECTOR_TOKEN"]);
        var createModule = function (factory) {
            return factory.create(ng2Injector);
        };
        var applyModule = function (moduleRef) {
            return applyNgModule(transition, moduleRef);
        };
        return loadModuleFactory(moduleToLoad, ng2Injector)
            .then(createModule)
            .then(applyModule);
    };
}
/**
 * Returns the module factory that can be used to instantiate a module
 *
 * For strings this:
 * - Finds the correct NgModuleFactoryLoader
 * - Loads the new NgModuleFactory from the path string (async)
 *
 * For a Type<any> or Promise<Type<any>> this:
 * - Compiles the component type (if not running with AOT)
 * - Returns the NgModuleFactory resulting from compilation (or direct loading if using AOT) as a Promise
 *
 * @internalapi
 */
function loadModuleFactory(moduleToLoad, ng2Injector) {
    if (Object(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__["isString"])(moduleToLoad)) {
        return ng2Injector.get(__WEBPACK_IMPORTED_MODULE_0__angular_core__["NgModuleFactoryLoader"]).load(moduleToLoad);
    }
    var compiler = ng2Injector.get(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Compiler"]);
    var offlineMode = compiler instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__["Compiler"];
    var unwrapEsModuleDefault = function (x) {
        return x && x.__esModule && x['default'] ? x['default'] : x;
    };
    var compileAsync = function (moduleType) {
        return compiler.compileModuleAsync(moduleType);
    };
    var loadChildrenPromise = Promise.resolve(moduleToLoad()).then(unwrapEsModuleDefault);
    return offlineMode ? loadChildrenPromise : loadChildrenPromise.then(compileAsync);
}
/**
 * Apply the UI-Router Modules found in the lazy loaded module.
 *
 * Apply the Lazy Loaded NgModule's newly created Injector to the right state in the state tree.
 *
 * Lazy loading uses a placeholder state which is removed (and replaced) after the module is loaded.
 * The NgModule should include a state with the same name as the placeholder.
 *
 * Find the *newly loaded state* with the same name as the *placeholder state*.
 * The NgModule's Injector (and ComponentFactoryResolver) will be added to that state.
 * The Injector/Factory are used when creating Components for the `replacement` state and all its children.
 *
 * @internalapi
 */
function applyNgModule(transition, ng2Module) {
    var injector = ng2Module.injector;
    var parentInjector = ng2Module.injector['parent'] || ng2Module.injector['_parent'];
    var uiRouter = injector.get(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__["UIRouter"]);
    var registry = uiRouter.stateRegistry;
    var originalName = transition.to().name;
    var originalState = registry.get(originalName);
    // Check if it's a future state (ends with .**)
    var isFuture = /^(.*)\.\*\*$/.exec(originalName);
    // Final name (without the .**)
    var replacementName = isFuture && isFuture[1];
    var newRootModules = multiProviderParentChildDelta(parentInjector, injector, __WEBPACK_IMPORTED_MODULE_2__uiRouterNgModule__["b" /* UIROUTER_ROOT_MODULE */])
        .reduce(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__["uniqR"], []);
    var newChildModules = multiProviderParentChildDelta(parentInjector, injector, __WEBPACK_IMPORTED_MODULE_2__uiRouterNgModule__["a" /* UIROUTER_MODULE_TOKEN */])
        .reduce(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__["uniqR"], []);
    if (newRootModules.length) {
        console.log(newRootModules);
        throw new Error('Lazy loaded modules should not contain a UIRouterModule.forRoot() module');
    }
    var newStateObjects = newChildModules
        .map(function (module) { return Object(__WEBPACK_IMPORTED_MODULE_3__uiRouterConfig__["a" /* applyModuleConfig */])(uiRouter, injector, module); })
        .reduce(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__["unnestR"], [])
        .reduce(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__["uniqR"], []);
    var replacementState = registry.get(replacementName);
    if (!replacementState || replacementState === originalState) {
        throw new Error("The Future State named '" + originalName + "' lazy loaded an NgModule. " +
            ("The lazy loaded NgModule must have a state named '" + replacementName + "' ") +
            ("which replaces the (placeholder) '" + originalName + "' Future State. ") +
            ("Add a '" + replacementName + "' state to the lazy loaded NgModule ") +
            "using UIRouterModule.forChild({ states: CHILD_STATES }).");
    }
    // Supply the newly loaded states with the Injector from the lazy loaded NgModule.
    // If a tree of states is lazy loaded, only add the injector to the root of the lazy loaded tree.
    // The children will get the injector by resolve inheritance.
    var newParentStates = newStateObjects.filter(function (state) { return !Object(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__["inArray"])(newStateObjects, state.parent); });
    // Add the Injector to the top of the lazy loaded state tree as a resolve
    newParentStates.forEach(function (state) { return state.resolvables.push(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__["Resolvable"].fromData(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__["NATIVE_INJECTOR_TOKEN"], injector)); });
    return {};
}
/**
 * Returns the new dependency injection values from the Child Injector
 *
 * When a DI token is defined as multi: true, the child injector
 * can add new values for the token.
 *
 * This function returns the values added by the child injector,  and excludes all values from the parent injector.
 *
 * @internalapi
 */
function multiProviderParentChildDelta(parent, child, token) {
    var childVals = child.get(token, []);
    var parentVals = parent.get(token, []);
    return childVals.filter(function (val) { return parentVals.indexOf(val) === -1; });
}
//# sourceMappingURL=lazyLoadNgModule.js.map

/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = __extends;
/* unused harmony export __assign */
/* unused harmony export __rest */
/* unused harmony export __decorate */
/* unused harmony export __param */
/* unused harmony export __metadata */
/* unused harmony export __awaiter */
/* unused harmony export __generator */
/* unused harmony export __exportStar */
/* unused harmony export __values */
/* unused harmony export __read */
/* unused harmony export __spread */
/* unused harmony export __await */
/* unused harmony export __asyncGenerator */
/* unused harmony export __asyncDelegator */
/* unused harmony export __asyncValues */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; }; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator];
    return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
}

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var platform_browser_1 = __webpack_require__(70);
// import { getDOM } from '@angular/platform-browser/src/dom/dom_adapter';
var angulartics2_1 = __webpack_require__(6);
var Angulartics2On = /** @class */ (function () {
    function Angulartics2On(elRef, angulartics2, eventManager) {
        this.elRef = elRef;
        this.angulartics2 = angulartics2;
        this.eventManager = eventManager;
        this.el = this.elRef.nativeElement;
    }
    Angulartics2On.prototype.ngAfterContentInit = function () {
        var _this = this;
        // Don't listen in server-side
        if (this.isBrowser()) {
            this.eventManager.addEventListener(this.el, this.angulartics2On || 'click', function (event) { return _this.eventTrack(event); });
        }
    };
    Angulartics2On.prototype.isBrowser = function () {
        return typeof (window) !== 'undefined';
    };
    Angulartics2On.prototype.eventTrack = function (event) {
        var action = this.angularticsEvent; // || this.inferEventName();
        var properties = {
            eventType: event.type
        };
        if (this.angularticsCategory) {
            properties.category = this.angularticsCategory;
        }
        // Allow components to pass through an expression that gets merged on to the event properties
        // eg. angulartics-properites='myComponentScope.someConfigExpression.$angularticsProperties'
        if (this.angularticsProperties) {
            Object.assign(properties, this.angularticsProperties);
        }
        this.angulartics2.eventTrack.next({
            action: action,
            properties: properties
        });
    };
    __decorate([
        core_1.Input('angulartics2On'),
        __metadata("design:type", String)
    ], Angulartics2On.prototype, "angulartics2On", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", String)
    ], Angulartics2On.prototype, "angularticsEvent", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", String)
    ], Angulartics2On.prototype, "angularticsCategory", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Object)
    ], Angulartics2On.prototype, "angularticsProperties", void 0);
    Angulartics2On = __decorate([
        core_1.Injectable(),
        core_1.Directive({
            selector: '[angulartics2On]'
        }),
        __metadata("design:paramtypes", [core_1.ElementRef,
            angulartics2_1.Angulartics2,
            platform_browser_1.EventManager])
    ], Angulartics2On);
    return Angulartics2On;
}());
exports.Angulartics2On = Angulartics2On;


/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_70__;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var angulartics2_1 = __webpack_require__(6);
var angulartics2On_1 = __webpack_require__(69);
__export(__webpack_require__(6));
__export(__webpack_require__(69));
__export(__webpack_require__(109));
exports.ANGULARTICS2_FORROOT_GUARD = new core_1.InjectionToken('ANGULARTICS2_FORROOT_GUARD');
function provideForRootGuard(angulartics2) {
    if (angulartics2) {
        throw new Error("Angulartics2Module.forRoot() called twice. Lazy loaded modules should use Angulartics2Module.forChild() instead.");
    }
    return 'guarded';
}
exports.provideForRootGuard = provideForRootGuard;
var Angulartics2Module = /** @class */ (function () {
    function Angulartics2Module(guard) {
    }
    Angulartics2Module_1 = Angulartics2Module;
    Angulartics2Module.forRoot = function (providers) {
        return {
            ngModule: Angulartics2Module_1,
            providers: [
                {
                    provide: exports.ANGULARTICS2_FORROOT_GUARD,
                    useFactory: provideForRootGuard,
                    deps: [[angulartics2_1.Angulartics2, new core_1.Optional(), new core_1.SkipSelf()]]
                },
                angulartics2_1.Angulartics2
            ].concat(providers)
        };
    };
    Angulartics2Module.forChild = function () {
        return {
            ngModule: Angulartics2Module_1,
            providers: []
        };
    };
    Angulartics2Module = Angulartics2Module_1 = __decorate([
        core_1.NgModule({
            declarations: [angulartics2On_1.Angulartics2On],
            exports: [angulartics2On_1.Angulartics2On]
        }),
        __param(0, core_1.Optional()), __param(0, core_1.Inject(exports.ANGULARTICS2_FORROOT_GUARD)),
        __metadata("design:paramtypes", [Object])
    ], Angulartics2Module);
    return Angulartics2Module;
    var Angulartics2Module_1;
}());
exports.Angulartics2Module = Angulartics2Module;


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__providers__ = __webpack_require__(38);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "uiRouterFactory", function() { return __WEBPACK_IMPORTED_MODULE_0__providers__["m"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "parentUIViewInjectFactory", function() { return __WEBPACK_IMPORTED_MODULE_0__providers__["l"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "_UIROUTER_INSTANCE_PROVIDERS", function() { return __WEBPACK_IMPORTED_MODULE_0__providers__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "fnStateService", function() { return __WEBPACK_IMPORTED_MODULE_0__providers__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "fnTransitionService", function() { return __WEBPACK_IMPORTED_MODULE_0__providers__["g"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "fnUrlMatcherFactory", function() { return __WEBPACK_IMPORTED_MODULE_0__providers__["h"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "fnUrlRouter", function() { return __WEBPACK_IMPORTED_MODULE_0__providers__["i"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "fnUrlService", function() { return __WEBPACK_IMPORTED_MODULE_0__providers__["j"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "fnViewService", function() { return __WEBPACK_IMPORTED_MODULE_0__providers__["k"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "fnStateRegistry", function() { return __WEBPACK_IMPORTED_MODULE_0__providers__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "fnGlobals", function() { return __WEBPACK_IMPORTED_MODULE_0__providers__["d"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "_UIROUTER_SERVICE_PROVIDERS", function() { return __WEBPACK_IMPORTED_MODULE_0__providers__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "UIROUTER_PROVIDERS", function() { return __WEBPACK_IMPORTED_MODULE_0__providers__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__uiRouterNgModule__ = __webpack_require__(35);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "UIROUTER_ROOT_MODULE", function() { return __WEBPACK_IMPORTED_MODULE_1__uiRouterNgModule__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "UIROUTER_MODULE_TOKEN", function() { return __WEBPACK_IMPORTED_MODULE_1__uiRouterNgModule__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "UIROUTER_STATES", function() { return __WEBPACK_IMPORTED_MODULE_1__uiRouterNgModule__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "onTransitionReady", function() { return __WEBPACK_IMPORTED_MODULE_1__uiRouterNgModule__["h"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "makeRootProviders", function() { return __WEBPACK_IMPORTED_MODULE_1__uiRouterNgModule__["g"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "makeChildProviders", function() { return __WEBPACK_IMPORTED_MODULE_1__uiRouterNgModule__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "locationStrategy", function() { return __WEBPACK_IMPORTED_MODULE_1__uiRouterNgModule__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "UIRouterModule", function() { return __WEBPACK_IMPORTED_MODULE_1__uiRouterNgModule__["d"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__uiRouterConfig__ = __webpack_require__(34);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "applyModuleConfig", function() { return __WEBPACK_IMPORTED_MODULE_2__uiRouterConfig__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "applyRootModuleConfig", function() { return __WEBPACK_IMPORTED_MODULE_2__uiRouterConfig__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__directives_directives__ = __webpack_require__(64);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "_UIROUTER_DIRECTIVES", function() { return __WEBPACK_IMPORTED_MODULE_3__directives_directives__["g"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "UIROUTER_DIRECTIVES", function() { return __WEBPACK_IMPORTED_MODULE_3__directives_directives__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "UIView", function() { return __WEBPACK_IMPORTED_MODULE_3__directives_directives__["f"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "AnchorUISref", function() { return __WEBPACK_IMPORTED_MODULE_3__directives_directives__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "UISref", function() { return __WEBPACK_IMPORTED_MODULE_3__directives_directives__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "UISrefStatus", function() { return __WEBPACK_IMPORTED_MODULE_3__directives_directives__["e"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "UISrefActive", function() { return __WEBPACK_IMPORTED_MODULE_3__directives_directives__["d"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__statebuilders_views__ = __webpack_require__(33);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "ng2ViewsBuilder", function() { return __WEBPACK_IMPORTED_MODULE_4__statebuilders_views__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "Ng2ViewConfig", function() { return __WEBPACK_IMPORTED_MODULE_4__statebuilders_views__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__statebuilders_lazyLoad__ = __webpack_require__(66);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "ng2LazyLoadBuilder", function() { return __WEBPACK_IMPORTED_MODULE_5__statebuilders_lazyLoad__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__lazyLoad_lazyLoadNgModule__ = __webpack_require__(67);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "loadNgModule", function() { return __WEBPACK_IMPORTED_MODULE_6__lazyLoad_lazyLoadNgModule__["c"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "loadModuleFactory", function() { return __WEBPACK_IMPORTED_MODULE_6__lazyLoad_lazyLoadNgModule__["b"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "applyNgModule", function() { return __WEBPACK_IMPORTED_MODULE_6__lazyLoad_lazyLoadNgModule__["a"]; });
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "multiProviderParentChildDelta", function() { return __WEBPACK_IMPORTED_MODULE_6__lazyLoad_lazyLoadNgModule__["d"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__uirouter_core__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__uirouter_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__uirouter_core__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_7__uirouter_core__) if(["uiRouterFactory","parentUIViewInjectFactory","_UIROUTER_INSTANCE_PROVIDERS","fnStateService","fnTransitionService","fnUrlMatcherFactory","fnUrlRouter","fnUrlService","fnViewService","fnStateRegistry","fnGlobals","_UIROUTER_SERVICE_PROVIDERS","UIROUTER_PROVIDERS","UIROUTER_ROOT_MODULE","UIROUTER_MODULE_TOKEN","UIROUTER_STATES","onTransitionReady","makeRootProviders","makeChildProviders","locationStrategy","UIRouterModule","applyModuleConfig","applyRootModuleConfig","_UIROUTER_DIRECTIVES","UIROUTER_DIRECTIVES","UIView","AnchorUISref","UISref","UISrefStatus","UISrefActive","ng2ViewsBuilder","Ng2ViewConfig","ng2LazyLoadBuilder","loadNgModule","loadModuleFactory","applyNgModule","multiProviderParentChildDelta","default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_7__uirouter_core__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/** @ng2api @module ng2 */ /** for typedoc */








//# sourceMappingURL=index.js.map

/***/ }),
/* 73 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(13));
__export(__webpack_require__(41));
__export(__webpack_require__(42));
__export(__webpack_require__(30));
//# sourceMappingURL=index.js.map

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/** @module path */ /** for typedoc */
__export(__webpack_require__(29));
__export(__webpack_require__(20));
//# sourceMappingURL=index.js.map

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/** @module resolve */ /** for typedoc */
__export(__webpack_require__(40));
__export(__webpack_require__(16));
__export(__webpack_require__(21));
//# sourceMappingURL=index.js.map

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(43));
__export(__webpack_require__(26));
__export(__webpack_require__(44));
__export(__webpack_require__(45));
__export(__webpack_require__(46));
__export(__webpack_require__(47));
__export(__webpack_require__(12));
//# sourceMappingURL=index.js.map

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module hooks */ /** */
var transition_1 = __webpack_require__(19);
var router_1 = __webpack_require__(48);
function addCoreResolvables(trans) {
    trans.addResolvable({ token: router_1.UIRouter, deps: [], resolveFn: function () { return trans.router; }, data: trans.router }, "");
    trans.addResolvable({ token: transition_1.Transition, deps: [], resolveFn: function () { return trans; }, data: trans }, "");
    trans.addResolvable({ token: '$transition$', deps: [], resolveFn: function () { return trans; }, data: trans }, "");
    trans.addResolvable({ token: '$stateParams', deps: [], resolveFn: function () { return trans.params(); }, data: trans.params() }, "");
    trans.entering().forEach(function (state) {
        trans.addResolvable({ token: '$state$', deps: [], resolveFn: function () { return state; }, data: state }, state);
    });
}
exports.registerAddCoreResolvables = function (transitionService) {
    return transitionService.onCreate({}, addCoreResolvables);
};
//# sourceMappingURL=coreResolvables.js.map

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module hooks */ /** */
var predicates_1 = __webpack_require__(1);
var coreservices_1 = __webpack_require__(5);
var targetState_1 = __webpack_require__(12);
/**
 * A [[TransitionHookFn]] that redirects to a different state or params
 *
 * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`
 *
 * See [[StateDeclaration.redirectTo]]
 */
var redirectToHook = function (trans) {
    var redirect = trans.to().redirectTo;
    if (!redirect)
        return;
    var $state = trans.router.stateService;
    function handleResult(result) {
        if (!result)
            return;
        if (result instanceof targetState_1.TargetState)
            return result;
        if (predicates_1.isString(result))
            return $state.target(result, trans.params(), trans.options());
        if (result['state'] || result['params'])
            return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());
    }
    if (predicates_1.isFunction(redirect)) {
        return coreservices_1.services.$q.when(redirect(trans)).then(handleResult);
    }
    return handleResult(redirect);
};
exports.registerRedirectToHook = function (transitionService) {
    return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);
};
//# sourceMappingURL=redirectTo.js.map

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A factory which creates an onEnter, onExit or onRetain transition hook function
 *
 * The returned function invokes the (for instance) state.onEnter hook when the
 * state is being entered.
 *
 * @hidden
 */
function makeEnterExitRetainHook(hookName) {
    return function (transition, state) {
        var _state = state.$$state();
        var hookFn = _state[hookName];
        return hookFn(transition, state);
    };
}
/**
 * The [[TransitionStateHookFn]] for onExit
 *
 * When the state is being exited, the state's .onExit function is invoked.
 *
 * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`
 *
 * See: [[IHookRegistry.onExit]]
 */
var onExitHook = makeEnterExitRetainHook('onExit');
exports.registerOnExitHook = function (transitionService) {
    return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);
};
/**
 * The [[TransitionStateHookFn]] for onRetain
 *
 * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.
 *
 * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`
 *
 * See: [[IHookRegistry.onRetain]]
 */
var onRetainHook = makeEnterExitRetainHook('onRetain');
exports.registerOnRetainHook = function (transitionService) {
    return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);
};
/**
 * The [[TransitionStateHookFn]] for onEnter
 *
 * When the state is being entered, the state's .onEnter function is invoked.
 *
 * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`
 *
 * See: [[IHookRegistry.onEnter]]
 */
var onEnterHook = makeEnterExitRetainHook('onEnter');
exports.registerOnEnterHook = function (transitionService) {
    return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);
};
//# sourceMappingURL=onEnterExitRetain.js.map

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module hooks */
/** for typedoc */
var common_1 = __webpack_require__(0);
var resolveContext_1 = __webpack_require__(21);
var hof_1 = __webpack_require__(2);
/**
 * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path
 *
 * Registered using `transitionService.onStart({}, eagerResolvePath);`
 *
 * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.
 *
 * See [[StateDeclaration.resolve]]
 */
var eagerResolvePath = function (trans) {
    return new resolveContext_1.ResolveContext(trans.treeChanges().to)
        .resolvePath("EAGER", trans)
        .then(common_1.noop);
};
exports.registerEagerResolvePath = function (transitionService) {
    return transitionService.onStart({}, eagerResolvePath, { priority: 1000 });
};
/**
 * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path
 *
 * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState);`
 *
 * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.
 *
 * See [[StateDeclaration.resolve]]
 */
var lazyResolveState = function (trans, state) {
    return new resolveContext_1.ResolveContext(trans.treeChanges().to)
        .subContext(state.$$state())
        .resolvePath("LAZY", trans)
        .then(common_1.noop);
};
exports.registerLazyResolveState = function (transitionService) {
    return transitionService.onEnter({ entering: hof_1.val(true) }, lazyResolveState, { priority: 1000 });
};
//# sourceMappingURL=resolve.js.map

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module hooks */ /** for typedoc */
var common_1 = __webpack_require__(0);
var coreservices_1 = __webpack_require__(5);
/**
 * A [[TransitionHookFn]] which waits for the views to load
 *
 * Registered using `transitionService.onStart({}, loadEnteringViews);`
 *
 * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.
 * In angular 1, this includes loading the templates.
 */
var loadEnteringViews = function (transition) {
    var $q = coreservices_1.services.$q;
    var enteringViews = transition.views("entering");
    if (!enteringViews.length)
        return;
    return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(common_1.noop);
};
exports.registerLoadEnteringViews = function (transitionService) {
    return transitionService.onFinish({}, loadEnteringViews);
};
/**
 * A [[TransitionHookFn]] which activates the new views when a transition is successful.
 *
 * Registered using `transitionService.onSuccess({}, activateViews);`
 *
 * After a transition is complete, this hook deactivates the old views from the previous state,
 * and activates the new views from the destination state.
 *
 * See [[ViewService]]
 */
var activateViews = function (transition) {
    var enteringViews = transition.views("entering");
    var exitingViews = transition.views("exiting");
    if (!enteringViews.length && !exitingViews.length)
        return;
    var $view = transition.router.viewService;
    exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });
    enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });
    $view.sync();
};
exports.registerActivateViews = function (transitionService) {
    return transitionService.onSuccess({}, activateViews);
};
//# sourceMappingURL=views.js.map

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(0);
/**
 * A [[TransitionHookFn]] which updates global UI-Router state
 *
 * Registered using `transitionService.onBefore({}, updateGlobalState);`
 *
 * Before a [[Transition]] starts, updates the global value of "the current transition" ([[Globals.transition]]).
 * After a successful [[Transition]], updates the global values of "the current state"
 * ([[Globals.current]] and [[Globals.$current]]) and "the current param values" ([[Globals.params]]).
 *
 * See also the deprecated properties:
 * [[StateService.transition]], [[StateService.current]], [[StateService.params]]
 */
var updateGlobalState = function (trans) {
    var globals = trans.router.globals;
    var transitionSuccessful = function () {
        globals.successfulTransitions.enqueue(trans);
        globals.$current = trans.$to();
        globals.current = globals.$current.self;
        common_1.copy(trans.params(), globals.params);
    };
    var clearCurrentTransition = function () {
        // Do not clear globals.transition if a different transition has started in the meantime
        if (globals.transition === trans)
            globals.transition = null;
    };
    trans.onSuccess({}, transitionSuccessful, { priority: 10000 });
    trans.promise.then(clearCurrentTransition, clearCurrentTransition);
};
exports.registerUpdateGlobalState = function (transitionService) {
    return transitionService.onCreate({}, updateGlobalState);
};
//# sourceMappingURL=updateGlobals.js.map

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A [[TransitionHookFn]] which updates the URL after a successful transition
 *
 * Registered using `transitionService.onSuccess({}, updateUrl);`
 */
var updateUrl = function (transition) {
    var options = transition.options();
    var $state = transition.router.stateService;
    var $urlRouter = transition.router.urlRouter;
    // Dont update the url in these situations:
    // The transition was triggered by a URL sync (options.source === 'url')
    // The user doesn't want the url to update (options.location === false)
    // The destination state, and all parents have no navigable url
    if (options.source !== 'url' && options.location && $state.$current.navigable) {
        var urlOptions = { replace: options.location === 'replace' };
        $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);
    }
    $urlRouter.update(true);
};
exports.registerUpdateUrl = function (transitionService) {
    return transitionService.onSuccess({}, updateUrl, { priority: 9999 });
};
//# sourceMappingURL=url.js.map

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** @module hooks */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
var trace_1 = __webpack_require__(9);
var rejectFactory_1 = __webpack_require__(14);
/**
 * A [[TransitionHookFn]] that skips a transition if it should be ignored
 *
 * This hook is invoked at the end of the onBefore phase.
 *
 * If the transition should be ignored (because no parameter or states changed)
 * then the transition is ignored and not processed.
 */
function ignoredHook(trans) {
    var ignoredReason = trans._ignoredReason();
    if (!ignoredReason)
        return;
    trace_1.trace.traceTransitionIgnored(trans);
    var pending = trans.router.globals.transition;
    // The user clicked a link going back to the *current state* ('A')
    // However, there is also a pending transition in flight (to 'B')
    // Abort the transition to 'B' because the user now wants to be back at 'A'.
    if (ignoredReason === 'SameAsCurrent' && pending) {
        pending.abort();
    }
    return rejectFactory_1.Rejection.ignored().toPromise();
}
exports.registerIgnoredTransitionHook = function (transitionService) {
    return transitionService.onBefore({}, ignoredHook, { priority: -9999 });
};
//# sourceMappingURL=ignoredTransition.js.map

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** @module hooks */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A [[TransitionHookFn]] that rejects the Transition if it is invalid
 *
 * This hook is invoked at the end of the onBefore phase.
 * If the transition is invalid (for example, param values do not validate)
 * then the transition is rejected.
 */
function invalidTransitionHook(trans) {
    if (!trans.valid()) {
        throw new Error(trans.error());
    }
}
exports.registerInvalidTransitionHook = function (transitionService) {
    return transitionService.onBefore({}, invalidTransitionHook, { priority: -10000 });
};
//# sourceMappingURL=invalidTransition.js.map

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * # Transition subsystem
 *
 * This module contains APIs related to a Transition.
 *
 * See:
 * - [[TransitionService]]
 * - [[Transition]]
 * - [[HookFn]], [[TransitionHookFn]], [[TransitionStateHookFn]], [[HookMatchCriteria]], [[HookResult]]
 *
 * @coreapi
 * @preferred
 * @module transition
 */ /** for typedoc */
__export(__webpack_require__(11));
__export(__webpack_require__(39));
__export(__webpack_require__(28));
__export(__webpack_require__(14));
__export(__webpack_require__(19));
__export(__webpack_require__(15));
__export(__webpack_require__(56));
__export(__webpack_require__(31));
//# sourceMappingURL=index.js.map

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(22));
__export(__webpack_require__(49));
__export(__webpack_require__(50));
__export(__webpack_require__(51));
__export(__webpack_require__(54));
//# sourceMappingURL=index.js.map

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(52));
//# sourceMappingURL=index.js.map

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
__export(__webpack_require__(91));
//# sourceMappingURL=vanilla.js.map

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(57));
__export(__webpack_require__(58));
__export(__webpack_require__(23));
__export(__webpack_require__(59));
__export(__webpack_require__(60));
__export(__webpack_require__(61));
__export(__webpack_require__(62));
__export(__webpack_require__(63));
__export(__webpack_require__(32));
__export(__webpack_require__(92));
//# sourceMappingURL=index.js.map

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var browserLocationConfig_1 = __webpack_require__(63);
var hashLocationService_1 = __webpack_require__(59);
var utils_1 = __webpack_require__(32);
var pushStateLocationService_1 = __webpack_require__(61);
var memoryLocationService_1 = __webpack_require__(60);
var memoryLocationConfig_1 = __webpack_require__(62);
var injector_1 = __webpack_require__(58);
var q_1 = __webpack_require__(57);
var coreservices_1 = __webpack_require__(5);
function servicesPlugin(router) {
    coreservices_1.services.$injector = injector_1.$injector;
    coreservices_1.services.$q = q_1.$q;
    return { name: "vanilla.services", $q: q_1.$q, $injector: injector_1.$injector, dispose: function () { return null; } };
}
exports.servicesPlugin = servicesPlugin;
/** A `UIRouterPlugin` uses the browser hash to get/set the current location */
exports.hashLocationPlugin = utils_1.locationPluginFactory('vanilla.hashBangLocation', false, hashLocationService_1.HashLocationService, browserLocationConfig_1.BrowserLocationConfig);
/** A `UIRouterPlugin` that gets/sets the current location using the browser's `location` and `history` apis */
exports.pushStateLocationPlugin = utils_1.locationPluginFactory("vanilla.pushStateLocation", true, pushStateLocationService_1.PushStateLocationService, browserLocationConfig_1.BrowserLocationConfig);
/** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */
exports.memoryLocationPlugin = utils_1.locationPluginFactory("vanilla.memoryLocation", false, memoryLocationService_1.MemoryLocationService, memoryLocationConfig_1.MemoryLocationConfig);
//# sourceMappingURL=plugins.js.map

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * # Core classes and interfaces
 *
 * The classes and interfaces that are core to ui-router and do not belong
 * to a more specific subsystem (such as resolve).
 *
 * @coreapi
 * @preferred
 * @module core
 */ /** for typedoc */
Object.defineProperty(exports, "__esModule", { value: true });
/** @internalapi */
var UIRouterPluginBase = /** @class */ (function () {
    function UIRouterPluginBase() {
    }
    UIRouterPluginBase.prototype.dispose = function (router) { };
    return UIRouterPluginBase;
}());
exports.UIRouterPluginBase = UIRouterPluginBase;
//# sourceMappingURL=interface.js.map

/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MergeInjector; });
/**
 * Merge two injectors
 *
 * This class implements the Injector ng2 interface but delegates
 * to the Injectors provided in the constructor.
 */
var MergeInjector = (function () {
    function MergeInjector() {
        var injectors = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            injectors[_i] = arguments[_i];
        }
        if (injectors.length < 2)
            throw new Error("pass at least two injectors");
        this.injectors = injectors;
    }
    /**
     * Get the token from the first injector which contains it.
     *
     * Delegates to the first Injector.get().
     * If not found, then delegates to the second Injector (and so forth).
     * If no Injector contains the token, return the `notFoundValue`, or throw.
     *
     * @param token the DI token
     * @param notFoundValue the value to return if none of the Injectors contains the token.
     * @returns {any} the DI value
     */
    MergeInjector.prototype.get = function (token, notFoundValue) {
        for (var i = 0; i < this.injectors.length; i++) {
            var val = this.injectors[i].get(token, MergeInjector.NOT_FOUND);
            if (val !== MergeInjector.NOT_FOUND)
                return val;
        }
        if (arguments.length >= 2)
            return notFoundValue;
        // This will throw the DI Injector error
        this.injectors[0].get(token);
    };
    return MergeInjector;
}());

MergeInjector.NOT_FOUND = {};
//# sourceMappingURL=mergeInjector.js.map

/***/ }),
/* 95 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_95__;

/***/ }),
/* 96 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_96__;

/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_97__;

/***/ }),
/* 98 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_98__;

/***/ }),
/* 99 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_99__;

/***/ }),
/* 100 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_100__;

/***/ }),
/* 101 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_101__;

/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ui_router_rx__ = __webpack_require__(103);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__ui_router_rx__["a"]; });

//# sourceMappingURL=index.js.map

/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UIRouterRx; });
/* unused harmony export UIRouterRxPlugin */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_add_operator_mergeMap__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rxjs_add_operator_mergeMap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rxjs_add_operator_mergeMap__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_add_operator_map__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_add_operator_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_add_operator_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_ReplaySubject__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_ReplaySubject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_ReplaySubject__);
/** @module rx */
/** */



/** Augments UIRouterGlobals with observables for transition starts, successful transitions, and state parameters */
var UIRouterRx = (function () {
    function UIRouterRx(router) {
        this.name = '@uirouter/rx';
        this.deregisterFns = [];
        var start$ = new __WEBPACK_IMPORTED_MODULE_2_rxjs_ReplaySubject__["ReplaySubject"](1);
        var success$ = start$.mergeMap(function (t) { return t.promise.then(function () { return t; }); });
        var params$ = success$.map(function (transition) { return transition.params(); });
        var states$ = new __WEBPACK_IMPORTED_MODULE_2_rxjs_ReplaySubject__["ReplaySubject"](1);
        function onStatesChangedEvent(event, states) {
            var changeEvent = {
                currentStates: router.stateRegistry.get(),
                registered: [],
                deregistered: []
            };
            if (event)
                changeEvent[event] = states;
            states$.next(changeEvent);
        }
        this.deregisterFns.push(router.transitionService.onStart({}, function (transition) { return start$.next(transition); }));
        this.deregisterFns.push(router.stateRegistry.onStatesChanged(onStatesChangedEvent));
        onStatesChangedEvent(null, null);
        Object.assign(router.globals, { start$: start$, success$: success$, params$: params$, states$: states$ });
    }
    UIRouterRx.prototype.dispose = function () {
        this.deregisterFns.forEach(function (deregisterFn) { return deregisterFn(); });
        this.deregisterFns = [];
    };
    return UIRouterRx;
}());

var UIRouterRxPlugin = UIRouterRx;
//# sourceMappingURL=ui-router-rx.js.map

/***/ }),
/* 104 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_104__;

/***/ }),
/* 105 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_105__;

/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Ng2LocationServices; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__uirouter_core__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__uirouter_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__);

/** @module ng2 */
/** */

/** A `LocationServices` that delegates to the Angular LocationStrategy */
var Ng2LocationServices = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](Ng2LocationServices, _super);
    function Ng2LocationServices(router, _locationStrategy, isBrowser) {
        var _this = _super.call(this, router, isBrowser) || this;
        _this._locationStrategy = _locationStrategy;
        _this._locationStrategy.onPopState(function (evt) {
            if (evt.type !== 'hashchange') {
                _this._listener(evt);
            }
        });
        return _this;
    }
    Ng2LocationServices.prototype._get = function () {
        return this._locationStrategy.path(true)
            .replace(this._locationStrategy.getBaseHref().replace(/\/$/, ''), '');
    };
    Ng2LocationServices.prototype._set = function (state, title, url, replace) {
        var _a = Object(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__["parseUrl"])(url), path = _a.path, search = _a.search, hash = _a.hash;
        var urlWithHash = path + (hash ? "#" + hash : "");
        if (replace) {
            this._locationStrategy.replaceState(state, title, urlWithHash, search);
        }
        else {
            this._locationStrategy.pushState(state, title, urlWithHash, search);
        }
    };
    Ng2LocationServices.prototype.dispose = function (router) {
        _super.prototype.dispose.call(this, router);
    };
    return Ng2LocationServices;
}(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__["BaseLocationServices"]));

//# sourceMappingURL=locationService.js.map

/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Ng2LocationConfig; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__uirouter_core__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__uirouter_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_common__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_common___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__angular_common__);
/** @module ng2 */
/** */



var Ng2LocationConfig = (function (_super) {
    __WEBPACK_IMPORTED_MODULE_0_tslib__["a" /* __extends */](Ng2LocationConfig, _super);
    function Ng2LocationConfig(router, _locationStrategy) {
        var _this = _super.call(this, router, Object(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__["is"])(__WEBPACK_IMPORTED_MODULE_2__angular_common__["PathLocationStrategy"])(_locationStrategy)) || this;
        _this._locationStrategy = _locationStrategy;
        return _this;
    }
    Ng2LocationConfig.prototype.baseHref = function (href) {
        return this._locationStrategy.getBaseHref();
    };
    return Ng2LocationConfig;
}(__WEBPACK_IMPORTED_MODULE_1__uirouter_core__["BrowserLocationConfig"]));

//# sourceMappingURL=locationConfig.js.map

/***/ }),
/* 108 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_108__;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(110));
__export(__webpack_require__(111));
__export(__webpack_require__(112));
__export(__webpack_require__(113));
__export(__webpack_require__(114));
__export(__webpack_require__(115));
__export(__webpack_require__(116));
__export(__webpack_require__(117));
__export(__webpack_require__(118));
__export(__webpack_require__(119));
__export(__webpack_require__(120));


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var angulartics2_1 = __webpack_require__(6);
var Angulartics2BaiduAnalytics = /** @class */ (function () {
    function Angulartics2BaiduAnalytics(angulartics2) {
        var _this = this;
        this.angulartics2 = angulartics2;
        if (typeof (hmt) === 'undefined') {
            hmt = [];
        }
        else {
            hmt.push(['_ setAutoPageview', false]);
        }
        this.angulartics2.pageTrack.subscribe(function (x) { return _this.pageTrack(x.path); });
        this.angulartics2.eventTrack.subscribe(function (x) { return _this.eventTrack(x.action, x.properties); });
        this.angulartics2.setUsername.subscribe(function (x) { return _this.setUsername(x); });
        this.angulartics2.setUserProperties.subscribe(function (x) { return _this.setUserProperties(x); });
    }
    /**
     * Page Track in Baidu Analytics
     * @name pageTrack
     *
     * @param {string} path Required 'path' (string)
     *
     * @link http://tongji.baidu.com/open/api/more?p=ref_trackPageview
     *
     */
    Angulartics2BaiduAnalytics.prototype.pageTrack = function (path) {
        if (typeof hmt !== 'undefined' && hmt) {
            hmt.push(['_trackPageview', path]);
        }
    };
    /**
     * Track Event in Baidu Analytics
     * @name eventTrack
     *
     * @param {string} action Required 'action' (string) associated with the event
     * @param {object} properties Comprised of the mandatory field 'category' (string), 'opt_label'(string) and 'opt_value' (string)
     *
     * @link http://tongji.baidu.com/open/api/more?p=ref_trackEvent
     *
     */
    Angulartics2BaiduAnalytics.prototype.eventTrack = function (action, properties) {
        //baidu analytics requires category
        if (!properties || !properties.category) {
            properties = properties || {};
            properties.category = 'Event';
            properties.opt_label = 'default';
            properties.opt_value = 'default';
        }
        if (typeof hmt !== 'undefined' && hmt) {
            hmt.push(['_trackEvent', properties.category, action, properties.opt_label, properties.opt_value]);
        }
    };
    Angulartics2BaiduAnalytics.prototype.setUsername = function (userId) {
        // set default custom variables name to 'identity' and 'value'
        hmt.push(['_setCustomVar', 1, 'identity', userId]);
    };
    Angulartics2BaiduAnalytics.prototype.setUserProperties = function (properties) {
        hmt.push(['_setCustomVar', 2, 'user', JSON.stringify(properties)]);
    };
    Angulartics2BaiduAnalytics = __decorate([
        core_1.Injectable(),
        __metadata("design:paramtypes", [angulartics2_1.Angulartics2])
    ], Angulartics2BaiduAnalytics);
    return Angulartics2BaiduAnalytics;
}());
exports.Angulartics2BaiduAnalytics = Angulartics2BaiduAnalytics;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var angulartics2_1 = __webpack_require__(6);
var Angulartics2GoogleAnalytics = /** @class */ (function () {
    function Angulartics2GoogleAnalytics(angulartics2) {
        var _this = this;
        this.angulartics2 = angulartics2;
        this.angulartics2.settings.pageTracking.trackRelativePath = true;
        // Set the default settings for this module
        this.angulartics2.settings.ga = {
            // array of additional account names (only works for analyticsjs)
            additionalAccountNames: [],
            userId: null
        };
        this.angulartics2.pageTrack.subscribe(function (x) { return _this.pageTrack(x.path); });
        this.angulartics2.eventTrack.subscribe(function (x) { return _this.eventTrack(x.action, x.properties); });
        this.angulartics2.exceptionTrack.subscribe(function (x) { return _this.exceptionTrack(x); });
        this.angulartics2.setUsername.subscribe(function (x) { return _this.setUsername(x); });
        this.angulartics2.setUserProperties.subscribe(function (x) { return _this.setUserProperties(x); });
        this.angulartics2.userTimings.subscribe(function (x) { return _this.userTimings(x); });
    }
    Angulartics2GoogleAnalytics.prototype.pageTrack = function (path) {
        if (typeof _gaq !== 'undefined' && _gaq) {
            _gaq.push(['_trackPageview', path]);
            for (var _i = 0, _a = this.angulartics2.settings.ga.additionalAccountNames; _i < _a.length; _i++) {
                var accountName = _a[_i];
                _gaq.push([accountName + '._trackPageview', path]);
            }
            ;
        }
        if (typeof ga !== 'undefined' && ga) {
            if (this.angulartics2.settings.ga.userId) {
                ga('set', '&uid', this.angulartics2.settings.ga.userId);
            }
            ga('send', 'pageview', path);
            for (var _b = 0, _c = this.angulartics2.settings.ga.additionalAccountNames; _b < _c.length; _b++) {
                var accountName = _c[_b];
                ga(accountName + '.send', 'pageview', path);
            }
            ;
        }
    };
    /**
     * Track Event in GA
     * @name eventTrack
     *
     * @param {string} action Required 'action' (string) associated with the event
     * @param {object} properties Comprised of the mandatory field 'category' (string) and optional  fields 'label' (string), 'value' (integer) and 'noninteraction' (boolean)
     *
     * @link https://developers.google.com/analytics/devguides/collection/gajs/eventTrackerGuide#SettingUpEventTracking
     *
     * @link https://developers.google.com/analytics/devguides/collection/analyticsjs/events
     */
    Angulartics2GoogleAnalytics.prototype.eventTrack = function (action, properties) {
        // Google Analytics requires an Event Category
        if (!properties || !properties.category) {
            properties = properties || {};
            properties.category = 'Event';
        }
        // GA requires that eventValue be an integer, see:
        // https://developers.google.com/analytics/devguides/collection/analyticsjs/field-reference#eventValue
        // https://github.com/luisfarzati/angulartics/issues/81
        if (properties.value) {
            var parsed = parseInt(properties.value, 10);
            properties.value = isNaN(parsed) ? 0 : parsed;
        }
        if (typeof ga !== 'undefined') {
            var eventOptions = {
                eventCategory: properties.category,
                eventAction: action,
                eventLabel: properties.label,
                eventValue: properties.value,
                nonInteraction: properties.noninteraction,
                page: properties.page || location.hash.substring(1) || location.pathname,
                userId: this.angulartics2.settings.ga.userId,
                hitCallback: properties.hitCallback
            };
            // add custom dimensions and metrics
            this.setDimensionsAndMetrics(properties);
            if (this.angulartics2.settings.ga.transport) {
                ga('send', 'event', eventOptions, { transport: this.angulartics2.settings.ga.transport });
            }
            else {
                ga('send', 'event', eventOptions);
            }
            for (var _i = 0, _a = this.angulartics2.settings.ga.additionalAccountNames; _i < _a.length; _i++) {
                var accountName = _a[_i];
                ga(accountName + '.send', 'event', eventOptions);
            }
        }
        else if (typeof _gaq !== 'undefined') {
            _gaq.push(['_trackEvent', properties.category, action, properties.label, properties.value, properties.noninteraction]);
        }
    };
    /**
     * Exception Track Event in GA
     * @name exceptionTrack
     *
     * @param {object} properties Comprised of the optional fields:
     *     'fatal' (string),
     *     'description' (string)
     *
     * @https://developers.google.com/analytics/devguides/collection/analyticsjs/exceptions
     *
     * @link https://developers.google.com/analytics/devguides/collection/analyticsjs/events
     */
    Angulartics2GoogleAnalytics.prototype.exceptionTrack = function (properties) {
        if (properties.fatal === undefined) {
            console.log('No "fatal" provided, sending with fatal=true');
            properties.fatal = true;
        }
        properties.exDescription = properties.description;
        var eventOptions = {
            exFatal: properties.fatal,
            exDescription: properties.description
        };
        ga('send', 'exception', eventOptions);
    };
    Angulartics2GoogleAnalytics.prototype.setUsername = function (userId) {
        this.angulartics2.settings.ga.userId = userId;
    };
    Angulartics2GoogleAnalytics.prototype.setUserProperties = function (properties) {
        this.setDimensionsAndMetrics(properties);
    };
    /**
     * User Timings Event in GA
     * @name userTimings
     *
     * @param {object} properties Comprised of the mandatory fields:
     *     'timingCategory' (string),
     *     'timingVar' (string),
     *     'timingValue' (number)
     * Properties can also have the optional fields:
     *     'timingLabel' (string)
     *
     * @link https://developers.google.com/analytics/devguides/collection/analyticsjs/user-timings
     */
    Angulartics2GoogleAnalytics.prototype.userTimings = function (properties) {
        if (!properties || !properties.timingCategory || !properties.timingVar || !properties.timingValue) {
            console.error('Properties timingCategory, timingVar, and timingValue are required to be set.');
            return;
        }
        if (ga) {
            ga('send', 'timing', properties);
        }
    };
    Angulartics2GoogleAnalytics.prototype.setDimensionsAndMetrics = function (properties) {
        if (ga) {
            // add custom dimensions and metrics
            for (var idx = 1; idx <= 200; idx++) {
                if (properties['dimension' + idx.toString()]) {
                    ga('set', 'dimension' + idx.toString(), properties['dimension' + idx.toString()]);
                }
                else {
                    ga('set', 'dimension' + idx.toString(), undefined);
                }
                if (properties['metric' + idx.toString()]) {
                    ga('set', 'metric' + idx.toString(), properties['metric' + idx.toString()]);
                }
                else {
                    ga('set', 'metric' + idx.toString(), undefined);
                }
            }
        }
    };
    Angulartics2GoogleAnalytics = __decorate([
        core_1.Injectable(),
        __metadata("design:paramtypes", [angulartics2_1.Angulartics2])
    ], Angulartics2GoogleAnalytics);
    return Angulartics2GoogleAnalytics;
}());
exports.Angulartics2GoogleAnalytics = Angulartics2GoogleAnalytics;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var angulartics2_1 = __webpack_require__(6);
var Angulartics2GoogleTagManager = /** @class */ (function () {
    function Angulartics2GoogleTagManager(angulartics2) {
        var _this = this;
        this.angulartics2 = angulartics2;
        // The dataLayer needs to be initialized
        if (typeof dataLayer !== 'undefined' && dataLayer) {
            dataLayer = window.dataLayer = window.dataLayer || [];
        }
        this.angulartics2.settings.pageTracking.trackRelativePath = true;
        // Set the default settings for this module
        this.angulartics2.settings.gtm = {
            userId: null
        };
        this.angulartics2.pageTrack.subscribe(function (x) { return _this.pageTrack(x.path); });
        this.angulartics2.eventTrack.subscribe(function (x) { return _this.eventTrack(x.action, x.properties); });
        this.angulartics2.exceptionTrack.subscribe(function (x) { return _this.exceptionTrack(x); });
        this.angulartics2.setUsername.subscribe(function (x) { return _this.setUsername(x); });
    }
    Angulartics2GoogleTagManager.prototype.pageTrack = function (path) {
        if (typeof dataLayer !== 'undefined' && dataLayer) {
            dataLayer.push({
                'event': 'Page View',
                'content-name': path,
                'userId': this.angulartics2.settings.gtm.userId
            });
        }
    };
    /**
     * Send interactions to the dataLayer, i.e. for event tracking in Google Analytics
     * @name eventTrack
     *
     * @param {string} action Required 'action' (string) associated with the event
     * @param {object} properties Comprised of the mandatory field 'category' (string) and optional  fields 'label' (string), 'value' (integer) and 'noninteraction' (boolean)
     */
    Angulartics2GoogleTagManager.prototype.eventTrack = function (action, properties) {
        // Set a default GTM category
        properties = properties || {};
        if (typeof dataLayer !== 'undefined' && dataLayer) {
            dataLayer.push({
                event: properties.event || 'interaction',
                target: properties.category || 'Event',
                action: action,
                label: properties.label,
                value: properties.value,
                interactionType: properties.noninteraction,
                userId: this.angulartics2.settings.gtm.userId
            });
        }
    };
    /**
     * Exception Track Event in GTM
     * @name exceptionTrack
     *
     * @param {object} properties Comprised of the mandatory fields 'appId' (string), 'appName' (string) and 'appVersion' (string) and
     * optional  fields 'fatal' (boolean) and 'description' (string)
     */
    Angulartics2GoogleTagManager.prototype.exceptionTrack = function (properties) {
        if (!properties || !properties.appId || !properties.appName || !properties.appVersion) {
            console.error('Must be setted appId, appName and appVersion.');
            return;
        }
        if (properties.fatal === undefined) {
            console.log('No "fatal" provided, sending with fatal=true');
            properties.exFatal = true;
        }
        properties.exDescription = properties.event ? properties.event.stack : properties.description;
        this.eventTrack("Exception thrown for " + properties.appName + " <" + properties.appId + "@" + properties.appVersion + ">", {
            'category': 'Exception',
            'label': properties.exDescription
        });
    };
    /**
     * Set userId for use with Universal Analytics User ID feature
     * @name setUsername
     *
     * @param {string} userId Required 'userId' value (string) used to identify user cross-device in Google Analytics
     */
    Angulartics2GoogleTagManager.prototype.setUsername = function (userId) {
        this.angulartics2.settings.gtm.userId = userId;
    };
    Angulartics2GoogleTagManager = __decorate([
        core_1.Injectable(),
        __metadata("design:paramtypes", [angulartics2_1.Angulartics2])
    ], Angulartics2GoogleTagManager);
    return Angulartics2GoogleTagManager;
}());
exports.Angulartics2GoogleTagManager = Angulartics2GoogleTagManager;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var angulartics2_1 = __webpack_require__(6);
var Angulartics2Kissmetrics = /** @class */ (function () {
    function Angulartics2Kissmetrics(angulartics2) {
        var _this = this;
        this.angulartics2 = angulartics2;
        if (typeof (_kmq) === 'undefined') {
            _kmq = [];
        }
        this.angulartics2.pageTrack.subscribe(function (x) { return _this.pageTrack(x.path, x.location); });
        this.angulartics2.eventTrack.subscribe(function (x) { return _this.eventTrack(x.action, x.properties); });
        this.angulartics2.setUsername.subscribe(function (x) { return _this.setUsername(x); });
        this.angulartics2.setUserProperties.subscribe(function (x) { return _this.setUserProperties(x); });
    }
    Angulartics2Kissmetrics.prototype.pageTrack = function (path, location) {
        _kmq.push(['record', 'Pageview', { 'Page': path }]);
    };
    Angulartics2Kissmetrics.prototype.eventTrack = function (action, properties) {
        _kmq.push(['record', action, properties]);
    };
    Angulartics2Kissmetrics.prototype.setUsername = function (userId) {
        _kmq.push(['identify', userId]);
    };
    Angulartics2Kissmetrics.prototype.setUserProperties = function (properties) {
        _kmq.push(['set', properties]);
    };
    Angulartics2Kissmetrics = __decorate([
        core_1.Injectable(),
        __metadata("design:paramtypes", [angulartics2_1.Angulartics2])
    ], Angulartics2Kissmetrics);
    return Angulartics2Kissmetrics;
}());
exports.Angulartics2Kissmetrics = Angulartics2Kissmetrics;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var angulartics2_1 = __webpack_require__(6);
var Angulartics2Mixpanel = /** @class */ (function () {
    function Angulartics2Mixpanel(angulartics2) {
        var _this = this;
        this.angulartics2 = angulartics2;
        this.angulartics2.pageTrack.subscribe(function (x) { return _this.pageTrack(x.path, x.location); });
        this.angulartics2.eventTrack.subscribe(function (x) { return _this.eventTrack(x.action, x.properties); });
        this.angulartics2.setUsername.subscribe(function (x) { return _this.setUsername(x); });
        this.angulartics2.setUserProperties.subscribe(function (x) { return _this.setUserProperties(x); });
        this.angulartics2.setUserPropertiesOnce.subscribe(function (x) { return _this.setUserPropertiesOnce(x); });
        this.angulartics2.setSuperProperties.subscribe(function (x) { return _this.setSuperProperties(x); });
        this.angulartics2.setSuperPropertiesOnce.subscribe(function (x) { return _this.setSuperPropertiesOnce(x); });
        this.angulartics2.setAlias.subscribe(function (x) { return _this.setAlias(x); });
    }
    Angulartics2Mixpanel.prototype.pageTrack = function (path, location) {
        try {
            mixpanel.track('Page Viewed', { page: path });
        }
        catch (e) {
            if (!(e instanceof ReferenceError)) {
                throw e;
            }
        }
    };
    Angulartics2Mixpanel.prototype.eventTrack = function (action, properties) {
        try {
            mixpanel.track(action, properties);
        }
        catch (e) {
            if (!(e instanceof ReferenceError)) {
                throw e;
            }
        }
    };
    Angulartics2Mixpanel.prototype.setUsername = function (userId) {
        try {
            mixpanel.identify(userId);
        }
        catch (e) {
            if (!(e instanceof ReferenceError)) {
                throw e;
            }
        }
    };
    Angulartics2Mixpanel.prototype.setUserProperties = function (properties) {
        try {
            mixpanel.people.set(properties);
        }
        catch (e) {
            if (!(e instanceof ReferenceError)) {
                throw e;
            }
        }
    };
    Angulartics2Mixpanel.prototype.setUserPropertiesOnce = function (properties) {
        try {
            mixpanel.people.set_once(properties);
        }
        catch (e) {
            if (!(e instanceof ReferenceError)) {
                throw e;
            }
        }
    };
    Angulartics2Mixpanel.prototype.setSuperProperties = function (properties) {
        try {
            mixpanel.register(properties);
        }
        catch (e) {
            if (!(e instanceof ReferenceError)) {
                throw e;
            }
        }
    };
    Angulartics2Mixpanel.prototype.setSuperPropertiesOnce = function (properties) {
        try {
            mixpanel.register_once(properties);
        }
        catch (e) {
            if (!(e instanceof ReferenceError)) {
                throw e;
            }
        }
    };
    Angulartics2Mixpanel.prototype.setAlias = function (alias) {
        try {
            mixpanel.alias(alias);
        }
        catch (e) {
            if (!(e instanceof ReferenceError)) {
                throw e;
            }
        }
    };
    Angulartics2Mixpanel = __decorate([
        core_1.Injectable(),
        __metadata("design:paramtypes", [angulartics2_1.Angulartics2])
    ], Angulartics2Mixpanel);
    return Angulartics2Mixpanel;
}());
exports.Angulartics2Mixpanel = Angulartics2Mixpanel;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var angulartics2_1 = __webpack_require__(6);
var Angulartics2Piwik = /** @class */ (function () {
    function Angulartics2Piwik(angulartics2) {
        var _this = this;
        this.angulartics2 = angulartics2;
        if (typeof (_paq) === 'undefined') {
            console.warn('Piwik not found');
        }
        this.angulartics2.pageTrack.subscribe(function (x) { return _this.pageTrack(x.path, x.location); });
        this.angulartics2.eventTrack.subscribe(function (x) { return _this.eventTrack(x.action, x.properties); });
        this.angulartics2.setUsername.subscribe(function (x) { return _this.setUsername(x); });
        this.angulartics2.setUserProperties.subscribe(function (x) { return _this.setUserProperties(x); });
    }
    Angulartics2Piwik.prototype.pageTrack = function (path, location) {
        try {
            _paq.push(['setDocumentTitle', window.document.title]);
            _paq.push(['setCustomUrl', path]);
            _paq.push(['trackPageView']);
        }
        catch (e) {
            if (!(e instanceof ReferenceError)) {
                throw e;
            }
        }
    };
    Angulartics2Piwik.prototype.eventTrack = function (action, properties) {
        try {
            if (properties.value) {
                var parsed = parseInt(properties.value, 10);
                properties.value = isNaN(parsed) ? 0 : parsed;
            }
            _paq.push(['trackEvent', properties.category, action, properties.label, properties.value]);
        }
        catch (e) {
            if (!(e instanceof ReferenceError)) {
                throw e;
            }
        }
    };
    Angulartics2Piwik.prototype.setUsername = function (userId) {
        try {
            _paq.push(['setUserId', userId]);
        }
        catch (e) {
            if (!(e instanceof ReferenceError)) {
                throw e;
            }
        }
    };
    /**
     * Sets custom dimensions if at least one property has the key "dimension<n>",
     * e.g. dimension10. If there are custom dimensions, any other property is ignored.
     *
     * If there are no custom dimensions in the given properties object, the properties
     * object is saved as a custom variable.
     *
     * If in doubt, prefer custom dimensions.
     * @see https://piwik.org/docs/custom-variables/
     */
    Angulartics2Piwik.prototype.setUserProperties = function (properties) {
        try {
            var dimensions = this.setCustomDimensions(properties);
            if (dimensions.length === 0) {
                _paq.push(['setCustomVariable', properties]);
            }
        }
        catch (e) {
            if (!(e instanceof ReferenceError)) {
                throw e;
            }
        }
    };
    Angulartics2Piwik.prototype.setCustomDimensions = function (properties) {
        var dimensionRegex = /dimension[1-9]\d*/;
        var dimensions = Object.keys(properties).filter(function (key) { return dimensionRegex.exec(key); });
        dimensions.forEach(function (dimension) {
            var number = Number(dimension.substr(9));
            _paq.push(['setCustomDimension', number, properties[dimension]]);
        });
        return dimensions;
    };
    Angulartics2Piwik = __decorate([
        core_1.Injectable(),
        __metadata("design:paramtypes", [angulartics2_1.Angulartics2])
    ], Angulartics2Piwik);
    return Angulartics2Piwik;
}());
exports.Angulartics2Piwik = Angulartics2Piwik;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var angulartics2_1 = __webpack_require__(6);
var Angulartics2Segment = /** @class */ (function () {
    function Angulartics2Segment(angulartics2) {
        var _this = this;
        this.angulartics2 = angulartics2;
        this.angulartics2.pageTrack.subscribe(function (x) { return _this.pageTrack(x.path, x.location); });
        this.angulartics2.eventTrack.subscribe(function (x) { return _this.eventTrack(x.action, x.properties); });
        this.angulartics2.setUserProperties.subscribe(function (x) { return _this.setUserProperties(x); });
        this.angulartics2.setUserPropertiesOnce.subscribe(function (x) { return _this.setUserProperties(x); });
        this.angulartics2.setAlias.subscribe(function (x) { return _this.setAlias(x); });
    }
    // https://segment.com/docs/libraries/analytics.js/#page
    // analytics.page([category], [name], [properties], [options], [callback]);
    // TODO : Support optional parameters where the parameter order and type changes their meaning
    // e.g.
    // (string) is (name)
    // (string, string) is (category, name)
    // (string, object) is (name, properties)
    Angulartics2Segment.prototype.pageTrack = function (path, location) {
        try {
            analytics.page(path);
        }
        catch (e) {
            if (!(e instanceof ReferenceError)) {
                throw e;
            }
        }
    };
    // https://segment.com/docs/libraries/analytics.js/#track
    // analytics.track(event, [properties], [options], [callback]);
    Angulartics2Segment.prototype.eventTrack = function (action, properties) {
        try {
            analytics.track(action, properties);
        }
        catch (e) {
            if (!(e instanceof ReferenceError)) {
                throw e;
            }
        }
    };
    // https://segment.com/docs/libraries/analytics.js/#identify
    // analytics.identify([userId], [traits], [options], [callback]);
    Angulartics2Segment.prototype.setUserProperties = function (properties) {
        try {
            if (properties.userId) {
                analytics.identify(properties.userId, properties);
            }
            else {
                analytics.identify(properties);
            }
        }
        catch (e) {
            if (!(e instanceof ReferenceError)) {
                throw e;
            }
        }
    };
    // https://segment.com/docs/libraries/analytics.js/#alias
    // analytics.alias(userId, previousId, options, callback);
    Angulartics2Segment.prototype.setAlias = function (alias) {
        try {
            analytics.alias(alias);
        }
        catch (e) {
            if (!(e instanceof ReferenceError)) {
                throw e;
            }
        }
    };
    Angulartics2Segment = __decorate([
        core_1.Injectable(),
        __metadata("design:paramtypes", [angulartics2_1.Angulartics2])
    ], Angulartics2Segment);
    return Angulartics2Segment;
}());
exports.Angulartics2Segment = Angulartics2Segment;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var angulartics2_1 = __webpack_require__(6);
var Angulartics2Facebook = /** @class */ (function () {
    function Angulartics2Facebook(angulartics2) {
        var _this = this;
        this.angulartics2 = angulartics2;
        this.angulartics2.settings.pageTracking.trackRelativePath = true;
        this.angulartics2.eventTrack.subscribe(function (x) { return _this.eventTrack(x.action, x.properties); });
    }
    /**
     * Send interactions to the Pixel, i.e. for event tracking in Pixel
     * @name eventTrack
     *
     * @param {string} action Required 'action' (string) associated with the event
     * @param {object} properties
     */
    Angulartics2Facebook.prototype.eventTrack = function (action, properties) {
        properties = properties || {};
        var eventList = [
            'ViewContent',
            'Search',
            'AddToCart',
            'AddToWishlist',
            'InitiateCheckout',
            'AddPaymentInfo',
            'Purchase',
            'Lead',
            'CompleteRegistration'
        ];
        if (typeof fbq !== 'undefined' && fbq) {
            eventList.indexOf(action) === -1 ?
                fbq('trackCustom', action, properties) :
                fbq('track', action, properties);
        }
    };
    Angulartics2Facebook = __decorate([
        core_1.Injectable(),
        __metadata("design:paramtypes", [angulartics2_1.Angulartics2])
    ], Angulartics2Facebook);
    return Angulartics2Facebook;
}());
exports.Angulartics2Facebook = Angulartics2Facebook;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var angulartics2_1 = __webpack_require__(6);
var platform_browser_1 = __webpack_require__(70);
var router_1 = __webpack_require__(25);
var Angulartics2AppInsights = /** @class */ (function () {
    function Angulartics2AppInsights(angulartics2, title, router) {
        var _this = this;
        this.angulartics2 = angulartics2;
        this.title = title;
        this.router = router;
        this.loadStartTime = null;
        this.loadTime = null;
        this.metrics = null;
        this.dimensions = null;
        this.measurements = null;
        if (typeof (appInsights) === 'undefined') {
            console.warn('appInsights not found');
        }
        this.angulartics2.settings.appInsights = {
            userId: null
        };
        this.angulartics2.pageTrack.subscribe(function (x) { return _this.pageTrack(x.path); });
        this.angulartics2.eventTrack.subscribe(function (x) { return _this.eventTrack(x.action, x.properties); });
        this.angulartics2.exceptionTrack.subscribe(function (x) { return _this.exceptionTrack(x); });
        this.angulartics2.setUsername.subscribe(function (x) { return _this.setUsername(x); });
        this.angulartics2.setUserProperties.subscribe(function (x) { return _this.setUserProperties(x); });
        this.router.events
            .filter(function (event) { return event instanceof router_1.NavigationStart; })
            .subscribe(function (event) { return _this.startTimer(); });
        this.router.events
            .filter(function (event) {
            return (event instanceof router_1.NavigationError) ||
                (event instanceof router_1.NavigationEnd);
        })
            .subscribe(function (error) { return _this.stopTimer(); });
    }
    Angulartics2AppInsights.prototype.startTimer = function () {
        this.loadStartTime = Date.now();
        this.loadTime = null;
    };
    Angulartics2AppInsights.prototype.stopTimer = function () {
        this.loadTime = Date.now() - this.loadStartTime;
        this.loadStartTime = null;
    };
    /**
     * Page Track in Baidu Analytics
     * @name pageTrack
     *
     * @param {string} path Required 'path' (string)
     *
     * @link https://github.com/Microsoft/ApplicationInsights-JS/blob/master/API-reference.md#trackpageview
     *
     */
    Angulartics2AppInsights.prototype.pageTrack = function (path) {
        appInsights.trackPageView(this.title.getTitle(), path, this.dimensions, this.metrics, this.loadTime);
    };
    /**
     * Log a user action or other occurrence.
     * @param   name    A string to identify this event in the portal.
     *
     * @param   properties  map[string, string] - additional data used to filter events and metrics in the portal. Defaults to empty.
     *
     * @https://github.com/Microsoft/ApplicationInsights-JS/blob/master/API-reference.md#trackevent
     */
    Angulartics2AppInsights.prototype.eventTrack = function (name, properties) {
        appInsights.trackEvent(name, properties, this.measurements);
    };
    /**
     * Exception Track Event in GA
     * @name exceptionTrack
     *
     * @param {any} properties Comprised of the mandatory fields 'appId' (string), 'appName' (string) and 'appVersion' (string) and
     * optional  fields 'fatal' (boolean) and 'description' (string), error
     *
     * @link https://github.com/Microsoft/ApplicationInsights-JS/blob/master/API-reference.md#trackexception
     */
    Angulartics2AppInsights.prototype.exceptionTrack = function (properties) {
        var description = properties.event || properties.description || properties;
        appInsights.trackException(description);
    };
    /**
     *
     * @param userId
     *
     * @link https://github.com/Microsoft/ApplicationInsights-JS/blob/master/API-reference.md#setauthenticatedusercontext
     */
    Angulartics2AppInsights.prototype.setUsername = function (userId) {
        this.angulartics2.settings.appInsights.userId = userId;
        appInsights.setAuthenticatedUserContext(userId);
    };
    Angulartics2AppInsights.prototype.setUserProperties = function (properties) {
        if (properties.userId) {
            this.angulartics2.settings.appInsights.userId = properties.userId;
        }
        if (properties.accountId) {
            appInsights.setAuthenticatedUserContext(this.angulartics2.settings.appInsights.userId, properties.accountId);
        }
    };
    Angulartics2AppInsights = __decorate([
        core_1.Injectable(),
        __metadata("design:paramtypes", [angulartics2_1.Angulartics2,
            platform_browser_1.Title,
            router_1.Router])
    ], Angulartics2AppInsights);
    return Angulartics2AppInsights;
}());
exports.Angulartics2AppInsights = Angulartics2AppInsights;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var angulartics2_1 = __webpack_require__(6);
var Angulartics2Hubspot = /** @class */ (function () {
    function Angulartics2Hubspot(angulartics2) {
        var _this = this;
        this.angulartics2 = angulartics2;
        if (typeof _hsq === 'undefined') {
            _hsq = [];
        }
        this.angulartics2.pageTrack.subscribe(function (x) { return _this.pageTrack(x.path, x.location); });
        this.angulartics2.eventTrack.subscribe(function (x) { return _this.eventTrack(x.action, x.properties); });
        this.angulartics2.setUserProperties.subscribe(function (x) { return _this.setUserProperties(x); });
    }
    Angulartics2Hubspot.prototype.pageTrack = function (path, location) {
        if (typeof _hsq !== 'undefined') {
            _hsq.push(['setPath', path]);
            _hsq.push(['trackPageView']);
        }
    };
    Angulartics2Hubspot.prototype.eventTrack = function (action, properties) {
        if (typeof _hsq !== 'undefined') {
            _hsq.push(['trackEvent', properties]);
        }
    };
    Angulartics2Hubspot.prototype.setUserProperties = function (properties) {
        if (typeof _hsq !== 'undefined') {
            _hsq.push(['identify', properties]);
        }
    };
    Angulartics2Hubspot = __decorate([
        core_1.Injectable(),
        __metadata("design:paramtypes", [angulartics2_1.Angulartics2])
    ], Angulartics2Hubspot);
    return Angulartics2Hubspot;
}());
exports.Angulartics2Hubspot = Angulartics2Hubspot;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(3);
var common_1 = __webpack_require__(10);
var angulartics2_1 = __webpack_require__(6);
var Angulartics2AdobeAnalytics = /** @class */ (function () {
    function Angulartics2AdobeAnalytics(angulartics2, location) {
        var _this = this;
        this.angulartics2 = angulartics2;
        this.location = location;
        this.angulartics2.settings.pageTracking.trackRelativePath = true;
        this.angulartics2.pageTrack.subscribe(function (x) { return _this.pageTrack(x.path); });
        this.angulartics2.eventTrack.subscribe(function (x) { return _this.eventTrack(x.action, x.properties); });
        this.angulartics2.setUserProperties.subscribe(function (x) { return _this.setUserProperties(x); });
    }
    Angulartics2AdobeAnalytics.prototype.pageTrack = function (path) {
        if (typeof s !== 'undefined' && s) {
            s.clearVars();
            s.t({ pageName: path });
        }
    };
    /**
     * Track Event in Adobe Analytics
     * @name eventTrack
     *
     * @param {string} action Required 'action' (string) associated with the event
     * @param {object} properties Comprised of the mandatory field 'category' (string) and optional  fields 'label' (string), 'value' (integer) and 'noninteraction' (boolean)
     *
     * @link https://marketing.adobe.com/resources/help/en_US/sc/implement/js_implementation.html
     */
    Angulartics2AdobeAnalytics.prototype.eventTrack = function (action, properties) {
        if (!properties) {
            properties = properties || {};
        }
        if (typeof s !== 'undefined' && s) {
            if (typeof properties === 'object') {
                this.setUserProperties(properties);
            }
            if (action) {
                // if linkName property is passed, use that; otherwise, the action is the linkName
                var linkName = (properties['linkName']) ? properties['linkName'] : action;
                // note that 'this' should refer the link element, but we can't get that in this function. example:
                // <a href="http://anothersite.com" onclick="s.tl(this,'e','AnotherSite',null)">
                // if disableDelay property is passed, use that to turn off/on the 500ms delay; otherwise, it uses this
                var disableDelay = !!properties['disableDelay'] ? true : this;
                // if action property is passed, use that; otherwise, the action remains unchanged
                if (properties['action']) {
                    action = properties['action'];
                }
                this.setPageName();
                if (action.toUpperCase() === "DOWNLOAD") {
                    s.tl(disableDelay, 'd', linkName);
                }
                else if (action.toUpperCase() === "EXIT") {
                    s.tl(disableDelay, 'e', linkName);
                }
                else {
                    s.tl(disableDelay, 'o', linkName);
                }
            }
        }
    };
    Angulartics2AdobeAnalytics.prototype.setPageName = function () {
        var path = this.location.path(true);
        var hashNdx = path.indexOf('#');
        if (hashNdx > 0 && hashNdx < path.length) {
            s.pageName = path.substring(hashNdx + 1);
        }
        else {
            s.pageName = path;
        }
    };
    Angulartics2AdobeAnalytics.prototype.setUserProperties = function (properties) {
        if (typeof s !== 'undefined' && s) {
            if (typeof properties === 'object') {
                for (var key in properties) {
                    if (properties.hasOwnProperty(key)) {
                        s[key] = properties[key];
                    }
                }
            }
        }
    };
    Angulartics2AdobeAnalytics = __decorate([
        core_1.Injectable(),
        __metadata("design:paramtypes", [angulartics2_1.Angulartics2,
            common_1.Location])
    ], Angulartics2AdobeAnalytics);
    return Angulartics2AdobeAnalytics;
}());
exports.Angulartics2AdobeAnalytics = Angulartics2AdobeAnalytics;


/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBmYWMwMWZmYzEzZTZjNzEyZDVlOSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9jb21tb24vcHJlZGljYXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9ob2YuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiQGFuZ3VsYXIvY29yZVwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9jb21tb24vY29yZXNlcnZpY2VzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL2FuZ3VsYXJ0aWNzMi50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9zdHJpbmdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL3RyYWNlLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcIkBhbmd1bGFyL2NvbW1vblwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS90YXJnZXRTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9wYXJhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vcmVqZWN0RmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvbkhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9yZXNvbHZlL3Jlc29sdmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9hbmd1bGFyL2xpYi9kaXJlY3RpdmVzL3VpVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9nbG9iLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi90cmFuc2l0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvcGF0aC9wYXRoRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3Jlc29sdmUvcmVzb2x2ZUNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsTWF0Y2hlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvYmFzZUxvY2F0aW9uU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyeGpzL1JlcGxheVN1YmplY3RcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAYW5ndWxhci9yb3V0ZXJcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL3F1ZXVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi9ob29rUmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9wYXRoL3BhdGhOb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvcGFyYW1zL3BhcmFtVHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvblNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvYW5ndWxhci9saWIvc3RhdGVidWlsZGVycy92aWV3cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2FuZ3VsYXIvbGliL3VpUm91dGVyQ29uZmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvYW5ndWxhci9saWIvdWlSb3V0ZXJOZ01vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2FuZ3VsYXIvbGliL2RpcmVjdGl2ZXMvdWlTcmVmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvYW5ndWxhci9saWIvZGlyZWN0aXZlcy91aVNyZWZTdGF0dXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9hbmd1bGFyL2xpYi9wcm92aWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL2hvb2tCdWlsZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvcmVzb2x2ZS9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9wYXJhbXMvcGFyYW1UeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9zdGF0ZVBhcmFtcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlQnVpbGRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlTWF0Y2hlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlUXVldWVNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvc3RhdGUvc3RhdGVSZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxNYXRjaGVyRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsUnVsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZpZXcvdmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2dsb2JhbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL2xhenlMb2FkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi90cmFuc2l0aW9uRXZlbnRUeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9xLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9pbmplY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvaGFzaExvY2F0aW9uU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvbWVtb3J5TG9jYXRpb25TZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9wdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL21lbW9yeUxvY2F0aW9uQ29uZmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9icm93c2VyTG9jYXRpb25Db25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9hbmd1bGFyL2xpYi9kaXJlY3RpdmVzL2RpcmVjdGl2ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9hbmd1bGFyL2xpYi9kaXJlY3RpdmVzL3VpU3JlZkFjdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2FuZ3VsYXIvbGliL3N0YXRlYnVpbGRlcnMvbGF6eUxvYWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9hbmd1bGFyL2xpYi9sYXp5TG9hZC9sYXp5TG9hZE5nTW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvYW5ndWxhcnRpY3MyT24udHMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiIiwid2VicGFjazovLy8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2FuZ3VsYXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9wYXJhbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9wYXRoL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvcmVzb2x2ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvY29yZVJlc29sdmFibGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvcmVkaXJlY3RUby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL29uRW50ZXJFeGl0UmV0YWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvcmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL3ZpZXdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvdXBkYXRlR2xvYmFscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL3VybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL2lnbm9yZWRUcmFuc2l0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvaW52YWxpZFRyYW5zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdXJsL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmlldy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9wbHVnaW5zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaW50ZXJmYWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvYW5ndWxhci9saWIvbWVyZ2VJbmplY3Rvci5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyeGpzL0JlaGF2aW9yU3ViamVjdFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInJ4anMvb2JzZXJ2YWJsZS9vZlwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInJ4anMvb2JzZXJ2YWJsZS9mcm9tUHJvbWlzZVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInJ4anMvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0XCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicnhqcy9vcGVyYXRvci9zd2l0Y2hNYXBcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyeGpzL29wZXJhdG9yL21hcFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInJ4anMvb3BlcmF0b3IvY29uY2F0XCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9yeC9saWItZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvcngvbGliLWVzbS91aS1yb3V0ZXItcnguanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicnhqcy9hZGQvb3BlcmF0b3IvbWVyZ2VNYXBcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyeGpzL2FkZC9vcGVyYXRvci9tYXBcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2FuZ3VsYXIvbGliL2xvY2F0aW9uL2xvY2F0aW9uU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2FuZ3VsYXIvbGliL2xvY2F0aW9uL2xvY2F0aW9uQ29uZmlnLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcInJ4anMvYWRkL29wZXJhdG9yL2ZpbHRlclwiIiwid2VicGFjazovLy8uL3NyYy9wcm92aWRlcnMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Byb3ZpZGVycy9iYWlkdS9hbmd1bGFydGljczItYmFpZHUtYW5hbHl0aWNzLnRzIiwid2VicGFjazovLy8uL3NyYy9wcm92aWRlcnMvZ2EvYW5ndWxhcnRpY3MyLWdhLnRzIiwid2VicGFjazovLy8uL3NyYy9wcm92aWRlcnMvZ3RtL2FuZ3VsYXJ0aWNzMi1ndG0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Byb3ZpZGVycy9raXNzbWV0cmljcy9hbmd1bGFydGljczIta2lzc21ldHJpY3MudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Byb3ZpZGVycy9taXhwYW5lbC9hbmd1bGFydGljczItbWl4cGFuZWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Byb3ZpZGVycy9waXdpay9hbmd1bGFydGljczItcGl3aWsudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Byb3ZpZGVycy9zZWdtZW50L2FuZ3VsYXJ0aWNzMi1zZWdtZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9wcm92aWRlcnMvZmFjZWJvb2svYW5ndWxhcnRpY3MyLWZhY2Vib29rLnRzIiwid2VicGFjazovLy8uL3NyYy9wcm92aWRlcnMvYXBwaW5zaWdodHMvYW5ndWxhcnRpY3MyLWFwcGluc2lnaHRzLnRzIiwid2VicGFjazovLy8uL3NyYy9wcm92aWRlcnMvaHVic3BvdC9hbmd1bGFydGljczItaHVic3BvdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcHJvdmlkZXJzL2Fkb2JlYW5hbHl0aWNzL2FuZ3VsYXJ0aWNzMi1hZG9iZWFuYWx5dGljcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxh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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx5Qzs7Ozs7OztBQ3hGQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG9DQUFvQyxFQUFFO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUNBQXVDLEVBQUU7QUFDbkU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUNBQW1DLEVBQUU7QUFDL0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0NBQW9DLEVBQUU7QUFDaEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUNBQXFDLEVBQUU7QUFDakU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDZDQUE2QztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLHVDQUF1QyxFQUFFO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwrQkFBK0IsNERBQTREO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDZDOzs7Ozs7O0FDOUhBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0FBQyxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDM0IsQ0FBQztnQkFDSCxDQUFDO1lBQ0gsQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDO0lBcEZVLDBCQUEwQjtRQUR0QyxpQkFBVSxFQUFFO3lDQUlhLDJCQUFZO1lBQ2hCLGlCQUFRO09BSmpCLDBCQUEwQixDQXNGdEM7SUFBRCxpQ0FBQztDQUFBO0FBdEZZLGdFQUEwQiIsImZpbGUiOiJjb3JlLnVtZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIiksIHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIiksIHJlcXVpcmUoXCJyeGpzL1JlcGxheVN1YmplY3RcIiksIHJlcXVpcmUoXCJAYW5ndWxhci9yb3V0ZXJcIiksIHJlcXVpcmUoXCJAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyXCIpLCByZXF1aXJlKFwicnhqcy9CZWhhdmlvclN1YmplY3RcIiksIHJlcXVpcmUoXCJyeGpzL29ic2VydmFibGUvb2ZcIiksIHJlcXVpcmUoXCJyeGpzL29ic2VydmFibGUvZnJvbVByb21pc2VcIiksIHJlcXVpcmUoXCJyeGpzL29ic2VydmFibGUvY29tYmluZUxhdGVzdFwiKSwgcmVxdWlyZShcInJ4anMvb3BlcmF0b3Ivc3dpdGNoTWFwXCIpLCByZXF1aXJlKFwicnhqcy9vcGVyYXRvci9tYXBcIiksIHJlcXVpcmUoXCJyeGpzL29wZXJhdG9yL2NvbmNhdFwiKSwgcmVxdWlyZShcInJ4anMvYWRkL29wZXJhdG9yL21lcmdlTWFwXCIpLCByZXF1aXJlKFwicnhqcy9hZGQvb3BlcmF0b3IvbWFwXCIpLCByZXF1aXJlKFwicnhqcy9hZGQvb3BlcmF0b3IvZmlsdGVyXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcIkBhbmd1bGFyL2NvcmVcIiwgXCJAYW5ndWxhci9jb21tb25cIiwgXCJyeGpzL1JlcGxheVN1YmplY3RcIiwgXCJAYW5ndWxhci9yb3V0ZXJcIiwgXCJAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyXCIsIFwicnhqcy9CZWhhdmlvclN1YmplY3RcIiwgXCJyeGpzL29ic2VydmFibGUvb2ZcIiwgXCJyeGpzL29ic2VydmFibGUvZnJvbVByb21pc2VcIiwgXCJyeGpzL29ic2VydmFibGUvY29tYmluZUxhdGVzdFwiLCBcInJ4anMvb3BlcmF0b3Ivc3dpdGNoTWFwXCIsIFwicnhqcy9vcGVyYXRvci9tYXBcIiwgXCJyeGpzL29wZXJhdG9yL2NvbmNhdFwiLCBcInJ4anMvYWRkL29wZXJhdG9yL21lcmdlTWFwXCIsIFwicnhqcy9hZGQvb3BlcmF0b3IvbWFwXCIsIFwicnhqcy9hZGQvb3BlcmF0b3IvZmlsdGVyXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIm5neC10cmFuc2xhdGUtY29yZVwiXSA9IGZhY3RvcnkocmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIiksIHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIiksIHJlcXVpcmUoXCJyeGpzL1JlcGxheVN1YmplY3RcIiksIHJlcXVpcmUoXCJAYW5ndWxhci9yb3V0ZXJcIiksIHJlcXVpcmUoXCJAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyXCIpLCByZXF1aXJlKFwicnhqcy9CZWhhdmlvclN1YmplY3RcIiksIHJlcXVpcmUoXCJyeGpzL29ic2VydmFibGUvb2ZcIiksIHJlcXVpcmUoXCJyeGpzL29ic2VydmFibGUvZnJvbVByb21pc2VcIiksIHJlcXVpcmUoXCJyeGpzL29ic2VydmFibGUvY29tYmluZUxhdGVzdFwiKSwgcmVxdWlyZShcInJ4anMvb3BlcmF0b3Ivc3dpdGNoTWFwXCIpLCByZXF1aXJlKFwicnhqcy9vcGVyYXRvci9tYXBcIiksIHJlcXVpcmUoXCJyeGpzL29wZXJhdG9yL2NvbmNhdFwiKSwgcmVxdWlyZShcInJ4anMvYWRkL29wZXJhdG9yL21lcmdlTWFwXCIpLCByZXF1aXJlKFwicnhqcy9hZGQvb3BlcmF0b3IvbWFwXCIpLCByZXF1aXJlKFwicnhqcy9hZGQvb3BlcmF0b3IvZmlsdGVyXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJuZ3gtdHJhbnNsYXRlLWNvcmVcIl0gPSBmYWN0b3J5KHJvb3RbXCJAYW5ndWxhci9jb3JlXCJdLCByb290W1wiQGFuZ3VsYXIvY29tbW9uXCJdLCByb290W1wicnhqcy9SZXBsYXlTdWJqZWN0XCJdLCByb290W1wiQGFuZ3VsYXIvcm91dGVyXCJdLCByb290W1wiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiXSwgcm9vdFtcInJ4anMvQmVoYXZpb3JTdWJqZWN0XCJdLCByb290W1wicnhqcy9vYnNlcnZhYmxlL29mXCJdLCByb290W1wicnhqcy9vYnNlcnZhYmxlL2Zyb21Qcm9taXNlXCJdLCByb290W1wicnhqcy9vYnNlcnZhYmxlL2NvbWJpbmVMYXRlc3RcIl0sIHJvb3RbXCJyeGpzL29wZXJhdG9yL3N3aXRjaE1hcFwiXSwgcm9vdFtcInJ4anMvb3BlcmF0b3IvbWFwXCJdLCByb290W1wicnhqcy9vcGVyYXRvci9jb25jYXRcIl0sIHJvb3RbXCJyeGpzL2FkZC9vcGVyYXRvci9tZXJnZU1hcFwiXSwgcm9vdFtcInJ4anMvYWRkL29wZXJhdG9yL21hcFwiXSwgcm9vdFtcInJ4anMvYWRkL29wZXJhdG9yL2ZpbHRlclwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzNfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xMF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzI0X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMjVfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV83MF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzk1X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfOTZfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV85N19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzk4X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfOTlfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xMDBfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xMDFfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xMDRfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xMDVfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xMDhfXykge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNzEpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGZhYzAxZmZjMTNlNmM3MTJkNWU5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFJhbmRvbSB1dGlsaXR5IGZ1bmN0aW9ucyB1c2VkIGluIHRoZSBVSS1Sb3V0ZXIgY29kZVxuICpcbiAqIFRoZXNlIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQsIGJ1dCBhcmUgc3ViamVjdCB0byBjaGFuZ2Ugd2l0aG91dCBub3RpY2UuXG4gKlxuICogQHByZWZlcnJlZFxuICogQG1vZHVsZSBjb21tb25cbiAqL1xuLyoqIGZvciB0eXBlZG9jICovXG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4vcHJlZGljYXRlc1wiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuL2hvZlwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuL2NvcmVzZXJ2aWNlc1wiKTtcbmV4cG9ydHMucm9vdCA9ICh0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgJiYgc2VsZi5zZWxmID09PSBzZWxmICYmIHNlbGYpIHx8XG4gICAgKHR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnICYmIGdsb2JhbC5nbG9iYWwgPT09IGdsb2JhbCAmJiBnbG9iYWwpIHx8IHRoaXM7XG52YXIgYW5ndWxhciA9IGV4cG9ydHMucm9vdC5hbmd1bGFyIHx8IHt9O1xuZXhwb3J0cy5mcm9tSnNvbiA9IGFuZ3VsYXIuZnJvbUpzb24gfHwgSlNPTi5wYXJzZS5iaW5kKEpTT04pO1xuZXhwb3J0cy50b0pzb24gPSBhbmd1bGFyLnRvSnNvbiB8fCBKU09OLnN0cmluZ2lmeS5iaW5kKEpTT04pO1xuZXhwb3J0cy5mb3JFYWNoID0gYW5ndWxhci5mb3JFYWNoIHx8IF9mb3JFYWNoO1xuZXhwb3J0cy5leHRlbmQgPSBPYmplY3QuYXNzaWduIHx8IF9leHRlbmQ7XG5leHBvcnRzLmVxdWFscyA9IGFuZ3VsYXIuZXF1YWxzIHx8IF9lcXVhbHM7XG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7IHJldHVybiB4OyB9XG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG5mdW5jdGlvbiBub29wKCkgeyB9XG5leHBvcnRzLm5vb3AgPSBub29wO1xuLyoqXG4gKiBCdWlsZHMgcHJveHkgZnVuY3Rpb25zIG9uIHRoZSBgdG9gIG9iamVjdCB3aGljaCBwYXNzIHRocm91Z2ggdG8gdGhlIGBmcm9tYCBvYmplY3QuXG4gKlxuICogRm9yIGVhY2gga2V5IGluIGBmbk5hbWVzYCwgY3JlYXRlcyBhIHByb3h5IGZ1bmN0aW9uIG9uIHRoZSBgdG9gIG9iamVjdC5cbiAqIFRoZSBwcm94eSBmdW5jdGlvbiBjYWxscyB0aGUgcmVhbCBmdW5jdGlvbiBvbiB0aGUgYGZyb21gIG9iamVjdC5cbiAqXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgYW4gbmV3IGNsYXNzIGluc3RhbmNlIHdob3NlIGZ1bmN0aW9ucyBhcmUgcHJlYm91bmQgdG8gdGhlIG5ldydkIG9iamVjdC5cbiAqIGBgYGpzXG4gKiBjbGFzcyBGb28ge1xuICogICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gKiAgICAgLy8gQmluZHMgYWxsIGZ1bmN0aW9ucyBmcm9tIEZvby5wcm90b3R5cGUgdG8gJ3RoaXMnLFxuICogICAgIC8vIHRoZW4gY29waWVzIHRoZW0gdG8gJ3RoaXMnXG4gKiAgICAgYmluZEZ1bmN0aW9ucyhGb28ucHJvdG90eXBlLCB0aGlzLCB0aGlzKTtcbiAqICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICogICB9XG4gKlxuICogICBsb2coKSB7XG4gKiAgICAgY29uc29sZS5sb2codGhpcy5kYXRhKTtcbiAqICAgfVxuICogfVxuICpcbiAqIGxldCBteUZvbyA9IG5ldyBGb28oWzEsMiwzXSk7XG4gKiB2YXIgbG9naXQgPSBteUZvby5sb2c7XG4gKiBsb2dpdCgpOyAvLyBsb2dzIFsxLCAyLCAzXSBmcm9tIHRoZSBteUZvbyAndGhpcycgaW5zdGFuY2VcbiAqIGBgYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIFRoaXMgZXhhbXBsZSBjcmVhdGVzIGEgYm91bmQgdmVyc2lvbiBvZiBhIHNlcnZpY2UgZnVuY3Rpb24sIGFuZCBjb3BpZXMgaXQgdG8gYW5vdGhlciBvYmplY3RcbiAqIGBgYFxuICpcbiAqIHZhciBTb21lU2VydmljZSA9IHtcbiAqICAgdGhpcy5kYXRhID0gWzMsIDQsIDVdO1xuICogICB0aGlzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICogICAgIGNvbnNvbGUubG9nKHRoaXMuZGF0YSk7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiAvLyBDb25zdHJ1Y3RvciBmblxuICogZnVuY3Rpb24gT3RoZXJUaGluZygpIHtcbiAqICAgLy8gQmluZHMgYWxsIGZ1bmN0aW9ucyBmcm9tIFNvbWVTZXJ2aWNlIHRvIFNvbWVTZXJ2aWNlLFxuICogICAvLyB0aGVuIGNvcGllcyB0aGVtIHRvICd0aGlzJ1xuICogICBiaW5kRnVuY3Rpb25zKFNvbWVTZXJ2aWNlLCB0aGlzLCBTb21lU2VydmljZSk7XG4gKiB9XG4gKlxuICogbGV0IG15T3RoZXJUaGluZyA9IG5ldyBPdGhlclRoaW5nKCk7XG4gKiBteU90aGVyVGhpbmcubG9nKCk7IC8vIGxvZ3MgWzMsIDQsIDVdIGZyb20gU29tZVNlcnZpY2UncyAndGhpcydcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzb3VyY2UgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHNvdXJjZSBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9ucyB0byBiZSBib3VuZFxuICogQHBhcmFtIHRhcmdldCBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdGFyZ2V0IG9iamVjdCB3aGljaCB3aWxsIHJlY2VpdmUgdGhlIGJvdW5kIGZ1bmN0aW9uc1xuICogQHBhcmFtIGJpbmQgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG9iamVjdCB3aGljaCB0aGUgZnVuY3Rpb25zIHdpbGwgYmUgYm91bmQgdG9cbiAqIEBwYXJhbSBmbk5hbWVzIFRoZSBmdW5jdGlvbiBuYW1lcyB3aGljaCB3aWxsIGJlIGJvdW5kIChEZWZhdWx0cyB0byBhbGwgdGhlIGZ1bmN0aW9ucyBmb3VuZCBvbiB0aGUgJ2Zyb20nIG9iamVjdClcbiAqIEBwYXJhbSBsYXRlYmluZCBJZiB0cnVlLCB0aGUgYmluZGluZyBvZiB0aGUgZnVuY3Rpb24gaXMgZGVsYXllZCB1bnRpbCB0aGUgZmlyc3QgdGltZSBpdCdzIGludm9rZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJveHlGdW5jdGlvbnMoc291cmNlLCB0YXJnZXQsIGJpbmQsIGZuTmFtZXMsIGxhdGViaW5kKSB7XG4gICAgaWYgKGxhdGViaW5kID09PSB2b2lkIDApIHsgbGF0ZWJpbmQgPSBmYWxzZTsgfVxuICAgIHZhciBiaW5kRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm5OYW1lKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UoKVtmbk5hbWVdLmJpbmQoYmluZCgpKTtcbiAgICB9O1xuICAgIHZhciBtYWtlTGF0ZVJlYmluZEZuID0gZnVuY3Rpb24gKGZuTmFtZSkgeyByZXR1cm4gZnVuY3Rpb24gbGF0ZVJlYmluZEZ1bmN0aW9uKCkge1xuICAgICAgICB0YXJnZXRbZm5OYW1lXSA9IGJpbmRGdW5jdGlvbihmbk5hbWUpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0W2ZuTmFtZV0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9OyB9O1xuICAgIGZuTmFtZXMgPSBmbk5hbWVzIHx8IE9iamVjdC5rZXlzKHNvdXJjZSgpKTtcbiAgICByZXR1cm4gZm5OYW1lcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbmFtZSkge1xuICAgICAgICBhY2NbbmFtZV0gPSBsYXRlYmluZCA/IG1ha2VMYXRlUmViaW5kRm4obmFtZSkgOiBiaW5kRnVuY3Rpb24obmFtZSk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgdGFyZ2V0KTtcbn1cbmV4cG9ydHMuY3JlYXRlUHJveHlGdW5jdGlvbnMgPSBjcmVhdGVQcm94eUZ1bmN0aW9ucztcbi8qKlxuICogcHJvdG90eXBhbCBpbmhlcml0YW5jZSBoZWxwZXIuXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aGljaCBoYXMgYHBhcmVudGAgb2JqZWN0IGFzIGl0cyBwcm90b3R5cGUsIGFuZCB0aGVuIGNvcGllcyB0aGUgcHJvcGVydGllcyBmcm9tIGBleHRyYWAgb250byBpdFxuICovXG5leHBvcnRzLmluaGVyaXQgPSBmdW5jdGlvbiAocGFyZW50LCBleHRyYSkge1xuICAgIHJldHVybiBleHBvcnRzLmV4dGVuZChPYmplY3QuY3JlYXRlKHBhcmVudCksIGV4dHJhKTtcbn07XG4vKiogR2l2ZW4gYW4gYXJyYXksIHJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGZvdW5kIGluIHRoZSBhcnJheSwgKHVzaW5nIGluZGV4T2YpICovXG5leHBvcnRzLmluQXJyYXkgPSBob2ZfMS5jdXJyeShfaW5BcnJheSk7XG5mdW5jdGlvbiBfaW5BcnJheShhcnJheSwgb2JqKSB7XG4gICAgcmV0dXJuIGFycmF5LmluZGV4T2Yob2JqKSAhPT0gLTE7XG59XG5leHBvcnRzLl9pbkFycmF5ID0gX2luQXJyYXk7XG4vKipcbiAqIEdpdmVuIGFuIGFycmF5LCBhbmQgYW4gaXRlbSwgaWYgdGhlIGl0ZW0gaXMgZm91bmQgaW4gdGhlIGFycmF5LCBpdCByZW1vdmVzIGl0IChpbi1wbGFjZSkuXG4gKiBUaGUgc2FtZSBhcnJheSBpcyByZXR1cm5lZFxuICovXG5leHBvcnRzLnJlbW92ZUZyb20gPSBob2ZfMS5jdXJyeShfcmVtb3ZlRnJvbSk7XG5mdW5jdGlvbiBfcmVtb3ZlRnJvbShhcnJheSwgb2JqKSB7XG4gICAgdmFyIGlkeCA9IGFycmF5LmluZGV4T2Yob2JqKTtcbiAgICBpZiAoaWR4ID49IDApXG4gICAgICAgIGFycmF5LnNwbGljZShpZHgsIDEpO1xuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydHMuX3JlbW92ZUZyb20gPSBfcmVtb3ZlRnJvbTtcbi8qKiBwdXNoZXMgYSB2YWx1ZXMgdG8gYW4gYXJyYXkgYW5kIHJldHVybnMgdGhlIHZhbHVlICovXG5leHBvcnRzLnB1c2hUbyA9IGhvZl8xLmN1cnJ5KF9wdXNoVG8pO1xuZnVuY3Rpb24gX3B1c2hUbyhhcnIsIHZhbCkge1xuICAgIHJldHVybiAoYXJyLnB1c2godmFsKSwgdmFsKTtcbn1cbmV4cG9ydHMuX3B1c2hUbyA9IF9wdXNoVG87XG4vKiogR2l2ZW4gYW4gYXJyYXkgb2YgKGRlcmVnaXN0cmF0aW9uKSBmdW5jdGlvbnMsIGNhbGxzIGFsbCBmdW5jdGlvbnMgYW5kIHJlbW92ZXMgZWFjaCBvbmUgZnJvbSB0aGUgc291cmNlIGFycmF5ICovXG5leHBvcnRzLmRlcmVnQWxsID0gZnVuY3Rpb24gKGZ1bmN0aW9ucykge1xuICAgIHJldHVybiBmdW5jdGlvbnMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgZm4oKTtcbiAgICAgICAgZXhwb3J0cy5yZW1vdmVGcm9tKGZ1bmN0aW9ucywgZm4pO1xuICAgIH0pO1xufTtcbi8qKlxuICogQXBwbGllcyBhIHNldCBvZiBkZWZhdWx0cyB0byBhbiBvcHRpb25zIG9iamVjdC4gIFRoZSBvcHRpb25zIG9iamVjdCBpcyBmaWx0ZXJlZFxuICogdG8gb25seSB0aG9zZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3RzIGluIHRoZSBkZWZhdWx0c0xpc3QuXG4gKiBFYXJsaWVyIG9iamVjdHMgaW4gdGhlIGRlZmF1bHRzTGlzdCB0YWtlIHByZWNlZGVuY2Ugd2hlbiBhcHBseWluZyBkZWZhdWx0cy5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdHMob3B0cykge1xuICAgIHZhciBkZWZhdWx0c0xpc3QgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBkZWZhdWx0c0xpc3RbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBfZGVmYXVsdHNMaXN0ID0gZGVmYXVsdHNMaXN0LmNvbmNhdCh7fSkucmV2ZXJzZSgpO1xuICAgIHZhciBkZWZhdWx0VmFscyA9IGV4cG9ydHMuZXh0ZW5kLmFwcGx5KG51bGwsIF9kZWZhdWx0c0xpc3QpO1xuICAgIHJldHVybiBleHBvcnRzLmV4dGVuZCh7fSwgZGVmYXVsdFZhbHMsIHBpY2sob3B0cyB8fCB7fSwgT2JqZWN0LmtleXMoZGVmYXVsdFZhbHMpKSk7XG59XG5leHBvcnRzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4vKiogUmVkdWNlIGZ1bmN0aW9uIHRoYXQgbWVyZ2VzIGVhY2ggZWxlbWVudCBvZiB0aGUgbGlzdCBpbnRvIGEgc2luZ2xlIG9iamVjdCwgdXNpbmcgZXh0ZW5kICovXG5leHBvcnRzLm1lcmdlUiA9IGZ1bmN0aW9uIChtZW1vLCBpdGVtKSB7IHJldHVybiBleHBvcnRzLmV4dGVuZChtZW1vLCBpdGVtKTsgfTtcbi8qKlxuICogRmluZHMgdGhlIGNvbW1vbiBhbmNlc3RvciBwYXRoIGJldHdlZW4gdHdvIHN0YXRlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmlyc3QgVGhlIGZpcnN0IHN0YXRlLlxuICogQHBhcmFtIHtPYmplY3R9IHNlY29uZCBUaGUgc2Vjb25kIHN0YXRlLlxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2Ygc3RhdGUgbmFtZXMgaW4gZGVzY2VuZGluZyBvcmRlciwgbm90IGluY2x1ZGluZyB0aGUgcm9vdC5cbiAqL1xuZnVuY3Rpb24gYW5jZXN0b3JzKGZpcnN0LCBzZWNvbmQpIHtcbiAgICB2YXIgcGF0aCA9IFtdO1xuICAgIGZvciAodmFyIG4gaW4gZmlyc3QucGF0aCkge1xuICAgICAgICBpZiAoZmlyc3QucGF0aFtuXSAhPT0gc2Vjb25kLnBhdGhbbl0pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgcGF0aC5wdXNoKGZpcnN0LnBhdGhbbl0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbmV4cG9ydHMuYW5jZXN0b3JzID0gYW5jZXN0b3JzO1xuLyoqXG4gKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYFxuICogdmFyIGZvbyA9IHsgYTogMSwgYjogMiwgYzogMyB9O1xuICogdmFyIGFiID0gcGljayhmb28sIFsnYScsICdiJ10pOyAvLyB7IGE6IDEsIGI6IDIgfVxuICogYGBgXG4gKiBAcGFyYW0gb2JqIHRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0gcHJvcE5hbWVzIGFuIEFycmF5IG9mIHN0cmluZ3MsIHdoaWNoIGFyZSB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydHkgbmFtZXNcbiAqL1xuZnVuY3Rpb24gcGljayhvYmosIHByb3BOYW1lcykge1xuICAgIHZhciBvYmpDb3B5ID0ge307XG4gICAgZm9yICh2YXIgcHJvcF8xIGluIG9iaikge1xuICAgICAgICBpZiAocHJvcE5hbWVzLmluZGV4T2YocHJvcF8xKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIG9iakNvcHlbcHJvcF8xXSA9IG9ialtwcm9wXzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmpDb3B5O1xufVxuZXhwb3J0cy5waWNrID0gcGljaztcbi8qKlxuICogUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9taXR0aW5nIHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiB2YXIgZm9vID0geyBhOiAxLCBiOiAyLCBjOiAzIH07XG4gKiB2YXIgYWIgPSBvbWl0KGZvbywgWydhJywgJ2InXSk7IC8vIHsgYzogMyB9XG4gKiBgYGBcbiAqIEBwYXJhbSBvYmogdGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSBwcm9wTmFtZXMgYW4gQXJyYXkgb2Ygc3RyaW5ncywgd2hpY2ggYXJlIHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0eSBuYW1lc1xuICovXG5mdW5jdGlvbiBvbWl0KG9iaiwgcHJvcE5hbWVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgICAgICAgLmZpbHRlcihob2ZfMS5ub3QoZXhwb3J0cy5pbkFycmF5KHByb3BOYW1lcykpKVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkgeyByZXR1cm4gKGFjY1trZXldID0gb2JqW2tleV0sIGFjYyk7IH0sIHt9KTtcbn1cbmV4cG9ydHMub21pdCA9IG9taXQ7XG4vKipcbiAqIE1hcHMgYW4gYXJyYXksIG9yIG9iamVjdCB0byBhIHByb3BlcnR5IChieSBuYW1lKVxuICovXG5mdW5jdGlvbiBwbHVjayhjb2xsZWN0aW9uLCBwcm9wTmFtZSkge1xuICAgIHJldHVybiBtYXAoY29sbGVjdGlvbiwgaG9mXzEucHJvcChwcm9wTmFtZSkpO1xufVxuZXhwb3J0cy5wbHVjayA9IHBsdWNrO1xuLyoqIEZpbHRlcnMgYW4gQXJyYXkgb3IgYW4gT2JqZWN0J3MgcHJvcGVydGllcyBiYXNlZCBvbiBhIHByZWRpY2F0ZSAqL1xuZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyciA9IHByZWRpY2F0ZXNfMS5pc0FycmF5KGNvbGxlY3Rpb24pLCByZXN1bHQgPSBhcnIgPyBbXSA6IHt9O1xuICAgIHZhciBhY2NlcHQgPSBhcnIgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4gcmVzdWx0LnB1c2goeCk7IH0gOiBmdW5jdGlvbiAoeCwga2V5KSB7IHJldHVybiByZXN1bHRba2V5XSA9IHg7IH07XG4gICAgZXhwb3J0cy5mb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhpdGVtLCBpKSlcbiAgICAgICAgICAgIGFjY2VwdChpdGVtLCBpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7XG4vKiogRmluZHMgYW4gb2JqZWN0IGZyb20gYW4gYXJyYXksIG9yIGEgcHJvcGVydHkgb2YgYW4gb2JqZWN0LCB0aGF0IG1hdGNoZXMgYSBwcmVkaWNhdGUgKi9cbmZ1bmN0aW9uIGZpbmQoY29sbGVjdGlvbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGV4cG9ydHMuZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoY2FsbGJhY2soaXRlbSwgaSkpXG4gICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmZpbmQgPSBmaW5kO1xuLyoqIEdpdmVuIGFuIG9iamVjdCwgcmV0dXJucyBhIG5ldyBvYmplY3QsIHdoZXJlIGVhY2ggcHJvcGVydHkgaXMgdHJhbnNmb3JtZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uICovXG5leHBvcnRzLm1hcE9iaiA9IG1hcDtcbi8qKiBNYXBzIGFuIGFycmF5IG9yIG9iamVjdCBwcm9wZXJ0aWVzIHVzaW5nIGEgY2FsbGJhY2sgZnVuY3Rpb24gKi9cbmZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBjYWxsYmFjaykge1xuICAgIHZhciByZXN1bHQgPSBwcmVkaWNhdGVzXzEuaXNBcnJheShjb2xsZWN0aW9uKSA/IFtdIDoge307XG4gICAgZXhwb3J0cy5mb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uIChpdGVtLCBpKSB7IHJldHVybiByZXN1bHRbaV0gPSBjYWxsYmFjayhpdGVtLCBpKTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMubWFwID0gbWFwO1xuLyoqXG4gKiBHaXZlbiBhbiBvYmplY3QsIHJldHVybiBpdHMgZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IGZvbyA9IHsgYTogMSwgYjogMiwgYzogMyB9XG4gKiBsZXQgdmFscyA9IHZhbHVlcyhmb28pOyAvLyBbIDEsIDIsIDMgXVxuICogYGBgXG4gKi9cbmV4cG9ydHMudmFsdWVzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBvYmpba2V5XTsgfSk7XG59O1xuLyoqXG4gKiBSZWR1Y2UgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgYWxsIG9mIHRoZSB2YWx1ZXMgYXJlIHRydXRoeS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IHZhbHMgPSBbIDEsIHRydWUsIHt9LCBcImhlbGxvIHdvcmxkXCJdO1xuICogdmFscy5yZWR1Y2UoYWxsVHJ1ZVIsIHRydWUpOyAvLyB0cnVlXG4gKlxuICogdmFscy5wdXNoKDApO1xuICogdmFscy5yZWR1Y2UoYWxsVHJ1ZVIsIHRydWUpOyAvLyBmYWxzZVxuICogYGBgXG4gKi9cbmV4cG9ydHMuYWxsVHJ1ZVIgPSBmdW5jdGlvbiAobWVtbywgZWxlbSkgeyByZXR1cm4gbWVtbyAmJiBlbGVtOyB9O1xuLyoqXG4gKiBSZWR1Y2UgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgYW55IG9mIHRoZSB2YWx1ZXMgYXJlIHRydXRoeS5cbiAqXG4gKiAgKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IHZhbHMgPSBbIDAsIG51bGwsIHVuZGVmaW5lZCBdO1xuICogdmFscy5yZWR1Y2UoYW55VHJ1ZVIsIHRydWUpOyAvLyBmYWxzZVxuICpcbiAqIHZhbHMucHVzaChcImhlbGxvIHdvcmxkXCIpO1xuICogdmFscy5yZWR1Y2UoYW55VHJ1ZVIsIHRydWUpOyAvLyB0cnVlXG4gKiBgYGBcbiAqL1xuZXhwb3J0cy5hbnlUcnVlUiA9IGZ1bmN0aW9uIChtZW1vLCBlbGVtKSB7IHJldHVybiBtZW1vIHx8IGVsZW07IH07XG4vKipcbiAqIFJlZHVjZSBmdW5jdGlvbiB3aGljaCB1bi1uZXN0cyBhIHNpbmdsZSBsZXZlbCBvZiBhcnJheXNcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgaW5wdXQgPSBbIFsgXCJhXCIsIFwiYlwiIF0sIFsgXCJjXCIsIFwiZFwiIF0sIFsgWyBcImRvdWJsZVwiLCBcIm5lc3RlZFwiIF0gXSBdO1xuICogaW5wdXQucmVkdWNlKHVubmVzdFIsIFtdKSAvLyBbIFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBbIFwiZG91YmxlLCBcIm5lc3RlZFwiIF0gXVxuICogYGBgXG4gKi9cbmV4cG9ydHMudW5uZXN0UiA9IGZ1bmN0aW9uIChtZW1vLCBlbGVtKSB7IHJldHVybiBtZW1vLmNvbmNhdChlbGVtKTsgfTtcbi8qKlxuICogUmVkdWNlIGZ1bmN0aW9uIHdoaWNoIHJlY3Vyc2l2ZWx5IHVuLW5lc3RzIGFsbCBhcnJheXNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IGlucHV0ID0gWyBbIFwiYVwiLCBcImJcIiBdLCBbIFwiY1wiLCBcImRcIiBdLCBbIFsgXCJkb3VibGVcIiwgXCJuZXN0ZWRcIiBdIF0gXTtcbiAqIGlucHV0LnJlZHVjZSh1bm5lc3RSLCBbXSkgLy8gWyBcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIiwgXCJkb3VibGUsIFwibmVzdGVkXCIgXVxuICogYGBgXG4gKi9cbmV4cG9ydHMuZmxhdHRlblIgPSBmdW5jdGlvbiAobWVtbywgZWxlbSkge1xuICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNBcnJheShlbGVtKSA/IG1lbW8uY29uY2F0KGVsZW0ucmVkdWNlKGV4cG9ydHMuZmxhdHRlblIsIFtdKSkgOiBwdXNoUihtZW1vLCBlbGVtKTtcbn07XG4vKipcbiAqIFJlZHVjZSBmdW5jdGlvbiB0aGF0IHB1c2hlcyBhbiBvYmplY3QgdG8gYW4gYXJyYXksIHRoZW4gcmV0dXJucyB0aGUgYXJyYXkuXG4gKiBNb3N0bHkganVzdCBmb3IgW1tmbGF0dGVuUl1dIGFuZCBbW3VuaXFSXV1cbiAqL1xuZnVuY3Rpb24gcHVzaFIoYXJyLCBvYmopIHtcbiAgICBhcnIucHVzaChvYmopO1xuICAgIHJldHVybiBhcnI7XG59XG5leHBvcnRzLnB1c2hSID0gcHVzaFI7XG4vKiogUmVkdWNlIGZ1bmN0aW9uIHRoYXQgZmlsdGVycyBvdXQgZHVwbGljYXRlcyAqL1xuZXhwb3J0cy51bmlxUiA9IGZ1bmN0aW9uIChhY2MsIHRva2VuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuaW5BcnJheShhY2MsIHRva2VuKSA/IGFjYyA6IHB1c2hSKGFjYywgdG9rZW4pO1xufTtcbi8qKlxuICogUmV0dXJuIGEgbmV3IGFycmF5IHdpdGggYSBzaW5nbGUgbGV2ZWwgb2YgYXJyYXlzIHVubmVzdGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgaW5wdXQgPSBbIFsgXCJhXCIsIFwiYlwiIF0sIFsgXCJjXCIsIFwiZFwiIF0sIFsgWyBcImRvdWJsZVwiLCBcIm5lc3RlZFwiIF0gXSBdO1xuICogdW5uZXN0KGlucHV0KSAvLyBbIFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBbIFwiZG91YmxlLCBcIm5lc3RlZFwiIF0gXVxuICogYGBgXG4gKi9cbmV4cG9ydHMudW5uZXN0ID0gZnVuY3Rpb24gKGFycikgeyByZXR1cm4gYXJyLnJlZHVjZShleHBvcnRzLnVubmVzdFIsIFtdKTsgfTtcbi8qKlxuICogUmV0dXJuIGEgY29tcGxldGVseSBmbGF0dGVuZWQgdmVyc2lvbiBvZiBhbiBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IGlucHV0ID0gWyBbIFwiYVwiLCBcImJcIiBdLCBbIFwiY1wiLCBcImRcIiBdLCBbIFsgXCJkb3VibGVcIiwgXCJuZXN0ZWRcIiBdIF0gXTtcbiAqIGZsYXR0ZW4oaW5wdXQpIC8vIFsgXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZG91YmxlLCBcIm5lc3RlZFwiIF1cbiAqIGBgYFxuICovXG5leHBvcnRzLmZsYXR0ZW4gPSBmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBhcnIucmVkdWNlKGV4cG9ydHMuZmxhdHRlblIsIFtdKTsgfTtcbi8qKlxuICogR2l2ZW4gYSAuZmlsdGVyIFByZWRpY2F0ZSwgYnVpbGRzIGEgLmZpbHRlciBQcmVkaWNhdGUgd2hpY2ggdGhyb3dzIGFuIGVycm9yIGlmIGFueSBlbGVtZW50cyBkbyBub3QgcGFzcy5cbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgaXNOdW1iZXIgPSAob2JqKSA9PiB0eXBlb2Yob2JqKSA9PT0gJ251bWJlcic7XG4gKiBsZXQgYWxsTnVtYmVycyA9IFsgMSwgMiwgMywgNCwgNSBdO1xuICogYWxsTnVtYmVycy5maWx0ZXIoYXNzZXJ0UHJlZGljYXRlKGlzTnVtYmVyKSk7IC8vT0tcbiAqXG4gKiBsZXQgb25lU3RyaW5nID0gWyAxLCAyLCAzLCA0LCBcIjVcIiBdO1xuICogb25lU3RyaW5nLmZpbHRlcihhc3NlcnRQcmVkaWNhdGUoaXNOdW1iZXIsIFwiTm90IGFsbCBudW1iZXJzXCIpKTsgLy8gdGhyb3dzIEVycm9yKFwiXCJOb3QgYWxsIG51bWJlcnNcIlwiKTtcbiAqIGBgYFxuICovXG5leHBvcnRzLmFzc2VydFByZWRpY2F0ZSA9IGFzc2VydEZuO1xuLyoqXG4gKiBHaXZlbiBhIC5tYXAgZnVuY3Rpb24sIGJ1aWxkcyBhIC5tYXAgZnVuY3Rpb24gd2hpY2ggdGhyb3dzIGFuIGVycm9yIGlmIGFueSBtYXBwZWQgZWxlbWVudHMgZG8gbm90IHBhc3MgYSB0cnV0aHluZXNzIHRlc3QuXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogdmFyIGRhdGEgPSB7IGZvbzogMSwgYmFyOiAyIH07XG4gKlxuICogbGV0IGtleXMgPSBbICdmb28nLCAnYmFyJyBdXG4gKiBsZXQgdmFsdWVzID0ga2V5cy5tYXAoYXNzZXJ0TWFwKGtleSA9PiBkYXRhW2tleV0sIFwiS2V5IG5vdCBmb3VuZFwiKSk7XG4gKiAvLyB2YWx1ZXMgaXMgWzEsIDJdXG4gKlxuICogbGV0IGtleXMgPSBbICdmb28nLCAnYmFyJywgJ2JheicgXVxuICogbGV0IHZhbHVlcyA9IGtleXMubWFwKGFzc2VydE1hcChrZXkgPT4gZGF0YVtrZXldLCBcIktleSBub3QgZm91bmRcIikpO1xuICogLy8gdGhyb3dzIEVycm9yKFwiS2V5IG5vdCBmb3VuZFwiKVxuICogYGBgXG4gKi9cbmV4cG9ydHMuYXNzZXJ0TWFwID0gYXNzZXJ0Rm47XG5mdW5jdGlvbiBhc3NlcnRGbihwcmVkaWNhdGVPck1hcCwgZXJyTXNnKSB7XG4gICAgaWYgKGVyck1zZyA9PT0gdm9pZCAwKSB7IGVyck1zZyA9IFwiYXNzZXJ0IGZhaWx1cmVcIjsgfVxuICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBwcmVkaWNhdGVPck1hcChvYmopO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKGVyck1zZykgPyBlcnJNc2cob2JqKSA6IGVyck1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuZXhwb3J0cy5hc3NlcnRGbiA9IGFzc2VydEZuO1xuLyoqXG4gKiBMaWtlIF8ucGFpcnM6IEdpdmVuIGFuIG9iamVjdCwgcmV0dXJucyBhbiBhcnJheSBvZiBrZXkvdmFsdWUgcGFpcnNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogcGFpcnMoeyBmb286IFwiRk9PXCIsIGJhcjogXCJCQVIgfSkgLy8gWyBbIFwiZm9vXCIsIFwiRk9PXCIgXSwgWyBcImJhclwiOiBcIkJBUlwiIF0gXVxuICogYGBgXG4gKi9cbmV4cG9ydHMucGFpcnMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIFtrZXksIG9ialtrZXldXTsgfSk7XG59O1xuLyoqXG4gKiBHaXZlbiB0d28gb3IgbW9yZSBwYXJhbGxlbCBhcnJheXMsIHJldHVybnMgYW4gYXJyYXkgb2YgdHVwbGVzIHdoZXJlXG4gKiBlYWNoIHR1cGxlIGlzIGNvbXBvc2VkIG9mIFsgYVtpXSwgYltpXSwgLi4uIHpbaV0gXVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgZm9vID0gWyAwLCAyLCA0LCA2IF07XG4gKiBsZXQgYmFyID0gWyAxLCAzLCA1LCA3IF07XG4gKiBsZXQgYmF6ID0gWyAxMCwgMzAsIDUwLCA3MCBdO1xuICogYXJyYXlUdXBsZXMoZm9vLCBiYXIpOyAgICAgICAvLyBbIFswLCAxXSwgWzIsIDNdLCBbNCwgNV0sIFs2LCA3XSBdXG4gKiBhcnJheVR1cGxlcyhmb28sIGJhciwgYmF6KTsgIC8vIFsgWzAsIDEsIDEwXSwgWzIsIDMsIDMwXSwgWzQsIDUsIDUwXSwgWzYsIDcsIDcwXSBdXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gYXJyYXlUdXBsZXMoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIHZhciBtYXhBcnJheUxlbiA9IGFyZ3MucmVkdWNlKGZ1bmN0aW9uIChtaW4sIGFycikgeyByZXR1cm4gTWF0aC5taW4oYXJyLmxlbmd0aCwgbWluKTsgfSwgOTAwNzE5OTI1NDc0MDk5MSk7IC8vIGFrYSAyXjUzIOKIkiAxIGFrYSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICAgIHZhciBpLCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWF4QXJyYXlMZW47IGkrKykge1xuICAgICAgICAvLyBUaGlzIGlzIGEgaG90IGZ1bmN0aW9uXG4gICAgICAgIC8vIFVucm9sbCB3aGVuIHRoZXJlIGFyZSAxLTQgYXJndW1lbnRzXG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbYXJnc1swXVtpXV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFthcmdzWzBdW2ldLCBhcmdzWzFdW2ldXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goW2FyZ3NbMF1baV0sIGFyZ3NbMV1baV0sIGFyZ3NbMl1baV1dKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbYXJnc1swXVtpXSwgYXJnc1sxXVtpXSwgYXJnc1syXVtpXSwgYXJnc1szXVtpXV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhcmdzLm1hcChmdW5jdGlvbiAoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2ldOyB9KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuYXJyYXlUdXBsZXMgPSBhcnJheVR1cGxlcztcbi8qKlxuICogUmVkdWNlIGZ1bmN0aW9uIHdoaWNoIGJ1aWxkcyBhbiBvYmplY3QgZnJvbSBhbiBhcnJheSBvZiBba2V5LCB2YWx1ZV0gcGFpcnMuXG4gKlxuICogRWFjaCBpdGVyYXRpb24gc2V0cyB0aGUga2V5L3ZhbCBwYWlyIG9uIHRoZSBtZW1vIG9iamVjdCwgdGhlbiByZXR1cm5zIHRoZSBtZW1vIGZvciB0aGUgbmV4dCBpdGVyYXRpb24uXG4gKlxuICogRWFjaCBrZXlWYWx1ZVR1cGxlIHNob3VsZCBiZSBhbiBhcnJheSB3aXRoIHZhbHVlcyBbIGtleTogc3RyaW5nLCB2YWx1ZTogYW55IF1cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogdmFyIHBhaXJzID0gWyBbXCJmb29rZXlcIiwgXCJmb292YWxcIl0sIFtcImJhcmtleVwiLCBcImJhcnZhbFwiXSBdXG4gKlxuICogdmFyIHBhaXJzVG9PYmogPSBwYWlycy5yZWR1Y2UoKG1lbW8sIHBhaXIpID0+IGFwcGx5UGFpcnMobWVtbywgcGFpciksIHt9KVxuICogLy8gcGFpcnNUb09iaiA9PSB7IGZvb2tleTogXCJmb292YWxcIiwgYmFya2V5OiBcImJhcnZhbFwiIH1cbiAqXG4gKiAvLyBPciwgbW9yZSBzaW1wbHk6XG4gKiB2YXIgcGFpcnNUb09iaiA9IHBhaXJzLnJlZHVjZShhcHBseVBhaXJzLCB7fSlcbiAqIC8vIHBhaXJzVG9PYmogPT0geyBmb29rZXk6IFwiZm9vdmFsXCIsIGJhcmtleTogXCJiYXJ2YWxcIiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gYXBwbHlQYWlycyhtZW1vLCBrZXlWYWxUdXBsZSkge1xuICAgIHZhciBrZXksIHZhbHVlO1xuICAgIGlmIChwcmVkaWNhdGVzXzEuaXNBcnJheShrZXlWYWxUdXBsZSkpXG4gICAgICAgIGtleSA9IGtleVZhbFR1cGxlWzBdLCB2YWx1ZSA9IGtleVZhbFR1cGxlWzFdO1xuICAgIGlmICghcHJlZGljYXRlc18xLmlzU3RyaW5nKGtleSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGFyYW1ldGVycyB0byBhcHBseVBhaXJzXCIpO1xuICAgIG1lbW9ba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBtZW1vO1xufVxuZXhwb3J0cy5hcHBseVBhaXJzID0gYXBwbHlQYWlycztcbi8qKiBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheSAqL1xuZnVuY3Rpb24gdGFpbChhcnIpIHtcbiAgICByZXR1cm4gYXJyLmxlbmd0aCAmJiBhcnJbYXJyLmxlbmd0aCAtIDFdIHx8IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMudGFpbCA9IHRhaWw7XG4vKipcbiAqIHNoYWxsb3cgY29weSBmcm9tIHNyYyB0byBkZXN0XG4gKi9cbmZ1bmN0aW9uIGNvcHkoc3JjLCBkZXN0KSB7XG4gICAgaWYgKGRlc3QpXG4gICAgICAgIE9iamVjdC5rZXlzKGRlc3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZGVsZXRlIGRlc3Rba2V5XTsgfSk7XG4gICAgaWYgKCFkZXN0KVxuICAgICAgICBkZXN0ID0ge307XG4gICAgcmV0dXJuIGV4cG9ydHMuZXh0ZW5kKGRlc3QsIHNyYyk7XG59XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuLyoqIE5haXZlIGZvckVhY2ggaW1wbGVtZW50YXRpb24gd29ya3Mgd2l0aCBPYmplY3RzIG9yIEFycmF5cyAqL1xuZnVuY3Rpb24gX2ZvckVhY2gob2JqLCBjYiwgX3RoaXMpIHtcbiAgICBpZiAocHJlZGljYXRlc18xLmlzQXJyYXkob2JqKSlcbiAgICAgICAgcmV0dXJuIG9iai5mb3JFYWNoKGNiLCBfdGhpcyk7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGNiKG9ialtrZXldLCBrZXkpOyB9KTtcbn1cbmZ1bmN0aW9uIF9leHRlbmQodG9PYmopIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb2JqID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpZiAoIW9iailcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdG9PYmpba2V5c1tqXV0gPSBvYmpba2V5c1tqXV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqO1xufVxuZXhwb3J0cy5fZXh0ZW5kID0gX2V4dGVuZDtcbmZ1bmN0aW9uIF9lcXVhbHMobzEsIG8yKSB7XG4gICAgaWYgKG8xID09PSBvMilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKG8xID09PSBudWxsIHx8IG8yID09PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG8xICE9PSBvMSAmJiBvMiAhPT0gbzIpXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBOYU4gPT09IE5hTlxuICAgIHZhciB0MSA9IHR5cGVvZiBvMSwgdDIgPSB0eXBlb2YgbzI7XG4gICAgaWYgKHQxICE9PSB0MiB8fCB0MSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgdHVwID0gW28xLCBvMl07XG4gICAgaWYgKGhvZl8xLmFsbChwcmVkaWNhdGVzXzEuaXNBcnJheSkodHVwKSlcbiAgICAgICAgcmV0dXJuIF9hcnJheXNFcShvMSwgbzIpO1xuICAgIGlmIChob2ZfMS5hbGwocHJlZGljYXRlc18xLmlzRGF0ZSkodHVwKSlcbiAgICAgICAgcmV0dXJuIG8xLmdldFRpbWUoKSA9PT0gbzIuZ2V0VGltZSgpO1xuICAgIGlmIChob2ZfMS5hbGwocHJlZGljYXRlc18xLmlzUmVnRXhwKSh0dXApKVxuICAgICAgICByZXR1cm4gbzEudG9TdHJpbmcoKSA9PT0gbzIudG9TdHJpbmcoKTtcbiAgICBpZiAoaG9mXzEuYWxsKHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKSh0dXApKVxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gbWVoXG4gICAgdmFyIHByZWRpY2F0ZXMgPSBbcHJlZGljYXRlc18xLmlzRnVuY3Rpb24sIHByZWRpY2F0ZXNfMS5pc0FycmF5LCBwcmVkaWNhdGVzXzEuaXNEYXRlLCBwcmVkaWNhdGVzXzEuaXNSZWdFeHBdO1xuICAgIGlmIChwcmVkaWNhdGVzLm1hcChob2ZfMS5hbnkpLnJlZHVjZShmdW5jdGlvbiAoYiwgZm4pIHsgcmV0dXJuIGIgfHwgISFmbih0dXApOyB9LCBmYWxzZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIga2V5LCBrZXlzID0ge307XG4gICAgZm9yIChrZXkgaW4gbzEpIHtcbiAgICAgICAgaWYgKCFfZXF1YWxzKG8xW2tleV0sIG8yW2tleV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBrZXlzW2tleV0gPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBvMikge1xuICAgICAgICBpZiAoIWtleXNba2V5XSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBfYXJyYXlzRXEoYTEsIGEyKSB7XG4gICAgaWYgKGExLmxlbmd0aCAhPT0gYTIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGFycmF5VHVwbGVzKGExLCBhMikucmVkdWNlKGZ1bmN0aW9uIChiLCB0KSB7IHJldHVybiBiICYmIF9lcXVhbHModFswXSwgdFsxXSk7IH0sIHRydWUpO1xufVxuLy8gaXNzdWUgIzI2NzZcbmV4cG9ydHMuc2lsZW5jZVVuY2F1Z2h0SW5Qcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICByZXR1cm4gcHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gMDsgfSkgJiYgcHJvbWlzZTtcbn07XG5leHBvcnRzLnNpbGVudFJlamVjdGlvbiA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHJldHVybiBleHBvcnRzLnNpbGVuY2VVbmNhdWdodEluUHJvbWlzZShjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS5yZWplY3QoZXJyb3IpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9jb21tb24uanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogUHJlZGljYXRlc1xuICpcbiAqIFRoZXNlIHByZWRpY2F0ZXMgcmV0dXJuIHRydWUvZmFsc2UgYmFzZWQgb24gdGhlIGlucHV0LlxuICogQWx0aG91Z2ggdGhlc2UgZnVuY3Rpb25zIGFyZSBleHBvcnRlZCwgdGhleSBhcmUgc3ViamVjdCB0byBjaGFuZ2Ugd2l0aG91dCBub3RpY2UuXG4gKlxuICogQG1vZHVsZSBjb21tb25fcHJlZGljYXRlc1xuICovXG4vKiogKi9cbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuL2hvZlwiKTtcbnZhciBzdGF0ZU9iamVjdF8xID0gcmVxdWlyZShcIi4uL3N0YXRlL3N0YXRlT2JqZWN0XCIpO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciB0aXMgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHR5cGVvZiAoeCkgPT09IHQ7IH07IH07XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gdGlzKCd1bmRlZmluZWQnKTtcbmV4cG9ydHMuaXNEZWZpbmVkID0gaG9mXzEubm90KGV4cG9ydHMuaXNVbmRlZmluZWQpO1xuZXhwb3J0cy5pc051bGwgPSBmdW5jdGlvbiAobykgeyByZXR1cm4gbyA9PT0gbnVsbDsgfTtcbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBob2ZfMS5vcihleHBvcnRzLmlzTnVsbCwgZXhwb3J0cy5pc1VuZGVmaW5lZCk7XG5leHBvcnRzLmlzRnVuY3Rpb24gPSB0aXMoJ2Z1bmN0aW9uJyk7XG5leHBvcnRzLmlzTnVtYmVyID0gdGlzKCdudW1iZXInKTtcbmV4cG9ydHMuaXNTdHJpbmcgPSB0aXMoJ3N0cmluZycpO1xuZXhwb3J0cy5pc09iamVjdCA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICE9PSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0JzsgfTtcbmV4cG9ydHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5leHBvcnRzLmlzRGF0ZSA9IChmdW5jdGlvbiAoeCkgeyByZXR1cm4gdG9TdHIuY2FsbCh4KSA9PT0gJ1tvYmplY3QgRGF0ZV0nOyB9KTtcbmV4cG9ydHMuaXNSZWdFeHAgPSAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHRvU3RyLmNhbGwoeCkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nOyB9KTtcbmV4cG9ydHMuaXNTdGF0ZSA9IHN0YXRlT2JqZWN0XzEuU3RhdGVPYmplY3QuaXNTdGF0ZTtcbi8qKlxuICogUHJlZGljYXRlIHdoaWNoIGNoZWNrcyBpZiBhIHZhbHVlIGlzIGluamVjdGFibGVcbiAqXG4gKiBBIHZhbHVlIGlzIFwiaW5qZWN0YWJsZVwiIGlmIGl0IGlzIGEgZnVuY3Rpb24sIG9yIGlmIGl0IGlzIGFuIG5nMSBhcnJheS1ub3RhdGlvbi1zdHlsZSBhcnJheVxuICogd2hlcmUgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgYXJyYXkgYXJlIFN0cmluZ3MsIGV4Y2VwdCB0aGUgbGFzdCBvbmUsIHdoaWNoIGlzIGEgRnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gaXNJbmplY3RhYmxlKHZhbCkge1xuICAgIGlmIChleHBvcnRzLmlzQXJyYXkodmFsKSAmJiB2YWwubGVuZ3RoKSB7XG4gICAgICAgIHZhciBoZWFkID0gdmFsLnNsaWNlKDAsIC0xKSwgdGFpbCA9IHZhbC5zbGljZSgtMSk7XG4gICAgICAgIHJldHVybiAhKGhlYWQuZmlsdGVyKGhvZl8xLm5vdChleHBvcnRzLmlzU3RyaW5nKSkubGVuZ3RoIHx8IHRhaWwuZmlsdGVyKGhvZl8xLm5vdChleHBvcnRzLmlzRnVuY3Rpb24pKS5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0cy5pc0Z1bmN0aW9uKHZhbCk7XG59XG5leHBvcnRzLmlzSW5qZWN0YWJsZSA9IGlzSW5qZWN0YWJsZTtcbi8qKlxuICogUHJlZGljYXRlIHdoaWNoIGNoZWNrcyBpZiBhIHZhbHVlIGxvb2tzIGxpa2UgYSBQcm9taXNlXG4gKlxuICogSXQgaXMgcHJvYmFibHkgYSBQcm9taXNlIGlmIGl0J3MgYW4gb2JqZWN0LCBhbmQgaXQgaGFzIGEgYHRoZW5gIHByb3BlcnR5IHdoaWNoIGlzIGEgRnVuY3Rpb25cbiAqL1xuZXhwb3J0cy5pc1Byb21pc2UgPSBob2ZfMS5hbmQoZXhwb3J0cy5pc09iamVjdCwgaG9mXzEucGlwZShob2ZfMS5wcm9wKCd0aGVuJyksIGV4cG9ydHMuaXNGdW5jdGlvbikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlZGljYXRlcy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL3ByZWRpY2F0ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEhpZ2hlciBvcmRlciBmdW5jdGlvbnNcbiAqXG4gKiBUaGVzZSB1dGlsaXR5IGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQsIGJ1dCBhcmUgc3ViamVjdCB0byBjaGFuZ2Ugd2l0aG91dCBub3RpY2UuXG4gKlxuICogQG1vZHVsZSBjb21tb25faG9mXG4gKi8gLyoqICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gZm9yIFtQYXJ0aWFsIEFwcGxpY2F0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QYXJ0aWFsX2FwcGxpY2F0aW9uKSBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gKlxuICogR2l2ZW4gYSBmdW5jdGlvbiB3aXRoIE4gcGFyYW1ldGVycywgcmV0dXJucyBhIG5ldyBmdW5jdGlvbiB0aGF0IHN1cHBvcnRzIHBhcnRpYWwgYXBwbGljYXRpb24uXG4gKiBUaGUgbmV3IGZ1bmN0aW9uIGFjY2VwdHMgYW55d2hlcmUgZnJvbSAxIHRvIE4gcGFyYW1ldGVycy4gIFdoZW4gdGhhdCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBNIHBhcmFtZXRlcnMsXG4gKiB3aGVyZSBNIGlzIGxlc3MgdGhhbiBOLCBpdCByZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgcmVtYWluaW5nIHBhcmFtZXRlcnMuICBJdCBjb250aW51ZXMgdG9cbiAqIGFjY2VwdCBtb3JlIHBhcmFtZXRlcnMgdW50aWwgYWxsIE4gcGFyYW1ldGVycyBoYXZlIGJlZW4gc3VwcGxpZWQuXG4gKlxuICpcbiAqIFRoaXMgY29udHJpdmVkIGV4YW1wbGUgdXNlcyBhIHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uIGFzIGFuIHByZWRpY2F0ZSwgd2hpY2ggcmV0dXJucyB0cnVlXG4gKiBpZiBhbiBvYmplY3QgaXMgZm91bmQgaW4gYm90aCBhcnJheXMuXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiAvLyByZXR1cm5zIHRydWUgaWYgYW4gb2JqZWN0IGlzIGluIGJvdGggb2YgdGhlIHR3byBhcnJheXNcbiAqIGZ1bmN0aW9uIGluQm90aChhcnJheTEsIGFycmF5Miwgb2JqZWN0KSB7XG4gKiAgIHJldHVybiBhcnJheTEuaW5kZXhPZihvYmplY3QpICE9PSAtMSAmJlxuICogICAgICAgICAgYXJyYXkyLmluZGV4T2Yob2JqZWN0KSAhPT0gMTtcbiAqIH1cbiAqIGxldCBvYmoxLCBvYmoyLCBvYmozLCBvYmo0LCBvYmo1LCBvYmo2LCBvYmo3XG4gKiBsZXQgZm9vcyA9IFtvYmoxLCBvYmozXVxuICogbGV0IGJhcnMgPSBbb2JqMywgb2JqNCwgb2JqNV1cbiAqXG4gKiAvLyBBIGN1cnJpZWQgXCJjb3B5XCIgb2YgaW5Cb3RoXG4gKiBsZXQgY3VycmllZEluQm90aCA9IGN1cnJ5KGluQm90aCk7XG4gKiAvLyBQYXJ0aWFsbHkgYXBwbHkgYm90aCB0aGUgYXJyYXkxIGFuZCBhcnJheTJcbiAqIGxldCBpbkZvb3NBbmRCYXJzID0gY3VycmllZEluQm90aChmb29zLCBiYXJzKTtcbiAqXG4gKiAvLyBTdXBwbHkgdGhlIGZpbmFsIGFyZ3VtZW50OyBzaW5jZSBhbGwgYXJndW1lbnRzIGFyZVxuICogLy8gc3VwcGxpZWQsIHRoZSBvcmlnaW5hbCBpbkJvdGggZnVuY3Rpb24gaXMgdGhlbiBjYWxsZWQuXG4gKiBsZXQgb2JqMUluQm90aCA9IGluRm9vc0FuZEJhcnMob2JqMSk7IC8vIGZhbHNlXG4gKlxuICogLy8gVXNlIHRoZSBpbkZvb3NBbmRCYXJzIGFzIGEgcHJlZGljYXRlLlxuICogLy8gRmlsdGVyLCBvbiBlYWNoIGl0ZXJhdGlvbiwgc3VwcGxpZXMgdGhlIGZpbmFsIGFyZ3VtZW50XG4gKiBsZXQgYWxsT2JqcyA9IFsgb2JqMSwgb2JqMiwgb2JqMywgb2JqNCwgb2JqNSwgb2JqNiwgb2JqNyBdO1xuICogbGV0IGZvdW5kSW5Cb3RoID0gYWxsT2Jqcy5maWx0ZXIoaW5Gb29zQW5kQmFycyk7IC8vIFsgb2JqMyBdXG4gKlxuICogYGBgXG4gKlxuICogU3RvbGVuIGZyb206IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDM5NDc0Ny9qYXZhc2NyaXB0LWN1cnJ5LWZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIGZuXG4gKiBAcmV0dXJucyB7KnxmdW5jdGlvbigpOiAoKnxhbnkpfVxuICovXG5mdW5jdGlvbiBjdXJyeShmbikge1xuICAgIHZhciBpbml0aWFsX2FyZ3MgPSBbXS5zbGljZS5hcHBseShhcmd1bWVudHMsIFsxXSk7XG4gICAgdmFyIGZ1bmNfYXJnc19sZW5ndGggPSBmbi5sZW5ndGg7XG4gICAgZnVuY3Rpb24gY3VycmllZChhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+PSBmdW5jX2FyZ3NfbGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJpZWQoYXJncy5jb25jYXQoW10uc2xpY2UuYXBwbHkoYXJndW1lbnRzKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gY3VycmllZChpbml0aWFsX2FyZ3MpO1xufVxuZXhwb3J0cy5jdXJyeSA9IGN1cnJ5O1xuLyoqXG4gKiBHaXZlbiBhIHZhcmFyZ3MgbGlzdCBvZiBmdW5jdGlvbnMsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNvbXBvc2VzIHRoZSBhcmd1bWVudCBmdW5jdGlvbnMsIHJpZ2h0LXRvLWxlZnRcbiAqIGdpdmVuOiBmKHgpLCBnKHgpLCBoKHgpXG4gKiBsZXQgY29tcG9zZWQgPSBjb21wb3NlKGYsZyxoKVxuICogdGhlbiwgY29tcG9zZWQgaXM6IGYoZyhoKHgpKSlcbiAqL1xuZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgc3RhcnQgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGkgPSBzdGFydCwgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5leHBvcnRzLmNvbXBvc2UgPSBjb21wb3NlO1xuLyoqXG4gKiBHaXZlbiBhIHZhcmFyZ3MgbGlzdCBvZiBmdW5jdGlvbnMsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIGNvbXBvc2VzIHRoZSBhcmd1bWVudCBmdW5jdGlvbnMsIGxlZnQtdG8tcmlnaHRcbiAqIGdpdmVuOiBmKHgpLCBnKHgpLCBoKHgpXG4gKiBsZXQgcGlwZWQgPSBwaXBlKGYsZyxoKTtcbiAqIHRoZW4sIHBpcGVkIGlzOiBoKGcoZih4KSkpXG4gKi9cbmZ1bmN0aW9uIHBpcGUoKSB7XG4gICAgdmFyIGZ1bmNzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgZnVuY3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvc2UuYXBwbHkobnVsbCwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLnJldmVyc2UoKSk7XG59XG5leHBvcnRzLnBpcGUgPSBwaXBlO1xuLyoqXG4gKiBHaXZlbiBhIHByb3BlcnR5IG5hbWUsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhhdCBwcm9wZXJ0eSBmcm9tIGFuIG9iamVjdFxuICogbGV0IG9iaiA9IHsgZm9vOiAxLCBuYW1lOiBcImJsYXJnXCIgfTtcbiAqIGxldCBnZXROYW1lID0gcHJvcChcIm5hbWVcIik7XG4gKiBnZXROYW1lKG9iaikgPT09IFwiYmxhcmdcIlxuICovXG5leHBvcnRzLnByb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgb2JqW25hbWVdOyB9O1xufTtcbi8qKlxuICogR2l2ZW4gYSBwcm9wZXJ0eSBuYW1lIGFuZCBhIHZhbHVlLCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYm9vbGVhbiBiYXNlZCBvbiB3aGV0aGVyXG4gKiB0aGUgcGFzc2VkIG9iamVjdCBoYXMgYSBwcm9wZXJ0eSB0aGF0IG1hdGNoZXMgdGhlIHZhbHVlXG4gKiBsZXQgb2JqID0geyBmb286IDEsIG5hbWU6IFwiYmxhcmdcIiB9O1xuICogbGV0IGdldE5hbWUgPSBwcm9wRXEoXCJuYW1lXCIsIFwiYmxhcmdcIik7XG4gKiBnZXROYW1lKG9iaikgPT09IHRydWVcbiAqL1xuZXhwb3J0cy5wcm9wRXEgPSBjdXJyeShmdW5jdGlvbiAobmFtZSwgdmFsLCBvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmpbbmFtZV0gPT09IHZhbDsgfSk7XG4vKipcbiAqIEdpdmVuIGEgZG90dGVkIHByb3BlcnR5IG5hbWUsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBuZXN0ZWQgcHJvcGVydHkgZnJvbSBhbiBvYmplY3QsIG9yIHVuZGVmaW5lZFxuICogbGV0IG9iaiA9IHsgaWQ6IDEsIG5lc3RlZE9iajogeyBmb286IDEsIG5hbWU6IFwiYmxhcmdcIiB9LCB9O1xuICogbGV0IGdldE5hbWUgPSBwcm9wKFwibmVzdGVkT2JqLm5hbWVcIik7XG4gKiBnZXROYW1lKG9iaikgPT09IFwiYmxhcmdcIlxuICogbGV0IHByb3BOb3RGb3VuZCA9IHByb3AoXCJ0aGlzLnByb3BlcnR5LmRvZXNudC5leGlzdFwiKTtcbiAqIHByb3BOb3RGb3VuZChvYmopID09PSB1bmRlZmluZWRcbiAqL1xuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHBpcGUuYXBwbHkobnVsbCwgbmFtZS5zcGxpdChcIi5cIikubWFwKGV4cG9ydHMucHJvcCkpO1xufTtcbi8qKlxuICogR2l2ZW4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB0cnV0aHkgb3IgZmFsc2V5IHZhbHVlLCByZXR1cm5zIGFcbiAqIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgb3Bwb3NpdGUgKGZhbHNleSBvciB0cnV0aHkpIHZhbHVlIGdpdmVuIHRoZSBzYW1lIGlucHV0c1xuICovXG5leHBvcnRzLm5vdCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9O1xufTtcbi8qKlxuICogR2l2ZW4gdHdvIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB0cnV0aHkgb3IgZmFsc2V5IHZhbHVlcywgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnV0aHlcbiAqIGlmIGJvdGggZnVuY3Rpb25zIHJldHVybiB0cnV0aHkgZm9yIHRoZSBnaXZlbiBhcmd1bWVudHNcbiAqL1xuZnVuY3Rpb24gYW5kKGZuMSwgZm4yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4xLmFwcGx5KG51bGwsIGFyZ3MpICYmIGZuMi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9O1xufVxuZXhwb3J0cy5hbmQgPSBhbmQ7XG4vKipcbiAqIEdpdmVuIHR3byBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdHJ1dGh5IG9yIGZhbHNleSB2YWx1ZXMsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1dGh5XG4gKiBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZ1bmN0aW9ucyByZXR1cm5zIHRydXRoeSBmb3IgdGhlIGdpdmVuIGFyZ3VtZW50c1xuICovXG5mdW5jdGlvbiBvcihmbjEsIGZuMikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuMS5hcHBseShudWxsLCBhcmdzKSB8fCBmbjIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfTtcbn1cbmV4cG9ydHMub3IgPSBvcjtcbi8qKlxuICogQ2hlY2sgaWYgYWxsIHRoZSBlbGVtZW50cyBvZiBhbiBhcnJheSBtYXRjaCBhIHByZWRpY2F0ZSBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSBmbjEgYSBwcmVkaWNhdGUgZnVuY3Rpb24gYGZuMWBcbiAqIEByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYW4gYXJyYXkgYW5kIHJldHVybnMgdHJ1ZSBpZiBgZm4xYCBpcyB0cnVlIGZvciBhbGwgZWxlbWVudHMgb2YgdGhlIGFycmF5XG4gKi9cbmV4cG9ydHMuYWxsID0gZnVuY3Rpb24gKGZuMSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChiLCB4KSB7IHJldHVybiBiICYmICEhZm4xKHgpOyB9LCB0cnVlKTsgfTtcbn07XG5leHBvcnRzLmFueSA9IGZ1bmN0aW9uIChmbjEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFycikgeyByZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbiAoYiwgeCkgeyByZXR1cm4gYiB8fCAhIWZuMSh4KTsgfSwgZmFsc2UpOyB9O1xufTtcbi8qKiBHaXZlbiBhIGNsYXNzLCByZXR1cm5zIGEgUHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgb2YgdGhhdCBjbGFzcyAqL1xuZXhwb3J0cy5pcyA9IGZ1bmN0aW9uIChjdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgPT09IGN0b3IgfHwgb2JqIGluc3RhbmNlb2YgY3Rvcik7XG4gICAgfTtcbn07XG4vKiogR2l2ZW4gYSB2YWx1ZSwgcmV0dXJucyBhIFByZWRpY2F0ZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiBhbm90aGVyIHZhbHVlIGlzID09PSBlcXVhbCB0byB0aGUgb3JpZ2luYWwgdmFsdWUgKi9cbmV4cG9ydHMuZXEgPSBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICByZXR1cm4gdmFsID09PSBvdGhlcjtcbn07IH07XG4vKiogR2l2ZW4gYSB2YWx1ZSwgcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlIHZhbHVlICovXG5leHBvcnRzLnZhbCA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB2OyB9OyB9O1xuZnVuY3Rpb24gaW52b2tlKGZuTmFtZSwgYXJncykge1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmpbZm5OYW1lXS5hcHBseShvYmosIGFyZ3MpO1xuICAgIH07XG59XG5leHBvcnRzLmludm9rZSA9IGludm9rZTtcbi8qKlxuICogU29ydGEgbGlrZSBQYXR0ZXJuIE1hdGNoaW5nIChhIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgY29uZGl0aW9uYWwgY29uc3RydWN0KVxuICpcbiAqIFNlZSBodHRwOi8vYzIuY29tL2NnaS93aWtpP1BhdHRlcm5NYXRjaGluZ1xuICpcbiAqIFRoaXMgaXMgYSBjb25kaXRpb25hbCBjb25zdHJ1Y3Qgd2hpY2ggYWxsb3dzIGEgc2VyaWVzIG9mIHByZWRpY2F0ZXMgYW5kIG91dHB1dCBmdW5jdGlvbnNcbiAqIHRvIGJlIGNoZWNrZWQgYW5kIHRoZW4gYXBwbGllZC4gIEVhY2ggcHJlZGljYXRlIHJlY2VpdmVzIHRoZSBpbnB1dC4gIElmIHRoZSBwcmVkaWNhdGVcbiAqIHJldHVybnMgdHJ1dGh5LCB0aGVuIGl0cyBtYXRjaGluZyBvdXRwdXQgZnVuY3Rpb24gKG1hcHBpbmcgZnVuY3Rpb24pIGlzIHByb3ZpZGVkIHdpdGhcbiAqIHRoZSBpbnB1dCBhbmQsIHRoZW4gdGhlIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAqXG4gKiBFYWNoIGNvbWJpbmF0aW9uICgyLXR1cGxlKSBvZiBwcmVkaWNhdGUgKyBvdXRwdXQgZnVuY3Rpb24gc2hvdWxkIGJlIHBsYWNlZCBpbiBhbiBhcnJheVxuICogb2Ygc2l6ZSAyOiBbIHByZWRpY2F0ZSwgbWFwRm4gXVxuICpcbiAqIFRoZXNlIDItdHVwbGVzIHNob3VsZCBiZSBwdXQgaW4gYW4gb3V0ZXIgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIC8vIEhlcmUncyBhIDItdHVwbGUgd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlIGlzU3RyaW5nIHByZWRpY2F0ZVxuICogLy8gYW5kIHRoZSBzZWNvbmQgZWxlbWVudCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGRlc2NyaXB0aW9uIG9mIHRoZSBpbnB1dFxuICogbGV0IGZpcnN0VHVwbGUgPSBbIGFuZ3VsYXIuaXNTdHJpbmcsIChpbnB1dCkgPT4gYEhlcmVzIHlvdXIgc3RyaW5nICR7aW5wdXR9YCBdO1xuICpcbiAqIC8vIFNlY29uZCB0dXBsZTogcHJlZGljYXRlIFwiaXNOdW1iZXJcIiwgbWFwZm4gcmV0dXJucyBhIGRlc2NyaXB0aW9uXG4gKiBsZXQgc2Vjb25kVHVwbGUgPSBbIGFuZ3VsYXIuaXNOdW1iZXIsIChpbnB1dCkgPT4gYCgke2lucHV0fSkgVGhhdCdzIGEgbnVtYmVyIWAgXTtcbiAqXG4gKiBsZXQgdGhpcmQgPSBbIChpbnB1dCkgPT4gaW5wdXQgPT09IG51bGwsICAoaW5wdXQpID0+IGBPaCwgbnVsbC4uLmAgXTtcbiAqXG4gKiBsZXQgZm91cnRoID0gWyAoaW5wdXQpID0+IGlucHV0ID09PSB1bmRlZmluZWQsICAoaW5wdXQpID0+IGBub3RkZWZpbmVkYCBdO1xuICpcbiAqIGxldCBkZXNjcmlwdGlvbk9mID0gcGF0dGVybihbIGZpcnN0VHVwbGUsIHNlY29uZFR1cGxlLCB0aGlyZCwgZm91cnRoIF0pO1xuICpcbiAqIGNvbnNvbGUubG9nKGRlc2NyaXB0aW9uT2YodW5kZWZpbmVkKSk7IC8vICdub3RkZWZpbmVkJ1xuICogY29uc29sZS5sb2coZGVzY3JpcHRpb25PZig1NSkpOyAvLyAnKDU1KSBUaGF0J3MgYSBudW1iZXIhJ1xuICogY29uc29sZS5sb2coZGVzY3JpcHRpb25PZihcImZvb1wiKSk7IC8vICdIZXJlJ3MgeW91ciBzdHJpbmcgZm9vJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHN0cnVjdCBBIDJEIGFycmF5LiAgRWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheSBzaG91bGQgYmUgYW4gYXJyYXksIGEgMi10dXBsZSxcbiAqIHdpdGggYSBQcmVkaWNhdGUgYW5kIGEgbWFwcGluZy9vdXRwdXQgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtmdW5jdGlvbihhbnkpOiAqfVxuICovXG5mdW5jdGlvbiBwYXR0ZXJuKHN0cnVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cnVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHN0cnVjdFtpXVswXSh4KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RydWN0W2ldWzFdKHgpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMucGF0dGVybiA9IHBhdHRlcm47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob2YuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9ob2YuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzNfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIkBhbmd1bGFyL2NvcmVcIlxuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgY29tbW9uXG4gKi8gLyoqICovXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tbW9uL2luZGV4XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3BhcmFtcy9pbmRleFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wYXRoL2luZGV4XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3Jlc29sdmUvaW5kZXhcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3RhdGUvaW5kZXhcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdHJhbnNpdGlvbi9pbmRleFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi91cmwvaW5kZXhcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdmlldy9pbmRleFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9nbG9iYWxzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3JvdXRlclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi92YW5pbGxhXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vdEltcGxlbWVudGVkID0gZnVuY3Rpb24gKGZubmFtZSkgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihmbm5hbWUgKyBcIigpOiBObyBjb3Jlc2VydmljZXMgaW1wbGVtZW50YXRpb24gZm9yIFVJLVJvdXRlciBpcyBsb2FkZWQuXCIpO1xufTsgfTtcbnZhciBzZXJ2aWNlcyA9IHtcbiAgICAkcTogdW5kZWZpbmVkLFxuICAgICRpbmplY3RvcjogdW5kZWZpbmVkLFxufTtcbmV4cG9ydHMuc2VydmljZXMgPSBzZXJ2aWNlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmVzZXJ2aWNlcy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL2NvcmVzZXJ2aWNlcy5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVwbGF5U3ViamVjdCB9IGZyb20gJ3J4anMvUmVwbGF5U3ViamVjdCc7XG5pbXBvcnQgeyBMb2NhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBSb3V0ZXIsIE5hdmlnYXRpb25FbmQgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgVHJhbnNpdGlvblNlcnZpY2UsIFVybFNlcnZpY2UgfSBmcm9tICdAdWlyb3V0ZXIvYW5ndWxhcic7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL2ZpbHRlcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBbmd1bGFydGljczIge1xuICBwdWJsaWMgc2V0dGluZ3M6IGFueSA9IHtcbiAgICBwYWdlVHJhY2tpbmc6IHtcbiAgICAgIGF1dG9UcmFja1ZpcnR1YWxQYWdlczogdHJ1ZSxcbiAgICAgIGJhc2VQYXRoOiAnJyxcbiAgICAgIGV4Y2x1ZGVkUm91dGVzOiBbXVxuICAgIH0sXG4gICAgZXZlbnRUcmFja2luZzoge30sXG4gICAgZGV2ZWxvcGVyTW9kZTogZmFsc2VcbiAgfTtcblxuICAvKlxuICAgIEBQYXJhbTogKHt1cmw6IHN0cmluZywgbG9jYXRpb246IExvY2F0aW9ufSlcbiAgICovXG4gIHB1YmxpYyBwYWdlVHJhY2s6IFJlcGxheVN1YmplY3Q8YW55PiA9IG5ldyBSZXBsYXlTdWJqZWN0KDEwKTtcblxuICAvKlxuICAgIEBQYXJhbTogKHthY3Rpb246IGFueSwgcHJvcGVydGllczogYW55fSlcbiAgICovXG4gIHB1YmxpYyBldmVudFRyYWNrOiBSZXBsYXlTdWJqZWN0PGFueT4gPSBuZXcgUmVwbGF5U3ViamVjdCgxMCk7XG5cbiAgLypcbiAgICBAUGFyYW06IChwcm9wZXJ0aWVzOiBhbnkpXG4gICAqL1xuICBwdWJsaWMgZXhjZXB0aW9uVHJhY2s6IFJlcGxheVN1YmplY3Q8YW55PiA9IG5ldyBSZXBsYXlTdWJqZWN0KDEwKTtcblxuICAvKlxuICAgIEBQYXJhbTogKGFsaWFzOiBzdHJpbmcpXG4gICAqL1xuICBwdWJsaWMgc2V0QWxpYXM6IFJlcGxheVN1YmplY3Q8YW55PiA9IG5ldyBSZXBsYXlTdWJqZWN0KDEwKTtcblxuICAvKlxuICAgIEBQYXJhbTogKHVzZXJJZDogc3RyaW5nKVxuICAgKi9cbiAgcHVibGljIHNldFVzZXJuYW1lOiBSZXBsYXlTdWJqZWN0PGFueT4gPSBuZXcgUmVwbGF5U3ViamVjdCgxMCk7XG5cbiAgLypcbiAgICBAUGFyYW06ICh7YWN0aW9uOiBhbnksIHByb3BlcnRpZXM6IGFueX0pXG4gICAqL1xuICBwdWJsaWMgc2V0VXNlclByb3BlcnRpZXM6IFJlcGxheVN1YmplY3Q8YW55PiA9IG5ldyBSZXBsYXlTdWJqZWN0KDEwKTtcblxuICAvKlxuICAgIEBQYXJhbTogKHByb3BlcnRpZXM6IGFueSlcbiAgICovXG4gIHB1YmxpYyBzZXRVc2VyUHJvcGVydGllc09uY2U6IFJlcGxheVN1YmplY3Q8YW55PiA9IG5ldyBSZXBsYXlTdWJqZWN0KDEwKTtcblxuICAvKlxuICAgIEBQYXJhbTogKHByb3BlcnRpZXM6IGFueSlcbiAgICovXG4gIHB1YmxpYyBzZXRTdXBlclByb3BlcnRpZXM6IFJlcGxheVN1YmplY3Q8YW55PiA9IG5ldyBSZXBsYXlTdWJqZWN0KDEwKTtcblxuICAvKlxuICAgIEBQYXJhbTogKHByb3BlcnRpZXM6IGFueSlcbiAgICovXG4gIHB1YmxpYyBzZXRTdXBlclByb3BlcnRpZXNPbmNlOiBSZXBsYXlTdWJqZWN0PGFueT4gPSBuZXcgUmVwbGF5U3ViamVjdCgxMCk7XG5cbiAgLypcbiAgICBAUGFyYW06IChwcm9wZXJ0aWVzOiBhbnkpXG4gICAqL1xuICBwdWJsaWMgdXNlclRpbWluZ3M6IFJlcGxheVN1YmplY3Q8YW55PiA9IG5ldyBSZXBsYXlTdWJqZWN0KDEwKTtcblxuICBjb25zdHJ1Y3Rvcihsb2NhdGlvbjogTG9jYXRpb24sIEBPcHRpb25hbCgpIHJvdXRlcjogUm91dGVyLCBAT3B0aW9uYWwoKSB0cmFuc2l0aW9uU2VydmljZTogVHJhbnNpdGlvblNlcnZpY2UsIEBPcHRpb25hbCgpIHVybFNlcnZpY2U6IFVybFNlcnZpY2UpIHtcbiAgICBpZiAocm91dGVyKSB7XG4gICAgICB0aGlzLnRyYWNrTG9jYXRpb25XaXRoUm91dGVyKGxvY2F0aW9uLCByb3V0ZXIpO1xuICAgIH1cblxuICAgIGlmICh0cmFuc2l0aW9uU2VydmljZSAmJiB1cmxTZXJ2aWNlKSB7XG4gICAgICB0aGlzLnRyYWNrTG9jYXRpb25XaXRoVHJhbnNpdGlvbihsb2NhdGlvbiwgdHJhbnNpdGlvblNlcnZpY2UsIHVybFNlcnZpY2UpO1xuICAgIH1cbiAgfVxuXG4gIHRyYWNrTG9jYXRpb25XaXRoUm91dGVyKGxvY2F0aW9uOiBMb2NhdGlvbiwgcm91dGVyOiBSb3V0ZXIpIHtcbiAgICByb3V0ZXIuZXZlbnRzXG4gICAgICAuZmlsdGVyKGV2ZW50ID0+IGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVuZClcbiAgICAgIC5zdWJzY3JpYmUoKGV2ZW50OiBOYXZpZ2F0aW9uRW5kKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5kZXZlbG9wZXJNb2RlKSB7XG4gICAgICAgICAgdGhpcy50cmFja1VybENoYW5nZShldmVudC51cmxBZnRlclJlZGlyZWN0cywgbG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIHRyYWNrTG9jYXRpb25XaXRoVHJhbnNpdGlvbihsb2NhdGlvbjogTG9jYXRpb24sIHRyYW5zaXRpb25TZXJ2aWNlOiBUcmFuc2l0aW9uU2VydmljZSwgdXJsU2VydmljZTogVXJsU2VydmljZSkge1xuICAgIHRyYW5zaXRpb25TZXJ2aWNlLm9uRmluaXNoKHt9LCAodHJhbnNpdGlvbikgPT4ge1xuICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmRldmVsb3Blck1vZGUpIHtcbiAgICAgICAgdGhpcy50cmFja1VybENoYW5nZSh1cmxTZXJ2aWNlLnBhdGgoKSwgbG9jYXRpb24pO1xuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICB2aXJ0dWFsUGFnZXZpZXdzKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5zZXR0aW5ncy5wYWdlVHJhY2tpbmcuYXV0b1RyYWNrVmlydHVhbFBhZ2VzID0gdmFsdWU7XG4gIH1cbiAgZXhjbHVkZVJvdXRlcyhyb3V0ZXM6IEFycmF5PHN0cmluZyB8IFJlZ0V4cD4pIHtcbiAgICB0aGlzLnNldHRpbmdzLnBhZ2VUcmFja2luZy5leGNsdWRlZFJvdXRlcyA9IHJvdXRlcztcbiAgfVxuICBmaXJzdFBhZ2V2aWV3KHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5zZXR0aW5ncy5wYWdlVHJhY2tpbmcuYXV0b1RyYWNrRmlyc3RQYWdlID0gdmFsdWU7XG4gIH1cbiAgd2l0aEJhc2UodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuc2V0dGluZ3MucGFnZVRyYWNraW5nLmJhc2VQYXRoID0gKHZhbHVlKTtcbiAgfVxuICBkZXZlbG9wZXJNb2RlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5zZXR0aW5ncy5kZXZlbG9wZXJNb2RlID0gdmFsdWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgdHJhY2tVcmxDaGFuZ2UodXJsOiBzdHJpbmcsIGxvY2F0aW9uOiBMb2NhdGlvbikge1xuICAgIGlmICghdGhpcy5zZXR0aW5ncy5kZXZlbG9wZXJNb2RlKSB7XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5wYWdlVHJhY2tpbmcuYXV0b1RyYWNrVmlydHVhbFBhZ2VzICYmICF0aGlzLm1hdGNoZXNFeGNsdWRlZFJvdXRlKHVybCkpIHtcbiAgICAgICAgdGhpcy5wYWdlVHJhY2submV4dCh7XG4gICAgICAgICAgcGF0aDogdGhpcy5zZXR0aW5ncy5wYWdlVHJhY2tpbmcuYmFzZVBhdGgubGVuZ3RoID8gdGhpcy5zZXR0aW5ncy5wYWdlVHJhY2tpbmcuYmFzZVBhdGggKyB1cmwgOiBsb2NhdGlvbi5wcmVwYXJlRXh0ZXJuYWxVcmwodXJsKSxcbiAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG1hdGNoZXNFeGNsdWRlZFJvdXRlKHVybDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgZm9yIChsZXQgZXhjbHVkZWRSb3V0ZSBvZiB0aGlzLnNldHRpbmdzLnBhZ2VUcmFja2luZy5leGNsdWRlZFJvdXRlcykge1xuICAgICAgaWYgKChleGNsdWRlZFJvdXRlIGluc3RhbmNlb2YgUmVnRXhwICYmIGV4Y2x1ZGVkUm91dGUudGVzdCh1cmwpKSB8fCB1cmwuaW5kZXhPZihleGNsdWRlZFJvdXRlKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy90c2xpbnQtbG9hZGVyIS4vc3JjL2NvcmUvYW5ndWxhcnRpY3MyLnRzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgY29tbW9uICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tbW9uXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvcmVzZXJ2aWNlc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9nbG9iXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2hvZlwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wcmVkaWNhdGVzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3F1ZXVlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0cmluZ3NcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdHJhY2VcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogRnVuY3Rpb25zIHRoYXQgbWFuaXB1bGF0ZSBzdHJpbmdzXG4gKlxuICogQWx0aG91Z2ggdGhlc2UgZnVuY3Rpb25zIGFyZSBleHBvcnRlZCwgdGhleSBhcmUgc3ViamVjdCB0byBjaGFuZ2Ugd2l0aG91dCBub3RpY2UuXG4gKlxuICogQG1vZHVsZSBjb21tb25fc3RyaW5nc1xuICovIC8qKiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuL3ByZWRpY2F0ZXNcIik7XG52YXIgcmVqZWN0RmFjdG9yeV8xID0gcmVxdWlyZShcIi4uL3RyYW5zaXRpb24vcmVqZWN0RmFjdG9yeVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuL2NvbW1vblwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuL2hvZlwiKTtcbnZhciB0cmFuc2l0aW9uXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uXCIpO1xudmFyIHJlc29sdmFibGVfMSA9IHJlcXVpcmUoXCIuLi9yZXNvbHZlL3Jlc29sdmFibGVcIik7XG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgc2hvcnRlbmVkIHRvIGEgbWF4aW11bSBsZW5ndGhcbiAqXG4gKiBJZiB0aGUgc3RyaW5nIGlzIGFscmVhZHkgbGVzcyB0aGFuIHRoZSBgbWF4YCBsZW5ndGgsIHJldHVybiB0aGUgc3RyaW5nLlxuICogRWxzZSByZXR1cm4gdGhlIHN0cmluZywgc2hvcnRlbmVkIHRvIGBtYXggLSAzYCBhbmQgYXBwZW5kIHRocmVlIGRvdHMgKFwiLi4uXCIpLlxuICpcbiAqIEBwYXJhbSBtYXggdGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBzdHJpbmcgdG8gcmV0dXJuXG4gKiBAcGFyYW0gc3RyIHRoZSBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gbWF4TGVuZ3RoKG1heCwgc3RyKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPD0gbWF4KVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIG1heCAtIDMpICsgXCIuLi5cIjtcbn1cbmV4cG9ydHMubWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nLCB3aXRoIHNwYWNlcyBhZGRlZCB0byB0aGUgZW5kLCB1cCB0byBhIGRlc2lyZWQgc3RyIGxlbmd0aFxuICpcbiAqIElmIHRoZSBzdHJpbmcgaXMgYWxyZWFkeSBsb25nZXIgdGhhbiB0aGUgZGVzaXJlZCBsZW5ndGgsIHJldHVybiB0aGUgc3RyaW5nLlxuICogRWxzZSByZXR1cm5zIHRoZSBzdHJpbmcsIHdpdGggZXh0cmEgc3BhY2VzIG9uIHRoZSBlbmQsIHN1Y2ggdGhhdCBpdCByZWFjaGVzIGBsZW5ndGhgIGNoYXJhY3RlcnMuXG4gKlxuICogQHBhcmFtIGxlbmd0aCB0aGUgZGVzaXJlZCBsZW5ndGggb2YgdGhlIHN0cmluZyB0byByZXR1cm5cbiAqIEBwYXJhbSBzdHIgdGhlIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBwYWRTdHJpbmcobGVuZ3RoLCBzdHIpIHtcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgc3RyICs9IFwiIFwiO1xuICAgIHJldHVybiBzdHI7XG59XG5leHBvcnRzLnBhZFN0cmluZyA9IHBhZFN0cmluZztcbmZ1bmN0aW9uIGtlYm9iU3RyaW5nKGNhbWVsQ2FzZSkge1xuICAgIHJldHVybiBjYW1lbENhc2VcbiAgICAgICAgLnJlcGxhY2UoL14oW0EtWl0pLywgZnVuY3Rpb24gKCQxKSB7IHJldHVybiAkMS50b0xvd2VyQ2FzZSgpOyB9KSAvLyByZXBsYWNlIGZpcnN0IGNoYXJcbiAgICAgICAgLnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24gKCQxKSB7IHJldHVybiBcIi1cIiArICQxLnRvTG93ZXJDYXNlKCk7IH0pOyAvLyByZXBsYWNlIHJlc3Rcbn1cbmV4cG9ydHMua2Vib2JTdHJpbmcgPSBrZWJvYlN0cmluZztcbmZ1bmN0aW9uIF90b0pzb24ob2JqKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG59XG5mdW5jdGlvbiBfZnJvbUpzb24oanNvbikge1xuICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoanNvbikgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcbn1cbmZ1bmN0aW9uIHByb21pc2VUb1N0cmluZyhwKSB7XG4gICAgcmV0dXJuIFwiUHJvbWlzZShcIiArIEpTT04uc3RyaW5naWZ5KHApICsgXCIpXCI7XG59XG5mdW5jdGlvbiBmdW5jdGlvblRvU3RyaW5nKGZuKSB7XG4gICAgdmFyIGZuU3RyID0gZm5Ub1N0cmluZyhmbik7XG4gICAgdmFyIG5hbWVkRnVuY3Rpb25NYXRjaCA9IGZuU3RyLm1hdGNoKC9eKGZ1bmN0aW9uIFteIF0rXFwoW14pXSpcXCkpLyk7XG4gICAgdmFyIHRvU3RyID0gbmFtZWRGdW5jdGlvbk1hdGNoID8gbmFtZWRGdW5jdGlvbk1hdGNoWzFdIDogZm5TdHI7XG4gICAgdmFyIGZuTmFtZSA9IGZuWyduYW1lJ10gfHwgXCJcIjtcbiAgICBpZiAoZm5OYW1lICYmIHRvU3RyLm1hdGNoKC9mdW5jdGlvbiBcXCgvKSkge1xuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uICcgKyBmbk5hbWUgKyB0b1N0ci5zdWJzdHIoOSk7XG4gICAgfVxuICAgIHJldHVybiB0b1N0cjtcbn1cbmV4cG9ydHMuZnVuY3Rpb25Ub1N0cmluZyA9IGZ1bmN0aW9uVG9TdHJpbmc7XG5mdW5jdGlvbiBmblRvU3RyaW5nKGZuKSB7XG4gICAgdmFyIF9mbiA9IHByZWRpY2F0ZXNfMS5pc0FycmF5KGZuKSA/IGZuLnNsaWNlKC0xKVswXSA6IGZuO1xuICAgIHJldHVybiBfZm4gJiYgX2ZuLnRvU3RyaW5nKCkgfHwgXCJ1bmRlZmluZWRcIjtcbn1cbmV4cG9ydHMuZm5Ub1N0cmluZyA9IGZuVG9TdHJpbmc7XG52YXIgc3RyaW5naWZ5UGF0dGVybkZuID0gbnVsbDtcbnZhciBzdHJpbmdpZnlQYXR0ZXJuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGlzUmVqZWN0aW9uID0gcmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5pc1JlamVjdGlvblByb21pc2U7XG4gICAgc3RyaW5naWZ5UGF0dGVybkZuID0gc3RyaW5naWZ5UGF0dGVybkZuIHx8IGhvZl8xLnBhdHRlcm4oW1xuICAgICAgICBbaG9mXzEubm90KHByZWRpY2F0ZXNfMS5pc0RlZmluZWQpLCBob2ZfMS52YWwoXCJ1bmRlZmluZWRcIildLFxuICAgICAgICBbcHJlZGljYXRlc18xLmlzTnVsbCwgaG9mXzEudmFsKFwibnVsbFwiKV0sXG4gICAgICAgIFtwcmVkaWNhdGVzXzEuaXNQcm9taXNlLCBob2ZfMS52YWwoXCJbUHJvbWlzZV1cIildLFxuICAgICAgICBbaXNSZWplY3Rpb24sIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll90cmFuc2l0aW9uUmVqZWN0aW9uLnRvU3RyaW5nKCk7IH1dLFxuICAgICAgICBbaG9mXzEuaXMocmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbiksIGhvZl8xLmludm9rZShcInRvU3RyaW5nXCIpXSxcbiAgICAgICAgW2hvZl8xLmlzKHRyYW5zaXRpb25fMS5UcmFuc2l0aW9uKSwgaG9mXzEuaW52b2tlKFwidG9TdHJpbmdcIildLFxuICAgICAgICBbaG9mXzEuaXMocmVzb2x2YWJsZV8xLlJlc29sdmFibGUpLCBob2ZfMS5pbnZva2UoXCJ0b1N0cmluZ1wiKV0sXG4gICAgICAgIFtwcmVkaWNhdGVzXzEuaXNJbmplY3RhYmxlLCBmdW5jdGlvblRvU3RyaW5nXSxcbiAgICAgICAgW2hvZl8xLnZhbCh0cnVlKSwgY29tbW9uXzEuaWRlbnRpdHldXG4gICAgXSk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVBhdHRlcm5Gbih2YWx1ZSk7XG59O1xuZnVuY3Rpb24gc3RyaW5naWZ5KG8pIHtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZ1bmN0aW9uIGZvcm1hdCh2YWwpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc09iamVjdCh2YWwpKSB7XG4gICAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKHZhbCkgIT09IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiAnW2NpcmN1bGFyIHJlZl0nO1xuICAgICAgICAgICAgc2Vlbi5wdXNoKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeVBhdHRlcm4odmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG8sIGZ1bmN0aW9uIChrZXksIHZhbCkgeyByZXR1cm4gZm9ybWF0KHZhbCk7IH0pLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKTtcbn1cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuLyoqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHNwbGl0cyBhIHN0cmluZyBvbiBhIGNoYXJhY3RlciBvciBzdWJzdHJpbmcgKi9cbmV4cG9ydHMuYmVmb3JlQWZ0ZXJTdWJzdHIgPSBmdW5jdGlvbiAoY2hhcikgeyByZXR1cm4gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmICghc3RyKVxuICAgICAgICByZXR1cm4gW1wiXCIsIFwiXCJdO1xuICAgIHZhciBpZHggPSBzdHIuaW5kZXhPZihjaGFyKTtcbiAgICBpZiAoaWR4ID09PSAtMSlcbiAgICAgICAgcmV0dXJuIFtzdHIsIFwiXCJdO1xuICAgIHJldHVybiBbc3RyLnN1YnN0cigwLCBpZHgpLCBzdHIuc3Vic3RyKGlkeCArIDEpXTtcbn07IH07XG5leHBvcnRzLmhvc3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oPzpbYS16XSs6KT8vL1teL10rLycpO1xuZXhwb3J0cy5zdHJpcEZpbGUgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHIucmVwbGFjZSgvXFwvW14vXSokLywgJycpOyB9O1xuZXhwb3J0cy5zcGxpdEhhc2ggPSBleHBvcnRzLmJlZm9yZUFmdGVyU3Vic3RyKFwiI1wiKTtcbmV4cG9ydHMuc3BsaXRRdWVyeSA9IGV4cG9ydHMuYmVmb3JlQWZ0ZXJTdWJzdHIoXCI/XCIpO1xuZXhwb3J0cy5zcGxpdEVxdWFsID0gZXhwb3J0cy5iZWZvcmVBZnRlclN1YnN0cihcIj1cIik7XG5leHBvcnRzLnRyaW1IYXNoVmFsID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyID8gc3RyLnJlcGxhY2UoL14jLywgXCJcIikgOiBcIlwiOyB9O1xuLyoqXG4gKiBTcGxpdHMgb24gYSBkZWxpbWl0ZXIsIGJ1dCByZXR1cm5zIHRoZSBkZWxpbWl0ZXJzIGluIHRoZSBhcnJheVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiB2YXIgc3BsaXRPblNsYXNoZXMgPSBzcGxpdE9uRGVsaW0oJy8nKTtcbiAqIHNwbGl0T25TbGFzaGVzKFwiL2Zvb1wiKTsgLy8gW1wiL1wiLCBcImZvb1wiXVxuICogc3BsaXRPblNsYXNoZXMoXCIvZm9vL1wiKTsgLy8gW1wiL1wiLCBcImZvb1wiLCBcIi9cIl1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBzcGxpdE9uRGVsaW0oZGVsaW0pIHtcbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiKFwiICsgZGVsaW0gKyBcIilcIiwgXCJnXCIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIuc3BsaXQocmUpLmZpbHRlcihjb21tb25fMS5pZGVudGl0eSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuc3BsaXRPbkRlbGltID0gc3BsaXRPbkRlbGltO1xuO1xuLyoqXG4gKiBSZWR1Y2UgZm4gdGhhdCBqb2lucyBuZWlnaGJvcmluZyBzdHJpbmdzXG4gKlxuICogR2l2ZW4gYW4gYXJyYXkgb2Ygc3RyaW5ncywgcmV0dXJucyBhIG5ldyBhcnJheVxuICogd2hlcmUgYWxsIG5laWdoYm9yaW5nIHN0cmluZ3MgaGF2ZSBiZWVuIGpvaW5lZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogbGV0IGFyciA9IFtcImZvb1wiLCBcImJhclwiLCAxLCBcImJhelwiLCBcIlwiLCBcInF1eFwiIF07XG4gKiBhcnIucmVkdWNlKGpvaW5OZWlnaGJvcnNSLCBbXSkgLy8gW1wiZm9vYmFyXCIsIDEsIFwiYmF6cXV4XCIgXVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGpvaW5OZWlnaGJvcnNSKGFjYywgeCkge1xuICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcoY29tbW9uXzEudGFpbChhY2MpKSAmJiBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoeCkpXG4gICAgICAgIHJldHVybiBhY2Muc2xpY2UoMCwgLTEpLmNvbmNhdChjb21tb25fMS50YWlsKGFjYykgKyB4KTtcbiAgICByZXR1cm4gY29tbW9uXzEucHVzaFIoYWNjLCB4KTtcbn1cbmV4cG9ydHMuam9pbk5laWdoYm9yc1IgPSBqb2luTmVpZ2hib3JzUjtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZ3MuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9zdHJpbmdzLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiAjIFRyYW5zaXRpb24gdHJhY2luZyAoZGVidWcpXG4gKlxuICogRW5hYmxlIHRyYW5zaXRpb24gdHJhY2luZyB0byBwcmludCB0cmFuc2l0aW9uIGluZm9ybWF0aW9uIHRvIHRoZSBjb25zb2xlLFxuICogaW4gb3JkZXIgdG8gaGVscCBkZWJ1ZyB5b3VyIGFwcGxpY2F0aW9uLlxuICogVHJhY2luZyBsb2dzIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IGVhY2ggVHJhbnNpdGlvbiB0byB5b3VyIGNvbnNvbGUuXG4gKlxuICogVG8gZW5hYmxlIHRyYWNpbmcsIGltcG9ydCB0aGUgW1tUcmFjZV1dIHNpbmdsZXRvbiBhbmQgZW5hYmxlIG9uZSBvciBtb3JlIGNhdGVnb3JpZXMuXG4gKlxuICogIyMjIEVTNlxuICogYGBganNcbiAqIGltcG9ydCB7dHJhY2V9IGZyb20gXCJ1aS1yb3V0ZXItbmcyXCI7IC8vIG9yIFwiYW5ndWxhci11aS1yb3V0ZXJcIlxuICogdHJhY2UuZW5hYmxlKDEsIDUpOyAvLyBUUkFOU0lUSU9OIGFuZCBWSUVXQ09ORklHXG4gKiBgYGBcbiAqXG4gKiAjIyMgQ0pTXG4gKiBgYGBqc1xuICogbGV0IHRyYWNlID0gcmVxdWlyZShcImFuZ3VsYXItdWktcm91dGVyXCIpLnRyYWNlOyAvLyBvciBcInVpLXJvdXRlci1uZzJcIlxuICogdHJhY2UuZW5hYmxlKFwiVFJBTlNJVElPTlwiLCBcIlZJRVdDT05GSUdcIik7XG4gKiBgYGBcbiAqXG4gKiAjIyMgR2xvYmFsc1xuICogYGBganNcbiAqIGxldCB0cmFjZSA9IHdpbmRvd1tcImFuZ3VsYXItdWktcm91dGVyXCJdLnRyYWNlOyAvLyBvciBcInVpLXJvdXRlci1uZzJcIlxuICogdHJhY2UuZW5hYmxlKCk7IC8vIFRyYWNlIGV2ZXJ5dGhpbmcgKHZlcnkgdmVyYm9zZSlcbiAqIGBgYFxuICpcbiAqICMjIyBBbmd1bGFyIDE6XG4gKiBgYGBqc1xuICogYXBwLnJ1bigkdHJhY2UgPT4gJHRyYWNlLmVuYWJsZSgpKTtcbiAqIGBgYFxuICpcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHRyYWNlXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIi4vc3RyaW5nc1wiKTtcbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiB1aVZpZXdTdHJpbmcodWl2aWV3KSB7XG4gICAgaWYgKCF1aXZpZXcpXG4gICAgICAgIHJldHVybiAndWktdmlldyAoZGVmdW5jdCknO1xuICAgIHZhciBzdGF0ZSA9IHVpdmlldy5jcmVhdGlvbkNvbnRleHQgPyB1aXZpZXcuY3JlYXRpb25Db250ZXh0Lm5hbWUgfHwgJyhyb290KScgOiAnKG5vbmUpJztcbiAgICByZXR1cm4gXCJbdWktdmlldyNcIiArIHVpdmlldy5pZCArIFwiIFwiICsgdWl2aWV3LiR0eXBlICsgXCI6XCIgKyB1aXZpZXcuZnFuICsgXCIgKFwiICsgdWl2aWV3Lm5hbWUgKyBcIkBcIiArIHN0YXRlICsgXCIpXVwiO1xufVxuLyoqIEBoaWRkZW4gKi9cbnZhciB2aWV3Q29uZmlnU3RyaW5nID0gZnVuY3Rpb24gKHZpZXdDb25maWcpIHtcbiAgICB2YXIgdmlldyA9IHZpZXdDb25maWcudmlld0RlY2w7XG4gICAgdmFyIHN0YXRlID0gdmlldy4kY29udGV4dC5uYW1lIHx8ICcocm9vdCknO1xuICAgIHJldHVybiBcIltWaWV3I1wiICsgdmlld0NvbmZpZy4kaWQgKyBcIiBmcm9tICdcIiArIHN0YXRlICsgXCInIHN0YXRlXTogdGFyZ2V0IHVpLXZpZXc6ICdcIiArIHZpZXcuJHVpVmlld05hbWUgKyBcIkBcIiArIHZpZXcuJHVpVmlld0NvbnRleHRBbmNob3IgKyBcIidcIjtcbn07XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplZENhdChpbnB1dCkge1xuICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNOdW1iZXIoaW5wdXQpID8gQ2F0ZWdvcnlbaW5wdXRdIDogQ2F0ZWdvcnlbQ2F0ZWdvcnlbaW5wdXRdXTtcbn1cbi8qKiBAaGlkZGVuICovXG52YXIgY29uc29sZXRhYmxlID0gcHJlZGljYXRlc18xLmlzRnVuY3Rpb24oY29uc29sZS50YWJsZSkgPyBjb25zb2xlLnRhYmxlLmJpbmQoY29uc29sZSkgOiBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuLyoqXG4gKiBUcmFjZSBjYXRlZ29yaWVzIEVudW1cbiAqXG4gKiBFbmFibGUgb3IgZGlzYWJsZSBhIGNhdGVnb3J5IHVzaW5nIFtbVHJhY2UuZW5hYmxlXV0gb3IgW1tUcmFjZS5kaXNhYmxlXV1cbiAqXG4gKiBgdHJhY2UuZW5hYmxlKENhdGVnb3J5LlRSQU5TSVRJT04pYFxuICpcbiAqIFRoZXNlIGNhbiBhbHNvIGJlIHByb3ZpZGVkIHVzaW5nIGEgbWF0Y2hpbmcgc3RyaW5nLCBvciBwb3NpdGlvbiBvcmRpbmFsXG4gKlxuICogYHRyYWNlLmVuYWJsZShcIlRSQU5TSVRJT05cIilgXG4gKlxuICogYHRyYWNlLmVuYWJsZSgxKWBcbiAqL1xudmFyIENhdGVnb3J5O1xuKGZ1bmN0aW9uIChDYXRlZ29yeSkge1xuICAgIENhdGVnb3J5W0NhdGVnb3J5W1wiUkVTT0xWRVwiXSA9IDBdID0gXCJSRVNPTFZFXCI7XG4gICAgQ2F0ZWdvcnlbQ2F0ZWdvcnlbXCJUUkFOU0lUSU9OXCJdID0gMV0gPSBcIlRSQU5TSVRJT05cIjtcbiAgICBDYXRlZ29yeVtDYXRlZ29yeVtcIkhPT0tcIl0gPSAyXSA9IFwiSE9PS1wiO1xuICAgIENhdGVnb3J5W0NhdGVnb3J5W1wiVUlWSUVXXCJdID0gM10gPSBcIlVJVklFV1wiO1xuICAgIENhdGVnb3J5W0NhdGVnb3J5W1wiVklFV0NPTkZJR1wiXSA9IDRdID0gXCJWSUVXQ09ORklHXCI7XG59KShDYXRlZ29yeSA9IGV4cG9ydHMuQ2F0ZWdvcnkgfHwgKGV4cG9ydHMuQ2F0ZWdvcnkgPSB7fSkpO1xuLyoqIEBoaWRkZW4gKi8gdmFyIF90aWQgPSBob2ZfMS5wYXJzZShcIiRpZFwiKTtcbi8qKiBAaGlkZGVuICovIHZhciBfcmlkID0gaG9mXzEucGFyc2UoXCJyb3V0ZXIuJGlkXCIpO1xuLyoqIEBoaWRkZW4gKi8gdmFyIHRyYW5zTGJsID0gZnVuY3Rpb24gKHRyYW5zKSB7IHJldHVybiBcIlRyYW5zaXRpb24gI1wiICsgX3RpZCh0cmFucykgKyBcIi1cIiArIF9yaWQodHJhbnMpOyB9O1xuLyoqXG4gKiBQcmludHMgVUktUm91dGVyIFRyYW5zaXRpb24gdHJhY2UgaW5mb3JtYXRpb24gdG8gdGhlIGNvbnNvbGUuXG4gKi9cbnZhciBUcmFjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGZ1bmN0aW9uIFRyYWNlKCkge1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9lbmFibGVkID0ge307XG4gICAgICAgIHRoaXMuYXBwcm94aW1hdGVEaWdlc3RzID0gMDtcbiAgICB9XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUcmFjZS5wcm90b3R5cGUuX3NldCA9IGZ1bmN0aW9uIChlbmFibGVkLCBjYXRlZ29yaWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghY2F0ZWdvcmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXMgPSBPYmplY3Qua2V5cyhDYXRlZ29yeSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBwYXJzZUludChrLCAxMCk7IH0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gIWlzTmFOKGspOyB9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gQ2F0ZWdvcnlba2V5XTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0ZWdvcmllcy5tYXAobm9ybWFsaXplZENhdCkuZm9yRWFjaChmdW5jdGlvbiAoY2F0ZWdvcnkpIHsgcmV0dXJuIF90aGlzLl9lbmFibGVkW2NhdGVnb3J5XSA9IGVuYWJsZWQ7IH0pO1xuICAgIH07XG4gICAgVHJhY2UucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXQodHJ1ZSwgY2F0ZWdvcmllcyk7XG4gICAgfTtcbiAgICBUcmFjZS5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXQoZmFsc2UsIGNhdGVnb3JpZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBlbmFibGVkIHN0YXRldXMgb2YgYSBbW0NhdGVnb3J5XV1cbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogdHJhY2UuZW5hYmxlZChcIlZJRVdDT05GSUdcIik7IC8vIHRydWUgb3IgZmFsc2VcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGJvb2xlYW4gdHJ1ZSBpZiB0aGUgY2F0ZWdvcnkgaXMgZW5hYmxlZFxuICAgICAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS5lbmFibGVkID0gZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2VuYWJsZWRbbm9ybWFsaXplZENhdChjYXRlZ29yeSldO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VUcmFuc2l0aW9uU3RhcnQgPSBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVFJBTlNJVElPTikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKHRyYW5zTGJsKHRyYW5zKSArIFwiOiBTdGFydGVkICAtPiBcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkodHJhbnMpKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVHJhbnNpdGlvbklnbm9yZWQgPSBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVFJBTlNJVElPTikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKHRyYW5zTGJsKHRyYW5zKSArIFwiOiBJZ25vcmVkICA8PiBcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkodHJhbnMpKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlSG9va0ludm9jYXRpb24gPSBmdW5jdGlvbiAoc3RlcCwgdHJhbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuSE9PSykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBldmVudCA9IGhvZl8xLnBhcnNlKFwidHJhY2VEYXRhLmhvb2tUeXBlXCIpKG9wdGlvbnMpIHx8IFwiaW50ZXJuYWxcIiwgY29udGV4dCA9IGhvZl8xLnBhcnNlKFwidHJhY2VEYXRhLmNvbnRleHQuc3RhdGUubmFtZVwiKShvcHRpb25zKSB8fCBob2ZfMS5wYXJzZShcInRyYWNlRGF0YS5jb250ZXh0XCIpKG9wdGlvbnMpIHx8IFwidW5rbm93blwiLCBuYW1lID0gc3RyaW5nc18xLmZ1bmN0aW9uVG9TdHJpbmcoc3RlcC5yZWdpc3RlcmVkSG9vay5jYWxsYmFjayk7XG4gICAgICAgIGNvbnNvbGUubG9nKHRyYW5zTGJsKHRyYW5zKSArIFwiOiAgIEhvb2sgLT4gXCIgKyBldmVudCArIFwiIGNvbnRleHQ6IFwiICsgY29udGV4dCArIFwiLCBcIiArIHN0cmluZ3NfMS5tYXhMZW5ndGgoMjAwLCBuYW1lKSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZUhvb2tSZXN1bHQgPSBmdW5jdGlvbiAoaG9va1Jlc3VsdCwgdHJhbnMsIHRyYW5zaXRpb25PcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LkhPT0spKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyh0cmFuc0xibCh0cmFucykgKyBcIjogICA8LSBIb29rIHJldHVybmVkOiBcIiArIHN0cmluZ3NfMS5tYXhMZW5ndGgoMjAwLCBzdHJpbmdzXzEuc3RyaW5naWZ5KGhvb2tSZXN1bHQpKSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVJlc29sdmVQYXRoID0gZnVuY3Rpb24gKHBhdGgsIHdoZW4sIHRyYW5zKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlJFU09MVkUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyh0cmFuc0xibCh0cmFucykgKyBcIjogICAgICAgICBSZXNvbHZpbmcgXCIgKyBwYXRoICsgXCIgKFwiICsgd2hlbiArIFwiKVwiKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlUmVzb2x2YWJsZVJlc29sdmVkID0gZnVuY3Rpb24gKHJlc29sdmFibGUsIHRyYW5zKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlJFU09MVkUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyh0cmFuc0xibCh0cmFucykgKyBcIjogICAgICAgICAgICAgICA8LSBSZXNvbHZlZCAgXCIgKyByZXNvbHZhYmxlICsgXCIgdG86IFwiICsgc3RyaW5nc18xLm1heExlbmd0aCgyMDAsIHN0cmluZ3NfMS5zdHJpbmdpZnkocmVzb2x2YWJsZS5kYXRhKSkpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VFcnJvciA9IGZ1bmN0aW9uIChyZWFzb24sIHRyYW5zKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlRSQU5TSVRJT04pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyh0cmFuc0xibCh0cmFucykgKyBcIjogPC0gUmVqZWN0ZWQgXCIgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KHRyYW5zKSArIFwiLCByZWFzb246IFwiICsgcmVhc29uKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlU3VjY2VzcyA9IGZ1bmN0aW9uIChmaW5hbFN0YXRlLCB0cmFucykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5UUkFOU0lUSU9OKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc29sZS5sb2codHJhbnNMYmwodHJhbnMpICsgXCI6IDwtIFN1Y2Nlc3MgIFwiICsgc3RyaW5nc18xLnN0cmluZ2lmeSh0cmFucykgKyBcIiwgZmluYWwgc3RhdGU6IFwiICsgZmluYWxTdGF0ZS5uYW1lKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVUlWaWV3RXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIHZpZXdEYXRhLCBleHRyYSkge1xuICAgICAgICBpZiAoZXh0cmEgPT09IHZvaWQgMCkgeyBleHRyYSA9IFwiXCI7IH1cbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVUlWSUVXKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc29sZS5sb2coXCJ1aS12aWV3OiBcIiArIHN0cmluZ3NfMS5wYWRTdHJpbmcoMzAsIGV2ZW50KSArIFwiIFwiICsgdWlWaWV3U3RyaW5nKHZpZXdEYXRhKSArIGV4dHJhKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVUlWaWV3Q29uZmlnVXBkYXRlZCA9IGZ1bmN0aW9uICh2aWV3RGF0YSwgY29udGV4dCkge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5VSVZJRVcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnRyYWNlVUlWaWV3RXZlbnQoXCJVcGRhdGluZ1wiLCB2aWV3RGF0YSwgXCIgd2l0aCBWaWV3Q29uZmlnIGZyb20gY29udGV4dD0nXCIgKyBjb250ZXh0ICsgXCInXCIpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VVSVZpZXdGaWxsID0gZnVuY3Rpb24gKHZpZXdEYXRhLCBodG1sKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlVJVklFVykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMudHJhY2VVSVZpZXdFdmVudChcIkZpbGxcIiwgdmlld0RhdGEsIFwiIHdpdGg6IFwiICsgc3RyaW5nc18xLm1heExlbmd0aCgyMDAsIGh0bWwpKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVmlld1N5bmMgPSBmdW5jdGlvbiAocGFpcnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVklFV0NPTkZJRykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBtYXBwaW5nID0gcGFpcnMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHVpVmlld0RhdGEgPSBfYVswXSwgY29uZmlnID0gX2FbMV07XG4gICAgICAgICAgICB2YXIgdWlWaWV3ID0gdWlWaWV3RGF0YS4kdHlwZSArIFwiOlwiICsgdWlWaWV3RGF0YS5mcW47XG4gICAgICAgICAgICB2YXIgdmlldyA9IGNvbmZpZyAmJiBjb25maWcudmlld0RlY2wuJGNvbnRleHQubmFtZSArIFwiOiBcIiArIGNvbmZpZy52aWV3RGVjbC4kbmFtZSArIFwiIChcIiArIGNvbmZpZy52aWV3RGVjbC4kdHlwZSArIFwiKVwiO1xuICAgICAgICAgICAgcmV0dXJuIHsgJ3VpLXZpZXcgZnFuJzogdWlWaWV3LCAnc3RhdGU6IHZpZXcgbmFtZSc6IHZpZXcgfTtcbiAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVsndWktdmlldyBmcW4nXS5sb2NhbGVDb21wYXJlKGJbJ3VpLXZpZXcgZnFuJ10pOyB9KTtcbiAgICAgICAgY29uc29sZXRhYmxlKG1hcHBpbmcpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VWaWV3U2VydmljZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCB2aWV3Q29uZmlnKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlZJRVdDT05GSUcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlZJRVdDT05GSUc6IFwiICsgZXZlbnQgKyBcIiBcIiArIHZpZXdDb25maWdTdHJpbmcodmlld0NvbmZpZykpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VWaWV3U2VydmljZVVJVmlld0V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCB2aWV3RGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5WSUVXQ09ORklHKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc29sZS5sb2coXCJWSUVXQ09ORklHOiBcIiArIGV2ZW50ICsgXCIgXCIgKyB1aVZpZXdTdHJpbmcodmlld0RhdGEpKTtcbiAgICB9O1xuICAgIHJldHVybiBUcmFjZTtcbn0oKSk7XG5leHBvcnRzLlRyYWNlID0gVHJhY2U7XG4vKipcbiAqIFRoZSBbW1RyYWNlXV0gc2luZ2xldG9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBganNcbiAqIGltcG9ydCB7dHJhY2V9IGZyb20gXCJhbmd1bGFyLXVpLXJvdXRlclwiO1xuICogdHJhY2UuZW5hYmxlKDEsIDUpO1xuICogYGBgXG4gKi9cbnZhciB0cmFjZSA9IG5ldyBUcmFjZSgpO1xuZXhwb3J0cy50cmFjZSA9IHRyYWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi90cmFjZS5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTBfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIkBhbmd1bGFyL2NvbW1vblwiXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBUcmFuc2l0aW9uSG9va1BoYXNlO1xuKGZ1bmN0aW9uIChUcmFuc2l0aW9uSG9va1BoYXNlKSB7XG4gICAgVHJhbnNpdGlvbkhvb2tQaGFzZVtUcmFuc2l0aW9uSG9va1BoYXNlW1wiQ1JFQVRFXCJdID0gMF0gPSBcIkNSRUFURVwiO1xuICAgIFRyYW5zaXRpb25Ib29rUGhhc2VbVHJhbnNpdGlvbkhvb2tQaGFzZVtcIkJFRk9SRVwiXSA9IDFdID0gXCJCRUZPUkVcIjtcbiAgICBUcmFuc2l0aW9uSG9va1BoYXNlW1RyYW5zaXRpb25Ib29rUGhhc2VbXCJSVU5cIl0gPSAyXSA9IFwiUlVOXCI7XG4gICAgVHJhbnNpdGlvbkhvb2tQaGFzZVtUcmFuc2l0aW9uSG9va1BoYXNlW1wiU1VDQ0VTU1wiXSA9IDNdID0gXCJTVUNDRVNTXCI7XG4gICAgVHJhbnNpdGlvbkhvb2tQaGFzZVtUcmFuc2l0aW9uSG9va1BoYXNlW1wiRVJST1JcIl0gPSA0XSA9IFwiRVJST1JcIjtcbn0pKFRyYW5zaXRpb25Ib29rUGhhc2UgPSBleHBvcnRzLlRyYW5zaXRpb25Ib29rUGhhc2UgfHwgKGV4cG9ydHMuVHJhbnNpdGlvbkhvb2tQaGFzZSA9IHt9KSk7XG52YXIgVHJhbnNpdGlvbkhvb2tTY29wZTtcbihmdW5jdGlvbiAoVHJhbnNpdGlvbkhvb2tTY29wZSkge1xuICAgIFRyYW5zaXRpb25Ib29rU2NvcGVbVHJhbnNpdGlvbkhvb2tTY29wZVtcIlRSQU5TSVRJT05cIl0gPSAwXSA9IFwiVFJBTlNJVElPTlwiO1xuICAgIFRyYW5zaXRpb25Ib29rU2NvcGVbVHJhbnNpdGlvbkhvb2tTY29wZVtcIlNUQVRFXCJdID0gMV0gPSBcIlNUQVRFXCI7XG59KShUcmFuc2l0aW9uSG9va1Njb3BlID0gZXhwb3J0cy5UcmFuc2l0aW9uSG9va1Njb3BlIHx8IChleHBvcnRzLlRyYW5zaXRpb25Ib29rU2NvcGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL2ludGVyZmFjZS5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHN0YXRlXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc3RyaW5nc1wiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vKipcbiAqIEVuY2Fwc3VsYXRlIHRoZSB0YXJnZXQgKGRlc3RpbmF0aW9uKSBzdGF0ZS9wYXJhbXMvb3B0aW9ucyBvZiBhIFtbVHJhbnNpdGlvbl1dLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgZnJlcXVlbnRseSB1c2VkIHRvIHJlZGlyZWN0IGEgdHJhbnNpdGlvbiB0byBhIG5ldyBkZXN0aW5hdGlvbi5cbiAqXG4gKiBTZWU6XG4gKlxuICogLSBbW0hvb2tSZXN1bHRdXVxuICogLSBbW1RyYW5zaXRpb25Ib29rRm5dXVxuICogLSBbW1RyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnRdXVxuICpcbiAqIFRvIGNyZWF0ZSBhIGBUYXJnZXRTdGF0ZWAsIHVzZSBbW1N0YXRlU2VydmljZS50YXJnZXRdXS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBUaGlzIGNsYXNzIHdyYXBzOlxuICpcbiAqIDEpIGFuIGlkZW50aWZpZXIgZm9yIGEgc3RhdGVcbiAqIDIpIGEgc2V0IG9mIHBhcmFtZXRlcnNcbiAqIDMpIGFuZCB0cmFuc2l0aW9uIG9wdGlvbnNcbiAqIDQpIHRoZSByZWdpc3RlcmVkIHN0YXRlIG9iamVjdCAodGhlIFtbU3RhdGVEZWNsYXJhdGlvbl1dKVxuICpcbiAqIE1hbnkgVUktUm91dGVyIEFQSXMgc3VjaCBhcyBbW1N0YXRlU2VydmljZS5nb11dIHRha2UgYSBbW1N0YXRlT3JOYW1lXV0gYXJndW1lbnQgd2hpY2ggY2FuXG4gKiBlaXRoZXIgYmUgYSAqc3RhdGUgb2JqZWN0KiAoYSBbW1N0YXRlRGVjbGFyYXRpb25dXSBvciBbW1N0YXRlT2JqZWN0XV0pIG9yIGEgKnN0YXRlIG5hbWUqIChhIHN0cmluZykuXG4gKiBUaGUgYFRhcmdldFN0YXRlYCBjbGFzcyBub3JtYWxpemVzIHRob3NlIG9wdGlvbnMuXG4gKlxuICogQSBgVGFyZ2V0U3RhdGVgIG1heSBiZSB2YWxpZCAodGhlIHN0YXRlIGJlaW5nIHRhcmdldGVkIGV4aXN0cyBpbiB0aGUgcmVnaXN0cnkpXG4gKiBvciBpbnZhbGlkICh0aGUgc3RhdGUgYmVpbmcgdGFyZ2V0ZWQgaXMgbm90IHJlZ2lzdGVyZWQpLlxuICovXG52YXIgVGFyZ2V0U3RhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogVGhlIFRhcmdldFN0YXRlIGNvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBOb3RlOiBEbyBub3QgY29uc3RydWN0IGEgYFRhcmdldFN0YXRlYCBtYW51YWxseS5cbiAgICAgKiBUbyBjcmVhdGUgYSBgVGFyZ2V0U3RhdGVgLCB1c2UgdGhlIFtbU3RhdGVTZXJ2aWNlLnRhcmdldF1dIGZhY3RvcnkgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIF9zdGF0ZVJlZ2lzdHJ5IFRoZSBTdGF0ZVJlZ2lzdHJ5IHRvIHVzZSB0byBsb29rIHVwIHRoZSBfZGVmaW5pdGlvblxuICAgICAqIEBwYXJhbSBfaWRlbnRpZmllciBBbiBpZGVudGlmaWVyIGZvciBhIHN0YXRlLlxuICAgICAqICAgIEVpdGhlciBhIGZ1bGx5LXF1YWxpZmllZCBzdGF0ZSBuYW1lLCBvciB0aGUgb2JqZWN0IHVzZWQgdG8gZGVmaW5lIHRoZSBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gX3BhcmFtcyBQYXJhbWV0ZXJzIGZvciB0aGUgdGFyZ2V0IHN0YXRlXG4gICAgICogQHBhcmFtIF9vcHRpb25zIFRyYW5zaXRpb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRhcmdldFN0YXRlKF9zdGF0ZVJlZ2lzdHJ5LCBfaWRlbnRpZmllciwgX3BhcmFtcywgX29wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fc3RhdGVSZWdpc3RyeSA9IF9zdGF0ZVJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLl9pZGVudGlmaWVyID0gX2lkZW50aWZpZXI7XG4gICAgICAgIHRoaXMuX2lkZW50aWZpZXIgPSBfaWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy5fcGFyYW1zID0gY29tbW9uXzEuZXh0ZW5kKHt9LCBfcGFyYW1zIHx8IHt9KTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IGNvbW1vbl8xLmV4dGVuZCh7fSwgX29wdGlvbnMgfHwge30pO1xuICAgICAgICB0aGlzLl9kZWZpbml0aW9uID0gX3N0YXRlUmVnaXN0cnkubWF0Y2hlci5maW5kKF9pZGVudGlmaWVyLCB0aGlzLl9vcHRpb25zLnJlbGF0aXZlKTtcbiAgICB9XG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBzdGF0ZSB0aGlzIG9iamVjdCB0YXJnZXRzICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uICYmIHRoaXMuX2RlZmluaXRpb24ubmFtZSB8fCB0aGlzLl9pZGVudGlmaWVyO1xuICAgIH07XG4gICAgLyoqIFRoZSBpZGVudGlmaWVyIHVzZWQgd2hlbiBjcmVhdGluZyB0aGlzIFRhcmdldFN0YXRlICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLmlkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZGVudGlmaWVyO1xuICAgIH07XG4gICAgLyoqIFRoZSB0YXJnZXQgcGFyYW1ldGVyIHZhbHVlcyAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbXM7XG4gICAgfTtcbiAgICAvKiogVGhlIGludGVybmFsIHN0YXRlIG9iamVjdCAoaWYgaXQgd2FzIGZvdW5kKSAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS4kc3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uO1xuICAgIH07XG4gICAgLyoqIFRoZSBpbnRlcm5hbCBzdGF0ZSBkZWNsYXJhdGlvbiAoaWYgaXQgd2FzIGZvdW5kKSAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb24gJiYgdGhpcy5fZGVmaW5pdGlvbi5zZWxmO1xuICAgIH07XG4gICAgLyoqIFRoZSB0YXJnZXQgb3B0aW9ucyAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgICB9O1xuICAgIC8qKiBUcnVlIGlmIHRoZSB0YXJnZXQgc3RhdGUgd2FzIGZvdW5kICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuX2RlZmluaXRpb24gJiYgdGhpcy5fZGVmaW5pdGlvbi5zZWxmKTtcbiAgICB9O1xuICAgIC8qKiBUcnVlIGlmIHRoZSBvYmplY3QgaXMgdmFsaWQgKi9cbiAgICBUYXJnZXRTdGF0ZS5wcm90b3R5cGUudmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5lcnJvcigpO1xuICAgIH07XG4gICAgLyoqIElmIHRoZSBvYmplY3QgaXMgaW52YWxpZCwgcmV0dXJucyB0aGUgcmVhc29uIHdoeSAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJhc2UgPSB0aGlzLm9wdGlvbnMoKS5yZWxhdGl2ZTtcbiAgICAgICAgaWYgKCF0aGlzLl9kZWZpbml0aW9uICYmICEhYmFzZSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlTmFtZSA9IGJhc2UubmFtZSA/IGJhc2UubmFtZSA6IGJhc2U7XG4gICAgICAgICAgICByZXR1cm4gXCJDb3VsZCBub3QgcmVzb2x2ZSAnXCIgKyB0aGlzLm5hbWUoKSArIFwiJyBmcm9tIHN0YXRlICdcIiArIHN0YXRlTmFtZSArIFwiJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZGVmaW5pdGlvbilcbiAgICAgICAgICAgIHJldHVybiBcIk5vIHN1Y2ggc3RhdGUgJ1wiICsgdGhpcy5uYW1lKCkgKyBcIidcIjtcbiAgICAgICAgaWYgKCF0aGlzLl9kZWZpbml0aW9uLnNlbGYpXG4gICAgICAgICAgICByZXR1cm4gXCJTdGF0ZSAnXCIgKyB0aGlzLm5hbWUoKSArIFwiJyBoYXMgYW4gaW52YWxpZCBkZWZpbml0aW9uXCI7XG4gICAgfTtcbiAgICBUYXJnZXRTdGF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIidcIiArIHRoaXMubmFtZSgpICsgXCInXCIgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KHRoaXMucGFyYW1zKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBUYXJnZXRTdGF0ZSB3aGljaCB0YXJnZXRzIGEgZGlmZmVyZW50IHN0YXRlLlxuICAgICAqIFRoZSBuZXcgVGFyZ2V0U3RhdGUgaGFzIHRoZSBzYW1lIHBhcmFtZXRlciB2YWx1ZXMgYW5kIHRyYW5zaXRpb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgbmV3IHN0YXRlIHRoYXQgc2hvdWxkIGJlIHRhcmdldGVkXG4gICAgICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLndpdGhTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRhcmdldFN0YXRlKHRoaXMuX3N0YXRlUmVnaXN0cnksIHN0YXRlLCB0aGlzLl9wYXJhbXMsIHRoaXMuX29wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBUYXJnZXRTdGF0ZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyB0aGUgbmV3IHBhcmFtZXRlciB2YWx1ZXMgdG8gdXNlXG4gICAgICogQHBhcmFtIHJlcGxhY2UgV2hlbiBmYWxzZSAoZGVmYXVsdCkgdGhlIG5ldyBwYXJhbWV0ZXIgdmFsdWVzIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIGN1cnJlbnQgdmFsdWVzLlxuICAgICAqICAgICAgICAgICAgICAgIFdoZW4gdHJ1ZSB0aGUgcGFyYW1ldGVyIHZhbHVlcyB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgY3VycmVudCB2YWx1ZXMuXG4gICAgICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLndpdGhQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCByZXBsYWNlKSB7XG4gICAgICAgIGlmIChyZXBsYWNlID09PSB2b2lkIDApIHsgcmVwbGFjZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBuZXdQYXJhbXMgPSByZXBsYWNlID8gcGFyYW1zIDogY29tbW9uXzEuZXh0ZW5kKHt9LCB0aGlzLl9wYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0U3RhdGUodGhpcy5fc3RhdGVSZWdpc3RyeSwgdGhpcy5faWRlbnRpZmllciwgbmV3UGFyYW1zLCB0aGlzLl9vcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgVGFyZ2V0U3RhdGUsIHVzaW5nIHRoZSBzcGVjaWZpZWQgVHJhbnNpdGlvbiBPcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG5ldyBvcHRpb25zIHRvIHVzZVxuICAgICAqIEBwYXJhbSByZXBsYWNlIFdoZW4gZmFsc2UgKGRlZmF1bHQpIHRoZSBuZXcgb3B0aW9ucyB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZSBjdXJyZW50IG9wdGlvbnMuXG4gICAgICogICAgICAgICAgICAgICAgV2hlbiB0cnVlIHRoZSBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IG9wdGlvbnMuXG4gICAgICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLndpdGhPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMsIHJlcGxhY2UpIHtcbiAgICAgICAgaWYgKHJlcGxhY2UgPT09IHZvaWQgMCkgeyByZXBsYWNlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIG5ld09wdHMgPSByZXBsYWNlID8gb3B0aW9ucyA6IGNvbW1vbl8xLmV4dGVuZCh7fSwgdGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0U3RhdGUodGhpcy5fc3RhdGVSZWdpc3RyeSwgdGhpcy5faWRlbnRpZmllciwgdGhpcy5fcGFyYW1zLCBuZXdPcHRzKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBoYXMgYSBzdGF0ZSBwcm9wZXJ0eSB0aGF0IG1pZ2h0IGJlIGEgc3RhdGUgb3Igc3RhdGUgbmFtZSAqL1xuICAgIFRhcmdldFN0YXRlLmlzRGVmID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIG9iai5zdGF0ZSAmJiAocHJlZGljYXRlc18xLmlzU3RyaW5nKG9iai5zdGF0ZSkgfHwgcHJlZGljYXRlc18xLmlzU3RyaW5nKG9iai5zdGF0ZS5uYW1lKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFyZ2V0U3RhdGU7XG59KCkpO1xuZXhwb3J0cy5UYXJnZXRTdGF0ZSA9IFRhcmdldFN0YXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFyZ2V0U3RhdGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3RhcmdldFN0YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgcGFyYW1zXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIHBhcmFtVHlwZV8xID0gcmVxdWlyZShcIi4vcGFyYW1UeXBlXCIpO1xuLyoqIEBoaWRkZW4gKi8gdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4vKiogQGhpZGRlbiAqLyB2YXIgaXNTaG9ydGhhbmQgPSBmdW5jdGlvbiAoY2ZnKSB7XG4gICAgcmV0dXJuIFtcInZhbHVlXCIsIFwidHlwZVwiLCBcInNxdWFzaFwiLCBcImFycmF5XCIsIFwiZHluYW1pY1wiXS5maWx0ZXIoaGFzT3duLmJpbmQoY2ZnIHx8IHt9KSkubGVuZ3RoID09PSAwO1xufTtcbi8qKiBAaW50ZXJuYWxhcGkgKi9cbnZhciBEZWZUeXBlO1xuKGZ1bmN0aW9uIChEZWZUeXBlKSB7XG4gICAgRGVmVHlwZVtEZWZUeXBlW1wiUEFUSFwiXSA9IDBdID0gXCJQQVRIXCI7XG4gICAgRGVmVHlwZVtEZWZUeXBlW1wiU0VBUkNIXCJdID0gMV0gPSBcIlNFQVJDSFwiO1xuICAgIERlZlR5cGVbRGVmVHlwZVtcIkNPTkZJR1wiXSA9IDJdID0gXCJDT05GSUdcIjtcbn0pKERlZlR5cGUgPSBleHBvcnRzLkRlZlR5cGUgfHwgKGV4cG9ydHMuRGVmVHlwZSA9IHt9KSk7XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gdW53cmFwU2hvcnRoYW5kKGNmZykge1xuICAgIGNmZyA9IGlzU2hvcnRoYW5kKGNmZykgJiYgeyB2YWx1ZTogY2ZnIH0gfHwgY2ZnO1xuICAgIGdldFN0YXRpY0RlZmF1bHRWYWx1ZVsnX19jYWNoZWFibGUnXSA9IHRydWU7XG4gICAgZnVuY3Rpb24gZ2V0U3RhdGljRGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gY2ZnLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKGNmZywge1xuICAgICAgICAkJGZuOiBwcmVkaWNhdGVzXzEuaXNJbmplY3RhYmxlKGNmZy52YWx1ZSkgPyBjZmcudmFsdWUgOiBnZXRTdGF0aWNEZWZhdWx0VmFsdWUsXG4gICAgfSk7XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZShjZmcsIHVybFR5cGUsIGxvY2F0aW9uLCBpZCwgcGFyYW1UeXBlcykge1xuICAgIGlmIChjZmcudHlwZSAmJiB1cmxUeXBlICYmIHVybFR5cGUubmFtZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtICdcIiArIGlkICsgXCInIGhhcyB0d28gdHlwZSBjb25maWd1cmF0aW9ucy5cIik7XG4gICAgaWYgKGNmZy50eXBlICYmIHVybFR5cGUgJiYgdXJsVHlwZS5uYW1lID09PSAnc3RyaW5nJyAmJiBwYXJhbVR5cGVzLnR5cGUoY2ZnLnR5cGUpKVxuICAgICAgICByZXR1cm4gcGFyYW1UeXBlcy50eXBlKGNmZy50eXBlKTtcbiAgICBpZiAodXJsVHlwZSlcbiAgICAgICAgcmV0dXJuIHVybFR5cGU7XG4gICAgaWYgKCFjZmcudHlwZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGxvY2F0aW9uID09PSBEZWZUeXBlLkNPTkZJRyA/IFwiYW55XCIgOlxuICAgICAgICAgICAgbG9jYXRpb24gPT09IERlZlR5cGUuUEFUSCA/IFwicGF0aFwiIDpcbiAgICAgICAgICAgICAgICBsb2NhdGlvbiA9PT0gRGVmVHlwZS5TRUFSQ0ggPyBcInF1ZXJ5XCIgOiBcInN0cmluZ1wiO1xuICAgICAgICByZXR1cm4gcGFyYW1UeXBlcy50eXBlKHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2ZnLnR5cGUgaW5zdGFuY2VvZiBwYXJhbVR5cGVfMS5QYXJhbVR5cGUgPyBjZmcudHlwZSA6IHBhcmFtVHlwZXMudHlwZShjZmcudHlwZSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogcmV0dXJucyBmYWxzZSwgdHJ1ZSwgb3IgdGhlIHNxdWFzaCB2YWx1ZSB0byBpbmRpY2F0ZSB0aGUgXCJkZWZhdWx0IHBhcmFtZXRlciB1cmwgc3F1YXNoIHBvbGljeVwiLlxuICovXG5mdW5jdGlvbiBnZXRTcXVhc2hQb2xpY3koY29uZmlnLCBpc09wdGlvbmFsLCBkZWZhdWx0UG9saWN5KSB7XG4gICAgdmFyIHNxdWFzaCA9IGNvbmZpZy5zcXVhc2g7XG4gICAgaWYgKCFpc09wdGlvbmFsIHx8IHNxdWFzaCA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoc3F1YXNoKSB8fCBzcXVhc2ggPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQb2xpY3k7XG4gICAgaWYgKHNxdWFzaCA9PT0gdHJ1ZSB8fCBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc3F1YXNoKSlcbiAgICAgICAgcmV0dXJuIHNxdWFzaDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNxdWFzaCBwb2xpY3k6ICdcIiArIHNxdWFzaCArIFwiJy4gVmFsaWQgcG9saWNpZXM6IGZhbHNlLCB0cnVlLCBvciBhcmJpdHJhcnkgc3RyaW5nXCIpO1xufVxuLyoqIEBpbnRlcm5hbGFwaSAqL1xuZnVuY3Rpb24gZ2V0UmVwbGFjZShjb25maWcsIGFycmF5TW9kZSwgaXNPcHRpb25hbCwgc3F1YXNoKSB7XG4gICAgdmFyIHJlcGxhY2UsIGNvbmZpZ3VyZWRLZXlzLCBkZWZhdWx0UG9saWN5ID0gW1xuICAgICAgICB7IGZyb206IFwiXCIsIHRvOiAoaXNPcHRpb25hbCB8fCBhcnJheU1vZGUgPyB1bmRlZmluZWQgOiBcIlwiKSB9LFxuICAgICAgICB7IGZyb206IG51bGwsIHRvOiAoaXNPcHRpb25hbCB8fCBhcnJheU1vZGUgPyB1bmRlZmluZWQgOiBcIlwiKSB9LFxuICAgIF07XG4gICAgcmVwbGFjZSA9IHByZWRpY2F0ZXNfMS5pc0FycmF5KGNvbmZpZy5yZXBsYWNlKSA/IGNvbmZpZy5yZXBsYWNlIDogW107XG4gICAgaWYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzcXVhc2gpKVxuICAgICAgICByZXBsYWNlLnB1c2goeyBmcm9tOiBzcXVhc2gsIHRvOiB1bmRlZmluZWQgfSk7XG4gICAgY29uZmlndXJlZEtleXMgPSBjb21tb25fMS5tYXAocmVwbGFjZSwgaG9mXzEucHJvcChcImZyb21cIikpO1xuICAgIHJldHVybiBjb21tb25fMS5maWx0ZXIoZGVmYXVsdFBvbGljeSwgZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGNvbmZpZ3VyZWRLZXlzLmluZGV4T2YoaXRlbS5mcm9tKSA9PT0gLTE7IH0pLmNvbmNhdChyZXBsYWNlKTtcbn1cbi8qKiBAaW50ZXJuYWxhcGkgKi9cbnZhciBQYXJhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJhbShpZCwgdHlwZSwgY29uZmlnLCBsb2NhdGlvbiwgdXJsTWF0Y2hlckZhY3RvcnkpIHtcbiAgICAgICAgY29uZmlnID0gdW53cmFwU2hvcnRoYW5kKGNvbmZpZyk7XG4gICAgICAgIHR5cGUgPSBnZXRUeXBlKGNvbmZpZywgdHlwZSwgbG9jYXRpb24sIGlkLCB1cmxNYXRjaGVyRmFjdG9yeS5wYXJhbVR5cGVzKTtcbiAgICAgICAgdmFyIGFycmF5TW9kZSA9IGdldEFycmF5TW9kZSgpO1xuICAgICAgICB0eXBlID0gYXJyYXlNb2RlID8gdHlwZS4kYXNBcnJheShhcnJheU1vZGUsIGxvY2F0aW9uID09PSBEZWZUeXBlLlNFQVJDSCkgOiB0eXBlO1xuICAgICAgICB2YXIgaXNPcHRpb25hbCA9IGNvbmZpZy52YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGxvY2F0aW9uID09PSBEZWZUeXBlLlNFQVJDSDtcbiAgICAgICAgdmFyIGR5bmFtaWMgPSBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGNvbmZpZy5keW5hbWljKSA/ICEhY29uZmlnLmR5bmFtaWMgOiAhIXR5cGUuZHluYW1pYztcbiAgICAgICAgdmFyIHJhdyA9IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQoY29uZmlnLnJhdykgPyAhIWNvbmZpZy5yYXcgOiAhIXR5cGUucmF3O1xuICAgICAgICB2YXIgc3F1YXNoID0gZ2V0U3F1YXNoUG9saWN5KGNvbmZpZywgaXNPcHRpb25hbCwgdXJsTWF0Y2hlckZhY3RvcnkuZGVmYXVsdFNxdWFzaFBvbGljeSgpKTtcbiAgICAgICAgdmFyIHJlcGxhY2UgPSBnZXRSZXBsYWNlKGNvbmZpZywgYXJyYXlNb2RlLCBpc09wdGlvbmFsLCBzcXVhc2gpO1xuICAgICAgICB2YXIgaW5oZXJpdCA9IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQoY29uZmlnLmluaGVyaXQpID8gISFjb25maWcuaW5oZXJpdCA6ICEhdHlwZS5pbmhlcml0O1xuICAgICAgICAvLyBhcnJheSBjb25maWc6IHBhcmFtIG5hbWUgKHBhcmFtW10pIG92ZXJyaWRlcyBkZWZhdWx0IHNldHRpbmdzLiAgZXhwbGljaXQgY29uZmlnIG92ZXJyaWRlcyBwYXJhbSBuYW1lLlxuICAgICAgICBmdW5jdGlvbiBnZXRBcnJheU1vZGUoKSB7XG4gICAgICAgICAgICB2YXIgYXJyYXlEZWZhdWx0cyA9IHsgYXJyYXk6IChsb2NhdGlvbiA9PT0gRGVmVHlwZS5TRUFSQ0ggPyBcImF1dG9cIiA6IGZhbHNlKSB9O1xuICAgICAgICAgICAgdmFyIGFycmF5UGFyYW1Ob21lbmNsYXR1cmUgPSBpZC5tYXRjaCgvXFxbXFxdJC8pID8geyBhcnJheTogdHJ1ZSB9IDoge307XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKGFycmF5RGVmYXVsdHMsIGFycmF5UGFyYW1Ob21lbmNsYXR1cmUsIGNvbmZpZykuYXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMsIHsgaWQ6IGlkLCB0eXBlOiB0eXBlLCBsb2NhdGlvbjogbG9jYXRpb24sIGlzT3B0aW9uYWw6IGlzT3B0aW9uYWwsIGR5bmFtaWM6IGR5bmFtaWMsIHJhdzogcmF3LCBzcXVhc2g6IHNxdWFzaCwgcmVwbGFjZTogcmVwbGFjZSwgaW5oZXJpdDogaW5oZXJpdCwgYXJyYXk6IGFycmF5TW9kZSwgY29uZmlnOiBjb25maWcgfSk7XG4gICAgfVxuICAgIFBhcmFtLnByb3RvdHlwZS5pc0RlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc09wdGlvbmFsICYmIHRoaXMudHlwZS5lcXVhbHModGhpcy52YWx1ZSgpLCB2YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBbSW50ZXJuYWxdIEdldHMgdGhlIGRlY29kZWQgcmVwcmVzZW50YXRpb24gb2YgYSB2YWx1ZSBpZiB0aGUgdmFsdWUgaXMgZGVmaW5lZCwgb3RoZXJ3aXNlLCByZXR1cm5zIHRoZVxuICAgICAqIGRlZmF1bHQgdmFsdWUsIHdoaWNoIG1heSBiZSB0aGUgcmVzdWx0IG9mIGFuIGluamVjdGFibGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgUGFyYW0ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBbSW50ZXJuYWxdIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHBhcmFtZXRlciwgd2hpY2ggbWF5IGJlIGFuIGluamVjdGFibGUgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZ2V0RGVmYXVsdFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9kZWZhdWx0VmFsdWVDYWNoZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2RlZmF1bHRWYWx1ZUNhY2hlLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIGlmICghY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluamVjdGFibGUgZnVuY3Rpb25zIGNhbm5vdCBiZSBjYWxsZWQgYXQgY29uZmlndXJhdGlvbiB0aW1lXCIpO1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRpbmplY3Rvci5pbnZva2UoX3RoaXMuY29uZmlnLiQkZm4pO1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCAmJiBkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhX3RoaXMudHlwZS5pcyhkZWZhdWx0VmFsdWUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlZmF1bHQgdmFsdWUgKFwiICsgZGVmYXVsdFZhbHVlICsgXCIpIGZvciBwYXJhbWV0ZXIgJ1wiICsgX3RoaXMuaWQgKyBcIicgaXMgbm90IGFuIGluc3RhbmNlIG9mIFBhcmFtVHlwZSAoXCIgKyBfdGhpcy50eXBlLm5hbWUgKyBcIilcIik7XG4gICAgICAgICAgICBpZiAoX3RoaXMuY29uZmlnLiQkZm5bJ19fY2FjaGVhYmxlJ10pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZGVmYXVsdFZhbHVlQ2FjaGUgPSB7IGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVwbGFjZVNwZWNpYWxWYWx1ZXMgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gX3RoaXMucmVwbGFjZTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdHVwbGUgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKHR1cGxlLmZyb20gPT09IHZhbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR1cGxlLnRvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFsdWUgPSByZXBsYWNlU3BlY2lhbFZhbHVlcyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNVbmRlZmluZWQodmFsdWUpID8gZ2V0RGVmYXVsdFZhbHVlKCkgOiB0aGlzLnR5cGUuJG5vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgfTtcbiAgICBQYXJhbS5wcm90b3R5cGUuaXNTZWFyY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uID09PSBEZWZUeXBlLlNFQVJDSDtcbiAgICB9O1xuICAgIFBhcmFtLnByb3RvdHlwZS52YWxpZGF0ZXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gVGhlcmUgd2FzIG5vIHBhcmFtZXRlciB2YWx1ZSwgYnV0IHRoZSBwYXJhbSBpcyBvcHRpb25hbFxuICAgICAgICBpZiAoKHByZWRpY2F0ZXNfMS5pc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpICYmIHRoaXMuaXNPcHRpb25hbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBUaGUgdmFsdWUgd2FzIG5vdCBvZiB0aGUgY29ycmVjdCBQYXJhbVR5cGUsIGFuZCBjb3VsZCBub3QgYmUgZGVjb2RlZCB0byB0aGUgY29ycmVjdCBQYXJhbVR5cGVcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSB0aGlzLnR5cGUuJG5vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy50eXBlLmlzKG5vcm1hbGl6ZWQpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBUaGUgdmFsdWUgd2FzIG9mIHRoZSBjb3JyZWN0IHR5cGUsIGJ1dCB3aGVuIGVuY29kZWQsIGRpZCBub3QgbWF0Y2ggdGhlIFBhcmFtVHlwZSdzIHJlZ2V4cFxuICAgICAgICB2YXIgZW5jb2RlZCA9IHRoaXMudHlwZS5lbmNvZGUobm9ybWFsaXplZCk7XG4gICAgICAgIHJldHVybiAhKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhlbmNvZGVkKSAmJiAhdGhpcy50eXBlLnBhdHRlcm4uZXhlYyhlbmNvZGVkKSk7XG4gICAgfTtcbiAgICBQYXJhbS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIntQYXJhbTpcIiArIHRoaXMuaWQgKyBcIiBcIiArIHRoaXMudHlwZSArIFwiIHNxdWFzaDogJ1wiICsgdGhpcy5zcXVhc2ggKyBcIicgb3B0aW9uYWw6IFwiICsgdGhpcy5pc09wdGlvbmFsICsgXCJ9XCI7XG4gICAgfTtcbiAgICBQYXJhbS52YWx1ZXMgPSBmdW5jdGlvbiAocGFyYW1zLCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9PT0gdm9pZCAwKSB7IHZhbHVlcyA9IHt9OyB9XG4gICAgICAgIHZhciBwYXJhbVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHBhcmFtc18xID0gcGFyYW1zOyBfaSA8IHBhcmFtc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zXzFbX2ldO1xuICAgICAgICAgICAgcGFyYW1WYWx1ZXNbcGFyYW0uaWRdID0gcGFyYW0udmFsdWUodmFsdWVzW3BhcmFtLmlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtVmFsdWVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluZHMgW1tQYXJhbV1dIG9iamVjdHMgd2hpY2ggaGF2ZSBkaWZmZXJlbnQgcGFyYW0gdmFsdWVzXG4gICAgICpcbiAgICAgKiBGaWx0ZXJzIGEgbGlzdCBvZiBbW1BhcmFtXV0gb2JqZWN0cyB0byBvbmx5IHRob3NlIHdob3NlIHBhcmFtZXRlciB2YWx1ZXMgZGlmZmVyIGluIHR3byBwYXJhbSB2YWx1ZSBvYmplY3RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zOiBUaGUgbGlzdCBvZiBQYXJhbSBvYmplY3RzIHRvIGZpbHRlclxuICAgICAqIEBwYXJhbSB2YWx1ZXMxOiBUaGUgZmlyc3Qgc2V0IG9mIHBhcmFtZXRlciB2YWx1ZXNcbiAgICAgKiBAcGFyYW0gdmFsdWVzMjogdGhlIHNlY29uZCBzZXQgb2YgcGFyYW1ldGVyIHZhbHVlc1xuICAgICAqXG4gICAgICogQHJldHVybnMgYW55IFBhcmFtIG9iamVjdHMgd2hvc2UgdmFsdWVzIHdlcmUgZGlmZmVyZW50IGJldHdlZW4gdmFsdWVzMSBhbmQgdmFsdWVzMlxuICAgICAqL1xuICAgIFBhcmFtLmNoYW5nZWQgPSBmdW5jdGlvbiAocGFyYW1zLCB2YWx1ZXMxLCB2YWx1ZXMyKSB7XG4gICAgICAgIGlmICh2YWx1ZXMxID09PSB2b2lkIDApIHsgdmFsdWVzMSA9IHt9OyB9XG4gICAgICAgIGlmICh2YWx1ZXMyID09PSB2b2lkIDApIHsgdmFsdWVzMiA9IHt9OyB9XG4gICAgICAgIHJldHVybiBwYXJhbXMuZmlsdGVyKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gIXBhcmFtLnR5cGUuZXF1YWxzKHZhbHVlczFbcGFyYW0uaWRdLCB2YWx1ZXMyW3BhcmFtLmlkXSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHR3byBwYXJhbSB2YWx1ZSBvYmplY3RzIGFyZSBlcXVhbCAoZm9yIGEgc2V0IG9mIFtbUGFyYW1dXSBvYmplY3RzKVxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBUaGUgbGlzdCBvZiBbW1BhcmFtXV0gb2JqZWN0cyB0byBjaGVja1xuICAgICAqIEBwYXJhbSB2YWx1ZXMxIFRoZSBmaXJzdCBzZXQgb2YgcGFyYW0gdmFsdWVzXG4gICAgICogQHBhcmFtIHZhbHVlczIgVGhlIHNlY29uZCBzZXQgb2YgcGFyYW0gdmFsdWVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwYXJhbSB2YWx1ZXMgaW4gdmFsdWVzMSBhbmQgdmFsdWVzMiBhcmUgZXF1YWxcbiAgICAgKi9cbiAgICBQYXJhbS5lcXVhbHMgPSBmdW5jdGlvbiAocGFyYW1zLCB2YWx1ZXMxLCB2YWx1ZXMyKSB7XG4gICAgICAgIGlmICh2YWx1ZXMxID09PSB2b2lkIDApIHsgdmFsdWVzMSA9IHt9OyB9XG4gICAgICAgIGlmICh2YWx1ZXMyID09PSB2b2lkIDApIHsgdmFsdWVzMiA9IHt9OyB9XG4gICAgICAgIHJldHVybiBQYXJhbS5jaGFuZ2VkKHBhcmFtcywgdmFsdWVzMSwgdmFsdWVzMikubGVuZ3RoID09PSAwO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiBhIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFyZSB2YWxpZCwgYWNjb3JkaW5nIHRvIHRoZSBQYXJhbSBkZWZpbml0aW9ucyAqL1xuICAgIFBhcmFtLnZhbGlkYXRlcyA9IGZ1bmN0aW9uIChwYXJhbXMsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHsgdmFsdWVzID0ge307IH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS52YWxpZGF0ZXModmFsdWVzW3BhcmFtLmlkXSk7IH0pLnJlZHVjZShjb21tb25fMS5hbGxUcnVlUiwgdHJ1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFyYW07XG59KCkpO1xuZXhwb3J0cy5QYXJhbSA9IFBhcmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyYW0uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9wYXJhbS5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSB0cmFuc2l0aW9uXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc3RyaW5nc1wiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIFJlamVjdFR5cGU7XG4oZnVuY3Rpb24gKFJlamVjdFR5cGUpIHtcbiAgICBSZWplY3RUeXBlW1JlamVjdFR5cGVbXCJTVVBFUlNFREVEXCJdID0gMl0gPSBcIlNVUEVSU0VERURcIjtcbiAgICBSZWplY3RUeXBlW1JlamVjdFR5cGVbXCJBQk9SVEVEXCJdID0gM10gPSBcIkFCT1JURURcIjtcbiAgICBSZWplY3RUeXBlW1JlamVjdFR5cGVbXCJJTlZBTElEXCJdID0gNF0gPSBcIklOVkFMSURcIjtcbiAgICBSZWplY3RUeXBlW1JlamVjdFR5cGVbXCJJR05PUkVEXCJdID0gNV0gPSBcIklHTk9SRURcIjtcbiAgICBSZWplY3RUeXBlW1JlamVjdFR5cGVbXCJFUlJPUlwiXSA9IDZdID0gXCJFUlJPUlwiO1xufSkoUmVqZWN0VHlwZSA9IGV4cG9ydHMuUmVqZWN0VHlwZSB8fCAoZXhwb3J0cy5SZWplY3RUeXBlID0ge30pKTtcbi8qKiBAaGlkZGVuICovIHZhciBpZCA9IDA7XG52YXIgUmVqZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlamVjdGlvbih0eXBlLCBtZXNzYWdlLCBkZXRhaWwpIHtcbiAgICAgICAgdGhpcy4kaWQgPSBpZCsrO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmRldGFpbCA9IGRldGFpbDtcbiAgICB9XG4gICAgUmVqZWN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRldGFpbFN0cmluZyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZCAmJiBkLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nID8gZC50b1N0cmluZygpIDogc3RyaW5nc18xLnN0cmluZ2lmeShkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRldGFpbCA9IGRldGFpbFN0cmluZyh0aGlzLmRldGFpbCk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsICRpZCA9IF9hLiRpZCwgdHlwZSA9IF9hLnR5cGUsIG1lc3NhZ2UgPSBfYS5tZXNzYWdlO1xuICAgICAgICByZXR1cm4gXCJUcmFuc2l0aW9uIFJlamVjdGlvbigkaWQ6IFwiICsgJGlkICsgXCIgdHlwZTogXCIgKyB0eXBlICsgXCIsIG1lc3NhZ2U6IFwiICsgbWVzc2FnZSArIFwiLCBkZXRhaWw6IFwiICsgZGV0YWlsICsgXCIpXCI7XG4gICAgfTtcbiAgICBSZWplY3Rpb24ucHJvdG90eXBlLnRvUHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZChjb21tb25fMS5zaWxlbnRSZWplY3Rpb24odGhpcyksIHsgX3RyYW5zaXRpb25SZWplY3Rpb246IHRoaXMgfSk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmogaXMgYSByZWplY3RlZCBwcm9taXNlIGNyZWF0ZWQgZnJvbSB0aGUgYGFzUHJvbWlzZWAgZmFjdG9yeSAqL1xuICAgIFJlamVjdGlvbi5pc1JlamVjdGlvblByb21pc2UgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgKHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJykgJiYgaG9mXzEuaXMoUmVqZWN0aW9uKShvYmouX3RyYW5zaXRpb25SZWplY3Rpb24pO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSBSZWplY3Rpb24gZHVlIHRvIHRyYW5zaXRpb24gc3VwZXJzZWRlZCAqL1xuICAgIFJlamVjdGlvbi5zdXBlcnNlZGVkID0gZnVuY3Rpb24gKGRldGFpbCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiVGhlIHRyYW5zaXRpb24gaGFzIGJlZW4gc3VwZXJzZWRlZCBieSBhIGRpZmZlcmVudCB0cmFuc2l0aW9uXCI7XG4gICAgICAgIHZhciByZWplY3Rpb24gPSBuZXcgUmVqZWN0aW9uKFJlamVjdFR5cGUuU1VQRVJTRURFRCwgbWVzc2FnZSwgZGV0YWlsKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWRpcmVjdGVkKSB7XG4gICAgICAgICAgICByZWplY3Rpb24ucmVkaXJlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlamVjdGlvbjtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGEgUmVqZWN0aW9uIGR1ZSB0byByZWRpcmVjdGVkIHRyYW5zaXRpb24gKi9cbiAgICBSZWplY3Rpb24ucmVkaXJlY3RlZCA9IGZ1bmN0aW9uIChkZXRhaWwpIHtcbiAgICAgICAgcmV0dXJuIFJlamVjdGlvbi5zdXBlcnNlZGVkKGRldGFpbCwgeyByZWRpcmVjdGVkOiB0cnVlIH0pO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSBSZWplY3Rpb24gZHVlIHRvIGludmFsaWQgdHJhbnNpdGlvbiAqL1xuICAgIFJlamVjdGlvbi5pbnZhbGlkID0gZnVuY3Rpb24gKGRldGFpbCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiVGhpcyB0cmFuc2l0aW9uIGlzIGludmFsaWRcIjtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWplY3Rpb24oUmVqZWN0VHlwZS5JTlZBTElELCBtZXNzYWdlLCBkZXRhaWwpO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSBSZWplY3Rpb24gZHVlIHRvIGlnbm9yZWQgdHJhbnNpdGlvbiAqL1xuICAgIFJlamVjdGlvbi5pZ25vcmVkID0gZnVuY3Rpb24gKGRldGFpbCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiVGhlIHRyYW5zaXRpb24gd2FzIGlnbm9yZWRcIjtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWplY3Rpb24oUmVqZWN0VHlwZS5JR05PUkVELCBtZXNzYWdlLCBkZXRhaWwpO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSBSZWplY3Rpb24gZHVlIHRvIGFib3J0ZWQgdHJhbnNpdGlvbiAqL1xuICAgIFJlamVjdGlvbi5hYm9ydGVkID0gZnVuY3Rpb24gKGRldGFpbCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiVGhlIHRyYW5zaXRpb24gaGFzIGJlZW4gYWJvcnRlZFwiO1xuICAgICAgICByZXR1cm4gbmV3IFJlamVjdGlvbihSZWplY3RUeXBlLkFCT1JURUQsIG1lc3NhZ2UsIGRldGFpbCk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhIFJlamVjdGlvbiBkdWUgdG8gYWJvcnRlZCB0cmFuc2l0aW9uICovXG4gICAgUmVqZWN0aW9uLmVycm9yZWQgPSBmdW5jdGlvbiAoZGV0YWlsKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJUaGUgdHJhbnNpdGlvbiBlcnJvcmVkXCI7XG4gICAgICAgIHJldHVybiBuZXcgUmVqZWN0aW9uKFJlamVjdFR5cGUuRVJST1IsIG1lc3NhZ2UsIGRldGFpbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgUmVqZWN0aW9uXG4gICAgICpcbiAgICAgKiBOb3JtYWxpemVzIGEgdmFsdWUgYXMgYSBSZWplY3Rpb24uXG4gICAgICogSWYgdGhlIHZhbHVlIGlzIGFscmVhZHkgYSBSZWplY3Rpb24sIHJldHVybnMgaXQuXG4gICAgICogT3RoZXJ3aXNlLCB3cmFwcyBhbmQgcmV0dXJucyB0aGUgdmFsdWUgYXMgYSBSZWplY3Rpb24gKFJlamVjdGlvbiB0eXBlOiBFUlJPUikuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBgZGV0YWlsYCBpZiBpdCBpcyBhbHJlYWR5IGEgYFJlamVjdGlvbmAsIGVsc2UgcmV0dXJucyBhbiBFUlJPUiBSZWplY3Rpb24uXG4gICAgICovXG4gICAgUmVqZWN0aW9uLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChkZXRhaWwpIHtcbiAgICAgICAgcmV0dXJuIGhvZl8xLmlzKFJlamVjdGlvbikoZGV0YWlsKSA/IGRldGFpbCA6IFJlamVjdGlvbi5lcnJvcmVkKGRldGFpbCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVqZWN0aW9uO1xufSgpKTtcbmV4cG9ydHMuUmVqZWN0aW9uID0gUmVqZWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVqZWN0RmFjdG9yeS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi9yZWplY3RGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgdHJhbnNpdGlvblxuICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbnZhciBpbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc3RyaW5nc1wiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciB0cmFjZV8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi90cmFjZVwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIHJlamVjdEZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL3JlamVjdEZhY3RvcnlcIik7XG52YXIgdGFyZ2V0U3RhdGVfMSA9IHJlcXVpcmUoXCIuLi9zdGF0ZS90YXJnZXRTdGF0ZVwiKTtcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBjdXJyZW50OiBjb21tb25fMS5ub29wLFxuICAgIHRyYW5zaXRpb246IG51bGwsXG4gICAgdHJhY2VEYXRhOiB7fSxcbiAgICBiaW5kOiBudWxsLFxufTtcbi8qKiBAaGlkZGVuICovXG52YXIgVHJhbnNpdGlvbkhvb2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbkhvb2sodHJhbnNpdGlvbiwgc3RhdGVDb250ZXh0LCByZWdpc3RlcmVkSG9vaywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgICAgICB0aGlzLnN0YXRlQ29udGV4dCA9IHN0YXRlQ29udGV4dDtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkSG9vayA9IHJlZ2lzdGVyZWRIb29rO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmlzU3VwZXJzZWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy50eXBlLmhvb2tQaGFzZSA9PT0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5SVU4gJiYgIV90aGlzLm9wdGlvbnMudHJhbnNpdGlvbi5pc0FjdGl2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRpb25zLCBkZWZhdWx0T3B0aW9ucyk7XG4gICAgICAgIHRoaXMudHlwZSA9IHJlZ2lzdGVyZWRIb29rLmV2ZW50VHlwZTtcbiAgICB9XG4gICAgVHJhbnNpdGlvbkhvb2sucHJvdG90eXBlLmxvZ0Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb24ucm91dGVyLnN0YXRlU2VydmljZS5kZWZhdWx0RXJyb3JIYW5kbGVyKCkoZXJyKTtcbiAgICB9O1xuICAgIFRyYW5zaXRpb25Ib29rLnByb3RvdHlwZS5pbnZva2VIb29rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaG9vayA9IHRoaXMucmVnaXN0ZXJlZEhvb2s7XG4gICAgICAgIGlmIChob29rLl9kZXJlZ2lzdGVyZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBub3RDdXJyZW50ID0gdGhpcy5nZXROb3RDdXJyZW50UmVqZWN0aW9uKCk7XG4gICAgICAgIGlmIChub3RDdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5vdEN1cnJlbnQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlSG9va0ludm9jYXRpb24odGhpcywgdGhpcy50cmFuc2l0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIGludm9rZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhvb2suY2FsbGJhY2suY2FsbChvcHRpb25zLmJpbmQsIF90aGlzLnRyYW5zaXRpb24sIF90aGlzLnN0YXRlQ29udGV4dCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBub3JtYWxpemVFcnIgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5ub3JtYWxpemUoZXJyKS50b1Byb21pc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGhvb2suZXZlbnRUeXBlLmdldEVycm9ySGFuZGxlcihfdGhpcykoZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGhhbmRsZVJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBob29rLmV2ZW50VHlwZS5nZXRSZXN1bHRIYW5kbGVyKF90aGlzKShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGludm9rZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHlwZS5zeW5jaHJvbm91cyAmJiBwcmVkaWNhdGVzXzEuaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNhdGNoKG5vcm1hbGl6ZUVycilcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oaGFuZGxlUmVzdWx0LCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gSWYgY2FsbGJhY2sgdGhyb3dzIChzeW5jaHJvbm91c2x5KVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24ubm9ybWFsaXplKGVycikpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGhvb2suaW52b2tlTGltaXQgJiYgKytob29rLmludm9rZUNvdW50ID49IGhvb2suaW52b2tlTGltaXQpIHtcbiAgICAgICAgICAgICAgICBob29rLmRlcmVnaXN0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaGFuZGxlcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGEgVHJhbnNpdGlvbiBIb29rLlxuICAgICAqXG4gICAgICogQSBob29rIGNhbiByZXR1cm4gZmFsc2UgKGNhbmNlbCksIGEgVGFyZ2V0U3RhdGUgKHJlZGlyZWN0KSxcbiAgICAgKiBvciBhIHByb21pc2UgKHdoaWNoIG1heSBsYXRlciByZXNvbHZlIHRvIGZhbHNlIG9yIGEgcmVkaXJlY3QpXG4gICAgICpcbiAgICAgKiBUaGlzIGFsc28gaGFuZGxlcyBcInRyYW5zaXRpb24gc3VwZXJzZWRlZFwiIC0tIHdoZW4gYSBuZXcgdHJhbnNpdGlvblxuICAgICAqIHdhcyBzdGFydGVkIHdoaWxlIHRoZSBob29rIHdhcyBzdGlsbCBydW5uaW5nXG4gICAgICovXG4gICAgVHJhbnNpdGlvbkhvb2sucHJvdG90eXBlLmhhbmRsZUhvb2tSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBub3RDdXJyZW50ID0gdGhpcy5nZXROb3RDdXJyZW50UmVqZWN0aW9uKCk7XG4gICAgICAgIGlmIChub3RDdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5vdEN1cnJlbnQ7XG4gICAgICAgIC8vIEhvb2sgcmV0dXJuZWQgYSBwcm9taXNlXG4gICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBwcm9taXNlLCB0aGVuIHJlcHJvY2VzcyB3aXRoIHRoZSByZXN1bHRpbmcgdmFsdWVcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbihmdW5jdGlvbiAodmFsKSB7IHJldHVybiBfdGhpcy5oYW5kbGVIb29rUmVzdWx0KHZhbCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VIb29rUmVzdWx0KHJlc3VsdCwgdGhpcy50cmFuc2l0aW9uLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAvLyBIb29rIHJldHVybmVkIGZhbHNlXG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBBYm9ydCB0aGlzIFRyYW5zaXRpb25cbiAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmFib3J0ZWQoXCJIb29rIGFib3J0ZWQgdHJhbnNpdGlvblwiKS50b1Byb21pc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNUYXJnZXRTdGF0ZSA9IGhvZl8xLmlzKHRhcmdldFN0YXRlXzEuVGFyZ2V0U3RhdGUpO1xuICAgICAgICAvLyBob29rIHJldHVybmVkIGEgVGFyZ2V0U3RhdGVcbiAgICAgICAgaWYgKGlzVGFyZ2V0U3RhdGUocmVzdWx0KSkge1xuICAgICAgICAgICAgLy8gSGFsdCB0aGUgY3VycmVudCBUcmFuc2l0aW9uIGFuZCByZWRpcmVjdCAoYSBuZXcgVHJhbnNpdGlvbikgdG8gdGhlIFRhcmdldFN0YXRlLlxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24ucmVkaXJlY3RlZChyZXN1bHQpLnRvUHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBSZWplY3Rpb24gcHJvbWlzZSBpZiB0aGUgdHJhbnNpdGlvbiBpcyBubyBsb25nZXIgY3VycmVudCBkdWVcbiAgICAgKiB0byBhIHN0b3BwZWQgcm91dGVyIChkaXNwb3NlZCksIG9yIGEgbmV3IHRyYW5zaXRpb24gaGFzIHN0YXJ0ZWQgYW5kIHN1cGVyc2VkZWQgdGhpcyBvbmUuXG4gICAgICovXG4gICAgVHJhbnNpdGlvbkhvb2sucHJvdG90eXBlLmdldE5vdEN1cnJlbnRSZWplY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3V0ZXIgPSB0aGlzLnRyYW5zaXRpb24ucm91dGVyO1xuICAgICAgICAvLyBUaGUgcm91dGVyIGlzIHN0b3BwZWRcbiAgICAgICAgaWYgKHJvdXRlci5fZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmFib3J0ZWQoXCJVSVJvdXRlciBpbnN0YW5jZSAjXCIgKyByb3V0ZXIuJGlkICsgXCIgaGFzIGJlZW4gc3RvcHBlZCAoZGlzcG9zZWQpXCIpLnRvUHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyYW5zaXRpb24uX2Fib3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmFib3J0ZWQoKS50b1Byb21pc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHRyYW5zaXRpb24gaXMgbm8gbG9uZ2VyIGN1cnJlbnQuXG4gICAgICAgIC8vIEFub3RoZXIgdHJhbnNpdGlvbiBzdGFydGVkIHdoaWxlIHRoaXMgaG9vayB3YXMgc3RpbGwgcnVubmluZy5cbiAgICAgICAgaWYgKHRoaXMuaXNTdXBlcnNlZGVkKCkpIHtcbiAgICAgICAgICAgIC8vIEFib3J0IHRoaXMgdHJhbnNpdGlvblxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24uc3VwZXJzZWRlZCh0aGlzLm9wdGlvbnMuY3VycmVudCgpKS50b1Byb21pc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJhbnNpdGlvbkhvb2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBvcHRpb25zID0gX2Eub3B0aW9ucywgcmVnaXN0ZXJlZEhvb2sgPSBfYS5yZWdpc3RlcmVkSG9vaztcbiAgICAgICAgdmFyIGV2ZW50ID0gaG9mXzEucGFyc2UoXCJ0cmFjZURhdGEuaG9va1R5cGVcIikob3B0aW9ucykgfHwgXCJpbnRlcm5hbFwiLCBjb250ZXh0ID0gaG9mXzEucGFyc2UoXCJ0cmFjZURhdGEuY29udGV4dC5zdGF0ZS5uYW1lXCIpKG9wdGlvbnMpIHx8IGhvZl8xLnBhcnNlKFwidHJhY2VEYXRhLmNvbnRleHRcIikob3B0aW9ucykgfHwgXCJ1bmtub3duXCIsIG5hbWUgPSBzdHJpbmdzXzEuZm5Ub1N0cmluZyhyZWdpc3RlcmVkSG9vay5jYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBldmVudCArIFwiIGNvbnRleHQ6IFwiICsgY29udGV4dCArIFwiLCBcIiArIHN0cmluZ3NfMS5tYXhMZW5ndGgoMjAwLCBuYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoYWlucyB0b2dldGhlciBhbiBhcnJheSBvZiBUcmFuc2l0aW9uSG9va3MuXG4gICAgICpcbiAgICAgKiBHaXZlbiBhIGxpc3Qgb2YgW1tUcmFuc2l0aW9uSG9va11dIG9iamVjdHMsIGNoYWlucyB0aGVtIHRvZ2V0aGVyLlxuICAgICAqIEVhY2ggaG9vayBpcyBpbnZva2VkIGFmdGVyIHRoZSBwcmV2aW91cyBvbmUgY29tcGxldGVzLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGhvb2tzOiBUcmFuc2l0aW9uSG9va1tdID0gZ2V0SG9va3MoKTtcbiAgICAgKiBsZXQgcHJvbWlzZTogUHJvbWlzZTxhbnk+ID0gVHJhbnNpdGlvbkhvb2suY2hhaW4oaG9va3MpO1xuICAgICAqXG4gICAgICogcHJvbWlzZS50aGVuKGhhbmRsZVN1Y2Nlc3MsIGhhbmRsZUVycm9yKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBob29rcyB0aGUgbGlzdCBvZiBob29rcyB0byBjaGFpbiB0b2dldGhlclxuICAgICAqIEBwYXJhbSB3YWl0Rm9yIGlmIHByb3ZpZGVkLCB0aGUgY2hhaW4gaXMgYC50aGVuKClgJ2VkIG9mZiB0aGlzIHByb21pc2VcbiAgICAgKiBAcmV0dXJucyBhIGBQcm9taXNlYCBmb3Igc2VxdWVudGlhbGx5IGludm9raW5nIHRoZSBob29rcyAoaW4gb3JkZXIpXG4gICAgICovXG4gICAgVHJhbnNpdGlvbkhvb2suY2hhaW4gPSBmdW5jdGlvbiAoaG9va3MsIHdhaXRGb3IpIHtcbiAgICAgICAgLy8gQ2hhaW4gdGhlIG5leHQgaG9vayBvZmYgdGhlIHByZXZpb3VzXG4gICAgICAgIHZhciBjcmVhdGVIb29rQ2hhaW5SID0gZnVuY3Rpb24gKHByZXYsIG5leHRIb29rKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldi50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5leHRIb29rLmludm9rZUhvb2soKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBob29rcy5yZWR1Y2UoY3JlYXRlSG9va0NoYWluUiwgd2FpdEZvciB8fCBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS53aGVuKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW52b2tlcyBhbGwgdGhlIHByb3ZpZGVkIFRyYW5zaXRpb25Ib29rcywgaW4gb3JkZXIuXG4gICAgICogRWFjaCBob29rJ3MgcmV0dXJuIHZhbHVlIGlzIGNoZWNrZWQuXG4gICAgICogSWYgYW55IGhvb2sgcmV0dXJucyBhIHByb21pc2UsIHRoZW4gdGhlIHJlc3Qgb2YgdGhlIGhvb2tzIGFyZSBjaGFpbmVkIG9mZiB0aGF0IHByb21pc2UsIGFuZCB0aGUgcHJvbWlzZSBpcyByZXR1cm5lZC5cbiAgICAgKiBJZiBubyBob29rIHJldHVybnMgYSBwcm9taXNlLCB0aGVuIGFsbCBob29rcyBhcmUgcHJvY2Vzc2VkIHN5bmNocm9ub3VzbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaG9va3MgdGhlIGxpc3Qgb2YgVHJhbnNpdGlvbkhvb2tzIHRvIGludm9rZVxuICAgICAqIEBwYXJhbSBkb25lQ2FsbGJhY2sgYSBjYWxsYmFjayB0aGF0IGlzIGludm9rZWQgYWZ0ZXIgYWxsIHRoZSBob29rcyBoYXZlIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIGFzeW5jIHJlc3VsdCwgb3IgdGhlIHJlc3VsdCBvZiB0aGUgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uSG9vay5pbnZva2VIb29rcyA9IGZ1bmN0aW9uIChob29rcywgZG9uZUNhbGxiYWNrKSB7XG4gICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGhvb2tzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIHZhciBob29rUmVzdWx0ID0gaG9va3NbaWR4XS5pbnZva2VIb29rKCk7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzUHJvbWlzZShob29rUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmdIb29rcyA9IGhvb2tzLnNsaWNlKGlkeCArIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBUcmFuc2l0aW9uSG9vay5jaGFpbihyZW1haW5pbmdIb29rcywgaG9va1Jlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZG9uZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSdW4gYWxsIFRyYW5zaXRpb25Ib29rcywgaWdub3JpbmcgdGhlaXIgcmV0dXJuIHZhbHVlLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb25Ib29rLnJ1bkFsbEhvb2tzID0gZnVuY3Rpb24gKGhvb2tzKSB7XG4gICAgICAgIGhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGhvb2suaW52b2tlSG9vaygpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZXNlIEdldFJlc3VsdEhhbmRsZXIocykgYXJlIHVzZWQgYnkgW1tpbnZva2VIb29rXV0gYmVsb3dcbiAgICAgKiBFYWNoIEhvb2tUeXBlIGNob29zZXMgYSBHZXRSZXN1bHRIYW5kbGVyIChTZWU6IFtbVHJhbnNpdGlvblNlcnZpY2UuX2RlZmluZUNvcmVFdmVudHNdXSlcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uSG9vay5IQU5ETEVfUkVTVUxUID0gZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIGhvb2suaGFuZGxlSG9va1Jlc3VsdChyZXN1bHQpO1xuICAgIH07IH07XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHJlc3VsdCBpcyBhIHByb21pc2UgcmVqZWN0aW9uLCBsb2cgaXQuXG4gICAgICogT3RoZXJ3aXNlLCBpZ25vcmUgdGhlIHJlc3VsdC5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uSG9vay5MT0dfUkVKRUNURURfUkVTVUxUID0gZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcHJlZGljYXRlc18xLmlzUHJvbWlzZShyZXN1bHQpICYmIHJlc3VsdC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gaG9vay5sb2dFcnJvcihyZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLm5vcm1hbGl6ZShlcnIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTsgfTtcbiAgICAvKipcbiAgICAgKiBUaGVzZSBHZXRFcnJvckhhbmRsZXIocykgYXJlIHVzZWQgYnkgW1tpbnZva2VIb29rXV0gYmVsb3dcbiAgICAgKiBFYWNoIEhvb2tUeXBlIGNob29zZXMgYSBHZXRFcnJvckhhbmRsZXIgKFNlZTogW1tUcmFuc2l0aW9uU2VydmljZS5fZGVmaW5lQ29yZUV2ZW50c11dKVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25Ib29rLkxPR19FUlJPUiA9IGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGhvb2subG9nRXJyb3IoZXJyb3IpO1xuICAgIH07IH07XG4gICAgVHJhbnNpdGlvbkhvb2suUkVKRUNUX0VSUk9SID0gZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuc2lsZW50UmVqZWN0aW9uKGVycm9yKTtcbiAgICB9OyB9O1xuICAgIFRyYW5zaXRpb25Ib29rLlRIUk9XX0VSUk9SID0gZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9OyB9O1xuICAgIHJldHVybiBUcmFuc2l0aW9uSG9vaztcbn0oKSk7XG5leHBvcnRzLlRyYW5zaXRpb25Ib29rID0gVHJhbnNpdGlvbkhvb2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2l0aW9uSG9vay5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi90cmFuc2l0aW9uSG9vay5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHJlc29sdmVcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XG52YXIgdHJhY2VfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vdHJhY2VcIik7XG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zdHJpbmdzXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBjb21tb25fMiA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vLyBUT0RPOiBleHBsaWNpdGx5IG1ha2UgdGhpcyB1c2VyIGNvbmZpZ3VyYWJsZVxuZXhwb3J0cy5kZWZhdWx0UmVzb2x2ZVBvbGljeSA9IHtcbiAgICB3aGVuOiBcIkxBWllcIixcbiAgICBhc3luYzogXCJXQUlUXCJcbn07XG4vKipcbiAqIFRoZSBiYXNpYyBidWlsZGluZyBibG9jayBmb3IgdGhlIHJlc29sdmUgc3lzdGVtLlxuICpcbiAqIFJlc29sdmFibGVzIGVuY2Fwc3VsYXRlIGEgc3RhdGUncyByZXNvbHZlJ3MgcmVzb2x2ZUZuLCB0aGUgcmVzb2x2ZUZuJ3MgZGVjbGFyZWQgZGVwZW5kZW5jaWVzLCB0aGUgd3JhcHBlZCAoLnByb21pc2UpLFxuICogYW5kIHRoZSB1bndyYXBwZWQtd2hlbi1jb21wbGV0ZSAoLmRhdGEpIHJlc3VsdCBvZiB0aGUgcmVzb2x2ZUZuLlxuICpcbiAqIFJlc29sdmFibGUuZ2V0KCkgZWl0aGVyIHJldHJpZXZlcyB0aGUgUmVzb2x2YWJsZSdzIGV4aXN0aW5nIHByb21pc2UsIG9yIGVsc2UgaW52b2tlcyByZXNvbHZlKCkgKHdoaWNoIGludm9rZXMgdGhlXG4gKiByZXNvbHZlRm4pIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgcHJvbWlzZS5cbiAqXG4gKiBSZXNvbHZhYmxlLmdldCgpIGFuZCBSZXNvbHZhYmxlLnJlc29sdmUoKSBib3RoIGV4ZWN1dGUgd2l0aGluIGEgY29udGV4dCBwYXRoLCB3aGljaCBpcyBwYXNzZWQgYXMgdGhlIGZpcnN0XG4gKiBwYXJhbWV0ZXIgdG8gdGhvc2UgZm5zLlxuICovXG52YXIgUmVzb2x2YWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNvbHZhYmxlKGFyZzEsIHJlc29sdmVGbiwgZGVwcywgcG9saWN5LCBkYXRhKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIFJlc29sdmFibGUpIHtcbiAgICAgICAgICAgIGNvbW1vbl8xLmV4dGVuZCh0aGlzLCBhcmcxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihyZXNvbHZlRm4pKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uXzIuaXNOdWxsT3JVbmRlZmluZWQoYXJnMSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmV3IFJlc29sdmFibGUoKTogdG9rZW4gYXJndW1lbnQgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKHJlc29sdmVGbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmV3IFJlc29sdmFibGUoKTogcmVzb2x2ZUZuIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSBhcmcxO1xuICAgICAgICAgICAgdGhpcy5wb2xpY3kgPSBwb2xpY3k7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVGbiA9IHJlc29sdmVGbjtcbiAgICAgICAgICAgIHRoaXMuZGVwcyA9IGRlcHMgfHwgW107XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZCA9IGRhdGEgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMucHJvbWlzZSA9IHRoaXMucmVzb2x2ZWQgPyBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS53aGVuKHRoaXMuZGF0YSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJlZGljYXRlc18xLmlzT2JqZWN0KGFyZzEpICYmIGFyZzEudG9rZW4gJiYgcHJlZGljYXRlc18xLmlzRnVuY3Rpb24oYXJnMS5yZXNvbHZlRm4pKSB7XG4gICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IGFyZzE7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc29sdmFibGUobGl0ZXJhbC50b2tlbiwgbGl0ZXJhbC5yZXNvbHZlRm4sIGxpdGVyYWwuZGVwcywgbGl0ZXJhbC5wb2xpY3ksIGxpdGVyYWwuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVzb2x2YWJsZS5wcm90b3R5cGUuZ2V0UG9saWN5ID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciB0aGlzUG9saWN5ID0gdGhpcy5wb2xpY3kgfHwge307XG4gICAgICAgIHZhciBzdGF0ZVBvbGljeSA9IHN0YXRlICYmIHN0YXRlLnJlc29sdmVQb2xpY3kgfHwge307XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aGVuOiB0aGlzUG9saWN5LndoZW4gfHwgc3RhdGVQb2xpY3kud2hlbiB8fCBleHBvcnRzLmRlZmF1bHRSZXNvbHZlUG9saWN5LndoZW4sXG4gICAgICAgICAgICBhc3luYzogdGhpc1BvbGljeS5hc3luYyB8fCBzdGF0ZVBvbGljeS5hc3luYyB8fCBleHBvcnRzLmRlZmF1bHRSZXNvbHZlUG9saWN5LmFzeW5jLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzbHkgcmVzb2x2ZSB0aGlzIFJlc29sdmFibGUncyBkYXRhXG4gICAgICpcbiAgICAgKiBHaXZlbiBhIFJlc29sdmVDb250ZXh0IHRoYXQgdGhpcyBSZXNvbHZhYmxlIGlzIGZvdW5kIGluOlxuICAgICAqIFdhaXQgZm9yIHRoaXMgUmVzb2x2YWJsZSdzIGRlcGVuZGVuY2llcywgdGhlbiBpbnZva2UgdGhpcyBSZXNvbHZhYmxlJ3MgZnVuY3Rpb25cbiAgICAgKiBhbmQgdXBkYXRlIHRoZSBSZXNvbHZhYmxlJ3Mgc3RhdGVcbiAgICAgKi9cbiAgICBSZXNvbHZhYmxlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHJlc29sdmVDb250ZXh0LCB0cmFucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgJHEgPSBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcTtcbiAgICAgICAgLy8gR2V0cyBhbGwgZGVwZW5kZW5jaWVzIGZyb20gUmVzb2x2ZUNvbnRleHQgYW5kIHdhaXQgZm9yIHRoZW0gdG8gYmUgcmVzb2x2ZWRcbiAgICAgICAgdmFyIGdldFJlc29sdmFibGVEZXBlbmRlbmNpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJHEuYWxsKHJlc29sdmVDb250ZXh0LmdldERlcGVuZGVuY2llcyhfdGhpcykubWFwKGZ1bmN0aW9uIChyZXNvbHZhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmFibGUuZ2V0KHJlc29sdmVDb250ZXh0LCB0cmFucyk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEludm9rZXMgdGhlIHJlc29sdmUgZnVuY3Rpb24gcGFzc2luZyB0aGUgcmVzb2x2ZWQgZGVwZW5kZW5jaWVzIGFzIGFyZ3VtZW50c1xuICAgICAgICB2YXIgaW52b2tlUmVzb2x2ZUZuID0gZnVuY3Rpb24gKHJlc29sdmVkRGVwcykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlc29sdmVGbi5hcHBseShudWxsLCByZXNvbHZlZERlcHMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIFJYV0FJVCBwb2xpY3k6XG4gICAgICAgICAqXG4gICAgICAgICAqIEdpdmVuIGFuIG9ic2VydmFibGUgcmV0dXJuZWQgZnJvbSBhIHJlc29sdmUgZnVuY3Rpb246XG4gICAgICAgICAqIC0gZW5hYmxlcyAuY2FjaGUoKSBtb2RlICh0aGlzIGFsbG93cyBtdWx0aWNhc3Qgc3Vic2NyaWJlcnMpXG4gICAgICAgICAqIC0gdGhlbiBjYWxscyB0b1Byb21pc2UoKSAodGhpcyB0cmlnZ2VycyBzdWJzY3JpYmUoKSBhbmQgdGh1cyBmZXRjaGVzKVxuICAgICAgICAgKiAtIFdhaXRzIGZvciB0aGUgcHJvbWlzZSwgdGhlbiByZXR1cm4gdGhlIGNhY2hlZCBvYnNlcnZhYmxlIChub3QgdGhlIGZpcnN0IGVtaXR0ZWQgdmFsdWUpLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHdhaXRGb3JSeCA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlJCkge1xuICAgICAgICAgICAgdmFyIGNhY2hlZCA9IG9ic2VydmFibGUkLmNhY2hlKDEpO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZC50YWtlKDEpLnRvUHJvbWlzZSgpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FjaGVkOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgdGhlIHJlc29sdmUgcG9saWN5IGlzIFJYV0FJVCwgd2FpdCBmb3IgdGhlIG9ic2VydmFibGUgdG8gZW1pdCBzb21ldGhpbmcuIG90aGVyd2lzZSBwYXNzIHRocm91Z2guXG4gICAgICAgIHZhciBub2RlID0gcmVzb2x2ZUNvbnRleHQuZmluZE5vZGUodGhpcyk7XG4gICAgICAgIHZhciBzdGF0ZSA9IG5vZGUgJiYgbm9kZS5zdGF0ZTtcbiAgICAgICAgdmFyIG1heWJlV2FpdEZvclJ4ID0gdGhpcy5nZXRQb2xpY3koc3RhdGUpLmFzeW5jID09PSBcIlJYV0FJVFwiID8gd2FpdEZvclJ4IDogY29tbW9uXzEuaWRlbnRpdHk7XG4gICAgICAgIC8vIEFmdGVyIHRoZSBmaW5hbCB2YWx1ZSBoYXMgYmVlbiByZXNvbHZlZCwgdXBkYXRlIHRoZSBzdGF0ZSBvZiB0aGUgUmVzb2x2YWJsZVxuICAgICAgICB2YXIgYXBwbHlSZXNvbHZlZFZhbHVlID0gZnVuY3Rpb24gKHJlc29sdmVkVmFsdWUpIHtcbiAgICAgICAgICAgIF90aGlzLmRhdGEgPSByZXNvbHZlZFZhbHVlO1xuICAgICAgICAgICAgX3RoaXMucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZVJlc29sdmFibGVSZXNvbHZlZChfdGhpcywgdHJhbnMpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFNldHMgdGhlIHByb21pc2UgcHJvcGVydHkgZmlyc3QsIHRoZW4gZ2V0c1Jlc29sdmFibGVEZXBlbmRlbmNpZXMgaW4gdGhlIGNvbnRleHQgb2YgdGhlIHByb21pc2UgY2hhaW4uIEFsd2F5cyB3YWl0cyBvbmUgdGljay5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZSA9ICRxLndoZW4oKVxuICAgICAgICAgICAgLnRoZW4oZ2V0UmVzb2x2YWJsZURlcGVuZGVuY2llcylcbiAgICAgICAgICAgIC50aGVuKGludm9rZVJlc29sdmVGbilcbiAgICAgICAgICAgIC50aGVuKG1heWJlV2FpdEZvclJ4KVxuICAgICAgICAgICAgLnRoZW4oYXBwbHlSZXNvbHZlZFZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYSBwcm9taXNlIGZvciB0aGlzIFJlc29sdmFibGUncyBkYXRhLlxuICAgICAqXG4gICAgICogRmV0Y2hlcyB0aGUgZGF0YSBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gICAgICogUmV0dXJucyB0aGUgZXhpc3RpbmcgcHJvbWlzZSBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIGZldGNoZWQgb25jZS5cbiAgICAgKi9cbiAgICBSZXNvbHZhYmxlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocmVzb2x2ZUNvbnRleHQsIHRyYW5zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2UgfHwgdGhpcy5yZXNvbHZlKHJlc29sdmVDb250ZXh0LCB0cmFucyk7XG4gICAgfTtcbiAgICBSZXNvbHZhYmxlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiUmVzb2x2YWJsZSh0b2tlbjogXCIgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KHRoaXMudG9rZW4pICsgXCIsIHJlcXVpcmVzOiBbXCIgKyB0aGlzLmRlcHMubWFwKHN0cmluZ3NfMS5zdHJpbmdpZnkpICsgXCJdKVwiO1xuICAgIH07XG4gICAgUmVzb2x2YWJsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzb2x2YWJsZSh0aGlzKTtcbiAgICB9O1xuICAgIFJlc29sdmFibGUuZnJvbURhdGEgPSBmdW5jdGlvbiAodG9rZW4sIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZhYmxlKHRva2VuLCBmdW5jdGlvbiAoKSB7IHJldHVybiBkYXRhOyB9LCBudWxsLCBudWxsLCBkYXRhKTtcbiAgICB9O1xuICAgIHJldHVybiBSZXNvbHZhYmxlO1xufSgpKTtcbmV4cG9ydHMuUmVzb2x2YWJsZSA9IFJlc29sdmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZhYmxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9yZXNvbHZlL3Jlc29sdmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAbmcyYXBpIEBtb2R1bGUgZGlyZWN0aXZlcyAqL1xuLyoqICovXG5pbXBvcnQgeyBDb21wb25lbnQsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgVmlld0NvbnRhaW5lclJlZiwgSW5wdXQsIFJlZmxlY3RpdmVJbmplY3RvciwgVmlld0NoaWxkLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVJUm91dGVyLCBpc0Z1bmN0aW9uLCBwYXJzZSwgaW5BcnJheSwgdHJhY2UsIFJlc29sdmVDb250ZXh0LCBOQVRJVkVfSU5KRUNUT1JfVE9LRU4gfSBmcm9tICdAdWlyb3V0ZXIvY29yZSc7XG5pbXBvcnQgeyBOZzJWaWV3Q29uZmlnIH0gZnJvbSAnLi4vc3RhdGVidWlsZGVycy92aWV3cyc7XG5pbXBvcnQgeyBNZXJnZUluamVjdG9yIH0gZnJvbSAnLi4vbWVyZ2VJbmplY3Rvcic7XG4vKiogQGhpZGRlbiAqL1xudmFyIGlkID0gMDtcbi8qKlxuICogR2l2ZW4gYSBjb21wb25lbnQgY2xhc3MsIGdldHMgdGhlIGlucHV0cyBvZiBzdHlsZXM6XG4gKlxuICogLSBASW5wdXQoJ2ZvbycpIF9mb29cbiAqIC0gYGlucHV0czogWydmb28nXWBcbiAqXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xudmFyIG5nMkNvbXBvbmVudElucHV0cyA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuICh7IHByb3A6IGlucHV0LnByb3BOYW1lLCB0b2tlbjogaW5wdXQudGVtcGxhdGVOYW1lIH0pOyB9KTtcbn07XG4vKipcbiAqIEEgVUktUm91dGVyIHZpZXdwb3J0IGRpcmVjdGl2ZSwgd2hpY2ggaXMgZmlsbGVkIGluIGJ5IGEgdmlldyAoY29tcG9uZW50KSBvbiBhIHN0YXRlLlxuICpcbiAqICMjIyBTZWxlY3RvclxuICpcbiAqIEEgYHVpLXZpZXdgIGRpcmVjdGl2ZSBjYW4gYmUgY3JlYXRlZCBhcyBhbiBlbGVtZW50OiBgPHVpLXZpZXc+PC91aS12aWV3PmAgb3IgYXMgYW4gYXR0cmlidXRlOiBgPGRpdiB1aS12aWV3PjwvZGl2PmAuXG4gKlxuICogIyMjIFB1cnBvc2VcbiAqXG4gKiBUaGlzIGRpcmVjdGl2ZSBpcyB1c2VkIGluIGEgQ29tcG9uZW50IHRlbXBsYXRlIChvciBhcyB0aGUgcm9vdCBjb21wb25lbnQpIHRvIGNyZWF0ZSBhIHZpZXdwb3J0LiAgVGhlIHZpZXdwb3J0XG4gKiBpcyBmaWxsZWQgaW4gYnkgYSB2aWV3IChhcyBkZWZpbmVkIGJ5IGEgW1tOZzJWaWV3RGVjbGFyYXRpb25dXSBpbnNpZGUgYSBbW05nMlN0YXRlRGVjbGFyYXRpb25dXSkgd2hlbiB0aGUgdmlldydzXG4gKiBzdGF0ZSBoYXMgYmVlbiBhY3RpdmF0ZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBganNcbiAqIC8vIFRoaXMgYXBwIGhhcyB0d28gc3RhdGVzLCAnZm9vJyBhbmQgJ2JhcidcbiAqIHN0YXRlUmVnaXN0cnkucmVnaXN0ZXIoeyBuYW1lOiAnZm9vJywgdXJsOiAnL2ZvbycsIGNvbXBvbmVudDogRm9vQ29tcG9uZW50IH0pO1xuICogc3RhdGVSZWdpc3RyeS5yZWdpc3Rlcih7IG5hbWU6ICdiYXInLCB1cmw6ICcvYmFyJywgY29tcG9uZW50OiBCYXJDb21wb25lbnQgfSk7XG4gKiBgYGBcbiAqIGBgYGh0bWxcbiAqIDwhLS0gVGhpcyB1aS12aWV3IHdpbGwgYmUgZmlsbGVkIGluIGJ5IHRoZSBmb28gc3RhdGUncyBjb21wb25lbnQgb3JcbiAqICAgICAgdGhlIGJhciBzdGF0ZSdzIGNvbXBvbmVudCB3aGVuIHRoZSBmb28gb3IgYmFyIHN0YXRlIGlzIGFjdGl2YXRlZCAtLT5cbiAqIDx1aS12aWV3PjwvdWktdmlldz5cbiAqIGBgYFxuICpcbiAqICMjIyBOYW1lZCB1aS12aWV3c1xuICpcbiAqIEEgYHVpLXZpZXdgIG1heSBvcHRpb25hbGx5IGJlIGdpdmVuIGEgbmFtZSB2aWEgdGhlIGF0dHJpYnV0ZSB2YWx1ZTogYDxkaXYgdWktdmlldz0naGVhZGVyJz48L2Rpdj5gLiAgKk5vdGU6XG4gKiBhbiB1bm5hbWVkIGB1aS12aWV3YCBpcyBpbnRlcm5hbGx5IG5hbWVkIGAkZGVmYXVsdGAqLiAgIFdoZW4gYSBgdWktdmlld2AgaGFzIGEgbmFtZSwgaXQgd2lsbCBiZSBmaWxsZWQgaW5cbiAqIGJ5IGEgbWF0Y2hpbmcgbmFtZWQgdmlldy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogc3RhdGVSZWdpc3RyeS5yZWdpc3Rlcih7XG4gKiAgIG5hbWU6ICdmb28nLFxuICogICB1cmw6ICcvZm9vJyxcbiAqICAgdmlld3M6IHsgaGVhZGVyOiBIZWFkZXJDb21wb25lbnQsICRkZWZhdWx0OiBGb29Db21wb25lbnQgfSk7XG4gKiBgYGBcbiAqIGBgYGh0bWxcbiAqIDwhLS0gV2hlbiAnZm9vJyBzdGF0ZSBpcyBhY3RpdmUsIGZpbGxlZCBieSBIZWFkZXJDb21wb25lbnQgLS0+XG4gKiA8ZGl2IHVpLXZpZXc9XCJoZWFkZXJcIj48L2Rpdj5cbiAqXG4gKiA8IS0tIFdoZW4gJ2Zvbycgc3RhdGUgaXMgYWN0aXZlLCBmaWxsZWQgYnkgRm9vQ29tcG9uZW50IC0tPlxuICogPHVpLXZpZXc+PC91aS12aWV3PlxuICogYGBgXG4gKi9cbnZhciBVSVZpZXcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVJVmlldyhyb3V0ZXIsIHBhcmVudCwgdmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyUmVmID0gdmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgLyoqIERhdGEgYWJvdXQgdGhlIHRoaXMgVUlWaWV3ICovXG4gICAgICAgIHRoaXMudWlWaWV3RGF0YSA9IHt9O1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVJVmlldy5wcm90b3R5cGUsIFwiX25hbWVcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5uYW1lID0gdmFsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBVSVZpZXcucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcm91dGVyID0gdGhpcy5yb3V0ZXI7XG4gICAgICAgIHZhciBwYXJlbnRGcW4gPSB0aGlzLnBhcmVudC5mcW47XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lIHx8ICckZGVmYXVsdCc7XG4gICAgICAgIHRoaXMudWlWaWV3RGF0YSA9IHtcbiAgICAgICAgICAgICR0eXBlOiAnbmcyJyxcbiAgICAgICAgICAgIGlkOiBpZCsrLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGZxbjogcGFyZW50RnFuID8gcGFyZW50RnFuICsgXCIuXCIgKyBuYW1lIDogbmFtZSxcbiAgICAgICAgICAgIGNyZWF0aW9uQ29udGV4dDogdGhpcy5wYXJlbnQuY29udGV4dCxcbiAgICAgICAgICAgIGNvbmZpZ1VwZGF0ZWQ6IHRoaXMudmlld0NvbmZpZ1VwZGF0ZWQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNvbmZpZzogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVyZWdpc3Rlckhvb2sgPSByb3V0ZXIudHJhbnNpdGlvblNlcnZpY2Uub25CZWZvcmUoe30sIGZ1bmN0aW9uICh0cmFucykgeyByZXR1cm4gX3RoaXMuYXBwbHlVaUNhbkV4aXRIb29rKHRyYW5zKTsgfSk7XG4gICAgICAgIHRoaXMuZGVyZWdpc3RlclVJVmlldyA9IHJvdXRlci52aWV3U2VydmljZS5yZWdpc3RlclVJVmlldyh0aGlzLnVpVmlld0RhdGEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9yIGVhY2ggdHJhbnNpdGlvbiwgY2hlY2tzIHRoZSBjb21wb25lbnQgbG9hZGVkIGluIHRoZSB1aS12aWV3IGZvcjpcbiAgICAgKlxuICAgICAqIC0gaGFzIGEgdWlDYW5FeGl0KCkgY29tcG9uZW50IGhvb2tcbiAgICAgKiAtIGlzIGJlaW5nIGV4aXRlZFxuICAgICAqXG4gICAgICogSWYgYm90aCBhcmUgdHJ1ZSwgYWRkcyB0aGUgdWlDYW5FeGl0IGNvbXBvbmVudCBmdW5jdGlvbiBhcyBhIGhvb2sgdG8gdGhhdCBzaW5ndWxhciBUcmFuc2l0aW9uLlxuICAgICAqL1xuICAgIFVJVmlldy5wcm90b3R5cGUuYXBwbHlVaUNhbkV4aXRIb29rID0gZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuY29tcG9uZW50UmVmICYmIHRoaXMuY29tcG9uZW50UmVmLmluc3RhbmNlO1xuICAgICAgICB2YXIgdWlDYW5FeGl0Rm4gPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS51aUNhbkV4aXQ7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHVpQ2FuRXhpdEZuKSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gcGFyc2UoXCJ1aVZpZXdEYXRhLmNvbmZpZy52aWV3RGVjbC4kY29udGV4dC5zZWxmXCIpKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRyYW5zLmV4aXRpbmcoKS5pbmRleE9mKHN0YXRlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0cmFucy5vblN0YXJ0KHt9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1aUNhbkV4aXRGbi5jYWxsKGluc3RhbmNlLCB0cmFucyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVJVmlldy5wcm90b3R5cGUuZGlzcG9zZUxhc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudFJlZilcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50UmVmLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRSZWYgPSBudWxsO1xuICAgIH07XG4gICAgVUlWaWV3LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVyZWdpc3RlclVJVmlldylcbiAgICAgICAgICAgIHRoaXMuZGVyZWdpc3RlclVJVmlldygpO1xuICAgICAgICBpZiAodGhpcy5kZXJlZ2lzdGVySG9vaylcbiAgICAgICAgICAgIHRoaXMuZGVyZWdpc3Rlckhvb2soKTtcbiAgICAgICAgdGhpcy5kaXNwb3NlTGFzdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIHZpZXcgc2VydmljZSBpcyBpbmZvcm1pbmcgdXMgb2YgYW4gdXBkYXRlZCBWaWV3Q29uZmlnXG4gICAgICogKHVzdWFsbHkgYmVjYXVzZSBhIHRyYW5zaXRpb24gYWN0aXZhdGVkIHNvbWUgc3RhdGUgYW5kIGl0cyB2aWV3cylcbiAgICAgKi9cbiAgICBVSVZpZXcucHJvdG90eXBlLnZpZXdDb25maWdVcGRhdGVkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAvLyBUaGUgY29uZmlnIG1heSBiZSB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm90aGluZyBjdXJyZW50bHkgdGFyZ2V0aW5nIHRoaXMgVUlWaWV3LlxuICAgICAgICAvLyBEaXNwb3NlIHRoZSBjdXJyZW50IGNvbXBvbmVudCwgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgIGlmICghY29uZmlnKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcG9zZUxhc3QoKTtcbiAgICAgICAgLy8gT25seSBjYXJlIGFib3V0IE5nMiBjb25maWdzXG4gICAgICAgIGlmICghKGNvbmZpZyBpbnN0YW5jZW9mIE5nMlZpZXdDb25maWcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBUaGUgXCJuZXdcIiB2aWV3Y29uZmlnIGlzIGFscmVhZHkgYXBwbGllZCwgc28gZXhpdCBlYXJseVxuICAgICAgICBpZiAodGhpcy51aVZpZXdEYXRhLmNvbmZpZyA9PT0gY29uZmlnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IFZpZXdDb25maWcuICBEaXNwb3NlIHRoZSBwcmV2aW91cyBjb21wb25lbnRcbiAgICAgICAgdGhpcy5kaXNwb3NlTGFzdCgpO1xuICAgICAgICB0cmFjZS50cmFjZVVJVmlld0NvbmZpZ1VwZGF0ZWQodGhpcy51aVZpZXdEYXRhLCBjb25maWcgJiYgY29uZmlnLnZpZXdEZWNsLiRjb250ZXh0KTtcbiAgICAgICAgdGhpcy5hcHBseVVwZGF0ZWRDb25maWcoY29uZmlnKTtcbiAgICB9O1xuICAgIFVJVmlldy5wcm90b3R5cGUuYXBwbHlVcGRhdGVkQ29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB0aGlzLnVpVmlld0RhdGEuY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIEluamVjdG9yIGZvciB0aGUgcm91dGVkIGNvbXBvbmVudFxuICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBSZXNvbHZlQ29udGV4dChjb25maWcucGF0aCk7XG4gICAgICAgIHZhciBjb21wb25lbnRJbmplY3RvciA9IHRoaXMuZ2V0Q29tcG9uZW50SW5qZWN0b3IoY29udGV4dCk7XG4gICAgICAgIC8vIEdldCB0aGUgY29tcG9uZW50IGNsYXNzIGZyb20gdGhlIHZpZXcgZGVjbGFyYXRpb24uIFRPRE86IGFsbG93IHByb21pc2VzP1xuICAgICAgICB2YXIgY29tcG9uZW50Q2xhc3MgPSBjb25maWcudmlld0RlY2wuY29tcG9uZW50O1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGNvbXBvbmVudFxuICAgICAgICB2YXIgY29tcEZhY3RvcnlSZXNvbHZlciA9IGNvbXBvbmVudEluamVjdG9yLmdldChDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpO1xuICAgICAgICB2YXIgY29tcEZhY3RvcnkgPSBjb21wRmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGNvbXBvbmVudENsYXNzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRSZWYgPSB0aGlzLmNvbXBvbmVudFRhcmdldC5jcmVhdGVDb21wb25lbnQoY29tcEZhY3RvcnksIHVuZGVmaW5lZCwgY29tcG9uZW50SW5qZWN0b3IpO1xuICAgICAgICAvLyBXaXJlIHJlc29sdmVzIHRvIEBJbnB1dCgpc1xuICAgICAgICB0aGlzLmFwcGx5SW5wdXRCaW5kaW5ncyhjb21wRmFjdG9yeSwgdGhpcy5jb21wb25lbnRSZWYsIGNvbnRleHQsIGNvbXBvbmVudENsYXNzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW5qZWN0b3IgZm9yIGEgcm91dGVkIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEFkZHMgcmVzb2x2ZSB2YWx1ZXMgdG8gdGhlIEluamVjdG9yXG4gICAgICogQWRkcyBwcm92aWRlcnMgZnJvbSB0aGUgTmdNb2R1bGUgZm9yIHRoZSBzdGF0ZVxuICAgICAqIEFkZHMgcHJvdmlkZXJzIGZyb20gdGhlIHBhcmVudCBDb21wb25lbnQgaW4gdGhlIGNvbXBvbmVudCB0cmVlXG4gICAgICogQWRkcyBhIFBBUkVOVF9JTkpFQ1QgdmlldyBjb250ZXh0IG9iamVjdFxuICAgICAqXG4gICAgICogQHJldHVybnMgYW4gSW5qZWN0b3JcbiAgICAgKi9cbiAgICBVSVZpZXcucHJvdG90eXBlLmdldENvbXBvbmVudEluamVjdG9yID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgLy8gTWFwIHJlc29sdmVzIHRvIFwidXNlVmFsdWU6IHByb3ZpZGVyc1wiXG4gICAgICAgIHZhciByZXNvbHZhYmxlcyA9IGNvbnRleHQuZ2V0VG9rZW5zKCkubWFwKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gY29udGV4dC5nZXRSZXNvbHZhYmxlKHRva2VuKTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnJlc29sdmVkOyB9KTtcbiAgICAgICAgdmFyIG5ld1Byb3ZpZGVycyA9IHJlc29sdmFibGVzLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gKHsgcHJvdmlkZTogci50b2tlbiwgdXNlVmFsdWU6IHIuZGF0YSB9KTsgfSk7XG4gICAgICAgIHZhciBwYXJlbnRJbmplY3QgPSB7IGNvbnRleHQ6IHRoaXMudWlWaWV3RGF0YS5jb25maWcudmlld0RlY2wuJGNvbnRleHQsIGZxbjogdGhpcy51aVZpZXdEYXRhLmZxbiB9O1xuICAgICAgICBuZXdQcm92aWRlcnMucHVzaCh7IHByb3ZpZGU6IFVJVmlldy5QQVJFTlRfSU5KRUNULCB1c2VWYWx1ZTogcGFyZW50SW5qZWN0IH0pO1xuICAgICAgICB2YXIgcGFyZW50Q29tcG9uZW50SW5qZWN0b3IgPSB0aGlzLnZpZXdDb250YWluZXJSZWYuaW5qZWN0b3I7XG4gICAgICAgIHZhciBtb2R1bGVJbmplY3RvciA9IGNvbnRleHQuZ2V0UmVzb2x2YWJsZShOQVRJVkVfSU5KRUNUT1JfVE9LRU4pLmRhdGE7XG4gICAgICAgIHZhciBtZXJnZWRQYXJlbnRJbmplY3RvciA9IG5ldyBNZXJnZUluamVjdG9yKG1vZHVsZUluamVjdG9yLCBwYXJlbnRDb21wb25lbnRJbmplY3Rvcik7XG4gICAgICAgIHJldHVybiBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShuZXdQcm92aWRlcnMsIG1lcmdlZFBhcmVudEluamVjdG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN1cHBsaWVzIGNvbXBvbmVudCBpbnB1dHMgd2l0aCByZXNvbHZlIGRhdGFcbiAgICAgKlxuICAgICAqIEZpbmRzIGNvbXBvbmVudCBpbnB1dHMgd2hpY2ggbWF0Y2ggcmVzb2x2ZXMgKGJ5IG5hbWUpIGFuZCBzZXRzIHRoZSBpbnB1dCB2YWx1ZVxuICAgICAqIHRvIHRoZSByZXNvbHZlIGRhdGEuXG4gICAgICovXG4gICAgVUlWaWV3LnByb3RvdHlwZS5hcHBseUlucHV0QmluZGluZ3MgPSBmdW5jdGlvbiAoZmFjdG9yeSwgcmVmLCBjb250ZXh0LCBjb21wb25lbnRDbGFzcykge1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gcmVmLmluc3RhbmNlO1xuICAgICAgICB2YXIgYmluZGluZ3MgPSB0aGlzLnVpVmlld0RhdGEuY29uZmlnLnZpZXdEZWNsWydiaW5kaW5ncyddIHx8IHt9O1xuICAgICAgICB2YXIgZXhwbGljaXRCb3VuZFByb3BzID0gT2JqZWN0LmtleXMoYmluZGluZ3MpO1xuICAgICAgICAvLyBSZXR1cm5zIHRoZSBhY3R1YWwgY29tcG9uZW50IHByb3BlcnR5IGZvciBhIHJlbmFtZWQgYW4gaW5wdXQgcmVuYW1lZCB1c2luZyBgQElucHV0KCdmb28nKSBfZm9vYC5cbiAgICAgICAgLy8gcmV0dXJuIHRoZSBgX2Zvb2AgcHJvcGVydHlcbiAgICAgICAgdmFyIHJlbmFtZWRJbnB1dFByb3AgPSBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZmFjdG9yeS5pbnB1dHMuZmluZChmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS50ZW1wbGF0ZU5hbWUgPT09IHByb3A7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICYmIGlucHV0LnByb3BOYW1lIHx8IHByb3A7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFN1cHBseSByZXNvbHZlIGRhdGEgdG8gY29tcG9uZW50IGFzIHNwZWNpZmllZCBpbiB0aGUgc3RhdGUncyBgYmluZGluZ3M6IHt9YFxuICAgICAgICB2YXIgZXhwbGljaXRJbnB1dFR1cGxlcyA9IGV4cGxpY2l0Qm91bmRQcm9wc1xuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHsgcmV0dXJuIGFjYy5jb25jYXQoW3sgcHJvcDogcmVuYW1lZElucHV0UHJvcChrZXkpLCB0b2tlbjogYmluZGluZ3Nba2V5XSB9XSk7IH0sIFtdKTtcbiAgICAgICAgLy8gU3VwcGx5IHJlc29sdmUgZGF0YSB0byBtYXRjaGluZyBASW5wdXQoJ3Byb3AnKSBvciBpbnB1dHM6IFsncHJvcCddXG4gICAgICAgIHZhciBpbXBsaWNpdElucHV0VHVwbGVzID0gbmcyQ29tcG9uZW50SW5wdXRzKGZhY3RvcnkpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh0dXBsZSkgeyByZXR1cm4gIWluQXJyYXkoZXhwbGljaXRCb3VuZFByb3BzLCB0dXBsZS5wcm9wKTsgfSk7XG4gICAgICAgIHZhciBhZGRSZXNvbHZhYmxlID0gZnVuY3Rpb24gKHR1cGxlKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgcHJvcDogdHVwbGUucHJvcCxcbiAgICAgICAgICAgIHJlc29sdmFibGU6IGNvbnRleHQuZ2V0UmVzb2x2YWJsZSh0dXBsZS50b2tlbiksXG4gICAgICAgIH0pOyB9O1xuICAgICAgICBleHBsaWNpdElucHV0VHVwbGVzLmNvbmNhdChpbXBsaWNpdElucHV0VHVwbGVzKVxuICAgICAgICAgICAgLm1hcChhZGRSZXNvbHZhYmxlKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuIHR1cGxlLnJlc29sdmFibGUgJiYgdHVwbGUucmVzb2x2YWJsZS5yZXNvbHZlZDsgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uICh0dXBsZSkgeyBjb21wb25lbnRbdHVwbGUucHJvcF0gPSB0dXBsZS5yZXNvbHZhYmxlLmRhdGE7IH0pO1xuICAgICAgICAvLyBJbml0aWF0ZSBjaGFuZ2UgZGV0ZWN0aW9uIGZvciB0aGUgbmV3bHkgY3JlYXRlZCBjb21wb25lbnRcbiAgICAgICAgcmVmLmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICB9O1xuICAgIHJldHVybiBVSVZpZXc7XG59KCkpO1xuZXhwb3J0IHsgVUlWaWV3IH07XG5VSVZpZXcuUEFSRU5UX0lOSkVDVCA9IFwiVUlWaWV3LlBBUkVOVF9JTkpFQ1RcIjtcblVJVmlldy5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAndWktdmlldywgW3VpLXZpZXddJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5nLXRlbXBsYXRlICNjb21wb25lbnRUYXJnZXQ+PC9uZy10ZW1wbGF0ZT5cXG4gICAgPG5nLWNvbnRlbnQgKm5nSWY9XFxcIiFjb21wb25lbnRSZWZcXFwiPjwvbmctY29udGVudD5cXG4gIFwiXG4gICAgICAgICAgICAgICAgLy8gc3R5bGVzOiBbYFxuICAgICAgICAgICAgICAgIC8vICAgLmRvbmUtdHJ1ZSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIHRleHQtZGVjb3JhdGlvbjogbGluZS10aHJvdWdoO1xuICAgICAgICAgICAgICAgIC8vICAgICBjb2xvcjogZ3JleTtcbiAgICAgICAgICAgICAgICAvLyAgIH1gXG4gICAgICAgICAgICAgICAgLy8gXSxcbiAgICAgICAgICAgICAgICAvLyB0ZW1wbGF0ZTogYFxuICAgICAgICAgICAgICAgIC8vIDxkaXYgc3R5bGU9XCJwYWRkaW5nOiAxZW07IGJvcmRlcjogMXB4IHNvbGlkIGxpZ2h0Z3JleTtcIj5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgPGRpdiAjY29udGVudCBzdHlsZT1cImNvbG9yOiBsaWdodGdyZXk7IGZvbnQtc2l6ZTogc21hbGxlcjtcIj5cbiAgICAgICAgICAgICAgICAvLyAgICAgPGRpdj51aS12aWV3ICN7e3VpVmlld0RhdGE/LmlkfX0gY3JlYXRlZCBieSAne3sgcGFyZW50Q29udGV4dD8ubmFtZSB8fCBcIihyb290KVwiIH19JyBzdGF0ZTwvZGl2PlxuICAgICAgICAgICAgICAgIC8vICAgICA8ZGl2Pm5hbWU6IChhYnNvbHV0ZSkgJ3t7dWlWaWV3RGF0YT8uZnFufX0nIChjb250ZXh0dWFsKSAne3t1aVZpZXdEYXRhPy5uYW1lfX1Ae3twYXJlbnRDb250ZXh0Py5uYW1lfX0nIDwvZGl2PlxuICAgICAgICAgICAgICAgIC8vICAgICA8ZGl2PmN1cnJlbnRseSBmaWxsZWQgYnk6ICd7eyh1aVZpZXdEYXRhPy5jb25maWcgJiYgdWlWaWV3RGF0YT8uY29uZmlnPy52aWV3RGVjbD8uJGNvbnRleHQpIHx8ICdlbXB0eS4uLid9fSc8L2Rpdj5cbiAgICAgICAgICAgICAgICAvLyAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gPC9kaXY+YFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5VSVZpZXcuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBVSVJvdXRlciwgfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbVUlWaWV3LlBBUkVOVF9JTkpFQ1QsXSB9LF0gfSxcbiAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG5dOyB9O1xuVUlWaWV3LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICdjb21wb25lbnRUYXJnZXQnOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnY29tcG9uZW50VGFyZ2V0JywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0sXSB9LF0sXG4gICAgJ25hbWUnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWyduYW1lJyxdIH0sXSxcbiAgICAnX25hbWUnOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWyd1aS12aWV3JyxdIH0sXSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11aVZpZXcuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2FuZ3VsYXIvbGliL2RpcmVjdGl2ZXMvdWlWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgY29yZVxuICovXG4vKipcbiAqIE1hdGNoZXMgc3RhdGUgbmFtZXMgdXNpbmcgZ2xvYi1saWtlIHBhdHRlcm4gc3RyaW5ncy5cbiAqXG4gKiBHbG9icyBjYW4gYmUgdXNlZCBpbiBzcGVjaWZpYyBBUElzIGluY2x1ZGluZzpcbiAqXG4gKiAtIFtbU3RhdGVTZXJ2aWNlLmlzXV1cbiAqIC0gW1tTdGF0ZVNlcnZpY2UuaW5jbHVkZXNdXVxuICogLSBUaGUgZmlyc3QgYXJndW1lbnQgdG8gSG9vayBSZWdpc3RyYXRpb24gZnVuY3Rpb25zIGxpa2UgW1tUcmFuc2l0aW9uU2VydmljZS5vblN0YXJ0XV1cbiAqICAgIC0gW1tIb29rTWF0Y2hDcml0ZXJpYV1dIGFuZCBbW0hvb2tNYXRjaENyaXRlcmlvbl1dXG4gKlxuICogQSBgR2xvYmAgc3RyaW5nIGlzIGEgcGF0dGVybiB3aGljaCBtYXRjaGVzIHN0YXRlIG5hbWVzLlxuICogTmVzdGVkIHN0YXRlIG5hbWVzIGFyZSBzcGxpdCBpbnRvIHNlZ21lbnRzIChzZXBhcmF0ZWQgYnkgYSBkb3QpIHdoZW4gcHJvY2Vzc2luZy5cbiAqIFRoZSBzdGF0ZSBuYW1lZCBgZm9vLmJhci5iYXpgIGlzIHNwbGl0IGludG8gdGhyZWUgc2VnbWVudHMgWydmb28nLCAnYmFyJywgJ2JheiddXG4gKlxuICogR2xvYnMgd29yayBhY2NvcmRpbmcgdG8gdGhlIGZvbGxvd2luZyBydWxlczpcbiAqXG4gKiAjIyMgRXhhY3QgbWF0Y2g6XG4gKlxuICogVGhlIGdsb2IgYCdBLkInYCBtYXRjaGVzIHRoZSBzdGF0ZSBuYW1lZCBleGFjdGx5IGAnQS5CJ2AuXG4gKlxuICogfCBHbG9iICAgICAgICB8TWF0Y2hlcyBzdGF0ZXMgbmFtZWR8RG9lcyBub3QgbWF0Y2ggc3RhdGUgbmFtZWR8XG4gKiB8Oi0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS18Oi0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgYCdBJ2AgICAgICAgfCBgJ0EnYCAgICAgICAgICAgICAgIHwgYCdCJ2AgLCBgJ0EuQydgICAgICAgfFxuICogfCBgJ0EuQidgICAgICB8IGAnQS5CJ2AgICAgICAgICAgICAgfCBgJ0EnYCAsIGAnQS5CLkMnYCAgICB8XG4gKiB8IGAnZm9vJ2AgICAgIHwgYCdmb28nYCAgICAgICAgICAgICB8IGAnRk9PJ2AgLCBgJ2Zvby5iYXInYHxcbiAqXG4gKiAjIyMgU2luZ2xlIHN0YXIgKGAqYClcbiAqXG4gKiBBIHNpbmdsZSBzdGFyIChgKmApIGlzIGEgd2lsZGNhcmQgdGhhdCBtYXRjaGVzIGV4YWN0bHkgb25lIHNlZ21lbnQuXG4gKlxuICogfCBHbG9iICAgICAgICB8TWF0Y2hlcyBzdGF0ZXMgbmFtZWQgIHxEb2VzIG5vdCBtYXRjaCBzdGF0ZSBuYW1lZCB8XG4gKiB8Oi0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tfDotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgYCcqJ2AgICAgICAgfCBgJ0EnYCAsIGAnWidgICAgICAgICB8IGAnQS5CJ2AgLCBgJ1ouWS5YJ2AgICAgICAgfFxuICogfCBgJ0EuKidgICAgICB8IGAnQS5CJ2AgLCBgJ0EuQydgICAgIHwgYCdBJ2AgLCBgJ0EuQi5DJ2AgICAgICAgICB8XG4gKiB8IGAnQS4qLionYCAgIHwgYCdBLkIuQydgICwgYCdBLlguWSdgfCBgJ0EnYCwgYCdBLkInYCAsIGAnWi5ZLlgnYHxcbiAqXG4gKiAjIyMgRG91YmxlIHN0YXIgKGAqKmApXG4gKlxuICogQSBkb3VibGUgc3RhciAoYCcqKidgKSBpcyBhIHdpbGRjYXJkIHRoYXQgbWF0Y2hlcyAqemVybyBvciBtb3JlIHNlZ21lbnRzKlxuICpcbiAqIHwgR2xvYiAgICAgICAgfE1hdGNoZXMgc3RhdGVzIG5hbWVkICAgICAgICAgICAgICAgICAgICAgICAgICAgfERvZXMgbm90IG1hdGNoIHN0YXRlIG5hbWVkICAgICAgICAgfFxuICogfDotLS0tLS0tLS0tLS18Oi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18Oi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8IGAnKionYCAgICAgIHwgYCdBJ2AgLCBgJ0EuQidgLCBgJ1ouWS5YJ2AgICAgICAgICAgICAgICAgICAgIHwgKG1hdGNoZXMgYWxsIHN0YXRlcykgICAgICAgICAgICAgIHxcbiAqIHwgYCdBLioqJ2AgICAgfCBgJ0EnYCAsIGAnQS5CJ2AgLCBgJ0EuQy5YJ2AgICAgICAgICAgICAgICAgICAgfCBgJ1ouWS5YJ2AgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgJyoqLlgnYCAgICB8IGAnWCdgICwgYCdBLlgnYCAsIGAnWi5ZLlgnYCAgICAgICAgICAgICAgICAgICB8IGAnQSdgICwgYCdBLmxvZ2luLlonYCAgICAgICAgICAgICB8XG4gKiB8IGAnQS4qKi5YJ2AgIHwgYCdBLlgnYCAsIGAnQS5CLlgnYCAsIGAnQS5CLkMuWCdgICAgICAgICAgICAgIHwgYCdBJ2AgLCBgJ0EuQi5DJ2AgICAgICAgICAgICAgICAgIHxcbiAqXG4gKi9cbnZhciBHbG9iID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdsb2IodGV4dCkge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLmdsb2IgPSB0ZXh0LnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciByZWdleHBTdHJpbmcgPSB0aGlzLnRleHQuc3BsaXQoJy4nKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc2VnKSB7XG4gICAgICAgICAgICBpZiAoc2VnID09PSAnKionKVxuICAgICAgICAgICAgICAgIHJldHVybiAnKD86fCg/OlxcXFwuW14uXSopKiknO1xuICAgICAgICAgICAgaWYgKHNlZyA9PT0gJyonKVxuICAgICAgICAgICAgICAgIHJldHVybiAnXFxcXC5bXi5dKic7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFwuJyArIHNlZztcbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChcIl5cIiArIHJlZ2V4cFN0cmluZyArIFwiJFwiKTtcbiAgICB9XG4gICAgR2xvYi5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cC50ZXN0KCcuJyArIG5hbWUpO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3RyaW5nIGhhcyBnbG9iLWxpa2UgY2hhcmFjdGVycyBpbiBpdCAqL1xuICAgIEdsb2IuaXMgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICByZXR1cm4gISEvWyEsKl0rLy5leGVjKHRleHQpO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSBnbG9iIGZyb20gdGhlIHN0cmluZywgb3IgbnVsbCBpZiB0aGUgc3RyaW5nIGlzbid0IEdsb2ItbGlrZSAqL1xuICAgIEdsb2IuZnJvbVN0cmluZyA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBHbG9iLmlzKHRleHQpID8gbmV3IEdsb2IodGV4dCkgOiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIEdsb2I7XG59KCkpO1xuZXhwb3J0cy5HbG9iID0gR2xvYjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2IuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9nbG9iLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgdHJhbnNpdGlvblxuICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbnZhciB0cmFjZV8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi90cmFjZVwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc3RyaW5nc1wiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIGludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpOyAvLyBoYXMgb3IgaXMgdXNpbmdcbnZhciB0cmFuc2l0aW9uSG9va18xID0gcmVxdWlyZShcIi4vdHJhbnNpdGlvbkhvb2tcIik7XG52YXIgaG9va1JlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi9ob29rUmVnaXN0cnlcIik7XG52YXIgaG9va0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL2hvb2tCdWlsZGVyXCIpO1xudmFyIHBhdGhGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi4vcGF0aC9wYXRoRmFjdG9yeVwiKTtcbnZhciBwYXJhbV8xID0gcmVxdWlyZShcIi4uL3BhcmFtcy9wYXJhbVwiKTtcbnZhciByZXNvbHZhYmxlXzEgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZS9yZXNvbHZhYmxlXCIpO1xudmFyIHJlc29sdmVDb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZS9yZXNvbHZlQ29udGV4dFwiKTtcbi8qKiBAaGlkZGVuICovXG52YXIgc3RhdGVTZWxmID0gaG9mXzEucHJvcChcInNlbGZcIik7XG4vKipcbiAqIFJlcHJlc2VudHMgYSB0cmFuc2l0aW9uIGJldHdlZW4gdHdvIHN0YXRlcy5cbiAqXG4gKiBXaGVuIG5hdmlnYXRpbmcgdG8gYSBzdGF0ZSwgd2UgYXJlIHRyYW5zaXRpb25pbmcgKipmcm9tKiogdGhlIGN1cnJlbnQgc3RhdGUgKip0byoqIHRoZSBuZXcgc3RhdGUuXG4gKlxuICogVGhpcyBvYmplY3QgY29udGFpbnMgYWxsIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRvL2Zyb20gc3RhdGVzLCBwYXJhbWV0ZXJzLCByZXNvbHZlcy5cbiAqIEl0IGhhcyBpbmZvcm1hdGlvbiBhYm91dCBhbGwgc3RhdGVzIGJlaW5nIGVudGVyZWQgYW5kIGV4aXRlZCBhcyBhIHJlc3VsdCBvZiB0aGUgdHJhbnNpdGlvbi5cbiAqL1xudmFyIFRyYW5zaXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUcmFuc2l0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIElmIHRoZSB0YXJnZXQgc3RhdGUgaXMgbm90IHZhbGlkLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxhcGlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcm9tUGF0aCBUaGUgcGF0aCBvZiBbW1BhdGhOb2RlXV1zIGZyb20gd2hpY2ggdGhlIHRyYW5zaXRpb24gaXMgbGVhdmluZy4gIFRoZSBsYXN0IG5vZGUgaW4gdGhlIGBmcm9tUGF0aGBcbiAgICAgKiAgICAgICAgZW5jYXBzdWxhdGVzIHRoZSBcImZyb20gc3RhdGVcIi5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0U3RhdGUgVGhlIHRhcmdldCBzdGF0ZSBhbmQgcGFyYW1ldGVycyBiZWluZyB0cmFuc2l0aW9uZWQgdG8gKGFsc28sIHRoZSB0cmFuc2l0aW9uIG9wdGlvbnMpXG4gICAgICogQHBhcmFtIHJvdXRlciBUaGUgW1tVSVJvdXRlcl1dIGluc3RhbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbihmcm9tUGF0aCwgdGFyZ2V0U3RhdGUsIHJvdXRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9kZWZlcnJlZCA9IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLmRlZmVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHByb21pc2UgaXMgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgYmFzZWQgb24gdGhlIG91dGNvbWUgb2YgdGhlIFRyYW5zaXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gdGhlIHRyYW5zaXRpb24gaXMgc3VjY2Vzc2Z1bCwgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWRcbiAgICAgICAgICogV2hlbiB0aGUgdHJhbnNpdGlvbiBpcyB1bnN1Y2Nlc3NmdWwsIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIHdpdGggdGhlIFtbUmVqZWN0aW9uXV0gb3IgamF2YXNjcmlwdCBlcnJvclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9taXNlID0gdGhpcy5fZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgLyoqIEBoaWRkZW4gSG9sZHMgdGhlIGhvb2sgcmVnaXN0cmF0aW9uIGZ1bmN0aW9ucyBzdWNoIGFzIHRob3NlIHBhc3NlZCB0byBUcmFuc2l0aW9uLm9uU3RhcnQoKSAqL1xuICAgICAgICB0aGlzLl9yZWdpc3RlcmVkSG9va3MgPSB7fTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5faG9va0J1aWxkZXIgPSBuZXcgaG9va0J1aWxkZXJfMS5Ib29rQnVpbGRlcih0aGlzKTtcbiAgICAgICAgLyoqIENoZWNrcyBpZiB0aGlzIHRyYW5zaXRpb24gaXMgY3VycmVudGx5IGFjdGl2ZS9ydW5uaW5nLiAqL1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJvdXRlci5nbG9iYWxzLnRyYW5zaXRpb24gPT09IF90aGlzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy5fdGFyZ2V0U3RhdGUgPSB0YXJnZXRTdGF0ZTtcbiAgICAgICAgaWYgKCF0YXJnZXRTdGF0ZS52YWxpZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGFyZ2V0U3RhdGUuZXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3VycmVudCgpIGlzIGFzc3VtZWQgdG8gY29tZSBmcm9tIHRhcmdldFN0YXRlLm9wdGlvbnMsIGJ1dCBwcm92aWRlIGEgbmFpdmUgaW1wbGVtZW50YXRpb24gb3RoZXJ3aXNlLlxuICAgICAgICB0aGlzLl9vcHRpb25zID0gY29tbW9uXzEuZXh0ZW5kKHsgY3VycmVudDogaG9mXzEudmFsKHRoaXMpIH0sIHRhcmdldFN0YXRlLm9wdGlvbnMoKSk7XG4gICAgICAgIHRoaXMuJGlkID0gcm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLl90cmFuc2l0aW9uQ291bnQrKztcbiAgICAgICAgdmFyIHRvUGF0aCA9IHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLmJ1aWxkVG9QYXRoKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSk7XG4gICAgICAgIHRoaXMuX3RyZWVDaGFuZ2VzID0gcGF0aEZhY3RvcnlfMS5QYXRoVXRpbHMudHJlZUNoYW5nZXMoZnJvbVBhdGgsIHRvUGF0aCwgdGhpcy5fb3B0aW9ucy5yZWxvYWRTdGF0ZSk7XG4gICAgICAgIHRoaXMuY3JlYXRlVHJhbnNpdGlvbkhvb2tSZWdGbnMoKTtcbiAgICAgICAgdmFyIG9uQ3JlYXRlSG9va3MgPSB0aGlzLl9ob29rQnVpbGRlci5idWlsZEhvb2tzRm9yUGhhc2UoaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5DUkVBVEUpO1xuICAgICAgICB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rLmludm9rZUhvb2tzKG9uQ3JlYXRlSG9va3MsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0pO1xuICAgICAgICB0aGlzLmFwcGx5Vmlld0NvbmZpZ3Mocm91dGVyKTtcbiAgICB9XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vbkJlZm9yZSA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vbkV4aXQgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vblJldGFpbiA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9uRW50ZXIgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vbkZpbmlzaCA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGhpZGRlblxuICAgICAqIENyZWF0ZXMgdGhlIHRyYW5zaXRpb24tbGV2ZWwgaG9vayByZWdpc3RyYXRpb24gZnVuY3Rpb25zXG4gICAgICogKHdoaWNoIGNhbiB0aGVuIGJlIHVzZWQgdG8gcmVnaXN0ZXIgaG9va3MpXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuY3JlYXRlVHJhbnNpdGlvbkhvb2tSZWdGbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLl9wbHVnaW5hcGkuX2dldEV2ZW50cygpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLmhvb2tQaGFzZSAhPT0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5DUkVBVEU7IH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gaG9va1JlZ2lzdHJ5XzEubWFrZUV2ZW50KF90aGlzLCBfdGhpcy5yb3V0ZXIudHJhbnNpdGlvblNlcnZpY2UsIHR5cGUpOyB9KTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5nZXRIb29rcyA9IGZ1bmN0aW9uIChob29rTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0ZXJlZEhvb2tzW2hvb2tOYW1lXTtcbiAgICB9O1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmFwcGx5Vmlld0NvbmZpZ3MgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgICAgIHZhciBlbnRlcmluZ1N0YXRlcyA9IHRoaXMuX3RyZWVDaGFuZ2VzLmVudGVyaW5nLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5zdGF0ZTsgfSk7XG4gICAgICAgIHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLmFwcGx5Vmlld0NvbmZpZ3Mocm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLiR2aWV3LCB0aGlzLl90cmVlQ2hhbmdlcy50bywgZW50ZXJpbmdTdGF0ZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgaW50ZXJuYWwgZnJvbSBbU3RhdGVdIG9iamVjdFxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLiRmcm9tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEudGFpbCh0aGlzLl90cmVlQ2hhbmdlcy5mcm9tKS5zdGF0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIGludGVybmFsIHRvIFtTdGF0ZV0gb2JqZWN0XG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuJHRvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEudGFpbCh0aGlzLl90cmVlQ2hhbmdlcy50bykuc3RhdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBcImZyb20gc3RhdGVcIlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgdGhhdCB0aGUgdHJhbnNpdGlvbiBpcyBjb21pbmcgKmZyb20qLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0YXRlIGRlY2xhcmF0aW9uIG9iamVjdCBmb3IgdGhlIFRyYW5zaXRpb24ncyAoXCJmcm9tIHN0YXRlXCIpLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmZyb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRmcm9tKCkuc2VsZjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFwidG8gc3RhdGVcIlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgdGhhdCB0aGUgdHJhbnNpdGlvbiBpcyBnb2luZyAqdG8qLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0YXRlIGRlY2xhcmF0aW9uIG9iamVjdCBmb3IgdGhlIFRyYW5zaXRpb24ncyB0YXJnZXQgc3RhdGUgKFwidG8gc3RhdGVcIikuXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR0bygpLnNlbGY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBUYXJnZXQgU3RhdGVcbiAgICAgKlxuICAgICAqIEEgdHJhbnNpdGlvbidzIFtbVGFyZ2V0U3RhdGVdXSBlbmNhcHN1bGF0ZXMgdGhlIFtbdG9dXSBzdGF0ZSwgdGhlIFtbcGFyYW1zXV0sIGFuZCB0aGUgW1tvcHRpb25zXV0gYXMgYSBzaW5nbGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIFtbVGFyZ2V0U3RhdGVdXSBvZiB0aGlzIFRyYW5zaXRpb25cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS50YXJnZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldFN0YXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byB0cmFuc2l0aW9ucyBhcmUgZXF1aXZhbGVudC5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmlzID0gZnVuY3Rpb24gKGNvbXBhcmUpIHtcbiAgICAgICAgaWYgKGNvbXBhcmUgaW5zdGFuY2VvZiBUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBBbHNvIGNvbXBhcmUgcGFyYW1ldGVyc1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXMoeyB0bzogY29tcGFyZS4kdG8oKS5uYW1lLCBmcm9tOiBjb21wYXJlLiRmcm9tKCkubmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISgoY29tcGFyZS50byAmJiAhaG9va1JlZ2lzdHJ5XzEubWF0Y2hTdGF0ZSh0aGlzLiR0bygpLCBjb21wYXJlLnRvKSkgfHxcbiAgICAgICAgICAgIChjb21wYXJlLmZyb20gJiYgIWhvb2tSZWdpc3RyeV8xLm1hdGNoU3RhdGUodGhpcy4kZnJvbSgpLCBjb21wYXJlLmZyb20pKSk7XG4gICAgfTtcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICAgICAgaWYgKHBhdGhuYW1lID09PSB2b2lkIDApIHsgcGF0aG5hbWUgPSBcInRvXCI7IH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUodGhpcy5fdHJlZUNoYW5nZXNbcGF0aG5hbWVdLm1hcChob2ZfMS5wcm9wKFwicGFyYW1WYWx1ZXNcIikpLnJlZHVjZShjb21tb25fMS5tZXJnZVIsIHt9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgW1tVSUluamVjdG9yXV0gRGVwZW5kZW5jeSBJbmplY3RvclxuICAgICAqXG4gICAgICogUmV0dXJucyBhIERlcGVuZGVuY3kgSW5qZWN0b3IgZm9yIHRoZSBUcmFuc2l0aW9uJ3MgdGFyZ2V0IHN0YXRlICh0byBzdGF0ZSkuXG4gICAgICogVGhlIGluamVjdG9yIHByb3ZpZGVzIHJlc29sdmUgdmFsdWVzIHdoaWNoIHRoZSB0YXJnZXQgc3RhdGUgaGFzIGFjY2VzcyB0by5cbiAgICAgKlxuICAgICAqIFRoZSBgVUlJbmplY3RvcmAgY2FuIGFsc28gcHJvdmlkZSB2YWx1ZXMgZnJvbSB0aGUgbmF0aXZlIHJvb3QvZ2xvYmFsIGluamVjdG9yIChuZzEvbmcyKS5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIC5vbkVudGVyKHsgZW50ZXJpbmc6ICdteVN0YXRlJyB9LCB0cmFucyA9PiB7XG4gICAgICogICB2YXIgbXlSZXNvbHZlVmFsdWUgPSB0cmFucy5pbmplY3RvcigpLmdldCgnbXlSZXNvbHZlJyk7XG4gICAgICogICAvLyBJbmplY3QgYSBnbG9iYWwgc2VydmljZSBmcm9tIHRoZSBnbG9iYWwvbmF0aXZlIGluamVjdG9yIChpZiBpdCBleGlzdHMpXG4gICAgICogICB2YXIgTXlTZXJ2aWNlID0gdHJhbnMuaW5qZWN0b3IoKS5nZXQoJ015U2VydmljZScpO1xuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBJbiBzb21lIGNhc2VzIChzdWNoIGFzIGBvbkJlZm9yZWApLCB5b3UgbWF5IG5lZWQgYWNjZXNzIHRvIHNvbWUgcmVzb2x2ZSBkYXRhIGJ1dCBpdCBoYXMgbm90IHlldCBiZWVuIGZldGNoZWQuXG4gICAgICogWW91IGNhbiB1c2UgW1tVSUluamVjdG9yLmdldEFzeW5jXV0gdG8gZ2V0IGEgcHJvbWlzZSBmb3IgdGhlIGRhdGEuXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogLm9uQmVmb3JlKHt9LCB0cmFucyA9PiB7XG4gICAgICogICByZXR1cm4gdHJhbnMuaW5qZWN0b3IoKS5nZXRBc3luYygnbXlSZXNvbHZlJykudGhlbihteVJlc29sdmVWYWx1ZSA9PlxuICAgICAqICAgICByZXR1cm4gbXlSZXNvbHZlVmFsdWUgIT09ICdBQk9SVCc7XG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIElmIGEgYHN0YXRlYCBpcyBwcm92aWRlZCwgdGhlIGluamVjdG9yIHRoYXQgaXMgcmV0dXJuZWQgd2lsbCBiZSBsaW1pdGVkIHRvIHJlc29sdmUgdmFsdWVzIHRoYXQgdGhlIHByb3ZpZGVkIHN0YXRlIGhhcyBhY2Nlc3MgdG8uXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZnVsIGlmIGJvdGggYSBwYXJlbnQgc3RhdGUgYGZvb2AgYW5kIGEgY2hpbGQgc3RhdGUgYGZvby5iYXJgIGhhdmUgYm90aCBkZWZpbmVkIGEgcmVzb2x2ZSBzdWNoIGFzIGBkYXRhYC5cbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiAub25FbnRlcih7IHRvOiAnZm9vLmJhcicgfSwgdHJhbnMgPT4ge1xuICAgICAqICAgLy8gcmV0dXJucyByZXN1bHQgb2YgYGZvb2Agc3RhdGUncyBgZGF0YWAgcmVzb2x2ZVxuICAgICAqICAgLy8gZXZlbiB0aG91Z2ggYGZvby5iYXJgIGFsc28gaGFzIGEgYGRhdGFgIHJlc29sdmVcbiAgICAgKiAgIHZhciBmb29EYXRhID0gdHJhbnMuaW5qZWN0b3IoJ2ZvbycpLmdldCgnZGF0YScpO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogSWYgeW91IG5lZWQgcmVzb2x2ZSBkYXRhIGZyb20gdGhlIGV4aXRpbmcgc3RhdGVzLCBwYXNzIGAnZnJvbSdgIGFzIGBwYXRoTmFtZWAuXG4gICAgICogVGhlIHJlc29sdmUgZGF0YSBmcm9tIHRoZSBgZnJvbWAgcGF0aCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIC5vbkV4aXQoeyBleGl0aW5nOiAnZm9vLmJhcicgfSwgdHJhbnMgPT4ge1xuICAgICAqICAgLy8gR2V0cyB0aGUgcmVzb2x2ZSB2YWx1ZSBvZiBgZGF0YWAgZnJvbSB0aGUgZXhpdGluZyBzdGF0ZS5cbiAgICAgKiAgIHZhciBmb29EYXRhID0gdHJhbnMuaW5qZWN0b3IobnVsbCwgJ2Zvby5iYXInKS5nZXQoJ2RhdGEnKTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlIExpbWl0cyB0aGUgcmVzb2x2ZXMgcHJvdmlkZWQgdG8gb25seSB0aGUgcmVzb2x2ZXMgdGhlIHByb3ZpZGVkIHN0YXRlIGhhcyBhY2Nlc3MgdG8uXG4gICAgICogQHBhcmFtIHBhdGhOYW1lIERlZmF1bHQ6IGAndG8nYDogQ2hvb3NlcyB0aGUgcGF0aCBmb3Igd2hpY2ggdG8gY3JlYXRlIHRoZSBpbmplY3Rvci4gVXNlIHRoaXMgdG8gYWNjZXNzIHJlc29sdmVzIGZvciBgZXhpdGluZ2Agc3RhdGVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBbW1VJSW5qZWN0b3JdXVxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmluamVjdG9yID0gZnVuY3Rpb24gKHN0YXRlLCBwYXRoTmFtZSkge1xuICAgICAgICBpZiAocGF0aE5hbWUgPT09IHZvaWQgMCkgeyBwYXRoTmFtZSA9IFwidG9cIjsgfVxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMuX3RyZWVDaGFuZ2VzW3BhdGhOYW1lXTtcbiAgICAgICAgaWYgKHN0YXRlKVxuICAgICAgICAgICAgcGF0aCA9IHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLnN1YlBhdGgocGF0aCwgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuc3RhdGUgPT09IHN0YXRlIHx8IG5vZGUuc3RhdGUubmFtZSA9PT0gc3RhdGU7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IHJlc29sdmVDb250ZXh0XzEuUmVzb2x2ZUNvbnRleHQocGF0aCkuaW5qZWN0b3IoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGF2YWlsYWJsZSByZXNvbHZlIHRva2VucyAoa2V5cylcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggW1tpbmplY3Rvcl1dIHRvIGluc3BlY3QgdGhlIHJlc29sdmUgdmFsdWVzXG4gICAgICogYXZhaWxhYmxlIHRvIHRoZSBUcmFuc2l0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyByZXR1cm5zIGFsbCB0aGUgdG9rZW5zIGRlZmluZWQgb24gW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXSBibG9ja3MsIGZvciB0aGUgc3RhdGVzXG4gICAgICogaW4gdGhlIFRyYW5zaXRpb24ncyBbW1RyZWVDaGFuZ2VzLnRvXV0gcGF0aC5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBUaGlzIGV4YW1wbGUgbG9ncyBhbGwgcmVzb2x2ZSB2YWx1ZXNcbiAgICAgKiBgYGBqc1xuICAgICAqIGxldCB0b2tlbnMgPSB0cmFucy5nZXRSZXNvbHZlVG9rZW5zKCk7XG4gICAgICogdG9rZW5zLmZvckVhY2godG9rZW4gPT4gY29uc29sZS5sb2codG9rZW4gKyBcIiA9IFwiICsgdHJhbnMuaW5qZWN0b3IoKS5nZXQodG9rZW4pKSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgcHJvbWlzZXMgZm9yIGVhY2ggcmVzb2x2ZSB2YWx1ZS5cbiAgICAgKiBUaGlzIHRyaWdnZXJzIGZldGNoZXMgb2YgcmVzb2x2ZXMgKGlmIGFueSBoYXZlIG5vdCB5ZXQgYmVlbiBmZXRjaGVkKS5cbiAgICAgKiBXaGVuIGFsbCBwcm9taXNlcyBoYXZlIGFsbCBzZXR0bGVkLCBpdCBsb2dzIHRoZSByZXNvbHZlIHZhbHVlcy5cbiAgICAgKiBgYGBqc1xuICAgICAqIGxldCB0b2tlbnMgPSB0cmFucy5nZXRSZXNvbHZlVG9rZW5zKCk7XG4gICAgICogbGV0IHByb21pc2UgPSB0b2tlbnMubWFwKHRva2VuID0+IHRyYW5zLmluamVjdG9yKCkuZ2V0QXN5bmModG9rZW4pKTtcbiAgICAgKiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbih2YWx1ZXMgPT4gY29uc29sZS5sb2coXCJSZXNvbHZlZCB2YWx1ZXM6IFwiICsgdmFsdWVzKSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBOb3RlOiBBbmd1bGFyIDEgdXNlcnMgd2hvdWxkIHVzZSBgJHEuYWxsKClgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aG5hbWUgcmVzb2x2ZSBjb250ZXh0J3MgcGF0aCBuYW1lIChlLmcuLCBgdG9gIG9yIGBmcm9tYClcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHJlc29sdmUgdG9rZW5zIChrZXlzKVxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmdldFJlc29sdmVUb2tlbnMgPSBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICAgICAgaWYgKHBhdGhuYW1lID09PSB2b2lkIDApIHsgcGF0aG5hbWUgPSBcInRvXCI7IH1cbiAgICAgICAgcmV0dXJuIG5ldyByZXNvbHZlQ29udGV4dF8xLlJlc29sdmVDb250ZXh0KHRoaXMuX3RyZWVDaGFuZ2VzW3BhdGhuYW1lXSkuZ2V0VG9rZW5zKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEeW5hbWljYWxseSBhZGRzIGEgbmV3IFtbUmVzb2x2YWJsZV1dIChpLmUuLCBbW1N0YXRlRGVjbGFyYXRpb24ucmVzb2x2ZV1dKSB0byB0aGlzIHRyYW5zaXRpb24uXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7fSwgdHJhbnNpdGlvbiA9PiB7XG4gICAgICogICB0cmFuc2l0aW9uLmFkZFJlc29sdmFibGUoe1xuICAgICAqICAgICB0b2tlbjogJ215UmVzb2x2ZScsXG4gICAgICogICAgIGRlcHM6IFsnTXlTZXJ2aWNlJ10sXG4gICAgICogICAgIHJlc29sdmVGbjogbXlTZXJ2aWNlID0+IG15U2VydmljZS5nZXREYXRhKClcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHJlc29sdmFibGUgYSBbW1Jlc29sdmFibGVMaXRlcmFsXV0gb2JqZWN0IChvciBhIFtbUmVzb2x2YWJsZV1dKVxuICAgICAqIEBwYXJhbSBzdGF0ZSB0aGUgc3RhdGUgaW4gdGhlIFwidG8gcGF0aFwiIHdoaWNoIHNob3VsZCByZWNlaXZlIHRoZSBuZXcgcmVzb2x2ZSAob3RoZXJ3aXNlLCB0aGUgcm9vdCBzdGF0ZSlcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5hZGRSZXNvbHZhYmxlID0gZnVuY3Rpb24gKHJlc29sdmFibGUsIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7IHN0YXRlID0gXCJcIjsgfVxuICAgICAgICByZXNvbHZhYmxlID0gaG9mXzEuaXMocmVzb2x2YWJsZV8xLlJlc29sdmFibGUpKHJlc29sdmFibGUpID8gcmVzb2x2YWJsZSA6IG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZShyZXNvbHZhYmxlKTtcbiAgICAgICAgdmFyIHN0YXRlTmFtZSA9ICh0eXBlb2Ygc3RhdGUgPT09IFwic3RyaW5nXCIpID8gc3RhdGUgOiBzdGF0ZS5uYW1lO1xuICAgICAgICB2YXIgdG9wYXRoID0gdGhpcy5fdHJlZUNoYW5nZXMudG87XG4gICAgICAgIHZhciB0YXJnZXROb2RlID0gY29tbW9uXzEuZmluZCh0b3BhdGgsIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnN0YXRlLm5hbWUgPT09IHN0YXRlTmFtZTsgfSk7XG4gICAgICAgIHZhciByZXNvbHZlQ29udGV4dCA9IG5ldyByZXNvbHZlQ29udGV4dF8xLlJlc29sdmVDb250ZXh0KHRvcGF0aCk7XG4gICAgICAgIHJlc29sdmVDb250ZXh0LmFkZFJlc29sdmFibGVzKFtyZXNvbHZhYmxlXSwgdGFyZ2V0Tm9kZS5zdGF0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0cmFuc2l0aW9uIGZyb20gd2hpY2ggdGhpcyB0cmFuc2l0aW9uIHdhcyByZWRpcmVjdGVkLlxuICAgICAqXG4gICAgICogSWYgdGhlIGN1cnJlbnQgdHJhbnNpdGlvbiBpcyBhIHJlZGlyZWN0LCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSB0cmFuc2l0aW9uIHRoYXQgd2FzIHJlZGlyZWN0ZWQuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBsZXQgdHJhbnNpdGlvbkEgPSAkc3RhdGUuZ28oJ0EnKS50cmFuc2l0aW9uXG4gICAgICogdHJhbnNpdGlvbkEub25TdGFydCh7fSwgKCkgPT4gJHN0YXRlLnRhcmdldCgnQicpKTtcbiAgICAgKiAkdHJhbnNpdGlvbnMub25TdWNjZXNzKHsgdG86ICdCJyB9LCAodHJhbnMpID0+IHtcbiAgICAgKiAgIHRyYW5zLnRvKCkubmFtZSA9PT0gJ0InOyAvLyB0cnVlXG4gICAgICogICB0cmFucy5yZWRpcmVjdGVkRnJvbSgpID09PSB0cmFuc2l0aW9uQTsgLy8gdHJ1ZVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHByZXZpb3VzIFRyYW5zaXRpb24sIG9yIG51bGwgaWYgdGhpcyBUcmFuc2l0aW9uIGlzIG5vdCB0aGUgcmVzdWx0IG9mIGEgcmVkaXJlY3Rpb25cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5yZWRpcmVjdGVkRnJvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMucmVkaXJlY3RlZEZyb20gfHwgbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gaW4gYSByZWRpcmVjdCBjaGFpblxuICAgICAqXG4gICAgICogQSB0cmFuc2l0aW9uIG1pZ2h0IGJlbG9uZyB0byBhIGxvbmcgY2hhaW4gb2YgbXVsdGlwbGUgcmVkaXJlY3RzLlxuICAgICAqIFRoaXMgbWV0aG9kIHdhbGtzIHRoZSBbW3JlZGlyZWN0ZWRGcm9tXV0gY2hhaW4gYmFjayB0byB0aGUgb3JpZ2luYWwgKGZpcnN0KSB0cmFuc2l0aW9uIGluIHRoZSBjaGFpbi5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vIHN0YXRlc1xuICAgICAqIHJlZ2lzdHJ5LnJlZ2lzdGVyKHsgbmFtZTogJ0EnLCByZWRpcmVjdFRvOiAnQicgfSk7XG4gICAgICogcmVnaXN0cnkucmVnaXN0ZXIoeyBuYW1lOiAnQicsIHJlZGlyZWN0VG86ICdDJyB9KTtcbiAgICAgKiByZWdpc3RyeS5yZWdpc3Rlcih7IG5hbWU6ICdDJywgcmVkaXJlY3RUbzogJ0QnIH0pO1xuICAgICAqIHJlZ2lzdHJ5LnJlZ2lzdGVyKHsgbmFtZTogJ0QnIH0pO1xuICAgICAqXG4gICAgICogbGV0IHRyYW5zaXRpb25BID0gJHN0YXRlLmdvKCdBJykudHJhbnNpdGlvblxuICAgICAqXG4gICAgICogJHRyYW5zaXRpb25zLm9uU3VjY2Vzcyh7IHRvOiAnRCcgfSwgKHRyYW5zKSA9PiB7XG4gICAgICogICB0cmFucy50bygpLm5hbWUgPT09ICdEJzsgLy8gdHJ1ZVxuICAgICAqICAgdHJhbnMucmVkaXJlY3RlZEZyb20oKS50bygpLm5hbWUgPT09ICdDJzsgLy8gdHJ1ZVxuICAgICAqICAgdHJhbnMub3JpZ2luYWxUcmFuc2l0aW9uKCkgPT09IHRyYW5zaXRpb25BOyAvLyB0cnVlXG4gICAgICogICB0cmFucy5vcmlnaW5hbFRyYW5zaXRpb24oKS50bygpLm5hbWUgPT09ICdBJzsgLy8gdHJ1ZVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG9yaWdpbmFsIFRyYW5zaXRpb24gdGhhdCBzdGFydGVkIGEgcmVkaXJlY3QgY2hhaW5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vcmlnaW5hbFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZiA9IHRoaXMucmVkaXJlY3RlZEZyb20oKTtcbiAgICAgICAgcmV0dXJuIChyZiAmJiByZi5vcmlnaW5hbFRyYW5zaXRpb24oKSkgfHwgdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdHJhbnNpdGlvbiBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgb3B0aW9ucyBmb3IgdGhpcyBUcmFuc2l0aW9uLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhdGVzIGJlaW5nIGVudGVyZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBzdGF0ZXMgdGhhdCB3aWxsIGJlIGVudGVyZWQgZHVyaW5nIHRoaXMgdHJhbnNpdGlvbi5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5lbnRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLm1hcCh0aGlzLl90cmVlQ2hhbmdlcy5lbnRlcmluZywgaG9mXzEucHJvcCgnc3RhdGUnKSkubWFwKHN0YXRlU2VsZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0ZXMgYmVpbmcgZXhpdGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgb2Ygc3RhdGVzIHRoYXQgd2lsbCBiZSBleGl0ZWQgZHVyaW5nIHRoaXMgdHJhbnNpdGlvbi5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5leGl0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEubWFwKHRoaXMuX3RyZWVDaGFuZ2VzLmV4aXRpbmcsIGhvZl8xLnByb3AoJ3N0YXRlJykpLm1hcChzdGF0ZVNlbGYpLnJldmVyc2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YXRlcyBiZWluZyByZXRhaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHN0YXRlcyB0aGF0IGFyZSBhbHJlYWR5IGVudGVyZWQgZnJvbSBhIHByZXZpb3VzIFRyYW5zaXRpb24sIHRoYXQgd2lsbCBub3QgYmVcbiAgICAgKiAgICBleGl0ZWQgZHVyaW5nIHRoaXMgVHJhbnNpdGlvblxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnJldGFpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEubWFwKHRoaXMuX3RyZWVDaGFuZ2VzLnJldGFpbmVkLCBob2ZfMS5wcm9wKCdzdGF0ZScpKS5tYXAoc3RhdGVTZWxmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgW1tWaWV3Q29uZmlnXV1zIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFRyYW5zaXRpb25cbiAgICAgKlxuICAgICAqIEVhY2ggc3RhdGUgY2FuIGRlZmluZSBvbmUgb3IgbW9yZSB2aWV3cyAodGVtcGxhdGUvY29udHJvbGxlciksIHdoaWNoIGFyZSBlbmNhcHN1bGF0ZWQgYXMgYFZpZXdDb25maWdgIG9iamVjdHMuXG4gICAgICogVGhpcyBtZXRob2QgZmV0Y2hlcyB0aGUgYFZpZXdDb25maWdzYCBmb3IgYSBnaXZlbiBwYXRoIGluIHRoZSBUcmFuc2l0aW9uIChlLmcuLCBcInRvXCIgb3IgXCJlbnRlcmluZ1wiKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRobmFtZSB0aGUgbmFtZSBvZiB0aGUgcGF0aCB0byBmZXRjaCB2aWV3cyBmb3I6XG4gICAgICogICAoYCd0bydgLCBgJ2Zyb20nYCwgYCdlbnRlcmluZydgLCBgJ2V4aXRpbmcnYCwgYCdyZXRhaW5lZCdgKVxuICAgICAqIEBwYXJhbSBzdGF0ZSBJZiBwcm92aWRlZCwgb25seSByZXR1cm5zIHRoZSBgVmlld0NvbmZpZ2BzIGZvciBhIHNpbmdsZSBzdGF0ZSBpbiB0aGUgcGF0aFxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBsaXN0IG9mIFZpZXdDb25maWcgb2JqZWN0cyBmb3IgdGhlIGdpdmVuIHBhdGguXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUudmlld3MgPSBmdW5jdGlvbiAocGF0aG5hbWUsIHN0YXRlKSB7XG4gICAgICAgIGlmIChwYXRobmFtZSA9PT0gdm9pZCAwKSB7IHBhdGhuYW1lID0gXCJlbnRlcmluZ1wiOyB9XG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5fdHJlZUNoYW5nZXNbcGF0aG5hbWVdO1xuICAgICAgICBwYXRoID0gIXN0YXRlID8gcGF0aCA6IHBhdGguZmlsdGVyKGhvZl8xLnByb3BFcSgnc3RhdGUnLCBzdGF0ZSkpO1xuICAgICAgICByZXR1cm4gcGF0aC5tYXAoaG9mXzEucHJvcChcInZpZXdzXCIpKS5maWx0ZXIoY29tbW9uXzEuaWRlbnRpdHkpLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSk7XG4gICAgfTtcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS50cmVlQ2hhbmdlcyA9IGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWUgPyB0aGlzLl90cmVlQ2hhbmdlc1twYXRobmFtZV0gOiB0aGlzLl90cmVlQ2hhbmdlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdHJhbnNpdGlvbiB0aGF0IGlzIGEgcmVkaXJlY3Rpb24gb2YgdGhlIGN1cnJlbnQgb25lLlxuICAgICAqXG4gICAgICogVGhpcyB0cmFuc2l0aW9uIGNhbiBiZSByZXR1cm5lZCBmcm9tIGEgW1tUcmFuc2l0aW9uU2VydmljZV1dIGhvb2sgdG9cbiAgICAgKiByZWRpcmVjdCBhIHRyYW5zaXRpb24gdG8gYSBuZXcgc3RhdGUgYW5kL29yIHNldCBvZiBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgbmV3IFtbVHJhbnNpdGlvbl1dIGluc3RhbmNlLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnJlZGlyZWN0ID0gZnVuY3Rpb24gKHRhcmdldFN0YXRlKSB7XG4gICAgICAgIHZhciByZWRpcmVjdHMgPSAxLCB0cmFucyA9IHRoaXM7XG4gICAgICAgIHdoaWxlICgodHJhbnMgPSB0cmFucy5yZWRpcmVjdGVkRnJvbSgpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoKytyZWRpcmVjdHMgPiAyMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gbWFueSBjb25zZWN1dGl2ZSBUcmFuc2l0aW9uIHJlZGlyZWN0cyAoMjArKVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVkaXJlY3RPcHRzID0geyByZWRpcmVjdGVkRnJvbTogdGhpcywgc291cmNlOiBcInJlZGlyZWN0XCIgfTtcbiAgICAgICAgLy8gSWYgdGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gd2FzIGNhdXNlZCBieSBVUkwgc3luYywgdGhlbiB1c2UgeyBsb2NhdGlvbjogJ3JlcGxhY2UnIH1cbiAgICAgICAgLy8gb24gdGhlIG5ldyB0cmFuc2l0aW9uICh1bmxlc3MgdGhlIHRhcmdldCBzdGF0ZSBleHBsaWNpdGx5IHNwZWNpZmllcyBsb2NhdGlvbjogZmFsc2UpLlxuICAgICAgICAvLyBUaGlzIGNhdXNlcyB0aGUgb3JpZ2luYWwgdXJsIHRvIGJlIHJlcGxhY2VkIHdpdGggdGhlIHVybCBmb3IgdGhlIHJlZGlyZWN0IHRhcmdldFxuICAgICAgICAvLyBzbyB0aGUgb3JpZ2luYWwgdXJsIGRpc2FwcGVhcnMgZnJvbSB0aGUgYnJvd3NlciBoaXN0b3J5LlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zKCkuc291cmNlID09PSAndXJsJyAmJiB0YXJnZXRTdGF0ZS5vcHRpb25zKCkubG9jYXRpb24gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZWRpcmVjdE9wdHMubG9jYXRpb24gPSAncmVwbGFjZSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld09wdGlvbnMgPSBjb21tb25fMS5leHRlbmQoe30sIHRoaXMub3B0aW9ucygpLCB0YXJnZXRTdGF0ZS5vcHRpb25zKCksIHJlZGlyZWN0T3B0cyk7XG4gICAgICAgIHRhcmdldFN0YXRlID0gdGFyZ2V0U3RhdGUud2l0aE9wdGlvbnMobmV3T3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIHZhciBuZXdUcmFuc2l0aW9uID0gdGhpcy5yb3V0ZXIudHJhbnNpdGlvblNlcnZpY2UuY3JlYXRlKHRoaXMuX3RyZWVDaGFuZ2VzLmZyb20sIHRhcmdldFN0YXRlKTtcbiAgICAgICAgdmFyIG9yaWdpbmFsRW50ZXJpbmdOb2RlcyA9IHRoaXMuX3RyZWVDaGFuZ2VzLmVudGVyaW5nO1xuICAgICAgICB2YXIgcmVkaXJlY3RFbnRlcmluZ05vZGVzID0gbmV3VHJhbnNpdGlvbi5fdHJlZUNoYW5nZXMuZW50ZXJpbmc7XG4gICAgICAgIC8vIC0tLSBSZS11c2UgcmVzb2x2ZSBkYXRhIGZyb20gb3JpZ2luYWwgdHJhbnNpdGlvbiAtLS1cbiAgICAgICAgLy8gV2hlbiByZWRpcmVjdGluZyBmcm9tIGEgcGFyZW50IHN0YXRlIHRvIGEgY2hpbGQgc3RhdGUgd2hlcmUgdGhlIHBhcmVudCBwYXJhbWV0ZXIgdmFsdWVzIGhhdmVuJ3QgY2hhbmdlZFxuICAgICAgICAvLyAoYmVjYXVzZSBvZiB0aGUgcmVkaXJlY3QpLCB0aGUgcmVzb2x2ZXMgZmV0Y2hlZCBieSB0aGUgb3JpZ2luYWwgdHJhbnNpdGlvbiBhcmUgc3RpbGwgdmFsaWQgaW4gdGhlXG4gICAgICAgIC8vIHJlZGlyZWN0ZWQgdHJhbnNpdGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgeW91IHRvIGRlZmluZSBhIHJlZGlyZWN0IG9uIGEgcGFyZW50IHN0YXRlIHdoaWNoIGRlcGVuZHMgb24gYW4gYXN5bmMgcmVzb2x2ZSB2YWx1ZS5cbiAgICAgICAgLy8gWW91IGNhbiB3YWl0IGZvciB0aGUgcmVzb2x2ZSwgdGhlbiByZWRpcmVjdCB0byBhIGNoaWxkIHN0YXRlIGJhc2VkIG9uIHRoZSByZXN1bHQuXG4gICAgICAgIC8vIFRoZSByZWRpcmVjdGVkIHRyYW5zaXRpb24gZG9lcyBub3QgaGF2ZSB0byByZS1mZXRjaCB0aGUgcmVzb2x2ZS5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHZhciBub2RlSXNSZWxvYWRpbmcgPSBmdW5jdGlvbiAocmVsb2FkU3RhdGUpIHsgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVsb2FkU3RhdGUgJiYgbm9kZS5zdGF0ZS5pbmNsdWRlc1tyZWxvYWRTdGF0ZS5uYW1lXTtcbiAgICAgICAgfTsgfTtcbiAgICAgICAgLy8gRmluZCBhbnkgXCJlbnRlcmluZ1wiIG5vZGVzIGluIHRoZSByZWRpcmVjdCBwYXRoIHRoYXQgbWF0Y2ggdGhlIG9yaWdpbmFsIHBhdGggYW5kIGFyZW4ndCBiZWluZyByZWxvYWRlZFxuICAgICAgICB2YXIgbWF0Y2hpbmdFbnRlcmluZ05vZGVzID0gcGF0aEZhY3RvcnlfMS5QYXRoVXRpbHMubWF0Y2hpbmcocmVkaXJlY3RFbnRlcmluZ05vZGVzLCBvcmlnaW5hbEVudGVyaW5nTm9kZXMsIHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLm5vbkR5bmFtaWNQYXJhbXMpXG4gICAgICAgICAgICAuZmlsdGVyKGhvZl8xLm5vdChub2RlSXNSZWxvYWRpbmcodGFyZ2V0U3RhdGUub3B0aW9ucygpLnJlbG9hZFN0YXRlKSkpO1xuICAgICAgICAvLyBVc2UgdGhlIGV4aXN0aW5nIChwb3NzaWJseSBwcmUtcmVzb2x2ZWQpIHJlc29sdmFibGVzIGZvciB0aGUgbWF0Y2hpbmcgZW50ZXJpbmcgbm9kZXMuXG4gICAgICAgIG1hdGNoaW5nRW50ZXJpbmdOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlLCBpZHgpIHtcbiAgICAgICAgICAgIG5vZGUucmVzb2x2YWJsZXMgPSBvcmlnaW5hbEVudGVyaW5nTm9kZXNbaWR4XS5yZXNvbHZhYmxlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdUcmFuc2l0aW9uO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gSWYgYSB0cmFuc2l0aW9uIGRvZXNuJ3QgZXhpdC9lbnRlciBhbnkgc3RhdGVzLCByZXR1cm5zIGFueSBbW1BhcmFtXV0gd2hvc2UgdmFsdWUgY2hhbmdlZCAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLl9jaGFuZ2VkUGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGMgPSB0aGlzLl90cmVlQ2hhbmdlcztcbiAgICAgICAgLyoqIFJldHVybiB1bmRlZmluZWQgaWYgaXQncyBub3QgYSBcImR5bmFtaWNcIiB0cmFuc2l0aW9uLCBmb3IgdGhlIGZvbGxvd2luZyByZWFzb25zICovXG4gICAgICAgIC8vIElmIHVzZXIgZXhwbGljaXRseSB3YW50cyBhIHJlbG9hZFxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5yZWxvYWQpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAvLyBJZiBhbnkgc3RhdGVzIGFyZSBleGl0aW5nIG9yIGVudGVyaW5nXG4gICAgICAgIGlmICh0Yy5leGl0aW5nLmxlbmd0aCB8fCB0Yy5lbnRlcmluZy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAvLyBJZiB0by9mcm9tIHBhdGggbGVuZ3RocyBkaWZmZXJcbiAgICAgICAgaWYgKHRjLnRvLmxlbmd0aCAhPT0gdGMuZnJvbS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAvLyBJZiB0aGUgdG8vZnJvbSBwYXRocyBhcmUgZGlmZmVyZW50XG4gICAgICAgIHZhciBwYXRoc0RpZmZlciA9IGNvbW1vbl8xLmFycmF5VHVwbGVzKHRjLnRvLCB0Yy5mcm9tKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuIHR1cGxlWzBdLnN0YXRlICE9PSB0dXBsZVsxXS5zdGF0ZTsgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoY29tbW9uXzEuYW55VHJ1ZVIsIGZhbHNlKTtcbiAgICAgICAgaWYgKHBhdGhzRGlmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgLy8gRmluZCBhbnkgcGFyYW1ldGVyIHZhbHVlcyB0aGF0IGRpZmZlclxuICAgICAgICB2YXIgbm9kZVNjaGVtYXMgPSB0Yy50by5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUucGFyYW1TY2hlbWE7IH0pO1xuICAgICAgICB2YXIgX2EgPSBbdGMudG8sIHRjLmZyb21dLm1hcChmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gcGF0aC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgucGFyYW1WYWx1ZXM7IH0pOyB9KSwgdG9WYWx1ZXMgPSBfYVswXSwgZnJvbVZhbHVlcyA9IF9hWzFdO1xuICAgICAgICB2YXIgdHVwbGVzID0gY29tbW9uXzEuYXJyYXlUdXBsZXMobm9kZVNjaGVtYXMsIHRvVmFsdWVzLCBmcm9tVmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIHR1cGxlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgc2NoZW1hID0gX2FbMF0sIHRvVmFscyA9IF9hWzFdLCBmcm9tVmFscyA9IF9hWzJdO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtXzEuUGFyYW0uY2hhbmdlZChzY2hlbWEsIHRvVmFscywgZnJvbVZhbHMpO1xuICAgICAgICB9KS5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2l0aW9uIGlzIGR5bmFtaWMuXG4gICAgICpcbiAgICAgKiBBIHRyYW5zaXRpb24gaXMgZHluYW1pYyBpZiBubyBzdGF0ZXMgYXJlIGVudGVyZWQgbm9yIGV4aXRlZCwgYnV0IGF0IGxlYXN0IG9uZSBkeW5hbWljIHBhcmFtZXRlciBoYXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFRyYW5zaXRpb24gaXMgZHluYW1pY1xuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmR5bmFtaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5fY2hhbmdlZFBhcmFtcygpO1xuICAgICAgICByZXR1cm4gIWNoYW5nZXMgPyBmYWxzZSA6IGNoYW5nZXMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmR5bmFtaWM7IH0pLnJlZHVjZShjb21tb25fMS5hbnlUcnVlUiwgZmFsc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2l0aW9uIGlzIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBBIHRyYW5zaXRpb24gaXMgaWdub3JlZCBpZiBubyBzdGF0ZXMgYXJlIGVudGVyZWQgbm9yIGV4aXRlZCwgYW5kIG5vIHBhcmFtZXRlciB2YWx1ZXMgaGF2ZSBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgVHJhbnNpdGlvbiBpcyBpZ25vcmVkLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmlnbm9yZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2lnbm9yZWRSZWFzb24oKTtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuX2lnbm9yZWRSZWFzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwZW5kaW5nID0gdGhpcy5yb3V0ZXIuZ2xvYmFscy50cmFuc2l0aW9uO1xuICAgICAgICB2YXIgcmVsb2FkU3RhdGUgPSB0aGlzLl9vcHRpb25zLnJlbG9hZFN0YXRlO1xuICAgICAgICB2YXIgc2FtZSA9IGZ1bmN0aW9uIChwYXRoQSwgcGF0aEIpIHtcbiAgICAgICAgICAgIGlmIChwYXRoQS5sZW5ndGggIT09IHBhdGhCLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmcgPSBwYXRoRmFjdG9yeV8xLlBhdGhVdGlscy5tYXRjaGluZyhwYXRoQSwgcGF0aEIpO1xuICAgICAgICAgICAgcmV0dXJuIHBhdGhBLmxlbmd0aCA9PT0gbWF0Y2hpbmcuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiAhcmVsb2FkU3RhdGUgfHwgIW5vZGUuc3RhdGUuaW5jbHVkZXNbcmVsb2FkU3RhdGUubmFtZV07IH0pLmxlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG5ld1RDID0gdGhpcy50cmVlQ2hhbmdlcygpO1xuICAgICAgICB2YXIgcGVuZFRDID0gcGVuZGluZyAmJiBwZW5kaW5nLnRyZWVDaGFuZ2VzKCk7XG4gICAgICAgIGlmIChwZW5kVEMgJiYgc2FtZShwZW5kVEMudG8sIG5ld1RDLnRvKSAmJiBzYW1lKHBlbmRUQy5leGl0aW5nLCBuZXdUQy5leGl0aW5nKSlcbiAgICAgICAgICAgIHJldHVybiBcIlNhbWVBc1BlbmRpbmdcIjtcbiAgICAgICAgaWYgKG5ld1RDLmV4aXRpbmcubGVuZ3RoID09PSAwICYmIG5ld1RDLmVudGVyaW5nLmxlbmd0aCA9PT0gMCAmJiBzYW1lKG5ld1RDLmZyb20sIG5ld1RDLnRvKSlcbiAgICAgICAgICAgIHJldHVybiBcIlNhbWVBc0N1cnJlbnRcIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIHRyYW5zaXRpb25cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGdlbmVyYWxseSBjYWxsZWQgZnJvbSB0aGUgW1tTdGF0ZVNlcnZpY2UudHJhbnNpdGlvblRvXV1cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBwcm9taXNlIGZvciBhIHN1Y2Nlc3NmdWwgdHJhbnNpdGlvbi5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBydW5BbGxIb29rcyA9IHRyYW5zaXRpb25Ib29rXzEuVHJhbnNpdGlvbkhvb2sucnVuQWxsSG9va3M7XG4gICAgICAgIC8vIEdldHMgdHJhbnNpdGlvbiBob29rcyBhcnJheSBmb3IgdGhlIGdpdmVuIHBoYXNlXG4gICAgICAgIHZhciBnZXRIb29rc0ZvciA9IGZ1bmN0aW9uIChwaGFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9ob29rQnVpbGRlci5idWlsZEhvb2tzRm9yUGhhc2UocGhhc2UpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBXaGVuIHRoZSBjaGFpbiBpcyBjb21wbGV0ZSwgdGhlbiByZXNvbHZlIG9yIHJlamVjdCB0aGUgZGVmZXJyZWRcbiAgICAgICAgdmFyIHRyYW5zaXRpb25TdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZVN1Y2Nlc3MoX3RoaXMuJHRvKCksIF90aGlzKTtcbiAgICAgICAgICAgIF90aGlzLnN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuX2RlZmVycmVkLnJlc29sdmUoX3RoaXMudG8oKSk7XG4gICAgICAgICAgICBydW5BbGxIb29rcyhnZXRIb29rc0ZvcihpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1BoYXNlLlNVQ0NFU1MpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25FcnJvciA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VFcnJvcihyZWFzb24sIF90aGlzKTtcbiAgICAgICAgICAgIF90aGlzLnN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLl9kZWZlcnJlZC5yZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgIF90aGlzLl9lcnJvciA9IHJlYXNvbjtcbiAgICAgICAgICAgIHJ1bkFsbEhvb2tzKGdldEhvb2tzRm9yKGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rUGhhc2UuRVJST1IpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJ1blRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBXYWl0IHRvIGJ1aWxkIHRoZSBSVU4gaG9vayBjaGFpbiB1bnRpbCB0aGUgQkVGT1JFIGhvb2tzIGFyZSBkb25lXG4gICAgICAgICAgICAvLyBUaGlzIGFsbG93cyBhIEJFRk9SRSBob29rIHRvIGR5bmFtaWNhbGx5IGFkZCBhZGRpdGlvbmFsIFJVTiBob29rcyB2aWEgdGhlIFRyYW5zaXRpb24gb2JqZWN0LlxuICAgICAgICAgICAgdmFyIGFsbFJ1bkhvb2tzID0gZ2V0SG9va3NGb3IoaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5SVU4pO1xuICAgICAgICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS53aGVuKHVuZGVmaW5lZCk7IH07XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNpdGlvbkhvb2tfMS5UcmFuc2l0aW9uSG9vay5pbnZva2VIb29rcyhhbGxSdW5Ib29rcywgZG9uZSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdGFydFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZ2xvYmFscyA9IF90aGlzLnJvdXRlci5nbG9iYWxzO1xuICAgICAgICAgICAgZ2xvYmFscy5sYXN0U3RhcnRlZFRyYW5zaXRpb25JZCA9IF90aGlzLiRpZDtcbiAgICAgICAgICAgIGdsb2JhbHMudHJhbnNpdGlvbiA9IF90aGlzO1xuICAgICAgICAgICAgZ2xvYmFscy50cmFuc2l0aW9uSGlzdG9yeS5lbnF1ZXVlKF90aGlzKTtcbiAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VUcmFuc2l0aW9uU3RhcnQoX3RoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4odW5kZWZpbmVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFsbEJlZm9yZUhvb2tzID0gZ2V0SG9va3NGb3IoaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5CRUZPUkUpO1xuICAgICAgICB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rLmludm9rZUhvb2tzKGFsbEJlZm9yZUhvb2tzLCBzdGFydFRyYW5zaXRpb24pXG4gICAgICAgICAgICAudGhlbihydW5UcmFuc2l0aW9uKVxuICAgICAgICAgICAgLnRoZW4odHJhbnNpdGlvblN1Y2Nlc3MsIHRyYW5zaXRpb25FcnJvcik7XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIFRyYW5zaXRpb24gaXMgdmFsaWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFRyYW5zaXRpb24gaXMgdmFsaWRcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS52YWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmVycm9yKCkgfHwgdGhpcy5zdWNjZXNzICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBYm9ydHMgdGhpcyB0cmFuc2l0aW9uXG4gICAgICpcbiAgICAgKiBJbXBlcmF0aXZlIEFQSSB0byBhYm9ydCBhIFRyYW5zaXRpb24uXG4gICAgICogVGhpcyBvbmx5IGFwcGxpZXMgdG8gVHJhbnNpdGlvbnMgdGhhdCBhcmUgbm90IHlldCBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRG8gbm90IHNldCBmbGFnIGlmIHRoZSB0cmFuc2l0aW9uIGlzIGFscmVhZHkgY29tcGxldGVcbiAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1VuZGVmaW5lZCh0aGlzLnN1Y2Nlc3MpKSB7XG4gICAgICAgICAgICB0aGlzLl9hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIFRyYW5zaXRpb24gZXJyb3IgcmVhc29uLlxuICAgICAqXG4gICAgICogSWYgdGhlIHRyYW5zaXRpb24gaXMgaW52YWxpZCAoYW5kIGNvdWxkIG5vdCBiZSBydW4pLCByZXR1cm5zIHRoZSByZWFzb24gdGhlIHRyYW5zaXRpb24gaXMgaW52YWxpZC5cbiAgICAgKiBJZiB0aGUgdHJhbnNpdGlvbiB3YXMgdmFsaWQgYW5kIHJhbiwgYnV0IHdhcyBub3Qgc3VjY2Vzc2Z1bCwgcmV0dXJucyB0aGUgcmVhc29uIHRoZSB0cmFuc2l0aW9uIGZhaWxlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGFuIGVycm9yIG1lc3NhZ2UgZXhwbGFpbmluZyB3aHkgdGhlIHRyYW5zaXRpb24gaXMgaW52YWxpZCwgb3IgdGhlIHJlYXNvbiB0aGUgdHJhbnNpdGlvbiBmYWlsZWQuXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuJHRvKCk7XG4gICAgICAgIGlmIChzdGF0ZS5zZWxmLmFic3RyYWN0KVxuICAgICAgICAgICAgcmV0dXJuIFwiQ2Fubm90IHRyYW5zaXRpb24gdG8gYWJzdHJhY3Qgc3RhdGUgJ1wiICsgc3RhdGUubmFtZSArIFwiJ1wiO1xuICAgICAgICB2YXIgcGFyYW1EZWZzID0gc3RhdGUucGFyYW1ldGVycygpLCB2YWx1ZXMgPSB0aGlzLnBhcmFtcygpO1xuICAgICAgICB2YXIgaW52YWxpZFBhcmFtcyA9IHBhcmFtRGVmcy5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiAhcGFyYW0udmFsaWRhdGVzKHZhbHVlc1twYXJhbS5pZF0pOyB9KTtcbiAgICAgICAgaWYgKGludmFsaWRQYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJQYXJhbSB2YWx1ZXMgbm90IHZhbGlkIGZvciBzdGF0ZSAnXCIgKyBzdGF0ZS5uYW1lICsgXCInLiBJbnZhbGlkIHBhcmFtczogWyBcIiArIGludmFsaWRQYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0uaWQ7IH0pLmpvaW4oJywgJykgKyBcIiBdXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3VjY2VzcyA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVHJhbnNpdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFRyYW5zaXRpb25cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZyb21TdGF0ZU9yTmFtZSA9IHRoaXMuZnJvbSgpO1xuICAgICAgICB2YXIgdG9TdGF0ZU9yTmFtZSA9IHRoaXMudG8oKTtcbiAgICAgICAgdmFyIGF2b2lkRW1wdHlIYXNoID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIChwYXJhbXNbXCIjXCJdICE9PSBudWxsICYmIHBhcmFtc1tcIiNcIl0gIT09IHVuZGVmaW5lZCkgPyBwYXJhbXMgOiBjb21tb25fMS5vbWl0KHBhcmFtcywgW1wiI1wiXSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIChYKSBtZWFucyB0aGUgdG8gc3RhdGUgaXMgaW52YWxpZC5cbiAgICAgICAgdmFyIGlkID0gdGhpcy4kaWQsIGZyb20gPSBwcmVkaWNhdGVzXzEuaXNPYmplY3QoZnJvbVN0YXRlT3JOYW1lKSA/IGZyb21TdGF0ZU9yTmFtZS5uYW1lIDogZnJvbVN0YXRlT3JOYW1lLCBmcm9tUGFyYW1zID0gc3RyaW5nc18xLnN0cmluZ2lmeShhdm9pZEVtcHR5SGFzaCh0aGlzLl90cmVlQ2hhbmdlcy5mcm9tLm1hcChob2ZfMS5wcm9wKCdwYXJhbVZhbHVlcycpKS5yZWR1Y2UoY29tbW9uXzEubWVyZ2VSLCB7fSkpKSwgdG9WYWxpZCA9IHRoaXMudmFsaWQoKSA/IFwiXCIgOiBcIihYKSBcIiwgdG8gPSBwcmVkaWNhdGVzXzEuaXNPYmplY3QodG9TdGF0ZU9yTmFtZSkgPyB0b1N0YXRlT3JOYW1lLm5hbWUgOiB0b1N0YXRlT3JOYW1lLCB0b1BhcmFtcyA9IHN0cmluZ3NfMS5zdHJpbmdpZnkoYXZvaWRFbXB0eUhhc2godGhpcy5wYXJhbXMoKSkpO1xuICAgICAgICByZXR1cm4gXCJUcmFuc2l0aW9uI1wiICsgaWQgKyBcIiggJ1wiICsgZnJvbSArIFwiJ1wiICsgZnJvbVBhcmFtcyArIFwiIC0+IFwiICsgdG9WYWxpZCArIFwiJ1wiICsgdG8gKyBcIidcIiArIHRvUGFyYW1zICsgXCIgKVwiO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUcmFuc2l0aW9uLmRpVG9rZW4gPSBUcmFuc2l0aW9uO1xuICAgIHJldHVybiBUcmFuc2l0aW9uO1xufSgpKTtcbmV4cG9ydHMuVHJhbnNpdGlvbiA9IFRyYW5zaXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2l0aW9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL3RyYW5zaXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuLyoqIEBtb2R1bGUgcGF0aCAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgdGFyZ2V0U3RhdGVfMSA9IHJlcXVpcmUoXCIuLi9zdGF0ZS90YXJnZXRTdGF0ZVwiKTtcbnZhciBwYXRoTm9kZV8xID0gcmVxdWlyZShcIi4vcGF0aE5vZGVcIik7XG4vKipcbiAqIFRoaXMgY2xhc3MgY29udGFpbnMgZnVuY3Rpb25zIHdoaWNoIGNvbnZlcnQgVGFyZ2V0U3RhdGVzLCBOb2RlcyBhbmQgcGF0aHMgZnJvbSBvbmUgdHlwZSB0byBhbm90aGVyLlxuICovXG52YXIgUGF0aFV0aWxzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhdGhVdGlscygpIHtcbiAgICB9XG4gICAgLyoqIEdpdmVuIGEgUGF0aE5vZGVbXSwgY3JlYXRlIGFuIFRhcmdldFN0YXRlICovXG4gICAgUGF0aFV0aWxzLm1ha2VUYXJnZXRTdGF0ZSA9IGZ1bmN0aW9uIChyZWdpc3RyeSwgcGF0aCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBjb21tb25fMS50YWlsKHBhdGgpLnN0YXRlO1xuICAgICAgICByZXR1cm4gbmV3IHRhcmdldFN0YXRlXzEuVGFyZ2V0U3RhdGUocmVnaXN0cnksIHN0YXRlLCBwYXRoLm1hcChob2ZfMS5wcm9wKFwicGFyYW1WYWx1ZXNcIikpLnJlZHVjZShjb21tb25fMS5tZXJnZVIsIHt9KSwge30pO1xuICAgIH07XG4gICAgUGF0aFV0aWxzLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uICh0YXJnZXRTdGF0ZSkge1xuICAgICAgICB2YXIgdG9QYXJhbXMgPSB0YXJnZXRTdGF0ZS5wYXJhbXMoKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFN0YXRlLiRzdGF0ZSgpLnBhdGgubWFwKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gbmV3IHBhdGhOb2RlXzEuUGF0aE5vZGUoc3RhdGUpLmFwcGx5UmF3UGFyYW1zKHRvUGFyYW1zKTsgfSk7XG4gICAgfTtcbiAgICAvKiogR2l2ZW4gYSBmcm9tUGF0aDogUGF0aE5vZGVbXSBhbmQgYSBUYXJnZXRTdGF0ZSwgYnVpbGRzIGEgdG9QYXRoOiBQYXRoTm9kZVtdICovXG4gICAgUGF0aFV0aWxzLmJ1aWxkVG9QYXRoID0gZnVuY3Rpb24gKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSkge1xuICAgICAgICB2YXIgdG9QYXRoID0gUGF0aFV0aWxzLmJ1aWxkUGF0aCh0YXJnZXRTdGF0ZSk7XG4gICAgICAgIGlmICh0YXJnZXRTdGF0ZS5vcHRpb25zKCkuaW5oZXJpdCkge1xuICAgICAgICAgICAgcmV0dXJuIFBhdGhVdGlscy5pbmhlcml0UGFyYW1zKGZyb21QYXRoLCB0b1BhdGgsIE9iamVjdC5rZXlzKHRhcmdldFN0YXRlLnBhcmFtcygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvUGF0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgVmlld0NvbmZpZyBvYmplY3RzIGFuZCBhZGRzIHRvIG5vZGVzLlxuICAgICAqXG4gICAgICogT24gZWFjaCBbW1BhdGhOb2RlXV0sIGNyZWF0ZXMgVmlld0NvbmZpZyBvYmplY3RzIGZyb20gdGhlIHZpZXdzOiBwcm9wZXJ0eSBvZiB0aGUgbm9kZSdzIHN0YXRlXG4gICAgICovXG4gICAgUGF0aFV0aWxzLmFwcGx5Vmlld0NvbmZpZ3MgPSBmdW5jdGlvbiAoJHZpZXcsIHBhdGgsIHN0YXRlcykge1xuICAgICAgICAvLyBPbmx5IGFwcGx5IHRoZSB2aWV3Q29uZmlncyB0byB0aGUgbm9kZXMgZm9yIHRoZSBnaXZlbiBzdGF0ZXNcbiAgICAgICAgcGF0aC5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGNvbW1vbl8xLmluQXJyYXkoc3RhdGVzLCBub2RlLnN0YXRlKTsgfSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHZpZXdEZWNscyA9IGNvbW1vbl8xLnZhbHVlcyhub2RlLnN0YXRlLnZpZXdzIHx8IHt9KTtcbiAgICAgICAgICAgIHZhciBzdWJQYXRoID0gUGF0aFV0aWxzLnN1YlBhdGgocGF0aCwgZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4gPT09IG5vZGU7IH0pO1xuICAgICAgICAgICAgdmFyIHZpZXdDb25maWdzID0gdmlld0RlY2xzLm1hcChmdW5jdGlvbiAodmlldykgeyByZXR1cm4gJHZpZXcuY3JlYXRlVmlld0NvbmZpZyhzdWJQYXRoLCB2aWV3KTsgfSk7XG4gICAgICAgICAgICBub2RlLnZpZXdzID0gdmlld0NvbmZpZ3MucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGZyb21QYXRoIGFuZCBhIHRvUGF0aCwgcmV0dXJucyBhIG5ldyB0byBwYXRoIHdoaWNoIGluaGVyaXRzIHBhcmFtZXRlcnMgZnJvbSB0aGUgZnJvbVBhdGhcbiAgICAgKlxuICAgICAqIEZvciBhIHBhcmFtZXRlciBpbiBhIG5vZGUgdG8gYmUgaW5oZXJpdGVkIGZyb20gdGhlIGZyb20gcGF0aDpcbiAgICAgKiAtIFRoZSB0b1BhdGgncyBub2RlIG11c3QgaGF2ZSBhIG1hdGNoaW5nIG5vZGUgaW4gdGhlIGZyb21QYXRoIChieSBzdGF0ZSkuXG4gICAgICogLSBUaGUgcGFyYW1ldGVyIG5hbWUgbXVzdCBub3QgYmUgZm91bmQgaW4gdGhlIHRvS2V5cyBwYXJhbWV0ZXIgYXJyYXkuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGUga2V5cyBwcm92aWRlZCBpbiB0b0tleXMgYXJlIGludGVuZGVkIHRvIGJlIHRob3NlIHBhcmFtIGtleXMgZXhwbGljaXRseSBzcGVjaWZpZWQgYnkgc29tZVxuICAgICAqIGNhbGxlciwgZm9yIGluc3RhbmNlLCAkc3RhdGUudHJhbnNpdGlvblRvKC4uLiwgdG9QYXJhbXMpLiAgSWYgYSBrZXkgd2FzIGZvdW5kIGluIHRvUGFyYW1zLFxuICAgICAqIGl0IGlzIG5vdCBpbmhlcml0ZWQgZnJvbSB0aGUgZnJvbVBhdGguXG4gICAgICovXG4gICAgUGF0aFV0aWxzLmluaGVyaXRQYXJhbXMgPSBmdW5jdGlvbiAoZnJvbVBhdGgsIHRvUGF0aCwgdG9LZXlzKSB7XG4gICAgICAgIGlmICh0b0tleXMgPT09IHZvaWQgMCkgeyB0b0tleXMgPSBbXTsgfVxuICAgICAgICBmdW5jdGlvbiBub2RlUGFyYW1WYWxzKHBhdGgsIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNvbW1vbl8xLmZpbmQocGF0aCwgaG9mXzEucHJvcEVxKCdzdGF0ZScsIHN0YXRlKSk7XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKHt9LCBub2RlICYmIG5vZGUucGFyYW1WYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub0luaGVyaXQgPSBmcm9tUGF0aC5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUucGFyYW1TY2hlbWE7IH0pXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuICFwYXJhbS5pbmhlcml0OyB9KVxuICAgICAgICAgICAgLm1hcChob2ZfMS5wcm9wKCdpZCcpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGFuIFtbUGF0aE5vZGVdXSBcInRvTm9kZVwiLCByZXR1cm4gYSBuZXcgW1tQYXRoTm9kZV1dIHdpdGggcGFyYW0gdmFsdWVzIGluaGVyaXRlZCBmcm9tIHRoZVxuICAgICAgICAgKiBtYXRjaGluZyBub2RlIGluIGZyb21QYXRoLiAgT25seSBpbmhlcml0IGtleXMgdGhhdCBhcmVuJ3QgZm91bmQgaW4gXCJ0b0tleXNcIiBmcm9tIHRoZSBub2RlIGluIFwiZnJvbVBhdGhcIlwiXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBtYWtlSW5oZXJpdGVkUGFyYW1zTm9kZSh0b05vZGUpIHtcbiAgICAgICAgICAgIC8vIEFsbCBwYXJhbSB2YWx1ZXMgZm9yIHRoZSBub2RlIChtYXkgaW5jbHVkZSBkZWZhdWx0IGtleS92YWxzLCB3aGVuIGtleSB3YXMgbm90IGZvdW5kIGluIHRvUGFyYW1zKVxuICAgICAgICAgICAgdmFyIHRvUGFyYW1WYWxzID0gY29tbW9uXzEuZXh0ZW5kKHt9LCB0b05vZGUgJiYgdG9Ob2RlLnBhcmFtVmFsdWVzKTtcbiAgICAgICAgICAgIC8vIGxpbWl0ZWQgdG8gb25seSB0aG9zZSBrZXlzIGZvdW5kIGluIHRvUGFyYW1zXG4gICAgICAgICAgICB2YXIgaW5jb21pbmdQYXJhbVZhbHMgPSBjb21tb25fMS5waWNrKHRvUGFyYW1WYWxzLCB0b0tleXMpO1xuICAgICAgICAgICAgdG9QYXJhbVZhbHMgPSBjb21tb25fMS5vbWl0KHRvUGFyYW1WYWxzLCB0b0tleXMpO1xuICAgICAgICAgICAgdmFyIGZyb21QYXJhbVZhbHMgPSBjb21tb25fMS5vbWl0KG5vZGVQYXJhbVZhbHMoZnJvbVBhdGgsIHRvTm9kZS5zdGF0ZSkgfHwge30sIG5vSW5oZXJpdCk7XG4gICAgICAgICAgICAvLyBleHRlbmQgdG9QYXJhbVZhbHMgd2l0aCBhbnkgZnJvbVBhcmFtVmFscywgdGhlbiBvdmVycmlkZSBhbnkgb2YgdGhvc2UgdGhvc2Ugd2l0aCBpbmNvbWluZ1BhcmFtVmFsc1xuICAgICAgICAgICAgdmFyIG93blBhcmFtVmFscyA9IGNvbW1vbl8xLmV4dGVuZCh0b1BhcmFtVmFscywgZnJvbVBhcmFtVmFscywgaW5jb21pbmdQYXJhbVZhbHMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwYXRoTm9kZV8xLlBhdGhOb2RlKHRvTm9kZS5zdGF0ZSkuYXBwbHlSYXdQYXJhbXMob3duUGFyYW1WYWxzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgcGFyYW0ga2V5cyBzcGVjaWZpZWQgYnkgdGhlIGluY29taW5nIHRvUGFyYW1zXG4gICAgICAgIHJldHVybiB0b1BhdGgubWFwKG1ha2VJbmhlcml0ZWRQYXJhbXNOb2RlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSB0cmVlIGNoYW5nZXMgKGVudGVyaW5nLCBleGl0aW5nKSBiZXR3ZWVuIGEgZnJvbVBhdGggYW5kIHRvUGF0aC5cbiAgICAgKi9cbiAgICBQYXRoVXRpbHMudHJlZUNoYW5nZXMgPSBmdW5jdGlvbiAoZnJvbVBhdGgsIHRvUGF0aCwgcmVsb2FkU3RhdGUpIHtcbiAgICAgICAgdmFyIGtlZXAgPSAwLCBtYXggPSBNYXRoLm1pbihmcm9tUGF0aC5sZW5ndGgsIHRvUGF0aC5sZW5ndGgpO1xuICAgICAgICB2YXIgbm9kZXNNYXRjaCA9IGZ1bmN0aW9uIChub2RlMSwgbm9kZTIpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlMS5lcXVhbHMobm9kZTIsIFBhdGhVdGlscy5ub25EeW5hbWljUGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBtYXggJiYgZnJvbVBhdGhba2VlcF0uc3RhdGUgIT09IHJlbG9hZFN0YXRlICYmIG5vZGVzTWF0Y2goZnJvbVBhdGhba2VlcF0sIHRvUGF0aFtrZWVwXSkpIHtcbiAgICAgICAgICAgIGtlZXArKztcbiAgICAgICAgfVxuICAgICAgICAvKiogR2l2ZW4gYSByZXRhaW5lZCBub2RlLCByZXR1cm4gYSBuZXcgbm9kZSB3aGljaCB1c2VzIHRoZSB0byBub2RlJ3MgcGFyYW0gdmFsdWVzICovXG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5VG9QYXJhbXMocmV0YWluZWROb2RlLCBpZHgpIHtcbiAgICAgICAgICAgIHZhciBjbG9uZWQgPSBwYXRoTm9kZV8xLlBhdGhOb2RlLmNsb25lKHJldGFpbmVkTm9kZSk7XG4gICAgICAgICAgICBjbG9uZWQucGFyYW1WYWx1ZXMgPSB0b1BhdGhbaWR4XS5wYXJhbVZhbHVlcztcbiAgICAgICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyb20sIHJldGFpbmVkLCBleGl0aW5nLCBlbnRlcmluZywgdG87XG4gICAgICAgIGZyb20gPSBmcm9tUGF0aDtcbiAgICAgICAgcmV0YWluZWQgPSBmcm9tLnNsaWNlKDAsIGtlZXApO1xuICAgICAgICBleGl0aW5nID0gZnJvbS5zbGljZShrZWVwKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHJldGFpbmVkIHBhdGggKHdpdGggc2hhbGxvdyBjb3BpZXMgb2Ygbm9kZXMpIHdoaWNoIGhhdmUgdGhlIHBhcmFtcyBvZiB0aGUgdG9QYXRoIG1hcHBlZFxuICAgICAgICB2YXIgcmV0YWluZWRXaXRoVG9QYXJhbXMgPSByZXRhaW5lZC5tYXAoYXBwbHlUb1BhcmFtcyk7XG4gICAgICAgIGVudGVyaW5nID0gdG9QYXRoLnNsaWNlKGtlZXApO1xuICAgICAgICB0byA9IChyZXRhaW5lZFdpdGhUb1BhcmFtcykuY29uY2F0KGVudGVyaW5nKTtcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogZnJvbSwgdG86IHRvLCByZXRhaW5lZDogcmV0YWluZWQsIGV4aXRpbmc6IGV4aXRpbmcsIGVudGVyaW5nOiBlbnRlcmluZyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBwYXRoIHdoaWNoIGlzOiB0aGUgc3VicGF0aCBvZiB0aGUgZmlyc3QgcGF0aCB3aGljaCBtYXRjaGVzIHRoZSBzZWNvbmQgcGF0aC5cbiAgICAgKlxuICAgICAqIFRoZSBuZXcgcGF0aCBzdGFydHMgZnJvbSByb290IGFuZCBjb250YWlucyBhbnkgbm9kZXMgdGhhdCBtYXRjaCB0aGUgbm9kZXMgaW4gdGhlIHNlY29uZCBwYXRoLlxuICAgICAqIEl0IHN0b3BzIGJlZm9yZSB0aGUgZmlyc3Qgbm9uLW1hdGNoaW5nIG5vZGUuXG4gICAgICpcbiAgICAgKiBOb2RlcyBhcmUgY29tcGFyZWQgdXNpbmcgdGhlaXIgc3RhdGUgcHJvcGVydHkgYW5kIHRoZWlyIHBhcmFtZXRlciB2YWx1ZXMuXG4gICAgICogSWYgYSBgcGFyYW1zRm5gIGlzIHByb3ZpZGVkLCBvbmx5IHRoZSBbW1BhcmFtXV0gcmV0dXJuZWQgYnkgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgY29uc2lkZXJlZCB3aGVuIGNvbXBhcmluZyBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoQSB0aGUgZmlyc3QgcGF0aFxuICAgICAqIEBwYXJhbSBwYXRoQiB0aGUgc2Vjb25kIHBhdGhcbiAgICAgKiBAcGFyYW0gcGFyYW1zRm4gYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnNpZGVyIHdoZW4gY29tcGFyaW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBQYXRoTm9kZXMgZnJvbSB0aGUgZmlyc3QgcGF0aCB3aGljaCBtYXRjaCB0aGUgbm9kZXMgaW4gdGhlIHNlY29uZCBwYXRoXG4gICAgICovXG4gICAgUGF0aFV0aWxzLm1hdGNoaW5nID0gZnVuY3Rpb24gKHBhdGhBLCBwYXRoQiwgcGFyYW1zRm4pIHtcbiAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIHR1cGxlcyA9IGNvbW1vbl8xLmFycmF5VHVwbGVzKHBhdGhBLCBwYXRoQik7XG4gICAgICAgIHJldHVybiB0dXBsZXMucmVkdWNlKGZ1bmN0aW9uIChtYXRjaGluZywgX2EpIHtcbiAgICAgICAgICAgIHZhciBub2RlQSA9IF9hWzBdLCBub2RlQiA9IF9hWzFdO1xuICAgICAgICAgICAgZG9uZSA9IGRvbmUgfHwgIW5vZGVBLmVxdWFscyhub2RlQiwgcGFyYW1zRm4pO1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUgPyBtYXRjaGluZyA6IG1hdGNoaW5nLmNvbmNhdChub2RlQSk7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0d28gcGF0aHMgYXJlIGlkZW50aWNhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoQVxuICAgICAqIEBwYXJhbSBwYXRoQlxuICAgICAqIEBwYXJhbSBwYXJhbXNGbiBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlIHBhcmFtZXRlcnMgdG8gY29uc2lkZXIgd2hlbiBjb21wYXJpbmdcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB0aGUgc3RhdGVzIGFuZCBwYXJhbWV0ZXIgdmFsdWVzIGZvciBib3RoIHBhdGhzIGFyZSBpZGVudGljYWxcbiAgICAgKi9cbiAgICBQYXRoVXRpbHMuZXF1YWxzID0gZnVuY3Rpb24gKHBhdGhBLCBwYXRoQiwgcGFyYW1zRm4pIHtcbiAgICAgICAgcmV0dXJuIHBhdGhBLmxlbmd0aCA9PT0gcGF0aEIubGVuZ3RoICYmXG4gICAgICAgICAgICBQYXRoVXRpbHMubWF0Y2hpbmcocGF0aEEsIHBhdGhCLCBwYXJhbXNGbikubGVuZ3RoID09PSBwYXRoQS5sZW5ndGg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBzdWJwYXRoIG9mIGEgcGF0aCwgd2hpY2ggc3RvcHMgYXQgdGhlIGZpcnN0IG1hdGNoaW5nIG5vZGVcbiAgICAgKlxuICAgICAqIEdpdmVuIGFuIGFycmF5IG9mIG5vZGVzLCByZXR1cm5zIGEgc3Vic2V0IG9mIHRoZSBhcnJheSBzdGFydGluZyBmcm9tIHRoZSBmaXJzdCBub2RlLFxuICAgICAqIHN0b3BwaW5nIHdoZW4gdGhlIGZpcnN0IG5vZGUgbWF0Y2hlcyB0aGUgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggYSBwYXRoIG9mIFtbUGF0aE5vZGVdXXNcbiAgICAgKiBAcGFyYW0gcHJlZGljYXRlIGEgW1tQcmVkaWNhdGVdXSBmbiB0aGF0IG1hdGNoZXMgW1tQYXRoTm9kZV1dc1xuICAgICAqIEByZXR1cm5zIGEgc3VicGF0aCB1cCB0byB0aGUgbWF0Y2hpbmcgbm9kZSwgb3IgdW5kZWZpbmVkIGlmIG5vIG1hdGNoIGlzIGZvdW5kXG4gICAgICovXG4gICAgUGF0aFV0aWxzLnN1YlBhdGggPSBmdW5jdGlvbiAocGF0aCwgcHJlZGljYXRlKSB7XG4gICAgICAgIHZhciBub2RlID0gY29tbW9uXzEuZmluZChwYXRoLCBwcmVkaWNhdGUpO1xuICAgICAgICB2YXIgZWxlbWVudElkeCA9IHBhdGguaW5kZXhPZihub2RlKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRJZHggPT09IC0xID8gdW5kZWZpbmVkIDogcGF0aC5zbGljZSgwLCBlbGVtZW50SWR4ICsgMSk7XG4gICAgfTtcbiAgICBQYXRoVXRpbHMubm9uRHluYW1pY1BhcmFtcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLnN0YXRlLnBhcmFtZXRlcnMoeyBpbmhlcml0OiBmYWxzZSB9KVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuICFwYXJhbS5keW5hbWljOyB9KTtcbiAgICB9O1xuICAgIC8qKiBHZXRzIHRoZSByYXcgcGFyYW1ldGVyIHZhbHVlcyBmcm9tIGEgcGF0aCAqL1xuICAgIFBhdGhVdGlscy5wYXJhbVZhbHVlcyA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHJldHVybiBwYXRoLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBub2RlKSB7IHJldHVybiBjb21tb25fMS5leHRlbmQoYWNjLCBub2RlLnBhcmFtVmFsdWVzKTsgfSwge30pO1xuICAgIH07XG4gICAgcmV0dXJuIFBhdGhVdGlscztcbn0oKSk7XG5leHBvcnRzLlBhdGhVdGlscyA9IFBhdGhVdGlscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGhGYWN0b3J5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9wYXRoL3BhdGhGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIHJlc29sdmUgKi9cbi8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciB0cmFjZV8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi90cmFjZVwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIGludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpO1xudmFyIHJlc29sdmFibGVfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmFibGVcIik7XG52YXIgcGF0aEZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuLi9wYXRoL3BhdGhGYWN0b3J5XCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc3RyaW5nc1wiKTtcbnZhciBjb21tb25fMiA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG52YXIgd2hlbnMgPSBpbnRlcmZhY2VfMS5yZXNvbHZlUG9saWNpZXMud2hlbjtcbnZhciBBTExfV0hFTlMgPSBbd2hlbnMuRUFHRVIsIHdoZW5zLkxBWlldO1xudmFyIEVBR0VSX1dIRU5TID0gW3doZW5zLkVBR0VSXTtcbmV4cG9ydHMuTkFUSVZFX0lOSkVDVE9SX1RPS0VOID0gXCJOYXRpdmUgSW5qZWN0b3JcIjtcbi8qKlxuICogRW5jYXBzdWxhdGVzIERlcGVuZGVuY3kgSW5qZWN0aW9uIGZvciBhIHBhdGggb2Ygbm9kZXNcbiAqXG4gKiBVSS1Sb3V0ZXIgc3RhdGVzIGFyZSBvcmdhbml6ZWQgYXMgYSB0cmVlLlxuICogQSBuZXN0ZWQgc3RhdGUgaGFzIGEgcGF0aCBvZiBhbmNlc3RvcnMgdG8gdGhlIHJvb3Qgb2YgdGhlIHRyZWUuXG4gKiBXaGVuIGEgc3RhdGUgaXMgYmVpbmcgYWN0aXZhdGVkLCBlYWNoIGVsZW1lbnQgaW4gdGhlIHBhdGggaXMgd3JhcHBlZCBhcyBhIFtbUGF0aE5vZGVdXS5cbiAqIEEgYFBhdGhOb2RlYCBpcyBhIHN0YXRlZnVsIG9iamVjdCB0aGF0IGhvbGRzIHRoaW5ncyBsaWtlIHBhcmFtZXRlcnMgYW5kIHJlc29sdmFibGVzIGZvciB0aGUgc3RhdGUgYmVpbmcgYWN0aXZhdGVkLlxuICpcbiAqIFRoZSBSZXNvbHZlQ29udGV4dCBjbG9zZXMgb3ZlciB0aGUgW1tQYXRoTm9kZV1dcywgYW5kIHByb3ZpZGVzIERJIGZvciB0aGUgbGFzdCBub2RlIGluIHRoZSBwYXRoLlxuICovXG52YXIgUmVzb2x2ZUNvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzb2x2ZUNvbnRleHQoX3BhdGgpIHtcbiAgICAgICAgdGhpcy5fcGF0aCA9IF9wYXRoO1xuICAgIH1cbiAgICAvKiogR2V0cyBhbGwgdGhlIHRva2VucyBmb3VuZCBpbiB0aGUgcmVzb2x2ZSBjb250ZXh0LCBkZS1kdXBsaWNhdGVkICovXG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmdldFRva2VucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdGgucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG5vZGUpIHsgcmV0dXJuIGFjYy5jb25jYXQobm9kZS5yZXNvbHZhYmxlcy5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIudG9rZW47IH0pKTsgfSwgW10pLnJlZHVjZShjb21tb25fMS51bmlxUiwgW10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgUmVzb2x2YWJsZSB0aGF0IG1hdGNoZXMgdGhlIHRva2VuXG4gICAgICpcbiAgICAgKiBHZXRzIHRoZSBsYXN0IFJlc29sdmFibGUgdGhhdCBtYXRjaGVzIHRoZSB0b2tlbiBpbiB0aGlzIGNvbnRleHQsIG9yIHVuZGVmaW5lZC5cbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgZG9lc24ndCBleGlzdCBpbiB0aGUgUmVzb2x2ZUNvbnRleHRcbiAgICAgKi9cbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUuZ2V0UmVzb2x2YWJsZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgbWF0Y2hpbmcgPSB0aGlzLl9wYXRoLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5yZXNvbHZhYmxlczsgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnRva2VuID09PSB0b2tlbjsgfSk7XG4gICAgICAgIHJldHVybiBjb21tb25fMS50YWlsKG1hdGNoaW5nKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHRoZSBbW1Jlc29sdmVQb2xpY3ldXSBmb3IgdGhlIGdpdmVuIFtbUmVzb2x2YWJsZV1dICovXG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmdldFBvbGljeSA9IGZ1bmN0aW9uIChyZXNvbHZhYmxlKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5maW5kTm9kZShyZXNvbHZhYmxlKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmFibGUuZ2V0UG9saWN5KG5vZGUuc3RhdGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFJlc29sdmVDb250ZXh0IHRoYXQgaW5jbHVkZXMgYSBwb3J0aW9uIG9mIHRoaXMgb25lXG4gICAgICpcbiAgICAgKiBHaXZlbiBhIHN0YXRlLCB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IFJlc29sdmVDb250ZXh0IGZyb20gdGhpcyBvbmUuXG4gICAgICogVGhlIG5ldyBjb250ZXh0IHN0YXJ0cyBhdCB0aGUgZmlyc3Qgbm9kZSAocm9vdCkgYW5kIHN0b3BzIGF0IHRoZSBub2RlIGZvciB0aGUgYHN0YXRlYCBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiAjIyMjIFdoeVxuICAgICAqXG4gICAgICogV2hlbiBhIHRyYW5zaXRpb24gaXMgY3JlYXRlZCwgdGhlIG5vZGVzIGluIHRoZSBcIlRvIFBhdGhcIiBhcmUgaW5qZWN0ZWQgZnJvbSBhIFJlc29sdmVDb250ZXh0LlxuICAgICAqIEEgUmVzb2x2ZUNvbnRleHQgY2xvc2VzIG92ZXIgYSBwYXRoIG9mIFtbUGF0aE5vZGVdXXMgYW5kIHByb2Nlc3NlcyB0aGUgcmVzb2x2YWJsZXMuXG4gICAgICogVGhlIFwiVG8gU3RhdGVcIiBjYW4gaW5qZWN0IHZhbHVlcyBmcm9tIGl0cyBvd24gcmVzb2x2YWJsZXMsIGFzIHdlbGwgYXMgdGhvc2UgZnJvbSBhbGwgaXRzIGFuY2VzdG9yIHN0YXRlJ3MgKG5vZGUncykuXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBjcmVhdGUgYSBuYXJyb3dlciBjb250ZXh0IHdoZW4gaW5qZWN0aW5nIGFuY2VzdG9yIG5vZGVzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgbGV0IEFCQ0QgPSBuZXcgUmVzb2x2ZUNvbnRleHQoW0EsIEIsIEMsIERdKTtgXG4gICAgICpcbiAgICAgKiBHaXZlbiBhIHBhdGggYFtBLCBCLCBDLCBEXWAsIHdoZXJlIGBBYCwgYEJgLCBgQ2AgYW5kIGBEYCBhcmUgbm9kZXMgZm9yIHN0YXRlcyBgYWAsIGBiYCwgYGNgLCBgZGA6XG4gICAgICogV2hlbiBpbmplY3RpbmcgYERgLCBgRGAgc2hvdWxkIGhhdmUgYWNjZXNzIHRvIGFsbCByZXNvbHZhYmxlcyBmcm9tIGBBYCwgYEJgLCBgQ2AsIGBEYC5cbiAgICAgKiBIb3dldmVyLCBgQmAgc2hvdWxkIG9ubHkgYmUgYWJsZSB0byBhY2Nlc3MgcmVzb2x2YWJsZXMgZnJvbSBgQWAsIGBCYC5cbiAgICAgKlxuICAgICAqIFdoZW4gcmVzb2x2aW5nIGZvciB0aGUgYEJgIG5vZGUsIGZpcnN0IHRha2UgdGhlIGZ1bGwgXCJUbyBQYXRoXCIgQ29udGV4dCBgW0EsQixDLERdYCBhbmQgbGltaXQgdG8gdGhlIHN1YnBhdGggYFtBLEJdYC5cbiAgICAgKiBgbGV0IEFCID0gQUJDRC5zdWJjb250ZXh0KGEpYFxuICAgICAqL1xuICAgIFJlc29sdmVDb250ZXh0LnByb3RvdHlwZS5zdWJDb250ZXh0ID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZUNvbnRleHQocGF0aEZhY3RvcnlfMS5QYXRoVXRpbHMuc3ViUGF0aCh0aGlzLl9wYXRoLCBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5zdGF0ZSA9PT0gc3RhdGU7IH0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgUmVzb2x2YWJsZXMgdG8gdGhlIG5vZGUgdGhhdCBtYXRjaGVzIHRoZSBzdGF0ZVxuICAgICAqXG4gICAgICogVGhpcyBhZGRzIGEgW1tSZXNvbHZhYmxlXV0gKGdlbmVyYWxseSBvbmUgY3JlYXRlZCBvbiB0aGUgZmx5OyBub3QgZGVjbGFyZWQgb24gYSBbW1N0YXRlRGVjbGFyYXRpb24ucmVzb2x2ZV1dIGJsb2NrKS5cbiAgICAgKiBUaGUgcmVzb2x2YWJsZSBpcyBhZGRlZCB0byB0aGUgbm9kZSBtYXRjaGluZyB0aGUgYHN0YXRlYCBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBUaGVzZSBuZXcgcmVzb2x2YWJsZXMgYXJlIG5vdCBhdXRvbWF0aWNhbGx5IGZldGNoZWQuXG4gICAgICogVGhlIGNhbGxpbmcgY29kZSBzaG91bGQgZWl0aGVyIGZldGNoIHRoZW0sIGZldGNoIHNvbWV0aGluZyB0aGF0IGRlcGVuZHMgb24gdGhlbSxcbiAgICAgKiBvciByZWx5IG9uIFtbcmVzb2x2ZVBhdGhdXSBiZWluZyBjYWxsZWQgd2hlbiBzb21lIHN0YXRlIGlzIGJlaW5nIGVudGVyZWQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBlYWNoIHJlc29sdmFibGUncyBbW1Jlc29sdmVQb2xpY3ldXSBpcyBtZXJnZWQgd2l0aCB0aGUgc3RhdGUncyBwb2xpY3ksIGFuZCB0aGUgZ2xvYmFsIGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV3UmVzb2x2YWJsZXMgdGhlIG5ldyBSZXNvbHZhYmxlc1xuICAgICAqIEBwYXJhbSBzdGF0ZSBVc2VkIHRvIGZpbmQgdGhlIG5vZGUgdG8gcHV0IHRoZSByZXNvbHZhYmxlIG9uXG4gICAgICovXG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmFkZFJlc29sdmFibGVzID0gZnVuY3Rpb24gKG5ld1Jlc29sdmFibGVzLCBzdGF0ZSkge1xuICAgICAgICB2YXIgbm9kZSA9IGNvbW1vbl8xLmZpbmQodGhpcy5fcGF0aCwgaG9mXzEucHJvcEVxKCdzdGF0ZScsIHN0YXRlKSk7XG4gICAgICAgIHZhciBrZXlzID0gbmV3UmVzb2x2YWJsZXMubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnRva2VuOyB9KTtcbiAgICAgICAgbm9kZS5yZXNvbHZhYmxlcyA9IG5vZGUucmVzb2x2YWJsZXMuZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBrZXlzLmluZGV4T2Yoci50b2tlbikgPT09IC0xOyB9KS5jb25jYXQobmV3UmVzb2x2YWJsZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHJlc29sdmVkIHBhdGggRWxlbWVudCBwcm9taXNlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHdoZW5cbiAgICAgKiBAcGFyYW0gdHJhbnNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fGFueX1cbiAgICAgKi9cbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUucmVzb2x2ZVBhdGggPSBmdW5jdGlvbiAod2hlbiwgdHJhbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHdoZW4gPT09IHZvaWQgMCkgeyB3aGVuID0gXCJMQVpZXCI7IH1cbiAgICAgICAgLy8gVGhpcyBvcHRpb24gZGV0ZXJtaW5lcyB3aGljaCAnd2hlbicgcG9saWN5IFJlc29sdmFibGVzIHdlIGFyZSBhYm91dCB0byBmZXRjaC5cbiAgICAgICAgdmFyIHdoZW5PcHRpb24gPSBjb21tb25fMS5pbkFycmF5KEFMTF9XSEVOUywgd2hlbikgPyB3aGVuIDogXCJMQVpZXCI7XG4gICAgICAgIC8vIElmIHRoZSBjYWxsZXIgc3BlY2lmaWVkIEVBR0VSLCBvbmx5IHRoZSBFQUdFUiBSZXNvbHZhYmxlcyBhcmUgZmV0Y2hlZC5cbiAgICAgICAgLy8gaWYgdGhlIGNhbGxlciBzcGVjaWZpZWQgTEFaWSwgYm90aCBFQUdFUiBhbmQgTEFaWSBSZXNvbHZhYmxlcyBhcmUgZmV0Y2hlZC5gXG4gICAgICAgIHZhciBtYXRjaGVkV2hlbnMgPSB3aGVuT3B0aW9uID09PSBpbnRlcmZhY2VfMS5yZXNvbHZlUG9saWNpZXMud2hlbi5FQUdFUiA/IEVBR0VSX1dIRU5TIDogQUxMX1dIRU5TO1xuICAgICAgICAvLyBnZXQgdGhlIHN1YnBhdGggdG8gdGhlIHN0YXRlIGFyZ3VtZW50LCBpZiBwcm92aWRlZFxuICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlUmVzb2x2ZVBhdGgodGhpcy5fcGF0aCwgd2hlbiwgdHJhbnMpO1xuICAgICAgICB2YXIgbWF0Y2hlc1BvbGljeSA9IGZ1bmN0aW9uIChhY2NlcHRlZFZhbHMsIHdoZW5PckFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJlc29sdmFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuaW5BcnJheShhY2NlcHRlZFZhbHMsIF90aGlzLmdldFBvbGljeShyZXNvbHZhYmxlKVt3aGVuT3JBc3luY10pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVHJpZ2dlciBhbGwgdGhlIChtYXRjaGluZykgUmVzb2x2YWJsZXMgaW4gdGhlIHBhdGhcbiAgICAgICAgLy8gUmVkdWNlIGFsbCB0aGUgXCJXQUlUXCIgUmVzb2x2YWJsZXMgaW50byBhbiBhcnJheVxuICAgICAgICB2YXIgcHJvbWlzZXMgPSB0aGlzLl9wYXRoLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBub2RlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZVJlc29sdmFibGVzID0gbm9kZS5yZXNvbHZhYmxlcy5maWx0ZXIobWF0Y2hlc1BvbGljeShtYXRjaGVkV2hlbnMsICd3aGVuJykpO1xuICAgICAgICAgICAgdmFyIG5vd2FpdCA9IG5vZGVSZXNvbHZhYmxlcy5maWx0ZXIobWF0Y2hlc1BvbGljeShbJ05PV0FJVCddLCAnYXN5bmMnKSk7XG4gICAgICAgICAgICB2YXIgd2FpdCA9IG5vZGVSZXNvbHZhYmxlcy5maWx0ZXIoaG9mXzEubm90KG1hdGNoZXNQb2xpY3koWydOT1dBSVQnXSwgJ2FzeW5jJykpKTtcbiAgICAgICAgICAgIC8vIEZvciB0aGUgbWF0Y2hpbmcgUmVzb2x2YWJsZXMsIHN0YXJ0IHRoZWlyIGFzeW5jIGZldGNoIHByb2Nlc3MuXG4gICAgICAgICAgICB2YXIgc3ViQ29udGV4dCA9IF90aGlzLnN1YkNvbnRleHQobm9kZS5zdGF0ZSk7XG4gICAgICAgICAgICB2YXIgZ2V0UmVzdWx0ID0gZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIuZ2V0KHN1YkNvbnRleHQsIHRyYW5zKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gKHsgdG9rZW46IHIudG9rZW4sIHZhbHVlOiB2YWx1ZSB9KTsgfSk7IH07XG4gICAgICAgICAgICBub3dhaXQuZm9yRWFjaChnZXRSZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQod2FpdC5tYXAoZ2V0UmVzdWx0KSk7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgLy8gV2FpdCBmb3IgYWxsIHRoZSBcIldBSVRcIiByZXNvbHZhYmxlc1xuICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEuYWxsKHByb21pc2VzKTtcbiAgICB9O1xuICAgIFJlc29sdmVDb250ZXh0LnByb3RvdHlwZS5pbmplY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luamVjdG9yIHx8ICh0aGlzLl9pbmplY3RvciA9IG5ldyBVSUluamVjdG9ySW1wbCh0aGlzKSk7XG4gICAgfTtcbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUuZmluZE5vZGUgPSBmdW5jdGlvbiAocmVzb2x2YWJsZSkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuZmluZCh0aGlzLl9wYXRoLCBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gY29tbW9uXzEuaW5BcnJheShub2RlLnJlc29sdmFibGVzLCByZXNvbHZhYmxlKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhc3luYyBkZXBlbmRlbmNpZXMgb2YgYSBSZXNvbHZhYmxlXG4gICAgICpcbiAgICAgKiBHaXZlbiBhIFJlc29sdmFibGUsIHJldHVybnMgaXRzIGRlcGVuZGVuY2llcyBhcyBhIFJlc29sdmFibGVbXVxuICAgICAqL1xuICAgIFJlc29sdmVDb250ZXh0LnByb3RvdHlwZS5nZXREZXBlbmRlbmNpZXMgPSBmdW5jdGlvbiAocmVzb2x2YWJsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZmluZE5vZGUocmVzb2x2YWJsZSk7XG4gICAgICAgIC8vIEZpbmQgd2hpY2ggb3RoZXIgcmVzb2x2YWJsZXMgYXJlIFwidmlzaWJsZVwiIHRvIHRoZSBgcmVzb2x2YWJsZWAgYXJndW1lbnRcbiAgICAgICAgLy8gc3VicGF0aCBzdG9wcGluZyBhdCByZXNvbHZhYmxlJ3Mgbm9kZSwgb3IgdGhlIHdob2xlIHBhdGggKGlmIHRoZSByZXNvbHZhYmxlIGlzbid0IGluIHRoZSBwYXRoKVxuICAgICAgICB2YXIgc3ViUGF0aCA9IHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLnN1YlBhdGgodGhpcy5fcGF0aCwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPT09IG5vZGU7IH0pIHx8IHRoaXMuX3BhdGg7XG4gICAgICAgIHZhciBhdmFpbGFibGVSZXNvbHZhYmxlcyA9IHN1YlBhdGhcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgX25vZGUpIHsgcmV0dXJuIGFjYy5jb25jYXQoX25vZGUucmVzb2x2YWJsZXMpOyB9LCBbXSkgLy9hbGwgb2Ygc3VicGF0aCdzIHJlc29sdmFibGVzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcyAhPT0gcmVzb2x2YWJsZTsgfSk7IC8vIGZpbHRlciBvdXQgdGhlIGByZXNvbHZhYmxlYCBhcmd1bWVudFxuICAgICAgICB2YXIgZ2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nID0gYXZhaWxhYmxlUmVzb2x2YWJsZXMuZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnRva2VuID09PSB0b2tlbjsgfSk7XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tb25fMS50YWlsKG1hdGNoaW5nKTtcbiAgICAgICAgICAgIHZhciBmcm9tSW5qZWN0b3IgPSBfdGhpcy5pbmplY3RvcigpLmdldE5hdGl2ZSh0b2tlbik7XG4gICAgICAgICAgICBpZiAoY29tbW9uXzIuaXNVbmRlZmluZWQoZnJvbUluamVjdG9yKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIERlcGVuZGVuY3kgSW5qZWN0aW9uIHRva2VuOiBcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkodG9rZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUodG9rZW4sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb21JbmplY3RvcjsgfSwgW10sIGZyb21JbmplY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXNvbHZhYmxlLmRlcHMubWFwKGdldERlcGVuZGVuY3kpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc29sdmVDb250ZXh0O1xufSgpKTtcbmV4cG9ydHMuUmVzb2x2ZUNvbnRleHQgPSBSZXNvbHZlQ29udGV4dDtcbnZhciBVSUluamVjdG9ySW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVSUluamVjdG9ySW1wbChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMubmF0aXZlID0gdGhpcy5nZXQoZXhwb3J0cy5OQVRJVkVfSU5KRUNUT1JfVE9LRU4pIHx8IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRpbmplY3RvcjtcbiAgICB9XG4gICAgVUlJbmplY3RvckltcGwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgcmVzb2x2YWJsZSA9IHRoaXMuY29udGV4dC5nZXRSZXNvbHZhYmxlKHRva2VuKTtcbiAgICAgICAgaWYgKHJlc29sdmFibGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuZ2V0UG9saWN5KHJlc29sdmFibGUpLmFzeW5jID09PSAnTk9XQUlUJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZhYmxlLmdldCh0aGlzLmNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXNvbHZhYmxlLnJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzb2x2YWJsZSBhc3luYyAuZ2V0KCkgbm90IGNvbXBsZXRlOlwiICsgc3RyaW5nc18xLnN0cmluZ2lmeShyZXNvbHZhYmxlLnRva2VuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2YWJsZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZSh0b2tlbik7XG4gICAgfTtcbiAgICBVSUluamVjdG9ySW1wbC5wcm90b3R5cGUuZ2V0QXN5bmMgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIHJlc29sdmFibGUgPSB0aGlzLmNvbnRleHQuZ2V0UmVzb2x2YWJsZSh0b2tlbik7XG4gICAgICAgIGlmIChyZXNvbHZhYmxlKVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmFibGUuZ2V0KHRoaXMuY29udGV4dCk7XG4gICAgICAgIHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS53aGVuKHRoaXMubmF0aXZlLmdldCh0b2tlbikpO1xuICAgIH07XG4gICAgVUlJbmplY3RvckltcGwucHJvdG90eXBlLmdldE5hdGl2ZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmUgJiYgdGhpcy5uYXRpdmUuZ2V0KHRva2VuKTtcbiAgICB9O1xuICAgIHJldHVybiBVSUluamVjdG9ySW1wbDtcbn0oKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlQ29udGV4dC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvcmVzb2x2ZS9yZXNvbHZlQ29udGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHVybFxuICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIHBhcmFtXzEgPSByZXF1aXJlKFwiLi4vcGFyYW1zL3BhcmFtXCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc3RyaW5nc1wiKTtcbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBxdW90ZVJlZ0V4cChzdHJpbmcsIHBhcmFtKSB7XG4gICAgdmFyIHN1cnJvdW5kUGF0dGVybiA9IFsnJywgJyddLCByZXN1bHQgPSBzdHJpbmcucmVwbGFjZSgvW1xcXFxcXFtcXF1cXF4kKis/LigpfHt9XS9nLCBcIlxcXFwkJlwiKTtcbiAgICBpZiAoIXBhcmFtKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIHN3aXRjaCAocGFyYW0uc3F1YXNoKSB7XG4gICAgICAgIGNhc2UgZmFsc2U6XG4gICAgICAgICAgICBzdXJyb3VuZFBhdHRlcm4gPSBbJygnLCAnKScgKyAocGFyYW0uaXNPcHRpb25hbCA/ICc/JyA6ICcnKV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0cnVlOlxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgICAgICAgICBzdXJyb3VuZFBhdHRlcm4gPSBbJyg/OlxcLygnLCAnKXxcXC8pPyddO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzdXJyb3VuZFBhdHRlcm4gPSBbXCIoXCIgKyBwYXJhbS5zcXVhc2ggKyBcInxcIiwgJyk/J107XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCArIHN1cnJvdW5kUGF0dGVyblswXSArIHBhcmFtLnR5cGUucGF0dGVybi5zb3VyY2UgKyBzdXJyb3VuZFBhdHRlcm5bMV07XG59XG4vKiogQGhpZGRlbiAqL1xudmFyIG1lbW9pemVUbyA9IGZ1bmN0aW9uIChvYmosIHByb3AsIGZuKSB7XG4gICAgcmV0dXJuIG9ialtwcm9wXSA9IG9ialtwcm9wXSB8fCBmbigpO1xufTtcbi8qKiBAaGlkZGVuICovXG52YXIgc3BsaXRPblNsYXNoID0gc3RyaW5nc18xLnNwbGl0T25EZWxpbSgnLycpO1xuLyoqXG4gKiBNYXRjaGVzIFVSTHMgYWdhaW5zdCBwYXR0ZXJucy5cbiAqXG4gKiBNYXRjaGVzIFVSTHMgYWdhaW5zdCBwYXR0ZXJucyBhbmQgZXh0cmFjdHMgbmFtZWQgcGFyYW1ldGVycyBmcm9tIHRoZSBwYXRoIG9yIHRoZSBzZWFyY2hcbiAqIHBhcnQgb2YgdGhlIFVSTC5cbiAqXG4gKiBBIFVSTCBwYXR0ZXJuIGNvbnNpc3RzIG9mIGEgcGF0aCBwYXR0ZXJuLCBvcHRpb25hbGx5IGZvbGxvd2VkIGJ5ICc/JyBhbmQgYSBsaXN0IG9mIHNlYXJjaCAocXVlcnkpXG4gKiBwYXJhbWV0ZXJzLiBNdWx0aXBsZSBzZWFyY2ggcGFyYW1ldGVyIG5hbWVzIGFyZSBzZXBhcmF0ZWQgYnkgJyYnLiBTZWFyY2ggcGFyYW1ldGVyc1xuICogZG8gbm90IGluZmx1ZW5jZSB3aGV0aGVyIG9yIG5vdCBhIFVSTCBpcyBtYXRjaGVkLCBidXQgdGhlaXIgdmFsdWVzIGFyZSBwYXNzZWQgdGhyb3VnaCBpbnRvXG4gKiB0aGUgbWF0Y2hlZCBwYXJhbWV0ZXJzIHJldHVybmVkIGJ5IFtbVXJsTWF0Y2hlci5leGVjXV0uXG4gKlxuICogLSAqUGF0aCBwYXJhbWV0ZXJzKiBhcmUgZGVmaW5lZCB1c2luZyBjdXJseSBicmFjZSBwbGFjZWhvbGRlcnMgKGAvc29tZXBhdGgve3BhcmFtfWApXG4gKiBvciBjb2xvbiBwbGFjZWhvbGRlcnMgKGAvc29tZVBhdGgvOnBhcmFtYCkuXG4gKlxuICogLSAqQSBwYXJhbWV0ZXIgUmVnRXhwKiBtYXkgYmUgZGVmaW5lZCBmb3IgYSBwYXJhbSBhZnRlciBhIGNvbG9uXG4gKiAoYC9zb21lUGF0aC97cGFyYW06W2EtekEtWjAtOV0rfWApIGluIGEgY3VybHkgYnJhY2UgcGxhY2Vob2xkZXIuXG4gKiBUaGUgcmVnZXhwIG11c3QgbWF0Y2ggZm9yIHRoZSB1cmwgdG8gYmUgbWF0Y2hlZC5cbiAqIFNob3VsZCB0aGUgcmVnZXhwIGl0c2VsZiBjb250YWluIGN1cmx5IGJyYWNlcywgdGhleSBtdXN0IGJlIGluIG1hdGNoZWQgcGFpcnMgb3IgZXNjYXBlZCB3aXRoIGEgYmFja3NsYXNoLlxuICpcbiAqIE5vdGU6IGEgUmVnRXhwIHBhcmFtZXRlciB3aWxsIGVuY29kZSBpdHMgdmFsdWUgdXNpbmcgZWl0aGVyIFtbUGFyYW1UeXBlcy5wYXRoXV0gb3IgW1tQYXJhbVR5cGVzLnF1ZXJ5XV0uXG4gKlxuICogLSAqQ3VzdG9tIHBhcmFtZXRlciB0eXBlcyogbWF5IGFsc28gYmUgc3BlY2lmaWVkIGFmdGVyIGEgY29sb24gKGAvc29tZVBhdGgve3BhcmFtOmludH1gKSBpbiBjdXJseSBicmFjZSBwYXJhbWV0ZXJzLlxuICogICBTZWUgW1tVcmxNYXRjaGVyRmFjdG9yeS50eXBlXV0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogLSAqQ2F0Y2gtYWxsIHBhcmFtZXRlcnMqIGFyZSBkZWZpbmVkIHVzaW5nIGFuIGFzdGVyaXNrIHBsYWNlaG9sZGVyIChgL3NvbWVwYXRoLypjYXRjaGFsbHBhcmFtYCkuXG4gKiAgIEEgY2F0Y2gtYWxsICogcGFyYW1ldGVyIHZhbHVlIHdpbGwgY29udGFpbiB0aGUgcmVtYWluZGVyIG9mIHRoZSBVUkwuXG4gKlxuICogLS0tXG4gKlxuICogUGFyYW1ldGVyIG5hbWVzIG1heSBjb250YWluIG9ubHkgd29yZCBjaGFyYWN0ZXJzIChsYXRpbiBsZXR0ZXJzLCBkaWdpdHMsIGFuZCB1bmRlcnNjb3JlKSBhbmRcbiAqIG11c3QgYmUgdW5pcXVlIHdpdGhpbiB0aGUgcGF0dGVybiAoYWNyb3NzIGJvdGggcGF0aCBhbmQgc2VhcmNoIHBhcmFtZXRlcnMpLlxuICogQSBwYXRoIHBhcmFtZXRlciBtYXRjaGVzIGFueSBudW1iZXIgb2YgY2hhcmFjdGVycyBvdGhlciB0aGFuICcvJy4gRm9yIGNhdGNoLWFsbFxuICogcGxhY2Vob2xkZXJzIHRoZSBwYXRoIHBhcmFtZXRlciBtYXRjaGVzIGFueSBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAqIGAnL2hlbGxvLydgIC0gTWF0Y2hlcyBvbmx5IGlmIHRoZSBwYXRoIGlzIGV4YWN0bHkgJy9oZWxsby8nLiBUaGVyZSBpcyBubyBzcGVjaWFsIHRyZWF0bWVudCBmb3JcbiAqICAgdHJhaWxpbmcgc2xhc2hlcywgYW5kIHBhdHRlcm5zIGhhdmUgdG8gbWF0Y2ggdGhlIGVudGlyZSBwYXRoLCBub3QganVzdCBhIHByZWZpeC5cbiAqICogYCcvdXNlci86aWQnYCAtIE1hdGNoZXMgJy91c2VyL2JvYicgb3IgJy91c2VyLzEyMzQhISEnIG9yIGV2ZW4gJy91c2VyLycgYnV0IG5vdCAnL3VzZXInIG9yXG4gKiAgICcvdXNlci9ib2IvZGV0YWlscycuIFRoZSBzZWNvbmQgcGF0aCBzZWdtZW50IHdpbGwgYmUgY2FwdHVyZWQgYXMgdGhlIHBhcmFtZXRlciAnaWQnLlxuICogKiBgJy91c2VyL3tpZH0nYCAtIFNhbWUgYXMgdGhlIHByZXZpb3VzIGV4YW1wbGUsIGJ1dCB1c2luZyBjdXJseSBicmFjZSBzeW50YXguXG4gKiAqIGAnL3VzZXIve2lkOlteL10qfSdgIC0gU2FtZSBhcyB0aGUgcHJldmlvdXMgZXhhbXBsZS5cbiAqICogYCcvdXNlci97aWQ6WzAtOWEtZkEtRl17MSw4fX0nYCAtIFNpbWlsYXIgdG8gdGhlIHByZXZpb3VzIGV4YW1wbGUsIGJ1dCBvbmx5IG1hdGNoZXMgaWYgdGhlIGlkXG4gKiAgIHBhcmFtZXRlciBjb25zaXN0cyBvZiAxIHRvIDggaGV4IGRpZ2l0cy5cbiAqICogYCcvZmlsZXMve3BhdGg6Lip9J2AgLSBNYXRjaGVzIGFueSBVUkwgc3RhcnRpbmcgd2l0aCAnL2ZpbGVzLycgYW5kIGNhcHR1cmVzIHRoZSByZXN0IG9mIHRoZVxuICogICBwYXRoIGludG8gdGhlIHBhcmFtZXRlciAncGF0aCcuXG4gKiAqIGAnL2ZpbGVzLypwYXRoJ2AgLSBkaXR0by5cbiAqICogYCcvY2FsZW5kYXIve3N0YXJ0OmRhdGV9J2AgLSBNYXRjaGVzIFwiL2NhbGVuZGFyLzIwMTQtMTEtMTJcIiAoYmVjYXVzZSB0aGUgcGF0dGVybiBkZWZpbmVkXG4gKiAgIGluIHRoZSBidWlsdC1pbiAgYGRhdGVgIFBhcmFtVHlwZSBtYXRjaGVzIGAyMDE0LTExLTEyYCkgYW5kIHByb3ZpZGVzIGEgRGF0ZSBvYmplY3QgaW4gJHN0YXRlUGFyYW1zLnN0YXJ0XG4gKlxuICovXG52YXIgVXJsTWF0Y2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcGF0dGVybiBUaGUgcGF0dGVybiB0byBjb21waWxlIGludG8gYSBtYXRjaGVyLlxuICAgICAqIEBwYXJhbSBwYXJhbVR5cGVzIFRoZSBbW1BhcmFtVHlwZXNdXSByZWdpc3RyeVxuICAgICAqIEBwYXJhbSBjb25maWcgIEEgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgKiAtIGBjYXNlSW5zZW5zaXRpdmVgIC0gYHRydWVgIGlmIFVSTCBtYXRjaGluZyBzaG91bGQgYmUgY2FzZSBpbnNlbnNpdGl2ZSwgb3RoZXJ3aXNlIGBmYWxzZWAsIHRoZSBkZWZhdWx0IHZhbHVlIChmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSkgaXMgYGZhbHNlYC5cbiAgICAgKiAtIGBzdHJpY3RgIC0gYGZhbHNlYCBpZiBtYXRjaGluZyBhZ2FpbnN0IGEgVVJMIHdpdGggYSB0cmFpbGluZyBzbGFzaCBzaG91bGQgYmUgdHJlYXRlZCBhcyBlcXVpdmFsZW50IHRvIGEgVVJMIHdpdGhvdXQgYSB0cmFpbGluZyBzbGFzaCwgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYHRydWVgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVybE1hdGNoZXIocGF0dGVybiwgcGFyYW1UeXBlcywgcGFyYW1GYWN0b3J5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX2NhY2hlID0geyBwYXRoOiBbdGhpc10gfTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5fcGFyYW1zID0gW107XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX3NlZ21lbnRzID0gW107XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX2NvbXBpbGVkID0gW107XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29tbW9uXzEuZGVmYXVsdHModGhpcy5jb25maWcsIHtcbiAgICAgICAgICAgIHBhcmFtczoge30sXG4gICAgICAgICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICAgICAgICBjYXNlSW5zZW5zaXRpdmU6IGZhbHNlLFxuICAgICAgICAgICAgcGFyYW1NYXA6IGNvbW1vbl8xLmlkZW50aXR5XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBGaW5kIGFsbCBwbGFjZWhvbGRlcnMgYW5kIGNyZWF0ZSBhIGNvbXBpbGVkIHBhdHRlcm4sIHVzaW5nIGVpdGhlciBjbGFzc2ljIG9yIGN1cmx5IHN5bnRheDpcbiAgICAgICAgLy8gICAnKicgbmFtZVxuICAgICAgICAvLyAgICc6JyBuYW1lXG4gICAgICAgIC8vICAgJ3snIG5hbWUgJ30nXG4gICAgICAgIC8vICAgJ3snIG5hbWUgJzonIHJlZ2V4cCAnfSdcbiAgICAgICAgLy8gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBzb21ld2hhdCBjb21wbGljYXRlZCBkdWUgdG8gdGhlIG5lZWQgdG8gYWxsb3cgY3VybHkgYnJhY2VzXG4gICAgICAgIC8vIGluc2lkZSB0aGUgcmVndWxhciBleHByZXNzaW9uLiBUaGUgcGxhY2Vob2xkZXIgcmVnZXhwIGJyZWFrcyBkb3duIGFzIGZvbGxvd3M6XG4gICAgICAgIC8vICAgIChbOipdKShbXFx3XFxbXFxdXSspICAgICAgICAgICAgICAtIGNsYXNzaWMgcGxhY2Vob2xkZXIgKCQxIC8gJDIpIChzZWFyY2ggdmVyc2lvbiBoYXMgLSBmb3Igc25ha2UtY2FzZSlcbiAgICAgICAgLy8gICAgXFx7KFtcXHdcXFtcXF1dKykoPzpcXDpcXHMqKCAuLi4gKSk/XFx9ICAtIGN1cmx5IGJyYWNlIHBsYWNlaG9sZGVyICgkMykgd2l0aCBvcHRpb25hbCByZWdleHAvdHlwZSAuLi4gKCQ0KSAoc2VhcmNoIHZlcnNpb24gaGFzIC0gZm9yIHNuYWtlLWNhc2VcbiAgICAgICAgLy8gICAgKD86IC4uLiB8IC4uLiB8IC4uLiApKyAgICAgICAgIC0gdGhlIHJlZ2V4cCBjb25zaXN0cyBvZiBhbnkgbnVtYmVyIG9mIGF0b21zLCBhbiBhdG9tIGJlaW5nIGVpdGhlclxuICAgICAgICAvLyAgICBbXnt9XFxcXF0rICAgICAgICAgICAgICAgICAgICAgICAtIGFueXRoaW5nIG90aGVyIHRoYW4gY3VybHkgYnJhY2VzIG9yIGJhY2tzbGFzaFxuICAgICAgICAvLyAgICBcXFxcLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGEgYmFja3NsYXNoIGVzY2FwZVxuICAgICAgICAvLyAgICBcXHsoPzpbXnt9XFxcXF0rfFxcXFwuKSpcXH0gICAgICAgICAgLSBhIG1hdGNoZWQgc2V0IG9mIGN1cmx5IGJyYWNlcyBjb250YWluaW5nIG90aGVyIGF0b21zXG4gICAgICAgIHZhciBwbGFjZWhvbGRlciA9IC8oWzoqXSkoW1xcd1xcW1xcXV0rKXxcXHsoW1xcd1xcW1xcXV0rKSg/OlxcOlxccyooKD86W157fVxcXFxdK3xcXFxcLnxcXHsoPzpbXnt9XFxcXF0rfFxcXFwuKSpcXH0pKykpP1xcfS9nLCBzZWFyY2hQbGFjZWhvbGRlciA9IC8oWzpdPykoW1xcd1xcW1xcXS4tXSspfFxceyhbXFx3XFxbXFxdLi1dKykoPzpcXDpcXHMqKCg/Oltee31cXFxcXSt8XFxcXC58XFx7KD86W157fVxcXFxdK3xcXFxcLikqXFx9KSspKT9cXH0vZywgbGFzdCA9IDAsIG0sIHBhdHRlcm5zID0gW107XG4gICAgICAgIHZhciBjaGVja1BhcmFtRXJyb3JzID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICBpZiAoIVVybE1hdGNoZXIubmFtZVZhbGlkYXRvci50ZXN0KGlkKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhcmFtZXRlciBuYW1lICdcIiArIGlkICsgXCInIGluIHBhdHRlcm4gJ1wiICsgcGF0dGVybiArIFwiJ1wiKTtcbiAgICAgICAgICAgIGlmIChjb21tb25fMS5maW5kKF90aGlzLl9wYXJhbXMsIGhvZl8xLnByb3BFcSgnaWQnLCBpZCkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZSAnXCIgKyBpZCArIFwiJyBpbiBwYXR0ZXJuICdcIiArIHBhdHRlcm4gKyBcIidcIik7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFNwbGl0IGludG8gc3RhdGljIHNlZ21lbnRzIHNlcGFyYXRlZCBieSBwYXRoIHBhcmFtZXRlciBwbGFjZWhvbGRlcnMuXG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2Ygc2VnbWVudHMgaXMgYWx3YXlzIDEgbW9yZSB0aGFuIHRoZSBudW1iZXIgb2YgcGFyYW1ldGVycy5cbiAgICAgICAgdmFyIG1hdGNoRGV0YWlscyA9IGZ1bmN0aW9uIChtLCBpc1NlYXJjaCkge1xuICAgICAgICAgICAgLy8gSUVbNzhdIHJldHVybnMgJycgZm9yIHVubWF0Y2hlZCBncm91cHMgaW5zdGVhZCBvZiBudWxsXG4gICAgICAgICAgICB2YXIgaWQgPSBtWzJdIHx8IG1bM107XG4gICAgICAgICAgICB2YXIgcmVnZXhwID0gaXNTZWFyY2ggPyBtWzRdIDogbVs0XSB8fCAobVsxXSA9PT0gJyonID8gJ1tcXFxcc1xcXFxTXSonIDogbnVsbCk7XG4gICAgICAgICAgICB2YXIgbWFrZVJlZ2V4cFR5cGUgPSBmdW5jdGlvbiAocmVnZXhwKSB7IHJldHVybiBjb21tb25fMS5pbmhlcml0KHBhcmFtVHlwZXMudHlwZShpc1NlYXJjaCA/IFwicXVlcnlcIiA6IFwicGF0aFwiKSwge1xuICAgICAgICAgICAgICAgIHBhdHRlcm46IG5ldyBSZWdFeHAocmVnZXhwLCBfdGhpcy5jb25maWcuY2FzZUluc2Vuc2l0aXZlID8gJ2knIDogdW5kZWZpbmVkKVxuICAgICAgICAgICAgfSk7IH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICByZWdleHA6IHJlZ2V4cCxcbiAgICAgICAgICAgICAgICBjZmc6IF90aGlzLmNvbmZpZy5wYXJhbXNbaWRdLFxuICAgICAgICAgICAgICAgIHNlZ21lbnQ6IHBhdHRlcm4uc3Vic3RyaW5nKGxhc3QsIG0uaW5kZXgpLFxuICAgICAgICAgICAgICAgIHR5cGU6ICFyZWdleHAgPyBudWxsIDogcGFyYW1UeXBlcy50eXBlKHJlZ2V4cCkgfHwgbWFrZVJlZ2V4cFR5cGUocmVnZXhwKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHAsIHNlZ21lbnQ7XG4gICAgICAgIHdoaWxlICgobSA9IHBsYWNlaG9sZGVyLmV4ZWMocGF0dGVybikpKSB7XG4gICAgICAgICAgICBwID0gbWF0Y2hEZXRhaWxzKG0sIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChwLnNlZ21lbnQuaW5kZXhPZignPycpID49IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIHdlJ3JlIGludG8gdGhlIHNlYXJjaCBwYXJ0XG4gICAgICAgICAgICBjaGVja1BhcmFtRXJyb3JzKHAuaWQpO1xuICAgICAgICAgICAgdGhpcy5fcGFyYW1zLnB1c2gocGFyYW1GYWN0b3J5LmZyb21QYXRoKHAuaWQsIHAudHlwZSwgdGhpcy5jb25maWcucGFyYW1NYXAocC5jZmcsIGZhbHNlKSkpO1xuICAgICAgICAgICAgdGhpcy5fc2VnbWVudHMucHVzaChwLnNlZ21lbnQpO1xuICAgICAgICAgICAgcGF0dGVybnMucHVzaChbcC5zZWdtZW50LCBjb21tb25fMS50YWlsKHRoaXMuX3BhcmFtcyldKTtcbiAgICAgICAgICAgIGxhc3QgPSBwbGFjZWhvbGRlci5sYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgc2VnbWVudCA9IHBhdHRlcm4uc3Vic3RyaW5nKGxhc3QpO1xuICAgICAgICAvLyBGaW5kIGFueSBzZWFyY2ggcGFyYW1ldGVyIG5hbWVzIGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSBsYXN0IHNlZ21lbnRcbiAgICAgICAgdmFyIGkgPSBzZWdtZW50LmluZGV4T2YoJz8nKTtcbiAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgICAgdmFyIHNlYXJjaCA9IHNlZ21lbnQuc3Vic3RyaW5nKGkpO1xuICAgICAgICAgICAgc2VnbWVudCA9IHNlZ21lbnQuc3Vic3RyaW5nKDAsIGkpO1xuICAgICAgICAgICAgaWYgKHNlYXJjaC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChtID0gc2VhcmNoUGxhY2Vob2xkZXIuZXhlYyhzZWFyY2gpKSkge1xuICAgICAgICAgICAgICAgICAgICBwID0gbWF0Y2hEZXRhaWxzKG0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBjaGVja1BhcmFtRXJyb3JzKHAuaWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXMucHVzaChwYXJhbUZhY3RvcnkuZnJvbVNlYXJjaChwLmlkLCBwLnR5cGUsIHRoaXMuY29uZmlnLnBhcmFtTWFwKHAuY2ZnLCB0cnVlKSkpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gcGxhY2Vob2xkZXIubGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiA/JlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICB0aGlzLl9jb21waWxlZCA9IHBhdHRlcm5zLm1hcChmdW5jdGlvbiAocGF0dGVybikgeyByZXR1cm4gcXVvdGVSZWdFeHAuYXBwbHkobnVsbCwgcGF0dGVybik7IH0pLmNvbmNhdChxdW90ZVJlZ0V4cChzZWdtZW50KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29uY2F0ZW5hdGVkIFVybE1hdGNoZXJcbiAgICAgKlxuICAgICAqIEJ1aWxkcyBhIG5ldyBVcmxNYXRjaGVyIGJ5IGFwcGVuZGluZyBhbm90aGVyIFVybE1hdGNoZXIgdG8gdGhpcyBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIEEgYFVybE1hdGNoZXJgIGluc3RhbmNlIHRvIGFwcGVuZCBhcyBhIGNoaWxkIG9mIHRoZSBjdXJyZW50IGBVcmxNYXRjaGVyYC5cbiAgICAgKi9cbiAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2godXJsKTtcbiAgICAgICAgdXJsLl9jYWNoZSA9IHtcbiAgICAgICAgICAgIHBhdGg6IHRoaXMuX2NhY2hlLnBhdGguY29uY2F0KHVybCksXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgICBwYXR0ZXJuOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS5pc1Jvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5wYXRoWzBdID09PSB0aGlzO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgdGhlIGlucHV0IHBhdHRlcm4gc3RyaW5nICovXG4gICAgVXJsTWF0Y2hlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdHRlcm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0cyB0aGUgc3BlY2lmaWVkIHVybC9wYXRoIGFnYWluc3QgdGhpcyBtYXRjaGVyLlxuICAgICAqXG4gICAgICogVGVzdHMgaWYgdGhlIGdpdmVuIHVybCBtYXRjaGVzIHRoaXMgbWF0Y2hlcidzIHBhdHRlcm4sIGFuZCByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjYXB0dXJlZFxuICAgICAqIHBhcmFtZXRlciB2YWx1ZXMuICBSZXR1cm5zIG51bGwgaWYgdGhlIHBhdGggZG9lcyBub3QgbWF0Y2guXG4gICAgICpcbiAgICAgKiBUaGUgcmV0dXJuZWQgb2JqZWN0IGNvbnRhaW5zIHRoZSB2YWx1ZXNcbiAgICAgKiBvZiBhbnkgc2VhcmNoIHBhcmFtZXRlcnMgdGhhdCBhcmUgbWVudGlvbmVkIGluIHRoZSBwYXR0ZXJuLCBidXQgdGhlaXIgdmFsdWUgbWF5IGJlIG51bGwgaWZcbiAgICAgKiB0aGV5IGFyZSBub3QgcHJlc2VudCBpbiBgc2VhcmNoYC4gVGhpcyBtZWFucyB0aGF0IHNlYXJjaCBwYXJhbWV0ZXJzIGFyZSBhbHdheXMgdHJlYXRlZFxuICAgICAqIGFzIG9wdGlvbmFsLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogbmV3IFVybE1hdGNoZXIoJy91c2VyL3tpZH0/cSZyJykuZXhlYygnL3VzZXIvYm9iJywge1xuICAgICAqICAgeDogJzEnLCBxOiAnaGVsbG8nXG4gICAgICogfSk7XG4gICAgICogLy8gcmV0dXJucyB7IGlkOiAnYm9iJywgcTogJ2hlbGxvJywgcjogbnVsbCB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAgICBUaGUgVVJMIHBhdGggdG8gbWF0Y2gsIGUuZy4gYCRsb2NhdGlvbi5wYXRoKClgLlxuICAgICAqIEBwYXJhbSBzZWFyY2ggIFVSTCBzZWFyY2ggcGFyYW1ldGVycywgZS5nLiBgJGxvY2F0aW9uLnNlYXJjaCgpYC5cbiAgICAgKiBAcGFyYW0gaGFzaCAgICBVUkwgaGFzaCBlLmcuIGAkbG9jYXRpb24uaGFzaCgpYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGNhcHR1cmVkIHBhcmFtZXRlciB2YWx1ZXMuXG4gICAgICovXG4gICAgVXJsTWF0Y2hlci5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uIChwYXRoLCBzZWFyY2gsIGhhc2gsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHNlYXJjaCA9PT0gdm9pZCAwKSB7IHNlYXJjaCA9IHt9OyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBtYXRjaCA9IG1lbW9pemVUbyh0aGlzLl9jYWNoZSwgJ3BhdHRlcm4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChbXG4gICAgICAgICAgICAgICAgJ14nLFxuICAgICAgICAgICAgICAgIGNvbW1vbl8xLnVubmVzdChfdGhpcy5fY2FjaGUucGF0aC5tYXAoaG9mXzEucHJvcCgnX2NvbXBpbGVkJykpKS5qb2luKCcnKSxcbiAgICAgICAgICAgICAgICBfdGhpcy5jb25maWcuc3RyaWN0ID09PSBmYWxzZSA/ICdcXC8/JyA6ICcnLFxuICAgICAgICAgICAgICAgICckJ1xuICAgICAgICAgICAgXS5qb2luKCcnKSwgX3RoaXMuY29uZmlnLmNhc2VJbnNlbnNpdGl2ZSA/ICdpJyA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH0pLmV4ZWMocGF0aCk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy9vcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywgeyBpc29sYXRlOiBmYWxzZSB9KTtcbiAgICAgICAgdmFyIGFsbFBhcmFtcyA9IHRoaXMucGFyYW1ldGVycygpLCBwYXRoUGFyYW1zID0gYWxsUGFyYW1zLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuICFwYXJhbS5pc1NlYXJjaCgpOyB9KSwgc2VhcmNoUGFyYW1zID0gYWxsUGFyYW1zLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLmlzU2VhcmNoKCk7IH0pLCBuUGF0aFNlZ21lbnRzID0gdGhpcy5fY2FjaGUucGF0aC5tYXAoZnVuY3Rpb24gKHVybG0pIHsgcmV0dXJuIHVybG0uX3NlZ21lbnRzLmxlbmd0aCAtIDE7IH0pLnJlZHVjZShmdW5jdGlvbiAoYSwgeCkgeyByZXR1cm4gYSArIHg7IH0pLCB2YWx1ZXMgPSB7fTtcbiAgICAgICAgaWYgKG5QYXRoU2VnbWVudHMgIT09IG1hdGNoLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmJhbGFuY2VkIGNhcHR1cmUgZ3JvdXAgaW4gcm91dGUgJ1wiICsgdGhpcy5wYXR0ZXJuICsgXCInXCIpO1xuICAgICAgICBmdW5jdGlvbiBkZWNvZGVQYXRoQXJyYXkoc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgcmV2ZXJzZVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0ci5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTsgfTtcbiAgICAgICAgICAgIHZhciB1bnF1b3RlRGFzaGVzID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwtL2csIFwiLVwiKTsgfTtcbiAgICAgICAgICAgIHZhciBzcGxpdCA9IHJldmVyc2VTdHJpbmcoc3RyaW5nKS5zcGxpdCgvLSg/IVxcXFwpLyk7XG4gICAgICAgICAgICB2YXIgYWxsUmV2ZXJzZWQgPSBjb21tb25fMS5tYXAoc3BsaXQsIHJldmVyc2VTdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLm1hcChhbGxSZXZlcnNlZCwgdW5xdW90ZURhc2hlcykucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblBhdGhTZWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXRoUGFyYW1zW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbWF0Y2hbaSArIDFdO1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBhcmFtIHZhbHVlIG1hdGNoZXMgYSBwcmUtcmVwbGFjZSBwYWlyLCByZXBsYWNlIHRoZSB2YWx1ZSBiZWZvcmUgZGVjb2RpbmcuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcmFtLnJlcGxhY2UubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0ucmVwbGFjZVtqXS5mcm9tID09PSB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJhbS5yZXBsYWNlW2pdLnRvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHBhcmFtLmFycmF5ID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVjb2RlUGF0aEFycmF5KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHZhbHVlKSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcmFtLnR5cGUuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlc1twYXJhbS5pZF0gPSBwYXJhbS52YWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VhcmNoUGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzZWFyY2hbcGFyYW0uaWRdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJhbS5yZXBsYWNlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLnJlcGxhY2Vbal0uZnJvbSA9PT0gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyYW0ucmVwbGFjZVtqXS50bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHZhbHVlKSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcmFtLnR5cGUuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlc1twYXJhbS5pZF0gPSBwYXJhbS52YWx1ZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzaClcbiAgICAgICAgICAgIHZhbHVlc1tcIiNcIl0gPSBoYXNoO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFJldHVybnMgYWxsIHRoZSBbW1BhcmFtXV0gb2JqZWN0cyBvZiBhbGwgcGF0aCBhbmQgc2VhcmNoIHBhcmFtZXRlcnMgb2YgdGhpcyBwYXR0ZXJuIGluIG9yZGVyIG9mIGFwcGVhcmFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPFBhcmFtPn0gIEFuIGFycmF5IG9mIFtbUGFyYW1dXSBvYmplY3RzLiBNdXN0IGJlIHRyZWF0ZWQgYXMgcmVhZC1vbmx5LiBJZiB0aGVcbiAgICAgKiAgICBwYXR0ZXJuIGhhcyBubyBwYXJhbWV0ZXJzLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cbiAgICAgICAgaWYgKG9wdHMuaW5oZXJpdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zO1xuICAgICAgICByZXR1cm4gY29tbW9uXzEudW5uZXN0KHRoaXMuX2NhY2hlLnBhdGgubWFwKGZ1bmN0aW9uIChtYXRjaGVyKSB7IHJldHVybiBtYXRjaGVyLl9wYXJhbXM7IH0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBSZXR1cm5zIGEgc2luZ2xlIHBhcmFtZXRlciBmcm9tIHRoaXMgVXJsTWF0Y2hlciBieSBpZFxuICAgICAqXG4gICAgICogQHBhcmFtIGlkXG4gICAgICogQHBhcmFtIG9wdHNcbiAgICAgKiBAcmV0dXJucyB7VHxQYXJhbXxhbnl8Ym9vbGVhbnxVcmxNYXRjaGVyfG51bGx9XG4gICAgICovXG4gICAgVXJsTWF0Y2hlci5wcm90b3R5cGUucGFyYW1ldGVyID0gZnVuY3Rpb24gKGlkLCBvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIHsgb3B0cyA9IHt9OyB9XG4gICAgICAgIHZhciBmaW5kUGFyYW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gX3RoaXMuX3BhcmFtczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLmlkID09PSBpZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fY2FjaGUucGFyZW50O1xuICAgICAgICByZXR1cm4gZmluZFBhcmFtKCkgfHwgKG9wdHMuaW5oZXJpdCAhPT0gZmFsc2UgJiYgcGFyZW50ICYmIHBhcmVudC5wYXJhbWV0ZXIoaWQsIG9wdHMpKSB8fCBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSBpbnB1dCBwYXJhbWV0ZXIgdmFsdWVzIGFnYWluc3QgdGhpcyBVcmxNYXRjaGVyXG4gICAgICpcbiAgICAgKiBDaGVja3MgYW4gb2JqZWN0IGhhc2ggb2YgcGFyYW1ldGVycyB0byB2YWxpZGF0ZSB0aGVpciBjb3JyZWN0bmVzcyBhY2NvcmRpbmcgdG8gdGhlIHBhcmFtZXRlclxuICAgICAqIHR5cGVzIG9mIHRoaXMgYFVybE1hdGNoZXJgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBUaGUgb2JqZWN0IGhhc2ggb2YgcGFyYW1ldGVycyB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGB0cnVlYCBpZiBgcGFyYW1zYCB2YWxpZGF0ZXMsIG90aGVyd2lzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIFVybE1hdGNoZXIucHJvdG90eXBlLnZhbGlkYXRlcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHZhbGlkUGFyYW1WYWwgPSBmdW5jdGlvbiAocGFyYW0sIHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuICFwYXJhbSB8fCBwYXJhbS52YWxpZGF0ZXModmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICAvLyBJJ20gbm90IHN1cmUgd2h5IHRoaXMgY2hlY2tzIG9ubHkgdGhlIHBhcmFtIGtleXMgcGFzc2VkIGluLCBhbmQgbm90IGFsbCB0aGUgcGFyYW1zIGtub3duIHRvIHRoZSBtYXRjaGVyXG4gICAgICAgIHZhciBwYXJhbVNjaGVtYSA9IHRoaXMucGFyYW1ldGVycygpLmZpbHRlcihmdW5jdGlvbiAocGFyYW1EZWYpIHsgcmV0dXJuIHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShwYXJhbURlZi5pZCk7IH0pO1xuICAgICAgICByZXR1cm4gcGFyYW1TY2hlbWEubWFwKGZ1bmN0aW9uIChwYXJhbURlZikgeyByZXR1cm4gdmFsaWRQYXJhbVZhbChwYXJhbURlZiwgcGFyYW1zW3BhcmFtRGVmLmlkXSk7IH0pLnJlZHVjZShjb21tb25fMS5hbGxUcnVlUiwgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHNldCBvZiBwYXJhbWV0ZXIgdmFsdWVzLCBjcmVhdGVzIGEgVVJMIGZyb20gdGhpcyBVcmxNYXRjaGVyLlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhIFVSTCB0aGF0IG1hdGNoZXMgdGhpcyBwYXR0ZXJuIGJ5IHN1YnN0aXR1dGluZyB0aGUgc3BlY2lmaWVkIHZhbHVlc1xuICAgICAqIGZvciB0aGUgcGF0aCBhbmQgc2VhcmNoIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBuZXcgVXJsTWF0Y2hlcignL3VzZXIve2lkfT9xJykuZm9ybWF0KHsgaWQ6J2JvYicsIHE6J3llcycgfSk7XG4gICAgICogLy8gcmV0dXJucyAnL3VzZXIvYm9iP3E9eWVzJ1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlcyAgdGhlIHZhbHVlcyB0byBzdWJzdGl0dXRlIGZvciB0aGUgcGFyYW1ldGVycyBpbiB0aGlzIHBhdHRlcm4uXG4gICAgICogQHJldHVybnMgdGhlIGZvcm1hdHRlZCBVUkwgKHBhdGggYW5kIG9wdGlvbmFsbHkgc2VhcmNoIHBhcnQpLlxuICAgICAqL1xuICAgIFVybE1hdGNoZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9PT0gdm9pZCAwKSB7IHZhbHVlcyA9IHt9OyB9XG4gICAgICAgIC8vIEJ1aWxkIHRoZSBmdWxsIHBhdGggb2YgVXJsTWF0Y2hlcnMgKGluY2x1ZGluZyBhbGwgcGFyZW50IFVybE1hdGNoZXJzKVxuICAgICAgICB2YXIgdXJsTWF0Y2hlcnMgPSB0aGlzLl9jYWNoZS5wYXRoO1xuICAgICAgICAvLyBFeHRyYWN0IGFsbCB0aGUgc3RhdGljIHNlZ21lbnRzIGFuZCBQYXJhbXMgKHByb2Nlc3NlZCBhcyBQYXJhbURldGFpbHMpXG4gICAgICAgIC8vIGludG8gYW4gb3JkZXJlZCBhcnJheVxuICAgICAgICB2YXIgcGF0aFNlZ21lbnRzQW5kUGFyYW1zID0gdXJsTWF0Y2hlcnMubWFwKFVybE1hdGNoZXIucGF0aFNlZ21lbnRzQW5kUGFyYW1zKVxuICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc1N0cmluZyh4KSA/IHggOiBnZXREZXRhaWxzKHgpOyB9KTtcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgcXVlcnkgcGFyYW1zIGludG8gYSBzZXBhcmF0ZSBhcnJheVxuICAgICAgICB2YXIgcXVlcnlQYXJhbXMgPSB1cmxNYXRjaGVycy5tYXAoVXJsTWF0Y2hlci5xdWVyeVBhcmFtcylcbiAgICAgICAgICAgIC5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pXG4gICAgICAgICAgICAubWFwKGdldERldGFpbHMpO1xuICAgICAgICB2YXIgaXNJbnZhbGlkID0gZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5pc1ZhbGlkID09PSBmYWxzZTsgfTtcbiAgICAgICAgaWYgKHBhdGhTZWdtZW50c0FuZFBhcmFtcy5jb25jYXQocXVlcnlQYXJhbXMpLmZpbHRlcihpc0ludmFsaWQpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgUGFyYW0sIGFwcGxpZXMgdGhlIHBhcmFtZXRlciB2YWx1ZSwgdGhlbiByZXR1cm5zIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IGl0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXREZXRhaWxzKHBhcmFtKSB7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gdHlwZWQgdmFsdWVcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtLnZhbHVlKHZhbHVlc1twYXJhbS5pZF0pO1xuICAgICAgICAgICAgdmFyIGlzVmFsaWQgPSBwYXJhbS52YWxpZGF0ZXModmFsdWUpO1xuICAgICAgICAgICAgdmFyIGlzRGVmYXVsdFZhbHVlID0gcGFyYW0uaXNEZWZhdWx0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgaW4gc3F1YXNoIG1vZGUgZm9yIHRoZSBwYXJhbWV0ZXJcbiAgICAgICAgICAgIHZhciBzcXVhc2ggPSBpc0RlZmF1bHRWYWx1ZSA/IHBhcmFtLnNxdWFzaCA6IGZhbHNlO1xuICAgICAgICAgICAgLy8gQWxsb3cgdGhlIFBhcmFtZXRlcidzIFR5cGUgdG8gZW5jb2RlIHRoZSB2YWx1ZVxuICAgICAgICAgICAgdmFyIGVuY29kZWQgPSBwYXJhbS50eXBlLmVuY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4geyBwYXJhbTogcGFyYW0sIHZhbHVlOiB2YWx1ZSwgaXNWYWxpZDogaXNWYWxpZCwgaXNEZWZhdWx0VmFsdWU6IGlzRGVmYXVsdFZhbHVlLCBzcXVhc2g6IHNxdWFzaCwgZW5jb2RlZDogZW5jb2RlZCB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIHVwIHRoZSBwYXRoLXBvcnRpb24gZnJvbSB0aGUgbGlzdCBvZiBzdGF0aWMgc2VnbWVudHMgYW5kIHBhcmFtZXRlcnNcbiAgICAgICAgdmFyIHBhdGhTdHJpbmcgPSBwYXRoU2VnbWVudHNBbmRQYXJhbXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGEgc3RhdGljIHNlZ21lbnQgKGEgcmF3IHN0cmluZyk7IGp1c3QgYXBwZW5kIGl0XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzU3RyaW5nKHgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyB4O1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCdzIGEgUGFyYW1EZXRhaWxzLlxuICAgICAgICAgICAgdmFyIHNxdWFzaCA9IHguc3F1YXNoLCBlbmNvZGVkID0geC5lbmNvZGVkLCBwYXJhbSA9IHgucGFyYW07XG4gICAgICAgICAgICAvLyBJZiBzcXVhc2ggaXMgPT09IHRydWUsIHRyeSB0byByZW1vdmUgYSBzbGFzaCBmcm9tIHRoZSBwYXRoXG4gICAgICAgICAgICBpZiAoc3F1YXNoID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHJldHVybiAoYWNjLm1hdGNoKC9cXC8kLykpID8gYWNjLnNsaWNlKDAsIC0xKSA6IGFjYztcbiAgICAgICAgICAgIC8vIElmIHNxdWFzaCBpcyBhIHN0cmluZywgdXNlIHRoZSBzdHJpbmcgZm9yIHRoZSBwYXJhbSB2YWx1ZVxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzcXVhc2gpKVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyBzcXVhc2g7XG4gICAgICAgICAgICBpZiAoc3F1YXNoICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjOyAvLyA/XG4gICAgICAgICAgICBpZiAoZW5jb2RlZCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIHBhcmFtZXRlciB2YWx1ZSBpcyBhbiBhcnJheSwgZW5jb2RlIHRoZSB2YWx1ZSB1c2luZyBlbmNvZGVEYXNoZXNcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNBcnJheShlbmNvZGVkKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjICsgY29tbW9uXzEubWFwKGVuY29kZWQsIFVybE1hdGNoZXIuZW5jb2RlRGFzaGVzKS5qb2luKFwiLVwiKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwYXJhbWV0ZXIgdHlwZSBpcyBcInJhd1wiLCB0aGVuIGRvIG5vdCBlbmNvZGVVUklDb21wb25lbnRcbiAgICAgICAgICAgIGlmIChwYXJhbS5yYXcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIGVuY29kZWQ7XG4gICAgICAgICAgICAvLyBFbmNvZGUgdGhlIHZhbHVlXG4gICAgICAgICAgICByZXR1cm4gYWNjICsgZW5jb2RlVVJJQ29tcG9uZW50KGVuY29kZWQpO1xuICAgICAgICB9LCBcIlwiKTtcbiAgICAgICAgLy8gQnVpbGQgdGhlIHF1ZXJ5IHN0cmluZyBieSBhcHBseWluZyBwYXJhbWV0ZXIgdmFsdWVzIChhcnJheSBvciByZWd1bGFyKVxuICAgICAgICAvLyB0aGVuIG1hcHBpbmcgdG8ga2V5PXZhbHVlLCB0aGVuIGZsYXR0ZW5pbmcgYW5kIGpvaW5pbmcgdXNpbmcgXCImXCJcbiAgICAgICAgdmFyIHF1ZXJ5U3RyaW5nID0gcXVlcnlQYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbURldGFpbHMpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IHBhcmFtRGV0YWlscy5wYXJhbSwgc3F1YXNoID0gcGFyYW1EZXRhaWxzLnNxdWFzaCwgZW5jb2RlZCA9IHBhcmFtRGV0YWlscy5lbmNvZGVkLCBpc0RlZmF1bHRWYWx1ZSA9IHBhcmFtRGV0YWlscy5pc0RlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVkID09IG51bGwgfHwgKGlzRGVmYXVsdFZhbHVlICYmIHNxdWFzaCAhPT0gZmFsc2UpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzQXJyYXkoZW5jb2RlZCkpXG4gICAgICAgICAgICAgICAgZW5jb2RlZCA9IFtlbmNvZGVkXTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIXBhcmFtLnJhdylcbiAgICAgICAgICAgICAgICBlbmNvZGVkID0gY29tbW9uXzEubWFwKGVuY29kZWQsIGVuY29kZVVSSUNvbXBvbmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlZC5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gcGFyYW0uaWQgKyBcIj1cIiArIHZhbDsgfSk7XG4gICAgICAgIH0pLmZpbHRlcihjb21tb25fMS5pZGVudGl0eSkucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKS5qb2luKFwiJlwiKTtcbiAgICAgICAgLy8gQ29uY2F0IHRoZSBwYXRoc3RyaW5nIHdpdGggdGhlIHF1ZXJ5U3RyaW5nIChpZiBleGlzdHMpIGFuZCB0aGUgaGFzaFN0cmluZyAoaWYgZXhpc3RzKVxuICAgICAgICByZXR1cm4gcGF0aFN0cmluZyArIChxdWVyeVN0cmluZyA/IFwiP1wiICsgcXVlcnlTdHJpbmcgOiBcIlwiKSArICh2YWx1ZXNbXCIjXCJdID8gXCIjXCIgKyB2YWx1ZXNbXCIjXCJdIDogXCJcIik7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFVybE1hdGNoZXIuZW5jb2RlRGFzaGVzID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvLS9nLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gXCIlNUMlXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH0pO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gR2l2ZW4gYSBtYXRjaGVyLCByZXR1cm4gYW4gYXJyYXkgd2l0aCB0aGUgbWF0Y2hlcidzIHBhdGggc2VnbWVudHMgYW5kIHBhdGggcGFyYW1zLCBpbiBvcmRlciAqL1xuICAgIFVybE1hdGNoZXIucGF0aFNlZ21lbnRzQW5kUGFyYW1zID0gZnVuY3Rpb24gKG1hdGNoZXIpIHtcbiAgICAgICAgdmFyIHN0YXRpY1NlZ21lbnRzID0gbWF0Y2hlci5fc2VnbWVudHM7XG4gICAgICAgIHZhciBwYXRoUGFyYW1zID0gbWF0Y2hlci5fcGFyYW1zLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5sb2NhdGlvbiA9PT0gcGFyYW1fMS5EZWZUeXBlLlBBVEg7IH0pO1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuYXJyYXlUdXBsZXMoc3RhdGljU2VnbWVudHMsIHBhdGhQYXJhbXMuY29uY2F0KHVuZGVmaW5lZCkpXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAhPT0gXCJcIiAmJiBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHgpOyB9KTtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuIEdpdmVuIGEgbWF0Y2hlciwgcmV0dXJuIGFuIGFycmF5IHdpdGggdGhlIG1hdGNoZXIncyBxdWVyeSBwYXJhbXMgKi9cbiAgICBVcmxNYXRjaGVyLnF1ZXJ5UGFyYW1zID0gZnVuY3Rpb24gKG1hdGNoZXIpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIuX3BhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAubG9jYXRpb24gPT09IHBhcmFtXzEuRGVmVHlwZS5TRUFSQ0g7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcGFyZSB0d28gVXJsTWF0Y2hlcnNcbiAgICAgKlxuICAgICAqIFRoaXMgY29tcGFyaXNvbiBmdW5jdGlvbiBjb252ZXJ0cyBhIFVybE1hdGNoZXIgaW50byBzdGF0aWMgYW5kIGR5bmFtaWMgcGF0aCBzZWdtZW50cy5cbiAgICAgKiBFYWNoIHN0YXRpYyBwYXRoIHNlZ21lbnQgaXMgYSBzdGF0aWMgc3RyaW5nIGJldHdlZW4gYSBwYXRoIHNlcGFyYXRvciAoc2xhc2ggY2hhcmFjdGVyKS5cbiAgICAgKiBFYWNoIGR5bmFtaWMgc2VnbWVudCBpcyBhIHBhdGggcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogVGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gc29ydHMgc3RhdGljIHNlZ21lbnRzIGJlZm9yZSBkeW5hbWljIG9uZXMuXG4gICAgICovXG4gICAgVXJsTWF0Y2hlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFR1cm4gYSBVcmxNYXRjaGVyIGFuZCBhbGwgaXRzIHBhcmVudCBtYXRjaGVycyBpbnRvIGFuIGFycmF5XG4gICAgICAgICAqIG9mIHNsYXNoIGxpdGVyYWxzICcvJywgc3RyaW5nIGxpdGVyYWxzLCBhbmQgUGFyYW0gb2JqZWN0c1xuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGV4YW1wbGUgbWF0Y2hlciBtYXRjaGVzIHN0cmluZ3MgbGlrZSBcIi9mb28vOnBhcmFtL3RhaWxcIjpcbiAgICAgICAgICogdmFyIG1hdGNoZXIgPSAkdW1mLmNvbXBpbGUoXCIvZm9vXCIpLmFwcGVuZCgkdW1mLmNvbXBpbGUoXCIvOnBhcmFtXCIpKS5hcHBlbmQoJHVtZi5jb21waWxlKFwiL1wiKSkuYXBwZW5kKCR1bWYuY29tcGlsZShcInRhaWxcIikpO1xuICAgICAgICAgKiB2YXIgcmVzdWx0ID0gc2VnbWVudHMobWF0Y2hlcik7IC8vIFsgJy8nLCAnZm9vJywgJy8nLCBQYXJhbSwgJy8nLCAndGFpbCcgXVxuICAgICAgICAgKlxuICAgICAgICAgKiBDYWNoZXMgdGhlIHJlc3VsdCBhcyBgbWF0Y2hlci5fY2FjaGUuc2VnbWVudHNgXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgc2VnbWVudHMgPSBmdW5jdGlvbiAobWF0Y2hlcikge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIuX2NhY2hlLnNlZ21lbnRzID0gbWF0Y2hlci5fY2FjaGUuc2VnbWVudHMgfHxcbiAgICAgICAgICAgICAgICBtYXRjaGVyLl9jYWNoZS5wYXRoLm1hcChVcmxNYXRjaGVyLnBhdGhTZWdtZW50c0FuZFBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcbiAgICAgICAgICAgICAgICAgICAgLnJlZHVjZShzdHJpbmdzXzEuam9pbk5laWdoYm9yc1IsIFtdKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoeCkgPyBzcGxpdE9uU2xhc2goeCkgOiB4OyB9KVxuICAgICAgICAgICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHNvcnQgd2VpZ2h0IGZvciBlYWNoIHNlZ21lbnQgb2YgYSBVcmxNYXRjaGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIENhY2hlcyB0aGUgcmVzdWx0IGFzIGBtYXRjaGVyLl9jYWNoZS53ZWlnaHRzYFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHdlaWdodHMgPSBmdW5jdGlvbiAobWF0Y2hlcikge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIuX2NhY2hlLndlaWdodHMgPSBtYXRjaGVyLl9jYWNoZS53ZWlnaHRzIHx8XG4gICAgICAgICAgICAgICAgc2VnbWVudHMobWF0Y2hlcikubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNvcnQgc2xhc2hlcyBmaXJzdCwgdGhlbiBzdGF0aWMgc3RyaW5ncywgdGhlIFBhcmFtc1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudCA9PT0gJy8nKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc2VnbWVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQgaW5zdGFuY2VvZiBwYXJhbV8xLlBhcmFtKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYWRzIHNob3J0ZXIgYXJyYXkgaW4tcGxhY2UgKG11dGF0ZXMpXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgcGFkQXJyYXlzID0gZnVuY3Rpb24gKGwsIHIsIHBhZFZhbCkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IE1hdGgubWF4KGwubGVuZ3RoLCByLmxlbmd0aCk7XG4gICAgICAgICAgICB3aGlsZSAobC5sZW5ndGggPCBsZW4pXG4gICAgICAgICAgICAgICAgbC5wdXNoKHBhZFZhbCk7XG4gICAgICAgICAgICB3aGlsZSAoci5sZW5ndGggPCBsZW4pXG4gICAgICAgICAgICAgICAgci5wdXNoKHBhZFZhbCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB3ZWlnaHRzQSA9IHdlaWdodHMoYSksIHdlaWdodHNCID0gd2VpZ2h0cyhiKTtcbiAgICAgICAgcGFkQXJyYXlzKHdlaWdodHNBLCB3ZWlnaHRzQiwgMCk7XG4gICAgICAgIHZhciBjbXAsIGksIHBhaXJzID0gY29tbW9uXzEuYXJyYXlUdXBsZXMod2VpZ2h0c0EsIHdlaWdodHNCKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjbXAgPSBwYWlyc1tpXVswXSAtIHBhaXJzW2ldWzFdO1xuICAgICAgICAgICAgaWYgKGNtcCAhPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBVcmxNYXRjaGVyLm5hbWVWYWxpZGF0b3IgPSAvXlxcdysoWy0uXStcXHcrKSooPzpcXFtcXF0pPyQvO1xuICAgIHJldHVybiBVcmxNYXRjaGVyO1xufSgpKTtcbmV4cG9ydHMuVXJsTWF0Y2hlciA9IFVybE1hdGNoZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmxNYXRjaGVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsTWF0Y2hlci5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSB2YW5pbGxhXG4gKi8gLyoqICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKiBBIGJhc2UgYExvY2F0aW9uU2VydmljZXNgICovXG52YXIgQmFzZUxvY2F0aW9uU2VydmljZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZUxvY2F0aW9uU2VydmljZXMocm91dGVyLCBmaXJlQWZ0ZXJVcGRhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5maXJlQWZ0ZXJVcGRhdGUgPSBmaXJlQWZ0ZXJVcGRhdGU7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyID0gZnVuY3Rpb24gKGV2dCkgeyByZXR1cm4gX3RoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyByZXR1cm4gY2IoZXZ0KTsgfSk7IH07XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLmhhc2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLnBhcnNlVXJsKF90aGlzLl9nZXQoKSkuaGFzaDsgfTtcbiAgICAgICAgdGhpcy5wYXRoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5wYXJzZVVybChfdGhpcy5fZ2V0KCkpLnBhdGg7IH07XG4gICAgICAgIHRoaXMuc2VhcmNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5nZXRQYXJhbXModXRpbHNfMS5wYXJzZVVybChfdGhpcy5fZ2V0KCkpLnNlYXJjaCk7IH07XG4gICAgICAgIHRoaXMuX2xvY2F0aW9uID0gY29tbW9uXzEucm9vdC5sb2NhdGlvbjtcbiAgICAgICAgdGhpcy5faGlzdG9yeSA9IGNvbW1vbl8xLnJvb3QuaGlzdG9yeTtcbiAgICB9XG4gICAgQmFzZUxvY2F0aW9uU2VydmljZXMucHJvdG90eXBlLnVybCA9IGZ1bmN0aW9uICh1cmwsIHJlcGxhY2UpIHtcbiAgICAgICAgaWYgKHJlcGxhY2UgPT09IHZvaWQgMCkgeyByZXBsYWNlID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoY29tbW9uXzEuaXNEZWZpbmVkKHVybCkgJiYgdXJsICE9PSB0aGlzLl9nZXQoKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0KG51bGwsIG51bGwsIHVybCwgcmVwbGFjZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5maXJlQWZ0ZXJVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIGNiKHsgdXJsOiB1cmwgfSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsc18xLmJ1aWxkVXJsKHRoaXMpO1xuICAgIH07XG4gICAgQmFzZUxvY2F0aW9uU2VydmljZXMucHJvdG90eXBlLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGNiKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbW1vbl8xLnJlbW92ZUZyb20oX3RoaXMuX2xpc3RlbmVycywgY2IpOyB9O1xuICAgIH07XG4gICAgQmFzZUxvY2F0aW9uU2VydmljZXMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgICAgIGNvbW1vbl8xLmRlcmVnQWxsKHRoaXMuX2xpc3RlbmVycyk7XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZUxvY2F0aW9uU2VydmljZXM7XG59KCkpO1xuZXhwb3J0cy5CYXNlTG9jYXRpb25TZXJ2aWNlcyA9IEJhc2VMb2NhdGlvblNlcnZpY2VzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZUxvY2F0aW9uU2VydmljZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9iYXNlTG9jYXRpb25TZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMjRfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJ4anMvUmVwbGF5U3ViamVjdFwiXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMjVfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIkBhbmd1bGFyL3JvdXRlclwiXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgZ2xvYl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9nbG9iXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbi8qKlxuICogSW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBVSS1Sb3V0ZXIgc3RhdGUuXG4gKlxuICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIGNyZWF0ZWQgd2hlbiBhIFtbU3RhdGVEZWNsYXJhdGlvbl1dIGlzIHJlZ2lzdGVyZWQgd2l0aCB0aGUgW1tTdGF0ZVJlZ2lzdHJ5XV0uXG4gKlxuICogQSByZWdpc3RlcmVkIFtbU3RhdGVEZWNsYXJhdGlvbl1dIGlzIGF1Z21lbnRlZCB3aXRoIGEgZ2V0dGVyIChbW1N0YXRlRGVjbGFyYXRpb24uJCRzdGF0ZV1dKSB3aGljaCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIFtbU3RhdGVPYmplY3RdXSBvYmplY3QuXG4gKlxuICogVGhpcyBjbGFzcyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSB0aGUgY29ycmVzcG9uZGluZyBbW1N0YXRlRGVjbGFyYXRpb25dXS5cbiAqIEVhY2ggb2YgaXRzIG93biBwcm9wZXJ0aWVzIChpLmUuLCBgaGFzT3duUHJvcGVydHlgKSBhcmUgYnVpbHQgdXNpbmcgYnVpbGRlcnMgZnJvbSB0aGUgW1tTdGF0ZUJ1aWxkZXJdXS5cbiAqL1xudmFyIFN0YXRlT2JqZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgU3RhdGUuY3JlYXRlKCkgKi9cbiAgICBmdW5jdGlvbiBTdGF0ZU9iamVjdChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIFN0YXRlT2JqZWN0LmNyZWF0ZShjb25maWcgfHwge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzdGF0ZSBvYmplY3QgdG8gcHV0IHRoZSBwcml2YXRlL2ludGVybmFsIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb250by5cbiAgICAgKiBUaGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIGxvb2tzIGxpa2U6XG4gICAgICogKEludGVybmFsIFN0YXRlIE9iamVjdCkgLT4gKENvcHkgb2YgU3RhdGUucHJvdG90eXBlKSAtPiAoU3RhdGUgRGVjbGFyYXRpb24gb2JqZWN0KSAtPiAoU3RhdGUgRGVjbGFyYXRpb24ncyBwcm90b3R5cGUuLi4pXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGVEZWNsIHRoZSB1c2VyLXN1cHBsaWVkIFN0YXRlIERlY2xhcmF0aW9uXG4gICAgICogQHJldHVybnMge1N0YXRlT2JqZWN0fSBhbiBpbnRlcm5hbCBTdGF0ZSBvYmplY3RcbiAgICAgKi9cbiAgICBTdGF0ZU9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAoc3RhdGVEZWNsKSB7XG4gICAgICAgIHN0YXRlRGVjbCA9IFN0YXRlT2JqZWN0LmlzU3RhdGVDbGFzcyhzdGF0ZURlY2wpID8gbmV3IHN0YXRlRGVjbCgpIDogc3RhdGVEZWNsO1xuICAgICAgICB2YXIgc3RhdGUgPSBjb21tb25fMS5pbmhlcml0KGNvbW1vbl8xLmluaGVyaXQoc3RhdGVEZWNsLCBTdGF0ZU9iamVjdC5wcm90b3R5cGUpKTtcbiAgICAgICAgc3RhdGVEZWNsLiQkc3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGF0ZTsgfTtcbiAgICAgICAgc3RhdGUuc2VsZiA9IHN0YXRlRGVjbDtcbiAgICAgICAgc3RhdGUuX19zdGF0ZU9iamVjdENhY2hlID0ge1xuICAgICAgICAgICAgbmFtZUdsb2I6IGdsb2JfMS5HbG9iLmZyb21TdHJpbmcoc3RhdGUubmFtZSkgLy8gbWlnaHQgcmV0dXJuIG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgdGhlIHNhbWUgc3RhdGUuXG4gICAgICpcbiAgICAgKiBDb21wYXJlcyB0aGUgaWRlbnRpdHkgb2YgdGhlIHN0YXRlIGFnYWluc3QgdGhlIHBhc3NlZCB2YWx1ZSwgd2hpY2ggaXMgZWl0aGVyIGFuIG9iamVjdFxuICAgICAqIHJlZmVyZW5jZSB0byB0aGUgYWN0dWFsIGBTdGF0ZWAgaW5zdGFuY2UsIHRoZSBvcmlnaW5hbCBkZWZpbml0aW9uIG9iamVjdCBwYXNzZWQgdG9cbiAgICAgKiBgJHN0YXRlUHJvdmlkZXIuc3RhdGUoKWAsIG9yIHRoZSBmdWxseS1xdWFsaWZpZWQgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWYgQ2FuIGJlIG9uZSBvZiAoYSkgYSBgU3RhdGVgIGluc3RhbmNlLCAoYikgYW4gb2JqZWN0IHRoYXQgd2FzIHBhc3NlZFxuICAgICAqICAgICAgICBpbnRvIGAkc3RhdGVQcm92aWRlci5zdGF0ZSgpYCwgKGMpIHRoZSBmdWxseS1xdWFsaWZpZWQgbmFtZSBvZiBhIHN0YXRlIGFzIGEgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgYHRydWVgIGlmIGByZWZgIG1hdGNoZXMgdGhlIGN1cnJlbnQgYFN0YXRlYCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBTdGF0ZU9iamVjdC5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09PSByZWYgfHwgdGhpcy5zZWxmID09PSByZWYgfHwgdGhpcy5mcW4oKSA9PT0gcmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgdGhpcyBkb2VzIG5vdCBwcm9wZXJseSBoYW5kbGUgZG90IG5vdGF0aW9uXG4gICAgICogQHJldHVybnMgUmV0dXJucyBhIGRvdC1zZXBhcmF0ZWQgbmFtZSBvZiB0aGUgc3RhdGUuXG4gICAgICovXG4gICAgU3RhdGVPYmplY3QucHJvdG90eXBlLmZxbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCB8fCAhKHRoaXMucGFyZW50IGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvcikpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMucGFyZW50LmZxbigpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IG5hbWUgKyBcIi5cIiArIHRoaXMubmFtZSA6IHRoaXMubmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJvb3Qgbm9kZSBvZiB0aGlzIHN0YXRlJ3MgdHJlZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSByb290IG9mIHRoaXMgc3RhdGUncyB0cmVlLlxuICAgICAqL1xuICAgIFN0YXRlT2JqZWN0LnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucm9vdCgpIHx8IHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0ZSdzIGBQYXJhbWAgb2JqZWN0c1xuICAgICAqXG4gICAgICogR2V0cyB0aGUgbGlzdCBvZiBbW1BhcmFtXV0gb2JqZWN0cyBvd25lZCBieSB0aGUgc3RhdGUuXG4gICAgICogSWYgYG9wdHMuaW5oZXJpdGAgaXMgdHJ1ZSwgaXQgYWxzbyBpbmNsdWRlcyB0aGUgYW5jZXN0b3Igc3RhdGVzJyBbW1BhcmFtXV0gb2JqZWN0cy5cbiAgICAgKiBJZiBgb3B0cy5tYXRjaGluZ0tleXNgIGV4aXN0cywgcmV0dXJucyBvbmx5IGBQYXJhbWBzIHdob3NlIGBpZGAgaXMgYSBrZXkgb24gdGhlIGBtYXRjaGluZ0tleXNgIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgb3B0aW9uc1xuICAgICAqL1xuICAgIFN0YXRlT2JqZWN0LnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IGNvbW1vbl8xLmRlZmF1bHRzKG9wdHMsIHsgaW5oZXJpdDogdHJ1ZSwgbWF0Y2hpbmdLZXlzOiBudWxsIH0pO1xuICAgICAgICB2YXIgaW5oZXJpdGVkID0gb3B0cy5pbmhlcml0ICYmIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnBhcmFtZXRlcnMoKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIGluaGVyaXRlZC5jb25jYXQoY29tbW9uXzEudmFsdWVzKHRoaXMucGFyYW1zKSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiAhb3B0cy5tYXRjaGluZ0tleXMgfHwgb3B0cy5tYXRjaGluZ0tleXMuaGFzT3duUHJvcGVydHkocGFyYW0uaWQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzaW5nbGUgW1tQYXJhbV1dIHRoYXQgaXMgb3duZWQgYnkgdGhlIHN0YXRlXG4gICAgICpcbiAgICAgKiBJZiBgb3B0cy5pbmhlcml0YCBpcyB0cnVlLCBpdCBhbHNvIHNlYXJjaGVzIHRoZSBhbmNlc3RvciBzdGF0ZXNgIFtbUGFyYW1dXXMuXG4gICAgICogQHBhcmFtIGlkIHRoZSBuYW1lIG9mIHRoZSBbW1BhcmFtXV0gdG8gcmV0dXJuXG4gICAgICogQHBhcmFtIG9wdHMgb3B0aW9uc1xuICAgICAqL1xuICAgIFN0YXRlT2JqZWN0LnByb3RvdHlwZS5wYXJhbWV0ZXIgPSBmdW5jdGlvbiAoaWQsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cbiAgICAgICAgcmV0dXJuICh0aGlzLnVybCAmJiB0aGlzLnVybC5wYXJhbWV0ZXIoaWQsIG9wdHMpIHx8XG4gICAgICAgICAgICBjb21tb25fMS5maW5kKGNvbW1vbl8xLnZhbHVlcyh0aGlzLnBhcmFtcyksIGhvZl8xLnByb3BFcSgnaWQnLCBpZCkpIHx8XG4gICAgICAgICAgICBvcHRzLmluaGVyaXQgJiYgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucGFyYW1ldGVyKGlkKSk7XG4gICAgfTtcbiAgICBTdGF0ZU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZxbigpO1xuICAgIH07XG4gICAgLyoqIFByZWRpY2F0ZSB3aGljaCByZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhbiBjbGFzcyB3aXRoIEBTdGF0ZSgpIGRlY29yYXRvciAqL1xuICAgIFN0YXRlT2JqZWN0LmlzU3RhdGVDbGFzcyA9IGZ1bmN0aW9uIChzdGF0ZURlY2wpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKHN0YXRlRGVjbCkgJiYgc3RhdGVEZWNsWydfX3VpUm91dGVyU3RhdGUnXSA9PT0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKiBQcmVkaWNhdGUgd2hpY2ggcmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYW4gaW50ZXJuYWwgW1tTdGF0ZU9iamVjdF1dIG9iamVjdCAqL1xuICAgIFN0YXRlT2JqZWN0LmlzU3RhdGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNPYmplY3Qob2JqWydfX3N0YXRlT2JqZWN0Q2FjaGUnXSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVPYmplY3Q7XG59KCkpO1xuZXhwb3J0cy5TdGF0ZU9iamVjdCA9IFN0YXRlT2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVPYmplY3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBjb21tb25cbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBRdWV1ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWV1ZShfaXRlbXMsIF9saW1pdCkge1xuICAgICAgICBpZiAoX2l0ZW1zID09PSB2b2lkIDApIHsgX2l0ZW1zID0gW107IH1cbiAgICAgICAgaWYgKF9saW1pdCA9PT0gdm9pZCAwKSB7IF9saW1pdCA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5faXRlbXMgPSBfaXRlbXM7XG4gICAgICAgIHRoaXMuX2xpbWl0ID0gX2xpbWl0O1xuICAgIH1cbiAgICBRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMuX2l0ZW1zO1xuICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICBpZiAodGhpcy5fbGltaXQgJiYgaXRlbXMubGVuZ3RoID4gdGhpcy5fbGltaXQpXG4gICAgICAgICAgICBpdGVtcy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuICAgIFF1ZXVlLnByb3RvdHlwZS5kZXF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zaXplKCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMuc3BsaWNlKDAsIDEpWzBdO1xuICAgIH07XG4gICAgUXVldWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2l0ZW1zO1xuICAgICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9O1xuICAgIFF1ZXVlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoO1xuICAgIH07XG4gICAgUXVldWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgICByZXR1cm4gaWR4ID4gLTEgJiYgdGhpcy5faXRlbXMuc3BsaWNlKGlkeCwgMSlbMF07XG4gICAgfTtcbiAgICBRdWV1ZS5wcm90b3R5cGUucGVla1RhaWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtc1t0aGlzLl9pdGVtcy5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIFF1ZXVlLnByb3RvdHlwZS5wZWVrSGVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSgpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zWzBdO1xuICAgIH07XG4gICAgcmV0dXJuIFF1ZXVlO1xufSgpKTtcbmV4cG9ydHMuUXVldWUgPSBRdWV1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXVlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9jb21tb24vcXVldWUuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSB0cmFuc2l0aW9uXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2VcIik7IC8vIGhhcyBvciBpcyB1c2luZ1xudmFyIGdsb2JfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vZ2xvYlwiKTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gc3RhdGUgbWF0Y2hlcyB0aGUgbWF0Y2hDcml0ZXJpYVxuICpcbiAqIEBoaWRkZW5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgYSBTdGF0ZSBPYmplY3QgdG8gdGVzdCBhZ2FpbnN0XG4gKiBAcGFyYW0gY3JpdGVyaW9uXG4gKiAtIElmIGEgc3RyaW5nLCBtYXRjaFN0YXRlIHVzZXMgdGhlIHN0cmluZyBhcyBhIGdsb2ItbWF0Y2hlciBhZ2FpbnN0IHRoZSBzdGF0ZSBuYW1lXG4gKiAtIElmIGFuIGFycmF5IChvZiBzdHJpbmdzKSwgbWF0Y2hTdGF0ZSB1c2VzIGVhY2ggc3RyaW5nIGluIHRoZSBhcnJheSBhcyBhIGdsb2ItbWF0Y2hlcnMgYWdhaW5zdCB0aGUgc3RhdGUgbmFtZVxuICogICBhbmQgcmV0dXJucyBhIHBvc2l0aXZlIG1hdGNoIGlmIGFueSBvZiB0aGUgZ2xvYnMgbWF0Y2guXG4gKiAtIElmIGEgZnVuY3Rpb24sIG1hdGNoU3RhdGUgY2FsbHMgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIHN0YXRlIGFuZCByZXR1cm5zIHRydWUgaWYgdGhlIGZ1bmN0aW9uJ3MgcmVzdWx0IGlzIHRydXRoeS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBtYXRjaFN0YXRlKHN0YXRlLCBjcml0ZXJpb24pIHtcbiAgICB2YXIgdG9NYXRjaCA9IHByZWRpY2F0ZXNfMS5pc1N0cmluZyhjcml0ZXJpb24pID8gW2NyaXRlcmlvbl0gOiBjcml0ZXJpb247XG4gICAgZnVuY3Rpb24gbWF0Y2hHbG9icyhfc3RhdGUpIHtcbiAgICAgICAgdmFyIGdsb2JTdHJpbmdzID0gdG9NYXRjaDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbG9iU3RyaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGdsb2IgPSBuZXcgZ2xvYl8xLkdsb2IoZ2xvYlN0cmluZ3NbaV0pO1xuICAgICAgICAgICAgaWYgKChnbG9iICYmIGdsb2IubWF0Y2hlcyhfc3RhdGUubmFtZSkpIHx8ICghZ2xvYiAmJiBnbG9iU3RyaW5nc1tpXSA9PT0gX3N0YXRlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbWF0Y2hGbiA9IChwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbih0b01hdGNoKSA/IHRvTWF0Y2ggOiBtYXRjaEdsb2JzKTtcbiAgICByZXR1cm4gISFtYXRjaEZuKHN0YXRlKTtcbn1cbmV4cG9ydHMubWF0Y2hTdGF0ZSA9IG1hdGNoU3RhdGU7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogVGhlIHJlZ2lzdHJhdGlvbiBkYXRhIGZvciBhIHJlZ2lzdGVyZWQgdHJhbnNpdGlvbiBob29rXG4gKi9cbnZhciBSZWdpc3RlcmVkSG9vayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWdpc3RlcmVkSG9vayh0cmFuU3ZjLCBldmVudFR5cGUsIGNhbGxiYWNrLCBtYXRjaENyaXRlcmlhLCByZW1vdmVIb29rRnJvbVJlZ2lzdHJ5LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRoaXMudHJhblN2YyA9IHRyYW5TdmM7XG4gICAgICAgIHRoaXMuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMubWF0Y2hDcml0ZXJpYSA9IG1hdGNoQ3JpdGVyaWE7XG4gICAgICAgIHRoaXMucmVtb3ZlSG9va0Zyb21SZWdpc3RyeSA9IHJlbW92ZUhvb2tGcm9tUmVnaXN0cnk7XG4gICAgICAgIHRoaXMuaW52b2tlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLl9kZXJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IG9wdGlvbnMucHJpb3JpdHkgfHwgMDtcbiAgICAgICAgdGhpcy5iaW5kID0gb3B0aW9ucy5iaW5kIHx8IG51bGw7XG4gICAgICAgIHRoaXMuaW52b2tlTGltaXQgPSBvcHRpb25zLmludm9rZUxpbWl0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXRjaGluZyBbW1BhdGhOb2RlXV1zXG4gICAgICpcbiAgICAgKiBHaXZlbiBhbiBhcnJheSBvZiBbW1BhdGhOb2RlXV1zLCBhbmQgYSBbW0hvb2tNYXRjaENyaXRlcmlvbl1dLCByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmdcbiAgICAgKiB0aGUgW1tQYXRoTm9kZV1dcyB0aGF0IHRoZSBjcml0ZXJpYSBtYXRjaGVzLCBvciBgbnVsbGAgaWYgdGhlcmUgd2VyZSBubyBtYXRjaGluZyBub2Rlcy5cbiAgICAgKlxuICAgICAqIFJldHVybmluZyBgbnVsbGAgaXMgc2lnbmlmaWNhbnQgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgZGVmYXVsdFxuICAgICAqIFwibWF0Y2gtYWxsIGNyaXRlcmlvbiB2YWx1ZVwiIG9mIGB0cnVlYCBjb21wYXJlZCB0byBhIGAoKSA9PiB0cnVlYCBmdW5jdGlvbixcbiAgICAgKiB3aGVuIHRoZSBub2RlcyBpcyBhbiBlbXB0eSBhcnJheS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIHRvIGFsbG93IGEgdHJhbnNpdGlvbiBtYXRjaCBjcml0ZXJpYSBvZiBgZW50ZXJpbmc6IHRydWVgXG4gICAgICogdG8gc3RpbGwgbWF0Y2ggYSB0cmFuc2l0aW9uLCBldmVuIHdoZW4gYGVudGVyaW5nID09PSBbXWAuICBDb250cmFzdCB0aGF0XG4gICAgICogd2l0aCBgZW50ZXJpbmc6IChzdGF0ZSkgPT4gdHJ1ZWAgd2hpY2ggb25seSBtYXRjaGVzIHdoZW4gYSBzdGF0ZSBpcyBhY3R1YWxseVxuICAgICAqIGJlaW5nIGVudGVyZWQuXG4gICAgICovXG4gICAgUmVnaXN0ZXJlZEhvb2sucHJvdG90eXBlLl9tYXRjaGluZ05vZGVzID0gZnVuY3Rpb24gKG5vZGVzLCBjcml0ZXJpb24pIHtcbiAgICAgICAgaWYgKGNyaXRlcmlvbiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgdmFyIG1hdGNoaW5nID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBtYXRjaFN0YXRlKG5vZGUuc3RhdGUsIGNyaXRlcmlvbik7IH0pO1xuICAgICAgICByZXR1cm4gbWF0Y2hpbmcubGVuZ3RoID8gbWF0Y2hpbmcgOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCBtYXRjaCBjcml0ZXJpYSAoYWxsIGB0cnVlYClcbiAgICAgKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHdoaWNoIGhhcyBhbGwgdGhlIGNyaXRlcmlhIG1hdGNoIHBhdGhzIGFzIGtleXMgYW5kIGB0cnVlYCBhcyB2YWx1ZXMsIGkuZS46XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIHtcbiAgICAgKiAgIHRvOiB0cnVlLFxuICAgICAqICAgZnJvbTogdHJ1ZSxcbiAgICAgKiAgIGVudGVyaW5nOiB0cnVlLFxuICAgICAqICAgZXhpdGluZzogdHJ1ZSxcbiAgICAgKiAgIHJldGFpbmVkOiB0cnVlLFxuICAgICAqIH1cbiAgICAgKi9cbiAgICBSZWdpc3RlcmVkSG9vay5wcm90b3R5cGUuX2dldERlZmF1bHRNYXRjaENyaXRlcmlhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEubWFwKHRoaXMudHJhblN2Yy5fcGx1Z2luYXBpLl9nZXRQYXRoVHlwZXMoKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIG1hdGNoaW5nIG5vZGVzIGFzIFtbSU1hdGNoaW5nTm9kZXNdXVxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgSU1hdGNoaW5nTm9kZXMgb2JqZWN0IGZyb20gdGhlIFRyYW5zaXRpb25Ib29rVHlwZXMgdGhhdCBpcyByb3VnaGx5IGVxdWl2YWxlbnQgdG86XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGxldCBtYXRjaGVzOiBJTWF0Y2hpbmdOb2RlcyA9IHtcbiAgICAgKiAgIHRvOiAgICAgICBfbWF0Y2hpbmdOb2RlcyhbdGFpbCh0cmVlQ2hhbmdlcy50byldLCAgIG1jLnRvKSxcbiAgICAgKiAgIGZyb206ICAgICBfbWF0Y2hpbmdOb2RlcyhbdGFpbCh0cmVlQ2hhbmdlcy5mcm9tKV0sIG1jLmZyb20pLFxuICAgICAqICAgZXhpdGluZzogIF9tYXRjaGluZ05vZGVzKHRyZWVDaGFuZ2VzLmV4aXRpbmcsICAgICAgbWMuZXhpdGluZyksXG4gICAgICogICByZXRhaW5lZDogX21hdGNoaW5nTm9kZXModHJlZUNoYW5nZXMucmV0YWluZWQsICAgICBtYy5yZXRhaW5lZCksXG4gICAgICogICBlbnRlcmluZzogX21hdGNoaW5nTm9kZXModHJlZUNoYW5nZXMuZW50ZXJpbmcsICAgICBtYy5lbnRlcmluZyksXG4gICAgICogfTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBSZWdpc3RlcmVkSG9vay5wcm90b3R5cGUuX2dldE1hdGNoaW5nTm9kZXMgPSBmdW5jdGlvbiAodHJlZUNoYW5nZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNyaXRlcmlhID0gY29tbW9uXzEuZXh0ZW5kKHRoaXMuX2dldERlZmF1bHRNYXRjaENyaXRlcmlhKCksIHRoaXMubWF0Y2hDcml0ZXJpYSk7XG4gICAgICAgIHZhciBwYXRocyA9IGNvbW1vbl8xLnZhbHVlcyh0aGlzLnRyYW5TdmMuX3BsdWdpbmFwaS5fZ2V0UGF0aFR5cGVzKCkpO1xuICAgICAgICByZXR1cm4gcGF0aHMucmVkdWNlKGZ1bmN0aW9uIChtbiwgcGF0aHR5cGUpIHtcbiAgICAgICAgICAgIC8vIFNUQVRFIHNjb3BlIGNyaXRlcmlhIG1hdGNoZXMgYWdhaW5zdCBldmVyeSBub2RlIGluIHRoZSBwYXRoLlxuICAgICAgICAgICAgLy8gVFJBTlNJVElPTiBzY29wZSBjcml0ZXJpYSBtYXRjaGVzIGFnYWluc3Qgb25seSB0aGUgbGFzdCBub2RlIGluIHRoZSBwYXRoXG4gICAgICAgICAgICB2YXIgaXNTdGF0ZUhvb2sgPSBwYXRodHlwZS5zY29wZSA9PT0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tTY29wZS5TVEFURTtcbiAgICAgICAgICAgIHZhciBwYXRoID0gdHJlZUNoYW5nZXNbcGF0aHR5cGUubmFtZV0gfHwgW107XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSBpc1N0YXRlSG9vayA/IHBhdGggOiBbY29tbW9uXzEudGFpbChwYXRoKV07XG4gICAgICAgICAgICBtbltwYXRodHlwZS5uYW1lXSA9IF90aGlzLl9tYXRjaGluZ05vZGVzKG5vZGVzLCBjcml0ZXJpYVtwYXRodHlwZS5uYW1lXSk7XG4gICAgICAgICAgICByZXR1cm4gbW47XG4gICAgICAgIH0sIHt9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhpcyBob29rJ3MgW1ttYXRjaENyaXRlcmlhXV0gbWF0Y2ggdGhlIGdpdmVuIFtbVHJlZUNoYW5nZXNdXVxuICAgICAqXG4gICAgICogQHJldHVybnMgYW4gSU1hdGNoaW5nTm9kZXMgb2JqZWN0LCBvciBudWxsLiBJZiBhbiBJTWF0Y2hpbmdOb2RlcyBvYmplY3QgaXMgcmV0dXJuZWQsIGl0cyB2YWx1ZXNcbiAgICAgKiBhcmUgdGhlIG1hdGNoaW5nIFtbUGF0aE5vZGVdXXMgZm9yIGVhY2ggW1tIb29rTWF0Y2hDcml0ZXJpb25dXSAodG8sIGZyb20sIGV4aXRpbmcsIHJldGFpbmVkLCBlbnRlcmluZylcbiAgICAgKi9cbiAgICBSZWdpc3RlcmVkSG9vay5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uICh0cmVlQ2hhbmdlcykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IHRoaXMuX2dldE1hdGNoaW5nTm9kZXModHJlZUNoYW5nZXMpO1xuICAgICAgICAvLyBDaGVjayBpZiBhbGwgdGhlIGNyaXRlcmlhIG1hdGNoZWQgdGhlIFRyZWVDaGFuZ2VzIG9iamVjdFxuICAgICAgICB2YXIgYWxsTWF0Y2hlZCA9IGNvbW1vbl8xLnZhbHVlcyhtYXRjaGVzKS5ldmVyeShjb21tb25fMS5pZGVudGl0eSk7XG4gICAgICAgIHJldHVybiBhbGxNYXRjaGVkID8gbWF0Y2hlcyA6IG51bGw7XG4gICAgfTtcbiAgICBSZWdpc3RlcmVkSG9vay5wcm90b3R5cGUuZGVyZWdpc3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVIb29rRnJvbVJlZ2lzdHJ5KHRoaXMpO1xuICAgICAgICB0aGlzLl9kZXJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZ2lzdGVyZWRIb29rO1xufSgpKTtcbmV4cG9ydHMuUmVnaXN0ZXJlZEhvb2sgPSBSZWdpc3RlcmVkSG9vaztcbi8qKiBAaGlkZGVuIFJldHVybiBhIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbiBvZiB0aGUgcmVxdWVzdGVkIHR5cGUuICovXG5mdW5jdGlvbiBtYWtlRXZlbnQocmVnaXN0cnksIHRyYW5zaXRpb25TZXJ2aWNlLCBldmVudFR5cGUpIHtcbiAgICAvLyBDcmVhdGUgdGhlIG9iamVjdCB3aGljaCBob2xkcyB0aGUgcmVnaXN0ZXJlZCB0cmFuc2l0aW9uIGhvb2tzLlxuICAgIHZhciBfcmVnaXN0ZXJlZEhvb2tzID0gcmVnaXN0cnkuX3JlZ2lzdGVyZWRIb29rcyA9IChyZWdpc3RyeS5fcmVnaXN0ZXJlZEhvb2tzIHx8IHt9KTtcbiAgICB2YXIgaG9va3MgPSBfcmVnaXN0ZXJlZEhvb2tzW2V2ZW50VHlwZS5uYW1lXSA9IFtdO1xuICAgIHZhciByZW1vdmVIb29rRm4gPSBjb21tb25fMS5yZW1vdmVGcm9tKGhvb2tzKTtcbiAgICAvLyBDcmVhdGUgaG9vayByZWdpc3RyYXRpb24gZnVuY3Rpb24gb24gdGhlIElIb29rUmVnaXN0cnkgZm9yIHRoZSBldmVudFxuICAgIHJlZ2lzdHJ5W2V2ZW50VHlwZS5uYW1lXSA9IGhvb2tSZWdpc3RyYXRpb25GbjtcbiAgICBmdW5jdGlvbiBob29rUmVnaXN0cmF0aW9uRm4obWF0Y2hPYmplY3QsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciByZWdpc3RlcmVkSG9vayA9IG5ldyBSZWdpc3RlcmVkSG9vayh0cmFuc2l0aW9uU2VydmljZSwgZXZlbnRUeXBlLCBjYWxsYmFjaywgbWF0Y2hPYmplY3QsIHJlbW92ZUhvb2tGbiwgb3B0aW9ucyk7XG4gICAgICAgIGhvb2tzLnB1c2gocmVnaXN0ZXJlZEhvb2spO1xuICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZEhvb2suZGVyZWdpc3Rlci5iaW5kKHJlZ2lzdGVyZWRIb29rKTtcbiAgICB9XG4gICAgcmV0dXJuIGhvb2tSZWdpc3RyYXRpb25Gbjtcbn1cbmV4cG9ydHMubWFrZUV2ZW50ID0gbWFrZUV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9va1JlZ2lzdHJ5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL2hvb2tSZWdpc3RyeS5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQG1vZHVsZSBwYXRoICovIC8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciBwYXJhbV8xID0gcmVxdWlyZShcIi4uL3BhcmFtcy9wYXJhbVwiKTtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKlxuICogQSBub2RlIGluIGEgW1tUcmVlQ2hhbmdlc11dIHBhdGhcbiAqXG4gKiBGb3IgYSBbW1RyZWVDaGFuZ2VzXV0gcGF0aCwgdGhpcyBjbGFzcyBob2xkcyB0aGUgc3RhdGVmdWwgaW5mb3JtYXRpb24gZm9yIGEgc2luZ2xlIG5vZGUgaW4gdGhlIHBhdGguXG4gKiBFYWNoIFBhdGhOb2RlIGNvcnJlc3BvbmRzIHRvIGEgc3RhdGUgYmVpbmcgZW50ZXJlZCwgZXhpdGVkLCBvciByZXRhaW5lZC5cbiAqIFRoZSBzdGF0ZWZ1bCBpbmZvcm1hdGlvbiBpbmNsdWRlcyBwYXJhbWV0ZXIgdmFsdWVzIGFuZCByZXNvbHZlIGRhdGEuXG4gKi9cbnZhciBQYXRoTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXRoTm9kZShzdGF0ZU9yTm9kZSkge1xuICAgICAgICBpZiAoc3RhdGVPck5vZGUgaW5zdGFuY2VvZiBQYXRoTm9kZSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGF0ZU9yTm9kZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBub2RlLnN0YXRlO1xuICAgICAgICAgICAgdGhpcy5wYXJhbVNjaGVtYSA9IG5vZGUucGFyYW1TY2hlbWEuc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMucGFyYW1WYWx1ZXMgPSBjb21tb25fMS5leHRlbmQoe30sIG5vZGUucGFyYW1WYWx1ZXMpO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZhYmxlcyA9IG5vZGUucmVzb2x2YWJsZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMudmlld3MgPSBub2RlLnZpZXdzICYmIG5vZGUudmlld3Muc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0YXRlT3JOb2RlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgdGhpcy5wYXJhbVNjaGVtYSA9IHN0YXRlLnBhcmFtZXRlcnMoeyBpbmhlcml0OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHRoaXMucGFyYW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2YWJsZXMgPSBzdGF0ZS5yZXNvbHZhYmxlcy5tYXAoZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcmVzLmNsb25lKCk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBTZXRzIFtbcGFyYW1WYWx1ZXNdXSBmb3IgdGhlIG5vZGUsIGZyb20gdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QgaGFzaCAqL1xuICAgIFBhdGhOb2RlLnByb3RvdHlwZS5hcHBseVJhd1BhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIGdldFBhcmFtVmFsID0gZnVuY3Rpb24gKHBhcmFtRGVmKSB7IHJldHVybiBbcGFyYW1EZWYuaWQsIHBhcmFtRGVmLnZhbHVlKHBhcmFtc1twYXJhbURlZi5pZF0pXTsgfTtcbiAgICAgICAgdGhpcy5wYXJhbVZhbHVlcyA9IHRoaXMucGFyYW1TY2hlbWEucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBwRGVmKSB7IHJldHVybiBjb21tb25fMS5hcHBseVBhaXJzKG1lbW8sIGdldFBhcmFtVmFsKHBEZWYpKTsgfSwge30pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBHZXRzIGEgc3BlY2lmaWMgW1tQYXJhbV1dIG1ldGFkYXRhIHRoYXQgYmVsb25ncyB0byB0aGUgbm9kZSAqL1xuICAgIFBhdGhOb2RlLnByb3RvdHlwZS5wYXJhbWV0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuZmluZCh0aGlzLnBhcmFtU2NoZW1hLCBob2ZfMS5wcm9wRXEoXCJpZFwiLCBuYW1lKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBzdGF0ZSBhbmQgcGFyYW1ldGVyIHZhbHVlcyBmb3IgYW5vdGhlciBQYXRoTm9kZSBhcmVcbiAgICAgKiBlcXVhbCB0byB0aGUgc3RhdGUgYW5kIHBhcmFtIHZhbHVlcyBmb3IgdGhpcyBQYXRoTm9kZVxuICAgICAqL1xuICAgIFBhdGhOb2RlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAobm9kZSwgcGFyYW1zRm4pIHtcbiAgICAgICAgdmFyIGRpZmYgPSB0aGlzLmRpZmYobm9kZSwgcGFyYW1zRm4pO1xuICAgICAgICByZXR1cm4gZGlmZiAmJiBkaWZmLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbmRzIFBhcmFtcyB3aXRoIGRpZmZlcmVudCBwYXJhbWV0ZXIgdmFsdWVzIG9uIGFub3RoZXIgUGF0aE5vZGUuXG4gICAgICpcbiAgICAgKiBHaXZlbiBhbm90aGVyIG5vZGUgKG9mIHRoZSBzYW1lIHN0YXRlKSwgZmluZHMgdGhlIHBhcmFtZXRlciB2YWx1ZXMgd2hpY2ggZGlmZmVyLlxuICAgICAqIFJldHVybnMgdGhlIFtbUGFyYW1dXSAoc2NoZW1hIG9iamVjdHMpIHdob3NlIHBhcmFtZXRlciB2YWx1ZXMgZGlmZmVyLlxuICAgICAqXG4gICAgICogR2l2ZW4gYW5vdGhlciBub2RlIGZvciBhIGRpZmZlcmVudCBzdGF0ZSwgcmV0dXJucyBgZmFsc2VgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBjb21wYXJlIHRvXG4gICAgICogQHBhcmFtIHBhcmFtc0ZuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHdoaWNoIHBhcmFtZXRlcnMgc2hvdWxkIGJlIGNvbXBhcmVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBbW1BhcmFtXV1zIHdoaWNoIGRpZmZlciwgb3IgbnVsbCBpZiB0aGUgdHdvIG5vZGVzIGFyZSBmb3IgZGlmZmVyZW50IHN0YXRlc1xuICAgICAqL1xuICAgIFBhdGhOb2RlLnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gKG5vZGUsIHBhcmFtc0ZuKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBub2RlLnN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgcGFyYW1zID0gcGFyYW1zRm4gPyBwYXJhbXNGbih0aGlzKSA6IHRoaXMucGFyYW1TY2hlbWE7XG4gICAgICAgIHJldHVybiBwYXJhbV8xLlBhcmFtLmNoYW5nZWQocGFyYW1zLCB0aGlzLnBhcmFtVmFsdWVzLCBub2RlLnBhcmFtVmFsdWVzKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFBhdGhOb2RlICovXG4gICAgUGF0aE5vZGUuY2xvbmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhdGhOb2RlKG5vZGUpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhdGhOb2RlO1xufSgpKTtcbmV4cG9ydHMuUGF0aE5vZGUgPSBQYXRoTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGhOb2RlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9wYXRoL3BhdGhOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgcGFyYW1zXG4gKi9cbi8qKiAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xuLyoqXG4gKiBBbiBpbnRlcm5hbCBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIFtbUGFyYW1UeXBlRGVmaW5pdGlvbl1dLlxuICpcbiAqIEEgW1tQYXJhbVR5cGVEZWZpbml0aW9uXV0gaXMgYSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdCB1c2VkIHRvIHJlZ2lzdGVyIGN1c3RvbSBwYXJhbWV0ZXIgdHlwZXMuXG4gKiBXaGVuIGEgcGFyYW0gdHlwZSBkZWZpbml0aW9uIGlzIHJlZ2lzdGVyZWQsIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgaXMgY3JlYXRlZCBpbnRlcm5hbGx5LlxuICpcbiAqIFRoaXMgY2xhc3MgaGFzIG5haXZlIGltcGxlbWVudGF0aW9ucyBmb3IgYWxsIHRoZSBbW1BhcmFtVHlwZURlZmluaXRpb25dXSBtZXRob2RzLlxuICpcbiAqIFVzZWQgYnkgW1tVcmxNYXRjaGVyXV0gd2hlbiBtYXRjaGluZyBvciBmb3JtYXR0aW5nIFVSTHMsIG9yIGNvbXBhcmluZyBhbmQgdmFsaWRhdGluZyBwYXJhbWV0ZXIgdmFsdWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiB2YXIgcGFyYW1UeXBlRGVmID0ge1xuICogICBkZWNvZGU6IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7IH0sXG4gKiAgIGVuY29kZTogZnVuY3Rpb24odmFsKSB7IHJldHVybiB2YWwgJiYgdmFsLnRvU3RyaW5nKCk7IH0sXG4gKiAgIGVxdWFsczogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gdGhpcy5pcyhhKSAmJiBhID09PSBiOyB9LFxuICogICBpczogZnVuY3Rpb24odmFsKSB7IHJldHVybiBhbmd1bGFyLmlzTnVtYmVyKHZhbCkgJiYgaXNGaW5pdGUodmFsKSAmJiB2YWwgJSAxID09PSAwOyB9LFxuICogICBwYXR0ZXJuOiAvXFxkKy9cbiAqIH1cbiAqXG4gKiB2YXIgcGFyYW1UeXBlID0gbmV3IFBhcmFtVHlwZShwYXJhbVR5cGVEZWYpO1xuICogYGBgXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xudmFyIFBhcmFtVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGVmICBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBjdXN0b20gdHlwZSBkZWZpbml0aW9uLiAgVGhlIG9iamVjdCdzXG4gICAgICogICAgICAgIHByb3BlcnRpZXMgd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBtZXRob2RzIGFuZC9vciBwYXR0ZXJuIGluIGBQYXJhbVR5cGVgJ3MgcHVibGljIGludGVyZmFjZS5cbiAgICAgKiBAcmV0dXJucyBhIG5ldyBQYXJhbVR5cGUgb2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyYW1UeXBlKGRlZikge1xuICAgICAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gLy4qLztcbiAgICAgICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgICAgIHRoaXMuaW5oZXJpdCA9IHRydWU7XG4gICAgICAgIGNvbW1vbl8xLmV4dGVuZCh0aGlzLCBkZWYpO1xuICAgIH1cbiAgICAvLyBjb25zaWRlciB0aGVzZSBmb3VyIG1ldGhvZHMgdG8gYmUgXCJhYnN0cmFjdCBtZXRob2RzXCIgdGhhdCBzaG91bGQgYmUgb3ZlcnJpZGRlblxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFBhcmFtVHlwZS5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbiAodmFsLCBrZXkpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgUGFyYW1UeXBlLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAodmFsLCBrZXkpIHsgcmV0dXJuIHZhbDsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBQYXJhbVR5cGUucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uICh2YWwsIGtleSkgeyByZXR1cm4gdmFsOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFBhcmFtVHlwZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgPT0gYjsgfTtcbiAgICBQYXJhbVR5cGUucHJvdG90eXBlLiRzdWJQYXR0ZXJuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3ViID0gdGhpcy5wYXR0ZXJuLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBzdWIuc3Vic3RyKDEsIHN1Yi5sZW5ndGggLSAyKTtcbiAgICB9O1xuICAgIFBhcmFtVHlwZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIntQYXJhbVR5cGU6XCIgKyB0aGlzLm5hbWUgKyBcIn1cIjtcbiAgICB9O1xuICAgIC8qKiBHaXZlbiBhbiBlbmNvZGVkIHN0cmluZywgb3IgYSBkZWNvZGVkIG9iamVjdCwgcmV0dXJucyBhIGRlY29kZWQgb2JqZWN0ICovXG4gICAgUGFyYW1UeXBlLnByb3RvdHlwZS4kbm9ybWFsaXplID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pcyh2YWwpID8gdmFsIDogdGhpcy5kZWNvZGUodmFsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdyYXBzIGFuIGV4aXN0aW5nIGN1c3RvbSBQYXJhbVR5cGUgYXMgYW4gYXJyYXkgb2YgUGFyYW1UeXBlLCBkZXBlbmRpbmcgb24gJ21vZGUnLlxuICAgICAqIGUuZy46XG4gICAgICogLSB1cmxtYXRjaGVyIHBhdHRlcm4gXCIvcGF0aD97cXVlcnlQYXJhbVtdOmludH1cIlxuICAgICAqIC0gdXJsOiBcIi9wYXRoP3F1ZXJ5UGFyYW09MSZxdWVyeVBhcmFtPTJcbiAgICAgKiAtICRzdGF0ZVBhcmFtcy5xdWVyeVBhcmFtIHdpbGwgYmUgWzEsIDJdXG4gICAgICogaWYgYG1vZGVgIGlzIFwiYXV0b1wiLCB0aGVuXG4gICAgICogLSB1cmw6IFwiL3BhdGg/cXVlcnlQYXJhbT0xIHdpbGwgY3JlYXRlICRzdGF0ZVBhcmFtcy5xdWVyeVBhcmFtOiAxXG4gICAgICogLSB1cmw6IFwiL3BhdGg/cXVlcnlQYXJhbT0xJnF1ZXJ5UGFyYW09MiB3aWxsIGNyZWF0ZSAkc3RhdGVQYXJhbXMucXVlcnlQYXJhbTogWzEsIDJdXG4gICAgICovXG4gICAgUGFyYW1UeXBlLnByb3RvdHlwZS4kYXNBcnJheSA9IGZ1bmN0aW9uIChtb2RlLCBpc1NlYXJjaCkge1xuICAgICAgICBpZiAoIW1vZGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKG1vZGUgPT09IFwiYXV0b1wiICYmICFpc1NlYXJjaClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidhdXRvJyBhcnJheSBtb2RlIGlzIGZvciBxdWVyeSBwYXJhbWV0ZXJzIG9ubHlcIik7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlUeXBlKHRoaXMsIG1vZGUpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcmFtVHlwZTtcbn0oKSk7XG5leHBvcnRzLlBhcmFtVHlwZSA9IFBhcmFtVHlwZTtcbi8qKlxuICogV3JhcHMgdXAgYSBgUGFyYW1UeXBlYCBvYmplY3QgdG8gaGFuZGxlIGFycmF5IHZhbHVlcy5cbiAqIEBpbnRlcm5hbGFwaVxuICovXG5mdW5jdGlvbiBBcnJheVR5cGUodHlwZSwgbW9kZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgLy8gV3JhcCBub24tYXJyYXkgdmFsdWUgYXMgYXJyYXlcbiAgICBmdW5jdGlvbiBhcnJheVdyYXAodmFsKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNBcnJheSh2YWwpID8gdmFsIDogKHByZWRpY2F0ZXNfMS5pc0RlZmluZWQodmFsKSA/IFt2YWxdIDogW10pO1xuICAgIH1cbiAgICAvLyBVbndyYXAgYXJyYXkgdmFsdWUgZm9yIFwiYXV0b1wiIG1vZGUuIFJldHVybiB1bmRlZmluZWQgZm9yIGVtcHR5IGFycmF5LlxuICAgIGZ1bmN0aW9uIGFycmF5VW53cmFwKHZhbCkge1xuICAgICAgICBzd2l0Y2ggKHZhbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG1vZGUgPT09IFwiYXV0b1wiID8gdmFsWzBdIDogdmFsO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXcmFwcyB0eXBlICguaXMvLmVuY29kZS8uZGVjb2RlKSBmdW5jdGlvbnMgdG8gb3BlcmF0ZSBvbiBlYWNoIHZhbHVlIG9mIGFuIGFycmF5XG4gICAgZnVuY3Rpb24gYXJyYXlIYW5kbGVyKGNhbGxiYWNrLCBhbGxUcnV0aHlNb2RlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVBcnJheSh2YWwpIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNBcnJheSh2YWwpICYmIHZhbC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIHZhciBhcnIgPSBhcnJheVdyYXAodmFsKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjb21tb25fMS5tYXAoYXJyLCBjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gKGFsbFRydXRoeU1vZGUgPT09IHRydWUpID8gY29tbW9uXzEuZmlsdGVyKHJlc3VsdCwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuICF4OyB9KS5sZW5ndGggPT09IDAgOiBhcnJheVVud3JhcChyZXN1bHQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBXcmFwcyB0eXBlICguZXF1YWxzKSBmdW5jdGlvbnMgdG8gb3BlcmF0ZSBvbiBlYWNoIHZhbHVlIG9mIGFuIGFycmF5XG4gICAgZnVuY3Rpb24gYXJyYXlFcXVhbHNIYW5kbGVyKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVBcnJheSh2YWwxLCB2YWwyKSB7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IGFycmF5V3JhcCh2YWwxKSwgcmlnaHQgPSBhcnJheVdyYXAodmFsMik7XG4gICAgICAgICAgICBpZiAobGVmdC5sZW5ndGggIT09IHJpZ2h0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrKGxlZnRbaV0sIHJpZ2h0W2ldKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFsnZW5jb2RlJywgJ2RlY29kZScsICdlcXVhbHMnLCAnJG5vcm1hbGl6ZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHBhcmFtVHlwZUZuID0gdHlwZVtuYW1lXS5iaW5kKHR5cGUpO1xuICAgICAgICB2YXIgd3JhcHBlckZuID0gbmFtZSA9PT0gJ2VxdWFscycgPyBhcnJheUVxdWFsc0hhbmRsZXIgOiBhcnJheUhhbmRsZXI7XG4gICAgICAgIF90aGlzW25hbWVdID0gd3JhcHBlckZuKHBhcmFtVHlwZUZuKTtcbiAgICB9KTtcbiAgICBjb21tb25fMS5leHRlbmQodGhpcywge1xuICAgICAgICBkeW5hbWljOiB0eXBlLmR5bmFtaWMsXG4gICAgICAgIG5hbWU6IHR5cGUubmFtZSxcbiAgICAgICAgcGF0dGVybjogdHlwZS5wYXR0ZXJuLFxuICAgICAgICBpbmhlcml0OiB0eXBlLmluaGVyaXQsXG4gICAgICAgIGlzOiBhcnJheUhhbmRsZXIodHlwZS5pcy5iaW5kKHR5cGUpLCB0cnVlKSxcbiAgICAgICAgJGFycmF5TW9kZTogbW9kZVxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyYW1UeXBlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9wYXJhbXMvcGFyYW1UeXBlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgdHJhbnNpdGlvblxuICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbnZhciBpbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKTtcbnZhciB0cmFuc2l0aW9uXzEgPSByZXF1aXJlKFwiLi90cmFuc2l0aW9uXCIpO1xudmFyIGhvb2tSZWdpc3RyeV8xID0gcmVxdWlyZShcIi4vaG9va1JlZ2lzdHJ5XCIpO1xudmFyIGNvcmVSZXNvbHZhYmxlc18xID0gcmVxdWlyZShcIi4uL2hvb2tzL2NvcmVSZXNvbHZhYmxlc1wiKTtcbnZhciByZWRpcmVjdFRvXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvcmVkaXJlY3RUb1wiKTtcbnZhciBvbkVudGVyRXhpdFJldGFpbl8xID0gcmVxdWlyZShcIi4uL2hvb2tzL29uRW50ZXJFeGl0UmV0YWluXCIpO1xudmFyIHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuLi9ob29rcy9yZXNvbHZlXCIpO1xudmFyIHZpZXdzXzEgPSByZXF1aXJlKFwiLi4vaG9va3Mvdmlld3NcIik7XG52YXIgdXBkYXRlR2xvYmFsc18xID0gcmVxdWlyZShcIi4uL2hvb2tzL3VwZGF0ZUdsb2JhbHNcIik7XG52YXIgdXJsXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvdXJsXCIpO1xudmFyIGxhenlMb2FkXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvbGF6eUxvYWRcIik7XG52YXIgdHJhbnNpdGlvbkV2ZW50VHlwZV8xID0gcmVxdWlyZShcIi4vdHJhbnNpdGlvbkV2ZW50VHlwZVwiKTtcbnZhciB0cmFuc2l0aW9uSG9va18xID0gcmVxdWlyZShcIi4vdHJhbnNpdGlvbkhvb2tcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciBpZ25vcmVkVHJhbnNpdGlvbl8xID0gcmVxdWlyZShcIi4uL2hvb2tzL2lnbm9yZWRUcmFuc2l0aW9uXCIpO1xudmFyIGludmFsaWRUcmFuc2l0aW9uXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvaW52YWxpZFRyYW5zaXRpb25cIik7XG4vKipcbiAqIFRoZSBkZWZhdWx0IFtbVHJhbnNpdGlvbl1dIG9wdGlvbnMuXG4gKlxuICogSW5jbHVkZSB0aGlzIG9iamVjdCB3aGVuIGFwcGx5aW5nIGN1c3RvbSBkZWZhdWx0czpcbiAqIGxldCByZWxvYWRPcHRzID0geyByZWxvYWQ6IHRydWUsIG5vdGlmeTogdHJ1ZSB9XG4gKiBsZXQgb3B0aW9ucyA9IGRlZmF1bHRzKHRoZWlyT3B0cywgY3VzdG9tRGVmYXVsdHMsIGRlZmF1bHRPcHRpb25zKTtcbiAqL1xuZXhwb3J0cy5kZWZhdWx0VHJhbnNPcHRzID0ge1xuICAgIGxvY2F0aW9uOiB0cnVlLFxuICAgIHJlbGF0aXZlOiBudWxsLFxuICAgIGluaGVyaXQ6IGZhbHNlLFxuICAgIG5vdGlmeTogdHJ1ZSxcbiAgICByZWxvYWQ6IGZhbHNlLFxuICAgIGN1c3RvbToge30sXG4gICAgY3VycmVudDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICBzb3VyY2U6IFwidW5rbm93blwiXG59O1xuLyoqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIHNlcnZpY2VzIHJlbGF0ZWQgdG8gVHJhbnNpdGlvbnMuXG4gKlxuICogLSBNb3N0IGltcG9ydGFudGx5LCBpdCBhbGxvd3MgZ2xvYmFsIFRyYW5zaXRpb24gSG9va3MgdG8gYmUgcmVnaXN0ZXJlZC5cbiAqIC0gSXQgYWxsb3dzIHRoZSBkZWZhdWx0IHRyYW5zaXRpb24gZXJyb3IgaGFuZGxlciB0byBiZSBzZXQuXG4gKiAtIEl0IGFsc28gaGFzIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgbmV3IFtbVHJhbnNpdGlvbl1dIG9iamVjdHMsICh1c2VkIGludGVybmFsbHkgYnkgdGhlIFtbU3RhdGVTZXJ2aWNlXV0pLlxuICpcbiAqIEF0IGJvb3RzdHJhcCwgW1tVSVJvdXRlcl1dIGNyZWF0ZXMgYSBzaW5nbGUgaW5zdGFuY2UgKHNpbmdsZXRvbikgb2YgdGhpcyBjbGFzcy5cbiAqL1xudmFyIFRyYW5zaXRpb25TZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvblNlcnZpY2UoX3JvdXRlcikge1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uQ291bnQgPSAwO1xuICAgICAgICAvKiogQGhpZGRlbiBUaGUgdHJhbnNpdGlvbiBob29rIHR5cGVzLCBzdWNoIGFzIGBvbkVudGVyYCwgYG9uU3RhcnRgLCBldGMgKi9cbiAgICAgICAgdGhpcy5fZXZlbnRUeXBlcyA9IFtdO1xuICAgICAgICAvKiogQGhpZGRlbiBUaGUgcmVnaXN0ZXJlZCB0cmFuc2l0aW9uIGhvb2tzICovXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyZWRIb29rcyA9IHt9O1xuICAgICAgICAvKiogQGhpZGRlbiBUaGUgIHBhdGhzIG9uIGEgY3JpdGVyaWEgb2JqZWN0ICovXG4gICAgICAgIHRoaXMuX2NyaXRlcmlhUGF0aHMgPSB7fTtcbiAgICAgICAgdGhpcy5fcm91dGVyID0gX3JvdXRlcjtcbiAgICAgICAgdGhpcy4kdmlldyA9IF9yb3V0ZXIudmlld1NlcnZpY2U7XG4gICAgICAgIHRoaXMuX2RlcmVnaXN0ZXJIb29rRm5zID0ge307XG4gICAgICAgIHRoaXMuX3BsdWdpbmFwaSA9IGNvbW1vbl8xLmNyZWF0ZVByb3h5RnVuY3Rpb25zKGhvZl8xLnZhbCh0aGlzKSwge30sIGhvZl8xLnZhbCh0aGlzKSwgW1xuICAgICAgICAgICAgJ19kZWZpbmVQYXRoVHlwZScsXG4gICAgICAgICAgICAnX2RlZmluZUV2ZW50JyxcbiAgICAgICAgICAgICdfZ2V0UGF0aFR5cGVzJyxcbiAgICAgICAgICAgICdfZ2V0RXZlbnRzJyxcbiAgICAgICAgICAgICdnZXRIb29rcycsXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLl9kZWZpbmVDb3JlUGF0aHMoKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lQ29yZUV2ZW50cygpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckNvcmVUcmFuc2l0aW9uSG9va3MoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgW1tUcmFuc2l0aW9uSG9va0ZuXV0sIGNhbGxlZCAqd2hpbGUgYSB0cmFuc2l0aW9uIGlzIGJlaW5nIGNvbnN0cnVjdGVkKi5cbiAgICAgKlxuICAgICAqIFJlZ2lzdGVycyBhIHRyYW5zaXRpb24gbGlmZWN5Y2xlIGhvb2ssIHdoaWNoIGlzIGludm9rZWQgZHVyaW5nIHRyYW5zaXRpb24gY29uc3RydWN0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBsb3cgbGV2ZWwgaG9vayBzaG91bGQgb25seSBiZSB1c2VkIGJ5IHBsdWdpbnMuXG4gICAgICogVGhpcyBjYW4gYmUgYSB1c2VmdWwgdGltZSBmb3IgcGx1Z2lucyB0byBhZGQgcmVzb2x2ZXMgb3IgbXV0YXRlIHRoZSB0cmFuc2l0aW9uIGFzIG5lZWRlZC5cbiAgICAgKiBUaGUgU3RpY2t5IFN0YXRlcyBwbHVnaW4gdXNlcyB0aGlzIGhvb2sgdG8gbW9kaWZ5IHRoZSB0cmVlY2hhbmdlcy5cbiAgICAgKlxuICAgICAqICMjIyBMaWZlY3ljbGVcbiAgICAgKlxuICAgICAqIGBvbkNyZWF0ZWAgaG9va3MgYXJlIGludm9rZWQgKndoaWxlIGEgdHJhbnNpdGlvbiBpcyBiZWluZyBjb25zdHJ1Y3RlZCouXG4gICAgICpcbiAgICAgKiAjIyMgUmV0dXJuIHZhbHVlXG4gICAgICpcbiAgICAgKiBUaGUgaG9vaydzIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxhcGlcbiAgICAgKiBAcGFyYW0gY3JpdGVyaWEgZGVmaW5lcyB3aGljaCBUcmFuc2l0aW9ucyB0aGUgSG9vayBzaG91bGQgYmUgaW52b2tlZCBmb3IuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSBob29rIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgcmVnaXN0cmF0aW9uIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGRlcmVnaXN0ZXJzIHRoZSBob29rLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5vbkNyZWF0ZSA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5vbkJlZm9yZSA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykgeyByZXR1cm47IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLm9uRXhpdCA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5vblJldGFpbiA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5vbkVudGVyID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykgeyByZXR1cm47IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLm9uRmluaXNoID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykgeyByZXR1cm47IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykgeyByZXR1cm47IH07XG4gICAgLyoqXG4gICAgICogZGlzcG9zZVxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgICAgICBjb21tb25fMS52YWx1ZXModGhpcy5fcmVnaXN0ZXJlZEhvb2tzKS5mb3JFYWNoKGZ1bmN0aW9uIChob29rc0FycmF5KSB7IHJldHVybiBob29rc0FycmF5LmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgICAgIGhvb2suX2RlcmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICBjb21tb25fMS5yZW1vdmVGcm9tKGhvb2tzQXJyYXksIGhvb2spO1xuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFtbVHJhbnNpdGlvbl1dIG9iamVjdFxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIG5ldyBUcmFuc2l0aW9uIG9iamVjdHMuXG4gICAgICogSXQgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBbW1N0YXRlU2VydmljZV1dIGFuZCBzaG91bGQgZ2VuZXJhbGx5IG5vdCBiZSBjYWxsZWQgYnkgYXBwbGljYXRpb24gY29kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcm9tUGF0aCB0aGUgcGF0aCB0byB0aGUgY3VycmVudCBzdGF0ZSAodGhlIGZyb20gc3RhdGUpXG4gICAgICogQHBhcmFtIHRhcmdldFN0YXRlIHRoZSB0YXJnZXQgc3RhdGUgKGRlc3RpbmF0aW9uKVxuICAgICAqIEByZXR1cm5zIGEgVHJhbnNpdGlvblxuICAgICAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoZnJvbVBhdGgsIHRhcmdldFN0YXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgdHJhbnNpdGlvbl8xLlRyYW5zaXRpb24oZnJvbVBhdGgsIHRhcmdldFN0YXRlLCB0aGlzLl9yb3V0ZXIpO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuX2RlZmluZUNvcmVFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBQaGFzZSA9IGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rUGhhc2U7XG4gICAgICAgIHZhciBUSCA9IHRyYW5zaXRpb25Ib29rXzEuVHJhbnNpdGlvbkhvb2s7XG4gICAgICAgIHZhciBwYXRocyA9IHRoaXMuX2NyaXRlcmlhUGF0aHM7XG4gICAgICAgIHZhciBOT1JNQUxfU09SVCA9IGZhbHNlLCBSRVZFUlNFX1NPUlQgPSB0cnVlO1xuICAgICAgICB2YXIgQVNZTkNIUk9OT1VTID0gZmFsc2UsIFNZTkNIUk9OT1VTID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoXCJvbkNyZWF0ZVwiLCBQaGFzZS5DUkVBVEUsIDAsIHBhdGhzLnRvLCBOT1JNQUxfU09SVCwgVEguTE9HX1JFSkVDVEVEX1JFU1VMVCwgVEguVEhST1dfRVJST1IsIFNZTkNIUk9OT1VTKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoXCJvbkJlZm9yZVwiLCBQaGFzZS5CRUZPUkUsIDAsIHBhdGhzLnRvKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoXCJvblN0YXJ0XCIsIFBoYXNlLlJVTiwgMCwgcGF0aHMudG8pO1xuICAgICAgICB0aGlzLl9kZWZpbmVFdmVudChcIm9uRXhpdFwiLCBQaGFzZS5SVU4sIDEwMCwgcGF0aHMuZXhpdGluZywgUkVWRVJTRV9TT1JUKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoXCJvblJldGFpblwiLCBQaGFzZS5SVU4sIDIwMCwgcGF0aHMucmV0YWluZWQpO1xuICAgICAgICB0aGlzLl9kZWZpbmVFdmVudChcIm9uRW50ZXJcIiwgUGhhc2UuUlVOLCAzMDAsIHBhdGhzLmVudGVyaW5nKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoXCJvbkZpbmlzaFwiLCBQaGFzZS5SVU4sIDQwMCwgcGF0aHMudG8pO1xuICAgICAgICB0aGlzLl9kZWZpbmVFdmVudChcIm9uU3VjY2Vzc1wiLCBQaGFzZS5TVUNDRVNTLCAwLCBwYXRocy50bywgTk9STUFMX1NPUlQsIFRILkxPR19SRUpFQ1RFRF9SRVNVTFQsIFRILkxPR19FUlJPUiwgU1lOQ0hST05PVVMpO1xuICAgICAgICB0aGlzLl9kZWZpbmVFdmVudChcIm9uRXJyb3JcIiwgUGhhc2UuRVJST1IsIDAsIHBhdGhzLnRvLCBOT1JNQUxfU09SVCwgVEguTE9HX1JFSkVDVEVEX1JFU1VMVCwgVEguTE9HX0VSUk9SLCBTWU5DSFJPTk9VUyk7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZGVmaW5lQ29yZVBhdGhzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgU1RBVEUgPSBpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1Njb3BlLlNUQVRFLCBUUkFOU0lUSU9OID0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tTY29wZS5UUkFOU0lUSU9OO1xuICAgICAgICB0aGlzLl9kZWZpbmVQYXRoVHlwZShcInRvXCIsIFRSQU5TSVRJT04pO1xuICAgICAgICB0aGlzLl9kZWZpbmVQYXRoVHlwZShcImZyb21cIiwgVFJBTlNJVElPTik7XG4gICAgICAgIHRoaXMuX2RlZmluZVBhdGhUeXBlKFwiZXhpdGluZ1wiLCBTVEFURSk7XG4gICAgICAgIHRoaXMuX2RlZmluZVBhdGhUeXBlKFwicmV0YWluZWRcIiwgU1RBVEUpO1xuICAgICAgICB0aGlzLl9kZWZpbmVQYXRoVHlwZShcImVudGVyaW5nXCIsIFNUQVRFKTtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLl9kZWZpbmVFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBob29rUGhhc2UsIGhvb2tPcmRlciwgY3JpdGVyaWFNYXRjaFBhdGgsIHJldmVyc2VTb3J0LCBnZXRSZXN1bHRIYW5kbGVyLCBnZXRFcnJvckhhbmRsZXIsIHN5bmNocm9ub3VzKSB7XG4gICAgICAgIGlmIChyZXZlcnNlU29ydCA9PT0gdm9pZCAwKSB7IHJldmVyc2VTb3J0ID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGdldFJlc3VsdEhhbmRsZXIgPT09IHZvaWQgMCkgeyBnZXRSZXN1bHRIYW5kbGVyID0gdHJhbnNpdGlvbkhvb2tfMS5UcmFuc2l0aW9uSG9vay5IQU5ETEVfUkVTVUxUOyB9XG4gICAgICAgIGlmIChnZXRFcnJvckhhbmRsZXIgPT09IHZvaWQgMCkgeyBnZXRFcnJvckhhbmRsZXIgPSB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rLlJFSkVDVF9FUlJPUjsgfVxuICAgICAgICBpZiAoc3luY2hyb25vdXMgPT09IHZvaWQgMCkgeyBzeW5jaHJvbm91cyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBuZXcgdHJhbnNpdGlvbkV2ZW50VHlwZV8xLlRyYW5zaXRpb25FdmVudFR5cGUobmFtZSwgaG9va1BoYXNlLCBob29rT3JkZXIsIGNyaXRlcmlhTWF0Y2hQYXRoLCByZXZlcnNlU29ydCwgZ2V0UmVzdWx0SGFuZGxlciwgZ2V0RXJyb3JIYW5kbGVyLCBzeW5jaHJvbm91cyk7XG4gICAgICAgIHRoaXMuX2V2ZW50VHlwZXMucHVzaChldmVudFR5cGUpO1xuICAgICAgICBob29rUmVnaXN0cnlfMS5tYWtlRXZlbnQodGhpcywgdGhpcywgZXZlbnRUeXBlKTtcbiAgICB9O1xuICAgIDtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZ2V0RXZlbnRzID0gZnVuY3Rpb24gKHBoYXNlKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uSG9va1R5cGVzID0gcHJlZGljYXRlc18xLmlzRGVmaW5lZChwaGFzZSkgP1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRUeXBlcy5maWx0ZXIoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHR5cGUuaG9va1BoYXNlID09PSBwaGFzZTsgfSkgOlxuICAgICAgICAgICAgdGhpcy5fZXZlbnRUeXBlcy5zbGljZSgpO1xuICAgICAgICByZXR1cm4gdHJhbnNpdGlvbkhvb2tUeXBlcy5zb3J0KGZ1bmN0aW9uIChsLCByKSB7XG4gICAgICAgICAgICB2YXIgY21wQnlQaGFzZSA9IGwuaG9va1BoYXNlIC0gci5ob29rUGhhc2U7XG4gICAgICAgICAgICByZXR1cm4gY21wQnlQaGFzZSA9PT0gMCA/IGwuaG9va09yZGVyIC0gci5ob29rT3JkZXIgOiBjbXBCeVBoYXNlO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBQYXRoIHRvIGJlIHVzZWQgYXMgYSBjcml0ZXJpb24gYWdhaW5zdCBhIFRyZWVDaGFuZ2VzIHBhdGhcbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlOiB0aGUgYGV4aXRpbmdgIHBhdGggaW4gW1tIb29rTWF0Y2hDcml0ZXJpYV1dIGlzIGEgU1RBVEUgc2NvcGVkIHBhdGguXG4gICAgICogSXQgd2FzIGRlZmluZWQgYnkgY2FsbGluZyBgZGVmaW5lVHJlZUNoYW5nZXNDcml0ZXJpb24oJ2V4aXRpbmcnLCBUcmFuc2l0aW9uSG9va1Njb3BlLlNUQVRFKWBcbiAgICAgKiBFYWNoIHN0YXRlIGluIHRoZSBleGl0aW5nIHBhdGggaXMgY2hlY2tlZCBhZ2FpbnN0IHRoZSBjcml0ZXJpYSBhbmQgcmV0dXJuZWQgYXMgcGFydCBvZiB0aGUgbWF0Y2guXG4gICAgICpcbiAgICAgKiBBbm90aGVyIGV4YW1wbGU6IHRoZSBgdG9gIHBhdGggaW4gW1tIb29rTWF0Y2hDcml0ZXJpYV1dIGlzIGEgVFJBTlNJVElPTiBzY29wZWQgcGF0aC5cbiAgICAgKiBJdCB3YXMgZGVmaW5lZCBieSBjYWxsaW5nIGBkZWZpbmVUcmVlQ2hhbmdlc0NyaXRlcmlvbigndG8nLCBUcmFuc2l0aW9uSG9va1Njb3BlLlRSQU5TSVRJT04pYFxuICAgICAqIE9ubHkgdGhlIHRhaWwgb2YgdGhlIGB0b2AgcGF0aCBpcyBjaGVja2VkIGFnYWluc3QgdGhlIGNyaXRlcmlhIGFuZCByZXR1cm5lZCBhcyBwYXJ0IG9mIHRoZSBtYXRjaC5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuX2RlZmluZVBhdGhUeXBlID0gZnVuY3Rpb24gKG5hbWUsIGhvb2tTY29wZSkge1xuICAgICAgICB0aGlzLl9jcml0ZXJpYVBhdGhzW25hbWVdID0geyBuYW1lOiBuYW1lLCBzY29wZTogaG9va1Njb3BlIH07XG4gICAgfTtcbiAgICAvKiogKiBAaGlkZGVuICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLl9nZXRQYXRoVHlwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jcml0ZXJpYVBhdGhzO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0SG9va3MgPSBmdW5jdGlvbiAoaG9va05hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdGVyZWRIb29rc1tob29rTmFtZV07XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fcmVnaXN0ZXJDb3JlVHJhbnNpdGlvbkhvb2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZm5zID0gdGhpcy5fZGVyZWdpc3Rlckhvb2tGbnM7XG4gICAgICAgIGZucy5hZGRDb3JlUmVzb2x2ZXMgPSBjb3JlUmVzb2x2YWJsZXNfMS5yZWdpc3RlckFkZENvcmVSZXNvbHZhYmxlcyh0aGlzKTtcbiAgICAgICAgZm5zLmlnbm9yZWQgPSBpZ25vcmVkVHJhbnNpdGlvbl8xLnJlZ2lzdGVySWdub3JlZFRyYW5zaXRpb25Ib29rKHRoaXMpO1xuICAgICAgICBmbnMuaW52YWxpZCA9IGludmFsaWRUcmFuc2l0aW9uXzEucmVnaXN0ZXJJbnZhbGlkVHJhbnNpdGlvbkhvb2sodGhpcyk7XG4gICAgICAgIC8vIFdpcmUgdXAgcmVkaXJlY3RUbyBob29rXG4gICAgICAgIGZucy5yZWRpcmVjdFRvID0gcmVkaXJlY3RUb18xLnJlZ2lzdGVyUmVkaXJlY3RUb0hvb2sodGhpcyk7XG4gICAgICAgIC8vIFdpcmUgdXAgb25FeGl0L1JldGFpbi9FbnRlciBzdGF0ZSBob29rc1xuICAgICAgICBmbnMub25FeGl0ID0gb25FbnRlckV4aXRSZXRhaW5fMS5yZWdpc3Rlck9uRXhpdEhvb2sodGhpcyk7XG4gICAgICAgIGZucy5vblJldGFpbiA9IG9uRW50ZXJFeGl0UmV0YWluXzEucmVnaXN0ZXJPblJldGFpbkhvb2sodGhpcyk7XG4gICAgICAgIGZucy5vbkVudGVyID0gb25FbnRlckV4aXRSZXRhaW5fMS5yZWdpc3Rlck9uRW50ZXJIb29rKHRoaXMpO1xuICAgICAgICAvLyBXaXJlIHVwIFJlc29sdmUgaG9va3NcbiAgICAgICAgZm5zLmVhZ2VyUmVzb2x2ZSA9IHJlc29sdmVfMS5yZWdpc3RlckVhZ2VyUmVzb2x2ZVBhdGgodGhpcyk7XG4gICAgICAgIGZucy5sYXp5UmVzb2x2ZSA9IHJlc29sdmVfMS5yZWdpc3RlckxhenlSZXNvbHZlU3RhdGUodGhpcyk7XG4gICAgICAgIC8vIFdpcmUgdXAgdGhlIFZpZXcgbWFuYWdlbWVudCBob29rc1xuICAgICAgICBmbnMubG9hZFZpZXdzID0gdmlld3NfMS5yZWdpc3RlckxvYWRFbnRlcmluZ1ZpZXdzKHRoaXMpO1xuICAgICAgICBmbnMuYWN0aXZhdGVWaWV3cyA9IHZpZXdzXzEucmVnaXN0ZXJBY3RpdmF0ZVZpZXdzKHRoaXMpO1xuICAgICAgICAvLyBVcGRhdGVzIGdsb2JhbCBzdGF0ZSBhZnRlciBhIHRyYW5zaXRpb25cbiAgICAgICAgZm5zLnVwZGF0ZUdsb2JhbHMgPSB1cGRhdGVHbG9iYWxzXzEucmVnaXN0ZXJVcGRhdGVHbG9iYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgLy8gQWZ0ZXIgZ2xvYmFscy5jdXJyZW50IGlzIHVwZGF0ZWQgYXQgcHJpb3JpdHk6IDEwMDAwXG4gICAgICAgIGZucy51cGRhdGVVcmwgPSB1cmxfMS5yZWdpc3RlclVwZGF0ZVVybCh0aGlzKTtcbiAgICAgICAgLy8gTGF6eSBsb2FkIHN0YXRlIHRyZWVzXG4gICAgICAgIGZucy5sYXp5TG9hZCA9IGxhenlMb2FkXzEucmVnaXN0ZXJMYXp5TG9hZEhvb2sodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhbnNpdGlvblNlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5UcmFuc2l0aW9uU2VydmljZSA9IFRyYW5zaXRpb25TZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNpdGlvblNlcnZpY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvblNlcnZpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBtb2R1bGUgdmFuaWxsYVxuICovXG4vKiogKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG5leHBvcnRzLmtleVZhbHNUb09iamVjdFIgPSBmdW5jdGlvbiAoYWNjdW0sIF9hKSB7XG4gICAgdmFyIGtleSA9IF9hWzBdLCB2YWwgPSBfYVsxXTtcbiAgICBpZiAoIWFjY3VtLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgYWNjdW1ba2V5XSA9IHZhbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29tbW9uXzEuaXNBcnJheShhY2N1bVtrZXldKSkge1xuICAgICAgICBhY2N1bVtrZXldLnB1c2godmFsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFjY3VtW2tleV0gPSBbYWNjdW1ba2V5XSwgdmFsXTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtO1xufTtcbmV4cG9ydHMuZ2V0UGFyYW1zID0gZnVuY3Rpb24gKHF1ZXJ5U3RyaW5nKSB7XG4gICAgcmV0dXJuIHF1ZXJ5U3RyaW5nLnNwbGl0KFwiJlwiKS5maWx0ZXIoY29tbW9uXzEuaWRlbnRpdHkpLm1hcChjb21tb25fMS5zcGxpdEVxdWFsKS5yZWR1Y2UoZXhwb3J0cy5rZXlWYWxzVG9PYmplY3RSLCB7fSk7XG59O1xuZnVuY3Rpb24gcGFyc2VVcmwodXJsKSB7XG4gICAgdmFyIG9yRW1wdHlTdHJpbmcgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCB8fCBcIlwiOyB9O1xuICAgIHZhciBfYSA9IGNvbW1vbl8xLnNwbGl0SGFzaCh1cmwpLm1hcChvckVtcHR5U3RyaW5nKSwgYmVmb3JlaGFzaCA9IF9hWzBdLCBoYXNoID0gX2FbMV07XG4gICAgdmFyIF9iID0gY29tbW9uXzEuc3BsaXRRdWVyeShiZWZvcmVoYXNoKS5tYXAob3JFbXB0eVN0cmluZyksIHBhdGggPSBfYlswXSwgc2VhcmNoID0gX2JbMV07XG4gICAgcmV0dXJuIHsgcGF0aDogcGF0aCwgc2VhcmNoOiBzZWFyY2gsIGhhc2g6IGhhc2gsIHVybDogdXJsIH07XG59XG5leHBvcnRzLnBhcnNlVXJsID0gcGFyc2VVcmw7XG5leHBvcnRzLmJ1aWxkVXJsID0gZnVuY3Rpb24gKGxvYykge1xuICAgIHZhciBwYXRoID0gbG9jLnBhdGgoKTtcbiAgICB2YXIgc2VhcmNoT2JqZWN0ID0gbG9jLnNlYXJjaCgpO1xuICAgIHZhciBoYXNoID0gbG9jLmhhc2goKTtcbiAgICB2YXIgc2VhcmNoID0gT2JqZWN0LmtleXMoc2VhcmNoT2JqZWN0KS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgcGFyYW0gPSBzZWFyY2hPYmplY3Rba2V5XTtcbiAgICAgICAgdmFyIHZhbHMgPSBjb21tb25fMS5pc0FycmF5KHBhcmFtKSA/IHBhcmFtIDogW3BhcmFtXTtcbiAgICAgICAgcmV0dXJuIHZhbHMubWFwKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIGtleSArIFwiPVwiICsgdmFsOyB9KTtcbiAgICB9KS5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pLmpvaW4oXCImXCIpO1xuICAgIHJldHVybiBwYXRoICsgKHNlYXJjaCA/IFwiP1wiICsgc2VhcmNoIDogXCJcIikgKyAoaGFzaCA/IFwiI1wiICsgaGFzaCA6IFwiXCIpO1xufTtcbmZ1bmN0aW9uIGxvY2F0aW9uUGx1Z2luRmFjdG9yeShuYW1lLCBpc0h0bWw1LCBzZXJ2aWNlQ2xhc3MsIGNvbmZpZ3VyYXRpb25DbGFzcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgICAgIHZhciBzZXJ2aWNlID0gcm91dGVyLmxvY2F0aW9uU2VydmljZSA9IG5ldyBzZXJ2aWNlQ2xhc3Mocm91dGVyKTtcbiAgICAgICAgdmFyIGNvbmZpZ3VyYXRpb24gPSByb3V0ZXIubG9jYXRpb25Db25maWcgPSBuZXcgY29uZmlndXJhdGlvbkNsYXNzKHJvdXRlciwgaXNIdG1sNSk7XG4gICAgICAgIGZ1bmN0aW9uIGRpc3Bvc2Uocm91dGVyKSB7XG4gICAgICAgICAgICByb3V0ZXIuZGlzcG9zZShzZXJ2aWNlKTtcbiAgICAgICAgICAgIHJvdXRlci5kaXNwb3NlKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG5hbWU6IG5hbWUsIHNlcnZpY2U6IHNlcnZpY2UsIGNvbmZpZ3VyYXRpb246IGNvbmZpZ3VyYXRpb24sIGRpc3Bvc2U6IGRpc3Bvc2UgfTtcbiAgICB9O1xufVxuZXhwb3J0cy5sb2NhdGlvblBsdWdpbkZhY3RvcnkgPSBsb2NhdGlvblBsdWdpbkZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS91dGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIEBtb2R1bGUgbmcyICovIC8qKiAqL1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gXCJAdWlyb3V0ZXIvY29yZVwiO1xuaW1wb3J0IHsgcGljaywgZm9yRWFjaCB9IGZyb20gXCJAdWlyb3V0ZXIvY29yZVwiO1xuaW1wb3J0IHsgc2VydmljZXMgfSBmcm9tIFwiQHVpcm91dGVyL2NvcmVcIjtcbmltcG9ydCB7IFZpZXdTZXJ2aWNlIH0gZnJvbSBcIkB1aXJvdXRlci9jb3JlXCI7XG4vKipcbiAqIFRoaXMgaXMgYSBbW1N0YXRlQnVpbGRlci5idWlsZGVyXV0gZnVuY3Rpb24gZm9yIEFuZ3VsYXIgYHZpZXdzYC5cbiAqXG4gKiBXaGVuIHRoZSBbW1N0YXRlQnVpbGRlcl1dIGJ1aWxkcyBhIFtbU3RhdGVdXSBvYmplY3QgZnJvbSBhIHJhdyBbW1N0YXRlRGVjbGFyYXRpb25dXSwgdGhpcyBidWlsZGVyXG4gKiBoYW5kbGVzIHRoZSBgdmlld3NgIHByb3BlcnR5IHdpdGggbG9naWMgc3BlY2lmaWMgdG8gQHVpcm91dGVyL2FuZ3VsYXIuXG4gKlxuICogSWYgbm8gYHZpZXdzOiB7fWAgcHJvcGVydHkgZXhpc3RzIG9uIHRoZSBbW1N0YXRlRGVjbGFyYXRpb25dXSwgdGhlbiBpdCBjcmVhdGVzIHRoZSBgdmlld3NgIG9iamVjdCBhbmRcbiAqIGFwcGxpZXMgdGhlIHN0YXRlLWxldmVsIGNvbmZpZ3VyYXRpb24gdG8gYSB2aWV3IG5hbWVkIGAkZGVmYXVsdGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuZzJWaWV3c0J1aWxkZXIoc3RhdGUpIHtcbiAgICB2YXIgdmlld3MgPSB7fSwgdmlld3NPYmplY3QgPSBzdGF0ZS52aWV3cyB8fCB7IFwiJGRlZmF1bHRcIjogcGljayhzdGF0ZSwgW1wiY29tcG9uZW50XCIsIFwiYmluZGluZ3NcIl0pIH07XG4gICAgZm9yRWFjaCh2aWV3c09iamVjdCwgZnVuY3Rpb24gKGNvbmZpZywgbmFtZSkge1xuICAgICAgICBuYW1lID0gbmFtZSB8fCBcIiRkZWZhdWx0XCI7IC8vIEFjY291bnQgZm9yIHZpZXdzOiB7IFwiXCI6IHsgdGVtcGxhdGUuLi4gfSB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGNvbmZpZykpXG4gICAgICAgICAgICBjb25maWcgPSB7IGNvbXBvbmVudDogY29uZmlnIH07XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhjb25maWcpLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25maWcuJHR5cGUgPSBcIm5nMlwiO1xuICAgICAgICBjb25maWcuJGNvbnRleHQgPSBzdGF0ZTtcbiAgICAgICAgY29uZmlnLiRuYW1lID0gbmFtZTtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBWaWV3U2VydmljZS5ub3JtYWxpemVVSVZpZXdUYXJnZXQoY29uZmlnLiRjb250ZXh0LCBjb25maWcuJG5hbWUpO1xuICAgICAgICBjb25maWcuJHVpVmlld05hbWUgPSBub3JtYWxpemVkLnVpVmlld05hbWU7XG4gICAgICAgIGNvbmZpZy4kdWlWaWV3Q29udGV4dEFuY2hvciA9IG5vcm1hbGl6ZWQudWlWaWV3Q29udGV4dEFuY2hvcjtcbiAgICAgICAgdmlld3NbbmFtZV0gPSBjb25maWc7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZpZXdzO1xufVxudmFyIGlkID0gMDtcbnZhciBOZzJWaWV3Q29uZmlnID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZzJWaWV3Q29uZmlnKHBhdGgsIHZpZXdEZWNsKSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMudmlld0RlY2wgPSB2aWV3RGVjbDtcbiAgICAgICAgdGhpcy4kaWQgPSBpZCsrO1xuICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgfVxuICAgIE5nMlZpZXdDb25maWcucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZXJ2aWNlcy4kcS53aGVuKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIE5nMlZpZXdDb25maWc7XG59KCkpO1xuZXhwb3J0IHsgTmcyVmlld0NvbmZpZyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld3MuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2FuZ3VsYXIvbGliL3N0YXRlYnVpbGRlcnMvdmlld3MuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAbW9kdWxlIG5nMiAqLyAvKiogKi9cbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tIFwiQHVpcm91dGVyL2NvcmVcIjtcbmltcG9ydCB7IGlzRGVmaW5lZCB9IGZyb20gXCJAdWlyb3V0ZXIvY29yZVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5TW9kdWxlQ29uZmlnKHVpUm91dGVyLCBpbmplY3RvciwgbW9kdWxlKSB7XG4gICAgaWYgKG1vZHVsZSA9PT0gdm9pZCAwKSB7IG1vZHVsZSA9IHt9OyB9XG4gICAgaWYgKGlzRnVuY3Rpb24obW9kdWxlLmNvbmZpZykpIHtcbiAgICAgICAgbW9kdWxlLmNvbmZpZyh1aVJvdXRlciwgaW5qZWN0b3IsIG1vZHVsZSk7XG4gICAgfVxuICAgIHZhciBzdGF0ZXMgPSBtb2R1bGUuc3RhdGVzIHx8IFtdO1xuICAgIHJldHVybiBzdGF0ZXMubWFwKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gdWlSb3V0ZXIuc3RhdGVSZWdpc3RyeS5yZWdpc3RlcihzdGF0ZSk7IH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5Um9vdE1vZHVsZUNvbmZpZyh1aVJvdXRlciwgaW5qZWN0b3IsIG1vZHVsZSkge1xuICAgIGlzRGVmaW5lZChtb2R1bGUuZGVmZXJJbnRlcmNlcHQpICYmIHVpUm91dGVyLnVybFNlcnZpY2UuZGVmZXJJbnRlcmNlcHQobW9kdWxlLmRlZmVySW50ZXJjZXB0KTtcbiAgICBpc0RlZmluZWQobW9kdWxlLm90aGVyd2lzZSkgJiYgdWlSb3V0ZXIudXJsU2VydmljZS5ydWxlcy5vdGhlcndpc2UobW9kdWxlLm90aGVyd2lzZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11aVJvdXRlckNvbmZpZy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvYW5ndWxhci9saWIvdWlSb3V0ZXJDb25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IE5nTW9kdWxlLCBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTLCBJbmplY3Rpb25Ub2tlbiwgQVBQX0lOSVRJQUxJWkVSLCB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUsIExvY2F0aW9uU3RyYXRlZ3ksIEhhc2hMb2NhdGlvblN0cmF0ZWd5LCBQYXRoTG9jYXRpb25TdHJhdGVneSB9IGZyb20gXCJAYW5ndWxhci9jb21tb25cIjtcbmltcG9ydCB7IF9VSVJPVVRFUl9ESVJFQ1RJVkVTIH0gZnJvbSBcIi4vZGlyZWN0aXZlcy9kaXJlY3RpdmVzXCI7XG5pbXBvcnQgeyBVSVZpZXcgfSBmcm9tIFwiLi9kaXJlY3RpdmVzL3VpVmlld1wiO1xuaW1wb3J0IHsgVHJhbnNpdGlvblNlcnZpY2UgfSBmcm9tIFwiQHVpcm91dGVyL2NvcmVcIjtcbmltcG9ydCB7IF9VSVJPVVRFUl9JTlNUQU5DRV9QUk9WSURFUlMsIF9VSVJPVVRFUl9TRVJWSUNFX1BST1ZJREVSUyB9IGZyb20gXCIuL3Byb3ZpZGVyc1wiO1xuaW1wb3J0IHsgUk9VVEVTIH0gZnJvbSBcIkBhbmd1bGFyL3JvdXRlclwiO1xuLyoqIEBoaWRkZW4gKi8gZXhwb3J0IHZhciBVSVJPVVRFUl9ST09UX01PRFVMRSA9IG5ldyBJbmplY3Rpb25Ub2tlbihcIlVJUm91dGVyIFJvb3QgTW9kdWxlXCIpO1xuLyoqIEBoaWRkZW4gKi8gZXhwb3J0IHZhciBVSVJPVVRFUl9NT0RVTEVfVE9LRU4gPSBuZXcgSW5qZWN0aW9uVG9rZW4oXCJVSVJvdXRlciBNb2R1bGVcIik7XG4vKiogQGhpZGRlbiAqLyBleHBvcnQgdmFyIFVJUk9VVEVSX1NUQVRFUyA9IG5ldyBJbmplY3Rpb25Ub2tlbihcIlVJUm91dGVyIFN0YXRlc1wiKTtcbi8vIC8qKiBAaGlkZGVuICovIGV4cG9ydCBjb25zdCBST1VURVMgPSBVSVJPVVRFUl9TVEFURVM7XG4vLyBEZWxheSBhbmd1bGFyIGJvb3RzdHJhcCB1bnRpbCBmaXJzdCB0cmFuc2l0aW9uIGlzIHN1Y2Nlc3NmdWwsIGZvciBTU1IuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3VpLXJvdXRlci9hbmd1bGFyL3B1bGwvMTI3XG5leHBvcnQgZnVuY3Rpb24gb25UcmFuc2l0aW9uUmVhZHkodHJhbnNpdGlvblNlcnZpY2UsIHJvb3QpIHtcbiAgICB2YXIgbW9kID0gcm9vdFswXTtcbiAgICBpZiAoIW1vZCB8fCAhbW9kLmRlZmVySW5pdGlhbFJlbmRlcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7IH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICB2YXIgaG9vayA9IGZ1bmN0aW9uICh0cmFucykgeyB0cmFucy5wcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVzb2x2ZSk7IH07XG4gICAgICAgIHRyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnQoe30sIGhvb2ssIHsgaW52b2tlTGltaXQ6IDEgfSk7XG4gICAgfSk7IH07XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZVJvb3RQcm92aWRlcnMobW9kdWxlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgeyBwcm92aWRlOiBVSVJPVVRFUl9ST09UX01PRFVMRSwgdXNlVmFsdWU6IG1vZHVsZSwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgeyBwcm92aWRlOiBVSVJPVVRFUl9NT0RVTEVfVE9LRU4sIHVzZVZhbHVlOiBtb2R1bGUsIG11bHRpOiB0cnVlIH0sXG4gICAgICAgIHsgcHJvdmlkZTogUk9VVEVTLCB1c2VWYWx1ZTogbW9kdWxlLnN0YXRlcyB8fCBbXSwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgeyBwcm92aWRlOiBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTLCB1c2VWYWx1ZTogbW9kdWxlLnN0YXRlcyB8fCBbXSwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgeyBwcm92aWRlOiBBUFBfSU5JVElBTElaRVIsIHVzZUZhY3Rvcnk6IG9uVHJhbnNpdGlvblJlYWR5LCBkZXBzOiBbVHJhbnNpdGlvblNlcnZpY2UsIFVJUk9VVEVSX1JPT1RfTU9EVUxFXSwgbXVsdGk6IHRydWUgfSxcbiAgICBdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VDaGlsZFByb3ZpZGVycyhtb2R1bGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICB7IHByb3ZpZGU6IFVJUk9VVEVSX01PRFVMRV9UT0tFTiwgdXNlVmFsdWU6IG1vZHVsZSwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgeyBwcm92aWRlOiBST1VURVMsIHVzZVZhbHVlOiBtb2R1bGUuc3RhdGVzIHx8IFtdLCBtdWx0aTogdHJ1ZSB9LFxuICAgICAgICB7IHByb3ZpZGU6IEFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMsIHVzZVZhbHVlOiBtb2R1bGUuc3RhdGVzIHx8IFtdLCBtdWx0aTogdHJ1ZSB9LFxuICAgIF07XG59XG5leHBvcnQgZnVuY3Rpb24gbG9jYXRpb25TdHJhdGVneSh1c2VIYXNoKSB7XG4gICAgcmV0dXJuIHsgcHJvdmlkZTogTG9jYXRpb25TdHJhdGVneSwgdXNlQ2xhc3M6IHVzZUhhc2ggPyBIYXNoTG9jYXRpb25TdHJhdGVneSA6IFBhdGhMb2NhdGlvblN0cmF0ZWd5IH07XG59XG4vKipcbiAqIENyZWF0ZXMgVUktUm91dGVyIE1vZHVsZXNcbiAqXG4gKiBUaGlzIGNsYXNzIGhhcyB0d28gc3RhdGljIGZhY3RvcnkgbWV0aG9kcyB3aGljaCBjcmVhdGUgVUlSb3V0ZXIgTW9kdWxlcy5cbiAqIEEgVUktUm91dGVyIE1vZHVsZSBpcyBhbiBbQW5ndWxhciBOZ01vZHVsZV0oaHR0cHM6Ly9hbmd1bGFyLmlvL2RvY3MvdHMvbGF0ZXN0L2d1aWRlL25nbW9kdWxlLmh0bWwpXG4gKiB3aXRoIHN1cHBvcnQgZm9yIFVJLVJvdXRlci5cbiAqXG4gKiAjIyMgVUlSb3V0ZXIgRGlyZWN0aXZlc1xuICpcbiAqIFdoZW4gYSBVSS1Sb3V0ZXIgTW9kdWxlIGlzIGltcG9ydGVkIGludG8gYSBgTmdNb2R1bGVgLCB0aGF0IG1vZHVsZSdzIGNvbXBvbmVudHNcbiAqIGNhbiB1c2UgdGhlIFVJUm91dGVyIERpcmVjdGl2ZXMgc3VjaCBhcyBbW1VJVmlld11dLCBbW1VJU3JlZl1dLCBbW1VJU3JlZkFjdGl2ZV1dLlxuICpcbiAqICMjIyBTdGF0ZSBEZWZpbml0aW9uc1xuICpcbiAqIFN0YXRlIGRlZmluaXRpb25zIGZvdW5kIGluIHRoZSBgc3RhdGVzOmAgcHJvcGVydHkgYXJlIHByb3ZpZGVkIHRvIHRoZSBEZXBlbmRlbmN5IEluamVjdG9yLlxuICogVGhpcyBlbmFibGVzIFVJLVJvdXRlciB0byBhdXRvbWF0aWNhbGx5IHJlZ2lzdGVyIHRoZSBzdGF0ZXMgd2l0aCB0aGUgW1tTdGF0ZVJlZ2lzdHJ5XV0gYXQgYm9vdHN0cmFwIChhbmQgZHVyaW5nIGxhenkgbG9hZCkuXG4gKlxuICogIyMjIEVudHJ5IENvbXBvbmVudHNcbiAqXG4gKiBBbnkgcm91dGVkIGNvbXBvbmVudHMgYXJlIGFkZGVkIGFzIGBlbnRyeUNvbXBvbmVudHM6YCBzbyB0aGV5IHdpbGwgZ2V0IGNvbXBpbGVkLlxuICovXG52YXIgVUlSb3V0ZXJNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVJUm91dGVyTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVUktUm91dGVyIE1vZHVsZSBmb3IgdGhlIHJvb3QgKGJvb3RzdHJhcHBlZCkgYXBwbGljYXRpb24gbW9kdWxlIHRvIGltcG9ydFxuICAgICAqXG4gICAgICogVGhpcyBmYWN0b3J5IGZ1bmN0aW9uIGNyZWF0ZXMgYW4gW0FuZ3VsYXIgTmdNb2R1bGVdKGh0dHBzOi8vYW5ndWxhci5pby9kb2NzL3RzL2xhdGVzdC9ndWlkZS9uZ21vZHVsZS5odG1sKVxuICAgICAqIHdpdGggVUktUm91dGVyIHN1cHBvcnQuXG4gICAgICpcbiAgICAgKiBUaGUgYGZvclJvb3RgIG1vZHVsZSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIGBpbXBvcnRzOmAgb2YgdGhlIGBOZ01vZHVsZWAgYmVpbmcgYm9vdHN0cmFwcGVkLlxuICAgICAqIEFuIGFwcGxpY2F0aW9uIHNob3VsZCBvbmx5IGNyZWF0ZSBhbmQgaW1wb3J0IGEgc2luZ2xlIGBOZ01vZHVsZWAgdXNpbmcgYGZvclJvb3QoKWAuXG4gICAgICogQWxsIG90aGVyIG1vZHVsZXMgc2hvdWxkIGJlIGNyZWF0ZWQgdXNpbmcgW1tVSVJvdXRlck1vZHVsZS5mb3JDaGlsZF1dLlxuICAgICAqXG4gICAgICogVW5saWtlIGBmb3JDaGlsZGAsIGFuIGBOZ01vZHVsZWAgcmV0dXJuZWQgYnkgdGhpcyBmYWN0b3J5IHByb3ZpZGVzIHRoZSBbW1VJUm91dGVyXV0gc2luZ2xldG9uIG9iamVjdC5cbiAgICAgKiBUaGlzIGZhY3RvcnkgYWxzbyBhY2NlcHRzIHJvb3QtbGV2ZWwgcm91dGVyIGNvbmZpZ3VyYXRpb24uXG4gICAgICogVGhlc2UgYXJlIHRoZSBvbmx5IGRpZmZlcmVuY2VzIGJldHdlZW4gYGZvclJvb3RgIGFuZCBgZm9yQ2hpbGRgLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIGxldCByb3V0ZXJDb25maWcgPSB7XG4gICAgICogICBvdGhlcndpc2U6ICcvaG9tZScsXG4gICAgICogICBzdGF0ZXM6IFtob21lU3RhdGUsIGFib3V0U3RhdGVdXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIEAgTmdNb2R1bGUoe1xuICAgICAqICAgaW1wb3J0czogW1xuICAgICAqICAgICBCcm93c2VyTW9kdWxlLFxuICAgICAqICAgICBVSVJvdXRlck1vZHVsZS5mb3JSb290KHJvdXRlckNvbmZpZyksXG4gICAgICogICAgIEZlYXR1cmVNb2R1bGUxXG4gICAgICogICBdXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBNeVJvb3RBcHBNb2R1bGUge31cbiAgICAgKlxuICAgICAqIGJyb3dzZXJQbGF0Zm9ybUR5bmFtaWMuYm9vdHN0cmFwTW9kdWxlKE15Um9vdEFwcE1vZHVsZSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIGRlY2xhcmF0aXZlIFVJLVJvdXRlciBjb25maWd1cmF0aW9uXG4gICAgICogQHJldHVybnMgYW4gYE5nTW9kdWxlYCB3aGljaCBwcm92aWRlcyB0aGUgW1tVSVJvdXRlcl1dIHNpbmdsZXRvbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIFVJUm91dGVyTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IFVJUm91dGVyTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgX1VJUk9VVEVSX0lOU1RBTkNFX1BST1ZJREVSUyxcbiAgICAgICAgICAgICAgICBfVUlST1VURVJfU0VSVklDRV9QUk9WSURFUlMsXG4gICAgICAgICAgICAgICAgbG9jYXRpb25TdHJhdGVneShjb25maWcudXNlSGFzaClcbiAgICAgICAgICAgIF0uY29uY2F0KG1ha2VSb290UHJvdmlkZXJzKGNvbmZpZykpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGBOZ01vZHVsZWAgZm9yIGEgVUlSb3V0ZXIgbW9kdWxlXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYW4gW0FuZ3VsYXIgTmdNb2R1bGVdKGh0dHBzOi8vYW5ndWxhci5pby9kb2NzL3RzL2xhdGVzdC9ndWlkZS9uZ21vZHVsZS5odG1sKVxuICAgICAqIHdpdGggVUktUm91dGVyIHN1cHBvcnQuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB2YXIgaG9tZVN0YXRlID0geyBuYW1lOiAnaG9tZScsIHVybDogJy9ob21lJywgY29tcG9uZW50OiBIb21lIH07XG4gICAgICogdmFyIGFib3V0U3RhdGUgPSB7IG5hbWU6ICdhYm91dCcsIHVybDogJy9hYm91dCcsIGNvbXBvbmVudDogQWJvdXQgfTtcbiAgICAgKlxuICAgICAqIEAgTmdNb2R1bGUoe1xuICAgICAqICAgaW1wb3J0czogW1xuICAgICAqICAgICBVSVJvdXRlck1vZHVsZS5mb3JDaGlsZCh7IHN0YXRlczogWyBob21lU3RhdGUsIGFib3V0U3RhdGUgXSB9KSxcbiAgICAgKiAgICAgU2hhcmVkTW9kdWxlLFxuICAgICAqICAgXSxcbiAgICAgKiAgIGRlY2xhcmF0aW9uczogWyBIb21lLCBBYm91dCBdLFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtb2R1bGUgVUktUm91dGVyIG1vZHVsZSBvcHRpb25zXG4gICAgICogQHJldHVybnMgYW4gYE5nTW9kdWxlYFxuICAgICAqL1xuICAgIFVJUm91dGVyTW9kdWxlLmZvckNoaWxkID0gZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICBpZiAobW9kdWxlID09PSB2b2lkIDApIHsgbW9kdWxlID0ge307IH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBVSVJvdXRlck1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogbWFrZUNoaWxkUHJvdmlkZXJzKG1vZHVsZSksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVUlSb3V0ZXJNb2R1bGU7XG59KCkpO1xuZXhwb3J0IHsgVUlSb3V0ZXJNb2R1bGUgfTtcblVJUm91dGVyTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtfVUlST1VURVJfRElSRUNUSVZFU10sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW19VSVJPVVRFUl9ESVJFQ1RJVkVTXSxcbiAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtVSVZpZXddLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5VSVJvdXRlck1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWlSb3V0ZXJOZ01vZHVsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvYW5ndWxhci9saWIvdWlSb3V0ZXJOZ01vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIEBuZzJhcGkgQG1vZHVsZSBkaXJlY3RpdmVzICovXG4vKiogKi9cbmltcG9ydCB7IFVJUm91dGVyLCBleHRlbmQgfSBmcm9tIFwiQHVpcm91dGVyL2NvcmVcIjtcbmltcG9ydCB7IERpcmVjdGl2ZSwgSW5qZWN0LCBJbnB1dCwgT3B0aW9uYWwsIEVsZW1lbnRSZWYsIFJlbmRlcmVyMiB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBVSVZpZXcgfSBmcm9tIFwiLi91aVZpZXdcIjtcbmltcG9ydCB7IFJlcGxheVN1YmplY3QgfSBmcm9tIFwicnhqcy9SZXBsYXlTdWJqZWN0XCI7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogIyBibGFoIGJsYWggYmxhaFxuICovXG52YXIgQW5jaG9yVUlTcmVmID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbmNob3JVSVNyZWYoX2VsLCBfcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5fZWwgPSBfZWw7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgIH1cbiAgICBBbmNob3JVSVNyZWYucHJvdG90eXBlLm9wZW5Jbk5ld1RhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQudGFyZ2V0ID09PSAnX2JsYW5rJztcbiAgICB9O1xuICAgIEFuY2hvclVJU3JlZi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGhyZWYpIHtcbiAgICAgICAgaWYgKGhyZWYgJiYgaHJlZiAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQsICdocmVmJywgaHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVBdHRyaWJ1dGUodGhpcy5fZWwubmF0aXZlRWxlbWVudCwgJ2hyZWYnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFuY2hvclVJU3JlZjtcbn0oKSk7XG5leHBvcnQgeyBBbmNob3JVSVNyZWYgfTtcbkFuY2hvclVJU3JlZi5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ2FbdWlTcmVmXScgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5BbmNob3JVSVNyZWYuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyLCB9LFxuXTsgfTtcbi8qKlxuICogQSBkaXJlY3RpdmUgd2hlbiBjbGlja2VkLCBpbml0aWF0ZXMgYSBbW1RyYW5zaXRpb25dXSB0byBhIFtbVGFyZ2V0U3RhdGVdXS5cbiAqXG4gKiAjIyMgUHVycG9zZVxuICpcbiAqIFRoaXMgZGlyZWN0aXZlIGlzIGFwcGxpZWQgdG8gYW5jaG9yIHRhZ3MgKGA8YT5gKSBvciBhbnkgb3RoZXIgY2xpY2thYmxlIGVsZW1lbnQuICBJdCBpcyBhIHN0YXRlIHJlZmVyZW5jZSAob3Igc3JlZiAtLVxuICogc2ltaWxhciB0byBhbiBocmVmKS4gIFdoZW4gY2xpY2tlZCwgdGhlIGRpcmVjdGl2ZSB3aWxsIHRyYW5zaXRpb24gdG8gdGhhdCBzdGF0ZSBieSBjYWxsaW5nIFtbU3RhdGVTZXJ2aWNlLmdvXV0sXG4gKiBhbmQgb3B0aW9uYWxseSBzdXBwbHkgc3RhdGUgcGFyYW1ldGVyIHZhbHVlcyBhbmQgdHJhbnNpdGlvbiBvcHRpb25zLlxuICpcbiAqIFdoZW4gdGhpcyBkaXJlY3RpdmUgaXMgb24gYW4gYW5jaG9yIHRhZywgaXQgd2lsbCBhbHNvIGFkZCBhbiBgaHJlZmAgYXR0cmlidXRlIHRvIHRoZSBhbmNob3IuXG4gKlxuICogIyMjIFNlbGVjdG9yXG4gKlxuICogLSBgW3VpU3JlZl1gOiBUaGUgZGlyZWN0aXZlIGlzIGNyZWF0ZWQgYXMgYW4gYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQsIGUuZy4sIGA8YSB1aVNyZWY+PC9hPmBcbiAqXG4gKiAjIyMgSW5wdXRzXG4gKlxuICogLSBgdWlTcmVmYDogdGhlIHRhcmdldCBzdGF0ZSdzIG5hbWUsIGUuZy4sIGB1aVNyZWY9XCJmb29zdGF0ZVwiYC4gIElmIGEgY29tcG9uZW50IHRlbXBsYXRlIHVzZXMgYSByZWxhdGl2ZSBgdWlTcmVmYCxcbiAqIGUuZy4sIGB1aVNyZWY9XCIuY2hpbGRcImAsIHRoZSByZWZlcmVuY2UgaXMgcmVsYXRpdmUgdG8gdGhhdCBjb21wb25lbnQncyBzdGF0ZS5cbiAqXG4gKiAtIGB1aVBhcmFtc2A6IGFueSB0YXJnZXQgc3RhdGUgcGFyYW1ldGVyIHZhbHVlcywgYXMgYW4gb2JqZWN0LCBlLmcuLCBgW3VpUGFyYW1zXT1cInsgZm9vSWQ6IGJhci5mb29JZCB9XCJgXG4gKlxuICogLSBgdWlPcHRpb25zYDogW1tUcmFuc2l0aW9uT3B0aW9uc11dLCBlLmcuLCBgW3VpT3B0aW9uc109XCJ7IGluaGVyaXQ6IGZhbHNlIH1cImBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbFxuICpcbiAqIDwhLS0gVGFyZ2V0cyBiYXIgc3RhdGUnIC0tPlxuICogPGEgdWlTcmVmPVwiYmFyXCI+QmFyPC9hPlxuICpcbiAqIDwhLS0gQXNzdW1lIHRoaXMgY29tcG9uZW50J3Mgc3RhdGUgaXMgXCJmb29cIi5cbiAqICAgICAgUmVsYXRpdmVseSB0YXJnZXRzIFwiZm9vLmNoaWxkXCIgLS0+XG4gKiA8YSB1aVNyZWY9XCIuY2hpbGRcIj5Gb28gQ2hpbGQ8L2E+XG4gKlxuICogPCEtLSBUYXJnZXRzIFwiYmFyXCIgc3RhdGUgYW5kIHN1cHBsaWVzIHBhcmFtZXRlciB2YWx1ZSAtLT5cbiAqIDxhIHVpU3JlZj1cImJhclwiIFt1aVBhcmFtc109XCJ7IGJhcklkOiBmb28uYmFySWQgfVwiPkJhciB7e2Zvby5iYXJJZH19PC9hPlxuICpcbiAqIDwhLS0gVGFyZ2V0cyBcImJhclwiIHN0YXRlIGFuZCBwYXJhbWV0ZXIsIGRvZXNuJ3QgaW5oZXJpdCBleGlzdGluZyBwYXJhbWV0ZXJzLS0+XG4gKiA8YSB1aVNyZWY9XCJiYXJcIiBbdWlQYXJhbXNdPVwieyBiYXJJZDogZm9vLmJhcklkIH1cIiBbdWlPcHRpb25zXT1cInsgaW5oZXJpdDogZmFsc2UgfVwiPkJhciB7e2Zvby5iYXJJZH19PC9hPlxuICogYGBgXG4gKi9cbnZhciBVSVNyZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVJU3JlZihfcm91dGVyLCBfYW5jaG9yVUlTcmVmLCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9ic2VydmFibGUgKFJlcGxheVN1YmplY3QpIG9mIHRoZSBzdGF0ZSB0aGlzIFVJU3JlZiBpcyB0YXJnZXRpbmcuXG4gICAgICAgICAqIFdoZW4gdGhlIFVJU3JlZiBpcyBjbGlja2VkLCBpdCB3aWxsIHRyYW5zaXRpb24gdG8gdGhpcyBbW1RhcmdldFN0YXRlXV0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhcmdldFN0YXRlJCA9IG5ldyBSZXBsYXlTdWJqZWN0KDEpO1xuICAgICAgICAvKiogQGludGVybmFsYXBpICovIHRoaXMuX2VtaXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcm91dGVyID0gX3JvdXRlcjtcbiAgICAgICAgdGhpcy5fYW5jaG9yVUlTcmVmID0gX2FuY2hvclVJU3JlZjtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuX3N0YXRlc1N1YiA9IF9yb3V0ZXIuZ2xvYmFscy5zdGF0ZXMkLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy51cGRhdGUoKTsgfSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVSVNyZWYucHJvdG90eXBlLCBcInVpU3JlZlwiLCB7XG4gICAgICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuc3RhdGUgPSB2YWw7IHRoaXMudXBkYXRlKCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVSVNyZWYucHJvdG90eXBlLCBcInVpUGFyYW1zXCIsIHtcbiAgICAgICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5wYXJhbXMgPSB2YWw7IHRoaXMudXBkYXRlKCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVSVNyZWYucHJvdG90eXBlLCBcInVpT3B0aW9uc1wiLCB7XG4gICAgICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMub3B0aW9ucyA9IHZhbDsgdGhpcy51cGRhdGUoKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVUlTcmVmLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZW1pdCA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBVSVNyZWYucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIFVJU3JlZi5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2VtaXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhdGVzU3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMudGFyZ2V0U3RhdGUkLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBVSVNyZWYucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRzdGF0ZSA9IHRoaXMuX3JvdXRlci5zdGF0ZVNlcnZpY2U7XG4gICAgICAgIGlmICh0aGlzLl9lbWl0KSB7XG4gICAgICAgICAgICB2YXIgbmV3VGFyZ2V0ID0gJHN0YXRlLnRhcmdldCh0aGlzLnN0YXRlLCB0aGlzLnBhcmFtcywgdGhpcy5nZXRPcHRpb25zKCkpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRTdGF0ZSQubmV4dChuZXdUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hbmNob3JVSVNyZWYpIHtcbiAgICAgICAgICAgIHZhciBocmVmID0gJHN0YXRlLmhyZWYodGhpcy5zdGF0ZSwgdGhpcy5wYXJhbXMsIHRoaXMuZ2V0T3B0aW9ucygpKTtcbiAgICAgICAgICAgIHRoaXMuX2FuY2hvclVJU3JlZi51cGRhdGUoaHJlZik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVJU3JlZi5wcm90b3R5cGUuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRPcHRzID0ge1xuICAgICAgICAgICAgcmVsYXRpdmU6IHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmNvbnRleHQgJiYgdGhpcy5wYXJlbnQuY29udGV4dC5uYW1lLFxuICAgICAgICAgICAgaW5oZXJpdDogdHJ1ZSxcbiAgICAgICAgICAgIHNvdXJjZTogXCJzcmVmXCJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZChkZWZhdWx0T3B0cywgdGhpcy5vcHRpb25zIHx8IHt9KTtcbiAgICB9O1xuICAgIC8qKiBXaGVuIHRyaWdnZXJlZCBieSBhIChjbGljaykgZXZlbnQsIHRoaXMgZnVuY3Rpb24gdHJhbnNpdGlvbnMgdG8gdGhlIFVJU3JlZidzIHRhcmdldCBzdGF0ZSAqL1xuICAgIFVJU3JlZi5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hbmNob3JVSVNyZWYgJiYgdGhpcy5fYW5jaG9yVUlTcmVmLm9wZW5Jbk5ld1RhYigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcm91dGVyLnN0YXRlU2VydmljZS5nbyh0aGlzLnN0YXRlLCB0aGlzLnBhcmFtcywgdGhpcy5nZXRPcHRpb25zKCkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gVUlTcmVmO1xufSgpKTtcbmV4cG9ydCB7IFVJU3JlZiB9O1xuVUlTcmVmLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbdWlTcmVmXScsXG4gICAgICAgICAgICAgICAgaG9zdDogeyAnKGNsaWNrKSc6ICdnbygpJyB9XG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblVJU3JlZi5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IFVJUm91dGVyLCB9LFxuICAgIHsgdHlwZTogQW5jaG9yVUlTcmVmLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbVUlWaWV3LlBBUkVOVF9JTkpFQ1QsXSB9LF0gfSxcbl07IH07XG5VSVNyZWYucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ3N0YXRlJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsndWlTcmVmJyxdIH0sXSxcbiAgICAncGFyYW1zJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsndWlQYXJhbXMnLF0gfSxdLFxuICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsndWlPcHRpb25zJyxdIH0sXSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11aVNyZWYuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2FuZ3VsYXIvbGliL2RpcmVjdGl2ZXMvdWlTcmVmLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogQG5nMmFwaSBAbW9kdWxlIGRpcmVjdGl2ZXMgKi9cbi8qKiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgQ29udGVudENoaWxkcmVuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVSVNyZWYgfSBmcm9tICcuL3VpU3JlZic7XG5pbXBvcnQgeyBhbnlUcnVlUiwgdGFpbCwgdW5uZXN0UiwgVUlSb3V0ZXJHbG9iYWxzLCBQYXJhbSwgUGF0aFV0aWxzIH0gZnJvbSAnQHVpcm91dGVyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgb2YgfSBmcm9tICdyeGpzL29ic2VydmFibGUvb2YnO1xuaW1wb3J0IHsgZnJvbVByb21pc2UgfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbVByb21pc2UnO1xuaW1wb3J0IHsgY29tYmluZUxhdGVzdCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0JztcbmltcG9ydCB7IHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3Ivc3dpdGNoTWFwJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3IvbWFwJztcbmltcG9ydCB7IGNvbmNhdCB9IGZyb20gJ3J4anMvb3BlcmF0b3IvY29uY2F0Jztcbi8qKiBAaW50ZXJuYWxhcGkgKi9cbnZhciBpbmFjdGl2ZVN0YXR1cyA9IHtcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIGV4YWN0OiBmYWxzZSxcbiAgICBlbnRlcmluZzogZmFsc2UsXG4gICAgZXhpdGluZzogZmFsc2UsXG4gICAgdGFyZ2V0U3RhdGVzOiBbXSxcbn07XG4vKipcbiAqIFJldHVybnMgYSBQcmVkaWNhdGU8UGF0aE5vZGVbXT5cbiAqXG4gKiBUaGUgcHJlZGljYXRlIHJldHVybnMgdHJ1ZSB3aGVuIHRoZSB0YXJnZXQgc3RhdGUgKGFuZCBwYXJhbSB2YWx1ZXMpXG4gKiBtYXRjaCB0aGUgKHRhaWwgb2YpIHRoZSBwYXRoLCBhbmQgdGhlIHBhdGgncyBwYXJhbSB2YWx1ZXNcbiAqXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xudmFyIHBhdGhNYXRjaGVzID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGlmICghdGFyZ2V0LmV4aXN0cygpKVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgdmFyIHN0YXRlID0gdGFyZ2V0LiRzdGF0ZSgpO1xuICAgIHZhciB0YXJnZXRQYXJhbVZhbHMgPSB0YXJnZXQucGFyYW1zKCk7XG4gICAgdmFyIHRhcmdldFBhdGggPSBQYXRoVXRpbHMuYnVpbGRQYXRoKHRhcmdldCk7XG4gICAgdmFyIHBhcmFtU2NoZW1hID0gdGFyZ2V0UGF0aC5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUucGFyYW1TY2hlbWE7IH0pXG4gICAgICAgIC5yZWR1Y2UodW5uZXN0UiwgW10pXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiB0YXJnZXRQYXJhbVZhbHMuaGFzT3duUHJvcGVydHkocGFyYW0uaWQpOyB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHRhaWxOb2RlID0gdGFpbChwYXRoKTtcbiAgICAgICAgaWYgKCF0YWlsTm9kZSB8fCB0YWlsTm9kZS5zdGF0ZSAhPT0gc3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBwYXJhbVZhbHVlcyA9IFBhdGhVdGlscy5wYXJhbVZhbHVlcyhwYXRoKTtcbiAgICAgICAgcmV0dXJuIFBhcmFtLmVxdWFscyhwYXJhbVNjaGVtYSwgcGFyYW1WYWx1ZXMsIHRhcmdldFBhcmFtVmFscyk7XG4gICAgfTtcbn07XG4vKipcbiAqIEdpdmVuIGJhc2VQYXRoOiBbYSwgYl0sIGFwcGVuZFBhdGg6IFtjLCBkXSksXG4gKiBFeHBhbmRzIHRoZSBwYXRoIHRvIFtjXSwgW2MsIGRdXG4gKiBUaGVuIGFwcGVuZHMgZWFjaCB0byBbYSxiLF0gYW5kIHJldHVybnM6IFthLCBiLCBjXSwgW2EsIGIsIGMsIGRdXG4gKlxuICogQGludGVybmFsYXBpXG4gKi9cbmZ1bmN0aW9uIHNwcmVhZFRvU3ViUGF0aHMoYmFzZVBhdGgsIGFwcGVuZFBhdGgpIHtcbiAgICByZXR1cm4gYXBwZW5kUGF0aC5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGJhc2VQYXRoLmNvbmNhdChQYXRoVXRpbHMuc3ViUGF0aChhcHBlbmRQYXRoLCBmdW5jdGlvbiAobikgeyByZXR1cm4gbi5zdGF0ZSA9PT0gbm9kZS5zdGF0ZTsgfSkpOyB9KTtcbn1cbi8qKlxuICogR2l2ZW4gYSBUcmFuc0V2dCAoVHJhbnNpdGlvbiBldmVudDogc3RhcnRlZCwgc3VjY2VzcywgZXJyb3IpXG4gKiBhbmQgYSBVSVNyZWYgVGFyZ2V0IFN0YXRlLCByZXR1cm4gYSBTcmVmU3RhdHVzIG9iamVjdFxuICogd2hpY2ggcmVwcmVzZW50cyB0aGUgY3VycmVudCBzdGF0dXMgb2YgdGhhdCBTcmVmOlxuICogYWN0aXZlLCBhY3RpdmVFcSAoZXhhY3QgbWF0Y2gpLCBlbnRlcmluZywgZXhpdGluZ1xuICpcbiAqIEBpbnRlcm5hbGFwaVxuICovXG5mdW5jdGlvbiBnZXRTcmVmU3RhdHVzKGV2ZW50LCBzcmVmVGFyZ2V0KSB7XG4gICAgdmFyIHBhdGhNYXRjaGVzVGFyZ2V0ID0gcGF0aE1hdGNoZXMoc3JlZlRhcmdldCk7XG4gICAgdmFyIHRjID0gZXZlbnQudHJhbnMudHJlZUNoYW5nZXMoKTtcbiAgICB2YXIgaXNTdGFydEV2ZW50ID0gZXZlbnQuZXZ0ID09PSAnc3RhcnQnO1xuICAgIHZhciBpc1N1Y2Nlc3NFdmVudCA9IGV2ZW50LmV2dCA9PT0gJ3N1Y2Nlc3MnO1xuICAgIHZhciBhY3RpdmVQYXRoID0gaXNTdWNjZXNzRXZlbnQgPyB0Yy50byA6IHRjLmZyb207XG4gICAgdmFyIGlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3ByZWFkVG9TdWJQYXRocyhbXSwgYWN0aXZlUGF0aClcbiAgICAgICAgICAgIC5tYXAocGF0aE1hdGNoZXNUYXJnZXQpXG4gICAgICAgICAgICAucmVkdWNlKGFueVRydWVSLCBmYWxzZSk7XG4gICAgfTtcbiAgICB2YXIgaXNFeGFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhNYXRjaGVzVGFyZ2V0KGFjdGl2ZVBhdGgpO1xuICAgIH07XG4gICAgdmFyIGlzRW50ZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzcHJlYWRUb1N1YlBhdGhzKHRjLnJldGFpbmVkLCB0Yy5lbnRlcmluZylcbiAgICAgICAgICAgIC5tYXAocGF0aE1hdGNoZXNUYXJnZXQpXG4gICAgICAgICAgICAucmVkdWNlKGFueVRydWVSLCBmYWxzZSk7XG4gICAgfTtcbiAgICB2YXIgaXNFeGl0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3ByZWFkVG9TdWJQYXRocyh0Yy5yZXRhaW5lZCwgdGMuZXhpdGluZylcbiAgICAgICAgICAgIC5tYXAocGF0aE1hdGNoZXNUYXJnZXQpXG4gICAgICAgICAgICAucmVkdWNlKGFueVRydWVSLCBmYWxzZSk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhY3RpdmU6IGlzQWN0aXZlKCksXG4gICAgICAgIGV4YWN0OiBpc0V4YWN0KCksXG4gICAgICAgIGVudGVyaW5nOiBpc1N0YXJ0RXZlbnQgPyBpc0VudGVyaW5nKCkgOiBmYWxzZSxcbiAgICAgICAgZXhpdGluZzogaXNTdGFydEV2ZW50ID8gaXNFeGl0aW5nKCkgOiBmYWxzZSxcbiAgICAgICAgdGFyZ2V0U3RhdGVzOiBbc3JlZlRhcmdldF0sXG4gICAgfTtcbn1cbi8qKiBAaW50ZXJuYWxhcGkgKi9cbmZ1bmN0aW9uIG1lcmdlU3JlZlN0YXR1cyhsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFjdGl2ZTogbGVmdC5hY3RpdmUgfHwgcmlnaHQuYWN0aXZlLFxuICAgICAgICBleGFjdDogbGVmdC5leGFjdCB8fCByaWdodC5leGFjdCxcbiAgICAgICAgZW50ZXJpbmc6IGxlZnQuZW50ZXJpbmcgfHwgcmlnaHQuZW50ZXJpbmcsXG4gICAgICAgIGV4aXRpbmc6IGxlZnQuZXhpdGluZyB8fCByaWdodC5leGl0aW5nLFxuICAgICAgICB0YXJnZXRTdGF0ZXM6IGxlZnQudGFyZ2V0U3RhdGVzLmNvbmNhdChyaWdodC50YXJnZXRTdGF0ZXMpLFxuICAgIH07XG59XG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGVtaXRzIGV2ZW50cyB3aGVuIGEgcGFpcmVkIFtbVUlTcmVmXV0gc3RhdHVzIGNoYW5nZXMuXG4gKlxuICogVGhpcyBkaXJlY3RpdmUgaXMgcHJpbWFyaWx5IHVzZWQgYnkgdGhlIFtbVUlTcmVmQWN0aXZlXV0gZGlyZWN0aXZlcyB0byBtb25pdG9yIGBVSVNyZWZgKHMpLlxuICpcbiAqIFRoaXMgZGlyZWN0aXZlIHNoYXJlcyB0d28gYXR0cmlidXRlIHNlbGVjdG9ycyB3aXRoIGBVSVNyZWZBY3RpdmVgOlxuICpcbiAqIC0gYFt1aVNyZWZBY3RpdmVdYFxuICogLSBgW3VpU3JlZkFjdGl2ZUVxXWAuXG4gKlxuICogVGh1cywgd2hlbmV2ZXIgYSBgVUlTcmVmQWN0aXZlYCBkaXJlY3RpdmUgaXMgY3JlYXRlZCwgYSBgVUlTcmVmU3RhdHVzYCBkaXJlY3RpdmUgaXMgYWxzbyBjcmVhdGVkLlxuICpcbiAqIE1vc3QgYXBwcyBzaG91bGQgc2ltcGx5IHVzZSBgVUlTcmVmQWN0aXZlYCwgYnV0IHNvbWUgYWR2YW5jZWQgY29tcG9uZW50cyBtYXkgd2FudCB0byBwcm9jZXNzIHRoZVxuICogW1tTcmVmU3RhdHVzXV0gZXZlbnRzIGRpcmVjdGx5LlxuICpcbiAqIGBgYGpzXG4gKiA8bGkgKHVpU3JlZlN0YXR1cyk9XCJvblNyZWZTdGF0dXNDaGFuZ2VkKCRldmVudClcIj5cbiAqICAgPGEgdWlTcmVmPVwiYm9va1wiIFt1aVBhcmFtc109XCJ7IGJvb2tJZDogYm9vay5pZCB9XCI+Qm9vayB7eyBib29rLm5hbWUgfX08L2E+XG4gKiA8L2xpPlxuICogYGBgXG4gKlxuICogVGhlIGB1aVNyZWZTdGF0dXNgIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbmV2ZXIgYW4gZW5jbG9zZWQgYHVpU3JlZmAncyBzdGF0dXMgY2hhbmdlcy5cbiAqIFRoZSBldmVudCBlbWl0dGVkIGlzIG9mIHR5cGUgW1tTcmVmU3RhdHVzXV0sIGFuZCBoYXMgYm9vbGVhbiB2YWx1ZXMgZm9yIGBhY3RpdmVgLCBgZXhhY3RgLCBgZW50ZXJpbmdgLCBhbmQgYGV4aXRpbmdgOyBhbHNvIGhhcyBhIFtbU3RhdGVPck5hbWVdXSBgaWRlbnRpZmllcmB2YWx1ZS5cbiAqXG4gKiBUaGUgdmFsdWVzIGZyb20gdGhpcyBldmVudCBjYW4gYmUgY2FwdHVyZWQgYW5kIHN0b3JlZCBvbiBhIGNvbXBvbmVudCAodGhlbiBhcHBsaWVkLCBlLmcuLCB1c2luZyBuZ0NsYXNzKS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBBIHNpbmdsZSBgdWlTcmVmU3RhdHVzYCBjYW4gZW5jbG9zZSBtdWx0aXBsZSBgdWlTcmVmYC5cbiAqIEVhY2ggc3RhdHVzIGJvb2xlYW4gKGBhY3RpdmVgLCBgZXhhY3RgLCBgZW50ZXJpbmdgLCBgZXhpdGluZ2ApIHdpbGwgYmUgdHJ1ZSBpZiAqYW55IG9mIHRoZSBlbmNsb3NlZCBgdWlTcmVmYCBzdGF0dXMgaXMgdHJ1ZSouXG4gKiBJbiBvdGhlciB3b3JkcywgYWxsIGVuY2xvc2VkIGB1aVNyZWZgIHN0YXR1c2VzICBhcmUgbWVyZ2VkIHRvIGEgc2luZ2xlIHN0YXR1cyB1c2luZyBgfHxgIChsb2dpY2FsIG9yKS5cbiAqXG4gKiBgYGBqc1xuICogPGxpICh1aVNyZWZTdGF0dXMpPVwib25TcmVmU3RhdHVzKCRldmVudClcIiB1aVNyZWY9XCJhZG1pblwiPlxuICogICBIb21lXG4gKiAgIDx1bD5cbiAqICAgICA8bGk+IDxhIHVpU3JlZj1cImFkbWluLnVzZXJzXCI+VXNlcnM8L2E+IDwvbGk+XG4gKiAgICAgPGxpPiA8YSB1aVNyZWY9XCJhZG1pbi5ncm91cHNcIj5Hcm91cHM8L2E+IDwvbGk+XG4gKiAgIDwvdWw+XG4gKiA8L2xpPlxuICogYGBgXG4gKlxuICogSW4gdGhlIGFib3ZlIGV4YW1wbGUsIGAkZXZlbnQuYWN0aXZlID09PSB0cnVlYCB3aGVuIGVpdGhlciBgYWRtaW4udXNlcnNgIG9yIGBhZG1pbi5ncm91cHNgIGlzIGFjdGl2ZS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBUaGlzIEFQSSBpcyBzdWJqZWN0IHRvIGNoYW5nZS5cbiAqL1xudmFyIFVJU3JlZlN0YXR1cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVUlTcmVmU3RhdHVzKF9nbG9iYWxzKSB7XG4gICAgICAgIC8qKiBjdXJyZW50IHN0YXR1c2VzIG9mIHRoZSBzdGF0ZS9wYXJhbXMgdGhlIHVpU3JlZiBkaXJlY3RpdmUgaXMgbGlua2luZyB0byAqL1xuICAgICAgICB0aGlzLnVpU3JlZlN0YXR1cyA9IG5ldyBFdmVudEVtaXR0ZXIoZmFsc2UpO1xuICAgICAgICB0aGlzLl9nbG9iYWxzID0gX2dsb2JhbHM7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gT2JqZWN0LmFzc2lnbih7fSwgaW5hY3RpdmVTdGF0dXMpO1xuICAgIH1cbiAgICBVSVNyZWZTdGF0dXMucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gTWFwIGVhY2ggdHJhbnNpdGlvbiBzdGFydCBldmVudCB0byBhIHN0cmVhbSBvZjpcbiAgICAgICAgLy8gc3RhcnQgLT4gKHN1Y2Nlc3N8ZXJyb3IpXG4gICAgICAgIHZhciB0cmFuc0V2ZW50cyQgPSBzd2l0Y2hNYXAuY2FsbCh0aGlzLl9nbG9iYWxzLnN0YXJ0JCwgZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBmdW5jdGlvbiAoZXZ0KSB7IHJldHVybiAoeyBldnQ6IGV2dCwgdHJhbnM6IHRyYW5zIH0pOyB9O1xuICAgICAgICAgICAgdmFyIHRyYW5zU3RhcnQkID0gb2YoZXZlbnQoXCJzdGFydFwiKSk7XG4gICAgICAgICAgICB2YXIgdHJhbnNSZXN1bHQgPSB0cmFucy5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlbnQoXCJzdWNjZXNzXCIpOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBldmVudChcImVycm9yXCIpOyB9KTtcbiAgICAgICAgICAgIHZhciB0cmFuc0ZpbmlzaCQgPSBmcm9tUHJvbWlzZSh0cmFuc1Jlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0LmNhbGwodHJhbnNTdGFydCQsIHRyYW5zRmluaXNoJCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXYXRjaCB0aGUgQENvbnRlbnRDaGlsZHJlbiBVSVNyZWZbXSBjb21wb25lbnRzIGFuZCBnZXQgdGhlaXIgdGFyZ2V0IHN0YXRlc1xuICAgICAgICAvLyBsZXQgc3JlZnMkOiBPYnNlcnZhYmxlPFVJU3JlZltdPiA9IG9mKHRoaXMuc3JlZnMudG9BcnJheSgpKS5jb25jYXQodGhpcy5zcmVmcy5jaGFuZ2VzKTtcbiAgICAgICAgdGhpcy5fc3JlZnMkID0gbmV3IEJlaGF2aW9yU3ViamVjdCh0aGlzLnNyZWZzLnRvQXJyYXkoKSk7XG4gICAgICAgIHRoaXMuX3NyZWZDaGFuZ2VzU3ViID0gdGhpcy5zcmVmcy5jaGFuZ2VzLnN1YnNjcmliZShmdW5jdGlvbiAoc3JlZnMpIHsgcmV0dXJuIF90aGlzLl9zcmVmcyQubmV4dChzcmVmcyk7IH0pO1xuICAgICAgICB2YXIgdGFyZ2V0U3RhdGVzJCA9IHN3aXRjaE1hcC5jYWxsKHRoaXMuX3NyZWZzJCwgZnVuY3Rpb24gKHNyZWZzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tYmluZUxhdGVzdChzcmVmcy5tYXAoZnVuY3Rpb24gKHNyZWYpIHsgcmV0dXJuIHNyZWYudGFyZ2V0U3RhdGUkOyB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHN0YXR1cyBvZiBlYWNoIFVJU3JlZiBiYXNlZCBvbiB0aGUgdHJhbnNpdGlvbiBldmVudC5cbiAgICAgICAgLy8gUmVkdWNlIHRoZSBzdGF0dXNlcyAoaWYgbXVsdGlwbGUpIGJ5IG9yLWluZyBlYWNoIGZsYWcuXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHN3aXRjaE1hcC5jYWxsKHRyYW5zRXZlbnRzJCwgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcC5jYWxsKHRhcmdldFN0YXRlcyQsIGZ1bmN0aW9uICh0YXJnZXRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1c2VzID0gdGFyZ2V0cy5tYXAoZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gZ2V0U3JlZlN0YXR1cyhldnQsIHRhcmdldCk7IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0dXNlcy5yZWR1Y2UobWVyZ2VTcmVmU3RhdHVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5zdWJzY3JpYmUodGhpcy5fc2V0U3RhdHVzLmJpbmQodGhpcykpO1xuICAgIH07XG4gICAgVUlTcmVmU3RhdHVzLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbilcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICBpZiAodGhpcy5fc3JlZkNoYW5nZXNTdWIpXG4gICAgICAgICAgICB0aGlzLl9zcmVmQ2hhbmdlc1N1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICBpZiAodGhpcy5fc3JlZnMkKVxuICAgICAgICAgICAgdGhpcy5fc3JlZnMkLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuX3NyZWZDaGFuZ2VzU3ViID0gdGhpcy5fc3JlZnMkID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgVUlTcmVmU3RhdHVzLnByb3RvdHlwZS5fc2V0U3RhdHVzID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy51aVNyZWZTdGF0dXMuZW1pdChzdGF0dXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFVJU3JlZlN0YXR1cztcbn0oKSk7XG5leHBvcnQgeyBVSVNyZWZTdGF0dXMgfTtcblVJU3JlZlN0YXR1cy5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1t1aVNyZWZTdGF0dXNdLFt1aVNyZWZBY3RpdmVdLFt1aVNyZWZBY3RpdmVFcV0nIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuVUlTcmVmU3RhdHVzLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogVUlSb3V0ZXJHbG9iYWxzLCB9LFxuXTsgfTtcblVJU3JlZlN0YXR1cy5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAndWlTcmVmU3RhdHVzJzogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbXCJ1aVNyZWZTdGF0dXNcIixdIH0sXSxcbiAgICAnc3JlZnMnOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtVSVNyZWYsIHsgZGVzY2VuZGFudHM6IHRydWUgfSxdIH0sXSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11aVNyZWZTdGF0dXMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2FuZ3VsYXIvbGliL2RpcmVjdGl2ZXMvdWlTcmVmU3RhdHVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqICMgVUktUm91dGVyIGZvciBBbmd1bGFyICh2MispXG4gKlxuICogLSBbQHVpcm91dGVyL2FuZ3VsYXIgaG9tZSBwYWdlXShodHRwczovL3VpLXJvdXRlci5naXRodWIuaW8vbmcyKVxuICogLSBbdHV0b3JpYWxzXShodHRwczovL3VpLXJvdXRlci5naXRodWIuaW8vdHV0b3JpYWwvbmcyL2hlbGxvd29ybGQpXG4gKiAtIFtxdWljayBzdGFydCByZXBvc2l0b3J5XShodHRwOi8vZ2l0aHViLmNvbS91aS1yb3V0ZXIvcXVpY2tzdGFydC1uZzIpXG4gKlxuICogR2V0dGluZyBzdGFydGVkOlxuICpcbiAqIC0gVXNlIG5wbS4gQWRkIGEgZGVwZW5kZW5jeSBvbiBsYXRlc3QgYEB1aXJvdXRlci9hbmd1bGFyYFxuICogLSBJbXBvcnQgVUktUm91dGVyIGNsYXNzZXMgZGlyZWN0bHkgZnJvbSBgXCJAdWlyb3V0ZXIvYW5ndWxhclwiYFxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQge1N0YXRlUmVnaXN0cnl9IGZyb20gXCJAdWlyb3V0ZXIvYW5ndWxhclwiO1xuICogYGBgXG4gKlxuICogLSBDcmVhdGUgYXBwbGljYXRpb24gc3RhdGVzIChhcyBkZWZpbmVkIGJ5IFtbTmcyU3RhdGVEZWNsYXJhdGlvbl1dKS5cbiAqXG4gKiBgYGBqc1xuICogZXhwb3J0IGxldCBzdGF0ZTE6IE5nMlN0YXRlRGVjbGFyYXRpb24gPSB7XG4gKiAgIG5hbWU6ICdzdGF0ZTEnLFxuICogICBjb21wb25lbnQ6IFN0YXRlMUNvbXBvbmVudCxcbiAqICAgdXJsOiAnL29uZSdcbiAqIH1cbiAqXG4gKiBleHBvcnQgbGV0IHN0YXRlMjogTmcyU3RhdGVEZWNsYXJhdGlvbiA9IHtcbiAqICAgbmFtZTogJ3N0YXRlMicsXG4gKiAgIGNvbXBvbmVudDogU3RhdGUyQ29tcG9uZW50LFxuICogICB1cmw6ICcvdHdvJ1xuICogfVxuICogYGBgXG4gKlxuICogLSBJbXBvcnQgYSBbW1VJUm91dGVyTW9kdWxlLmZvckNoaWxkXV0gbW9kdWxlIGludG8geW91ciBmZWF0dXJlIGBOZ01vZHVsZWBzLlxuICpcbiAqIGBgYGpzXG4gKiBAIE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIFNoYXJlZE1vZHVsZSxcbiAqICAgICBVSVJvdXRlck1vZHVsZS5mb3JDaGlsZCh7IHN0YXRlczogW3N0YXRlMSwgc3RhdGUyIF0gfSlcbiAqICAgXSxcbiAqICAgZGVjbGFyYXRpb25zOiBbXG4gKiAgICAgU3RhdGUxQ29tcG9uZW50LFxuICogICAgIFN0YXRlMkNvbXBvbmVudCxcbiAqICAgXVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBNeUZlYXR1cmVNb2R1bGUge31cbiAqIGBgYFxuICpcbiAqIC0gSW1wb3J0IGEgW1tVSVJvdXRlck1vZHVsZS5mb3JSb290XV0gbW9kdWxlIGludG8geW91ciBhcHBsaWNhdGlvbiByb290IGBOZ01vZHVsZWBcbiAqIC0gRWl0aGVyIGJvb3RzdHJhcCBhIFtbVUlWaWV3XV0gY29tcG9uZW50LCBvciBhZGQgYSBgPHVpLXZpZXc+PC91aS12aWV3PmAgdmlld3BvcnQgdG8geW91ciByb290IGNvbXBvbmVudC5cbiAqXG4gKiBgYGBqc1xuICogQCBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICBCcm93c2VyTW9kdWxlLFxuICogICAgIFVJUm91dGVyTW9kdWxlLmZvclJvb3QoeyBzdGF0ZXM6IFsgaG9tZVN0YXRlIF0gfSksXG4gKiAgICAgTXlGZWF0dXJlTW9kdWxlLFxuICogICBdLFxuICogICBkZWNsYXJhdGlvbnM6IFtcbiAqICAgICBIb21lQ29tcG9uZW50XG4gKiAgIF1cbiAqICAgYm9vdHN0cmFwOiBbIFVJVmlldyBdXG4gKiB9KVxuICogY2xhc3MgUm9vdEFwcE1vZHVsZSB7fVxuICpcbiAqIGJyb3dzZXJQbGF0Zm9ybUR5bmFtaWMuYm9vdHN0cmFwTW9kdWxlKFJvb3RBcHBNb2R1bGUpO1xuICogYGBgXG4gKlxuICogLSBPcHRpb25hbGx5IHNwZWNpZnkgYSBjb25maWd1cmF0aW9uIGNsYXNzIFtbQ2hpbGRNb2R1bGUuY29uZmlnQ2xhc3NdXSBmb3IgYW55IG1vZHVsZVxuICogdG8gcGVyZm9ybSBhbnkgcm91dGVyIGNvbmZpZ3VyYXRpb24gZHVyaW5nIGJvb3RzdHJhcCBvciBsYXp5bG9hZC5cbiAqIFBhc3MgdGhlIGNsYXNzIHRvIFtbVUlSb3V0ZXJNb2R1bGUuZm9yUm9vdF1dIG9yIFtbVUlSb3V0ZXJNb2R1bGUuZm9yQ2hpbGRdXS5cbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHtVSVJvdXRlcn0gZnJvbSBcIkB1aXJvdXRlci9hbmd1bGFyXCI7XG4gKlxuICogQCBJbmplY3RhYmxlKClcbiAqIGV4cG9ydCBjbGFzcyBNeVVJUm91dGVyQ29uZmlnIHtcbiAqICAgLy8gQ29uc3RydWN0b3IgaXMgaW5qZWN0YWJsZVxuICogICBjb25zdHJ1Y3Rvcih1aVJvdXRlcjogVUlSb3V0ZXIpIHtcbiAqICAgICB1aVJvdXRlci51cmxNYXRjaGVyRmFjdG9yeS50eXBlKCdkYXRldGltZScsIG15RGF0ZVRpbWVQYXJhbVR5cGUpO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcHJlZmVycmVkIEBtb2R1bGUgbmcyXG4gKi9cbi8qKiAqL1xuaW1wb3J0IHsgSW5qZWN0b3IsIFBMQVRGT1JNX0lEIH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSBcIkBhbmd1bGFyL2NvbW1vblwiO1xuaW1wb3J0IHsgVUlSb3V0ZXIsIFN0YXRlUmVnaXN0cnksIFN0YXRlU2VydmljZSwgVHJhbnNpdGlvblNlcnZpY2UsIFVybE1hdGNoZXJGYWN0b3J5LCBVcmxSb3V0ZXIsIFZpZXdTZXJ2aWNlLCBVcmxTZXJ2aWNlLCBVSVJvdXRlckdsb2JhbHMsIHNlcnZpY2VzLCBSZXNvbHZhYmxlLCBOQVRJVkVfSU5KRUNUT1JfVE9LRU4sIH0gZnJvbSBcIkB1aXJvdXRlci9jb3JlXCI7XG5pbXBvcnQgeyBVSVZpZXcgfSBmcm9tIFwiLi9kaXJlY3RpdmVzL3VpVmlld1wiO1xuaW1wb3J0IHsgbmcyVmlld3NCdWlsZGVyLCBOZzJWaWV3Q29uZmlnIH0gZnJvbSBcIi4vc3RhdGVidWlsZGVycy92aWV3c1wiO1xuaW1wb3J0IHsgYXBwbHlSb290TW9kdWxlQ29uZmlnLCBhcHBseU1vZHVsZUNvbmZpZyB9IGZyb20gXCIuL3VpUm91dGVyQ29uZmlnXCI7XG5pbXBvcnQgeyBVSVJPVVRFUl9ST09UX01PRFVMRSwgVUlST1VURVJfTU9EVUxFX1RPS0VOIH0gZnJvbSBcIi4vdWlSb3V0ZXJOZ01vZHVsZVwiO1xuaW1wb3J0IHsgc2VydmljZXNQbHVnaW4gfSBmcm9tIFwiQHVpcm91dGVyL2NvcmVcIjtcbmltcG9ydCB7IG5nMkxhenlMb2FkQnVpbGRlciB9IGZyb20gXCIuL3N0YXRlYnVpbGRlcnMvbGF6eUxvYWRcIjtcbmltcG9ydCB7IFVJUm91dGVyUnggfSBmcm9tIFwiQHVpcm91dGVyL3J4XCI7XG5pbXBvcnQgeyBMb2NhdGlvblN0cmF0ZWd5IH0gZnJvbSBcIkBhbmd1bGFyL2NvbW1vblwiO1xuaW1wb3J0IHsgTmcyTG9jYXRpb25TZXJ2aWNlcyB9IGZyb20gXCIuL2xvY2F0aW9uL2xvY2F0aW9uU2VydmljZVwiO1xuaW1wb3J0IHsgTmcyTG9jYXRpb25Db25maWcgfSBmcm9tIFwiLi9sb2NhdGlvbi9sb2NhdGlvbkNvbmZpZ1wiO1xuLyoqXG4gKiBUaGlzIGlzIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgYSBVSVJvdXRlciBpbnN0YW5jZVxuICpcbiAqIENyZWF0ZXMgYSBVSVJvdXRlciBpbnN0YW5jZSBhbmQgY29uZmlndXJlcyBpdCBmb3IgQW5ndWxhciwgdGhlbiBpbnZva2VzIHJvdXRlciBib290c3RyYXAuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYXMgYW4gQW5ndWxhciBgdXNlRmFjdG9yeWAgUHJvdmlkZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1aVJvdXRlckZhY3RvcnkobG9jYXRpb25TdHJhdGVneSwgcm9vdE1vZHVsZXMsIG1vZHVsZXMsIGluamVjdG9yKSB7XG4gICAgaWYgKHJvb3RNb2R1bGVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeGFjdGx5IG9uZSBVSVJvdXRlck1vZHVsZS5mb3JSb290KCkgc2hvdWxkIGJlIGluIHRoZSBib290c3RyYXBwZWQgYXBwIG1vZHVsZSdzIGltcG9ydHM6IFtdXCIpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLSBDcmVhdGUgcm91dGVyIC0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gQ3JlYXRlIGEgbmV3IG5nMiBVSVJvdXRlciBhbmQgY29uZmlndXJlIGl0IGZvciBuZzJcbiAgICB2YXIgcm91dGVyID0gbmV3IFVJUm91dGVyKCk7XG4gICAgLy8gQWRkIFJ4SlMgcGx1Z2luXG4gICAgcm91dGVyLnBsdWdpbihVSVJvdXRlclJ4KTtcbiAgICAvLyBBZGQgJHEtbGlrZSBhbmQgJGluamVjdG9yLWxpa2Ugc2VydmljZSBBUElzXG4gICAgcm91dGVyLnBsdWdpbihzZXJ2aWNlc1BsdWdpbik7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0gTW9ua2V5IFBhdGNoZXMgLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE1vbmtleSBwYXRjaCB0aGUgc2VydmljZXMuJGluamVjdG9yIHRvIHVzZSB0aGUgcm9vdCBuZzIgSW5qZWN0b3JcbiAgICBzZXJ2aWNlcy4kaW5qZWN0b3IuZ2V0ID0gaW5qZWN0b3IuZ2V0LmJpbmQoaW5qZWN0b3IpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tIENvbmZpZ3VyZSBmb3IgbmcyIC0tLS0tLS0tLS0tLS1cbiAgICByb3V0ZXIubG9jYXRpb25TZXJ2aWNlID0gbmV3IE5nMkxvY2F0aW9uU2VydmljZXMocm91dGVyLCBsb2NhdGlvblN0cmF0ZWd5LCBpc1BsYXRmb3JtQnJvd3NlcihpbmplY3Rvci5nZXQoUExBVEZPUk1fSUQpKSk7XG4gICAgcm91dGVyLmxvY2F0aW9uQ29uZmlnID0gbmV3IE5nMkxvY2F0aW9uQ29uZmlnKHJvdXRlciwgbG9jYXRpb25TdHJhdGVneSk7XG4gICAgLy8gQXBwbHkgbmcyIHVpLXZpZXcgaGFuZGxpbmcgY29kZVxuICAgIHZhciB2aWV3Q29uZmlnRmFjdG9yeSA9IGZ1bmN0aW9uIChwYXRoLCBjb25maWcpIHsgcmV0dXJuIG5ldyBOZzJWaWV3Q29uZmlnKHBhdGgsIGNvbmZpZyk7IH07XG4gICAgcm91dGVyLnZpZXdTZXJ2aWNlLl9wbHVnaW5hcGkuX3ZpZXdDb25maWdGYWN0b3J5KFwibmcyXCIsIHZpZXdDb25maWdGYWN0b3J5KTtcbiAgICAvLyBBcHBseSBzdGF0ZWJ1aWxkZXIgZGVjb3JhdG9yIGZvciBuZzIgTmdNb2R1bGUgcmVnaXN0cmF0aW9uXG4gICAgdmFyIHJlZ2lzdHJ5ID0gcm91dGVyLnN0YXRlUmVnaXN0cnk7XG4gICAgcmVnaXN0cnkuZGVjb3JhdG9yKCd2aWV3cycsIG5nMlZpZXdzQnVpbGRlcik7XG4gICAgcmVnaXN0cnkuZGVjb3JhdG9yKCdsYXp5TG9hZCcsIG5nMkxhenlMb2FkQnVpbGRlcik7XG4gICAgLy8gUHJlcCB0aGUgdHJlZSBvZiBOZ01vZHVsZSBieSBwbGFjaW5nIHRoZSByb290IE5nTW9kdWxlJ3MgSW5qZWN0b3Igb24gdGhlIHJvb3Qgc3RhdGUuXG4gICAgdmFyIG5nMkluamVjdG9yUmVzb2x2YWJsZSA9IFJlc29sdmFibGUuZnJvbURhdGEoTkFUSVZFX0lOSkVDVE9SX1RPS0VOLCBpbmplY3Rvcik7XG4gICAgcmVnaXN0cnkucm9vdCgpLnJlc29sdmFibGVzLnB1c2gobmcySW5qZWN0b3JSZXNvbHZhYmxlKTtcbiAgICAvLyBBdXRvLWZsdXNoIHRoZSBwYXJhbWV0ZXIgdHlwZSBxdWV1ZVxuICAgIHJvdXRlci51cmxNYXRjaGVyRmFjdG9yeS4kZ2V0KCk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0gSW5pdGlhbGl6ZSByb3V0ZXIgLS0tLS0tLS0tLS0tLVxuICAgIHJvb3RNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZUNvbmZpZykgeyByZXR1cm4gYXBwbHlSb290TW9kdWxlQ29uZmlnKHJvdXRlciwgaW5qZWN0b3IsIG1vZHVsZUNvbmZpZyk7IH0pO1xuICAgIG1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlQ29uZmlnKSB7IHJldHVybiBhcHBseU1vZHVsZUNvbmZpZyhyb3V0ZXIsIGluamVjdG9yLCBtb2R1bGVDb25maWcpOyB9KTtcbiAgICAvLyBTdGFydCBtb25pdG9yaW5nIHRoZSBVUkxcbiAgICBpZiAoIXJvdXRlci51cmxSb3V0ZXIuaW50ZXJjZXB0RGVmZXJyZWQpIHtcbiAgICAgICAgcm91dGVyLnVybFNlcnZpY2UubGlzdGVuKCk7XG4gICAgICAgIHJvdXRlci51cmxTZXJ2aWNlLnN5bmMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvdXRlcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJlbnRVSVZpZXdJbmplY3RGYWN0b3J5KHIpIHsgcmV0dXJuIHsgZnFuOiBudWxsLCBjb250ZXh0OiByLnJvb3QoKSB9OyB9XG5leHBvcnQgdmFyIF9VSVJPVVRFUl9JTlNUQU5DRV9QUk9WSURFUlMgPSBbXG4gICAgeyBwcm92aWRlOiBVSVJvdXRlciwgdXNlRmFjdG9yeTogdWlSb3V0ZXJGYWN0b3J5LCBkZXBzOiBbTG9jYXRpb25TdHJhdGVneSwgVUlST1VURVJfUk9PVF9NT0RVTEUsIFVJUk9VVEVSX01PRFVMRV9UT0tFTiwgSW5qZWN0b3JdIH0sXG4gICAgeyBwcm92aWRlOiBVSVZpZXcuUEFSRU5UX0lOSkVDVCwgdXNlRmFjdG9yeTogcGFyZW50VUlWaWV3SW5qZWN0RmFjdG9yeSwgZGVwczogW1N0YXRlUmVnaXN0cnldIH0sXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIGZuU3RhdGVTZXJ2aWNlKHIpIHsgcmV0dXJuIHIuc3RhdGVTZXJ2aWNlOyB9XG5leHBvcnQgZnVuY3Rpb24gZm5UcmFuc2l0aW9uU2VydmljZShyKSB7IHJldHVybiByLnRyYW5zaXRpb25TZXJ2aWNlOyB9XG5leHBvcnQgZnVuY3Rpb24gZm5VcmxNYXRjaGVyRmFjdG9yeShyKSB7IHJldHVybiByLnVybE1hdGNoZXJGYWN0b3J5OyB9XG5leHBvcnQgZnVuY3Rpb24gZm5VcmxSb3V0ZXIocikgeyByZXR1cm4gci51cmxSb3V0ZXI7IH1cbmV4cG9ydCBmdW5jdGlvbiBmblVybFNlcnZpY2UocikgeyByZXR1cm4gci51cmxTZXJ2aWNlOyB9XG5leHBvcnQgZnVuY3Rpb24gZm5WaWV3U2VydmljZShyKSB7IHJldHVybiByLnZpZXdTZXJ2aWNlOyB9XG5leHBvcnQgZnVuY3Rpb24gZm5TdGF0ZVJlZ2lzdHJ5KHIpIHsgcmV0dXJuIHIuc3RhdGVSZWdpc3RyeTsgfVxuZXhwb3J0IGZ1bmN0aW9uIGZuR2xvYmFscyhyKSB7IHJldHVybiByLmdsb2JhbHM7IH1cbmV4cG9ydCB2YXIgX1VJUk9VVEVSX1NFUlZJQ0VfUFJPVklERVJTID0gW1xuICAgIHsgcHJvdmlkZTogU3RhdGVTZXJ2aWNlLCB1c2VGYWN0b3J5OiBmblN0YXRlU2VydmljZSwgZGVwczogW1VJUm91dGVyXSB9LFxuICAgIHsgcHJvdmlkZTogVHJhbnNpdGlvblNlcnZpY2UsIHVzZUZhY3Rvcnk6IGZuVHJhbnNpdGlvblNlcnZpY2UsIGRlcHM6IFtVSVJvdXRlcl0gfSxcbiAgICB7IHByb3ZpZGU6IFVybE1hdGNoZXJGYWN0b3J5LCB1c2VGYWN0b3J5OiBmblVybE1hdGNoZXJGYWN0b3J5LCBkZXBzOiBbVUlSb3V0ZXJdIH0sXG4gICAgeyBwcm92aWRlOiBVcmxSb3V0ZXIsIHVzZUZhY3Rvcnk6IGZuVXJsUm91dGVyLCBkZXBzOiBbVUlSb3V0ZXJdIH0sXG4gICAgeyBwcm92aWRlOiBVcmxTZXJ2aWNlLCB1c2VGYWN0b3J5OiBmblVybFNlcnZpY2UsIGRlcHM6IFtVSVJvdXRlcl0gfSxcbiAgICB7IHByb3ZpZGU6IFZpZXdTZXJ2aWNlLCB1c2VGYWN0b3J5OiBmblZpZXdTZXJ2aWNlLCBkZXBzOiBbVUlSb3V0ZXJdIH0sXG4gICAgeyBwcm92aWRlOiBTdGF0ZVJlZ2lzdHJ5LCB1c2VGYWN0b3J5OiBmblN0YXRlUmVnaXN0cnksIGRlcHM6IFtVSVJvdXRlcl0gfSxcbiAgICB7IHByb3ZpZGU6IFVJUm91dGVyR2xvYmFscywgdXNlRmFjdG9yeTogZm5HbG9iYWxzLCBkZXBzOiBbVUlSb3V0ZXJdIH0sXG5dO1xuLyoqXG4gKiBUaGUgVUktUm91dGVyIHByb3ZpZGVycywgZm9yIHVzZSBpbiB5b3VyIGFwcGxpY2F0aW9uIGJvb3RzdHJhcFxuICpcbiAqIEBkZXByZWNhdGVkIHVzZSBbW1VJUm91dGVyTW9kdWxlLmZvclJvb3RdXVxuICovXG5leHBvcnQgdmFyIFVJUk9VVEVSX1BST1ZJREVSUyA9IF9VSVJPVVRFUl9JTlNUQU5DRV9QUk9WSURFUlMuY29uY2F0KF9VSVJPVVRFUl9TRVJWSUNFX1BST1ZJREVSUyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlcnMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2FuZ3VsYXIvbGliL3Byb3ZpZGVycy5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHRyYW5zaXRpb25cbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBpbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKTtcbnZhciB0cmFuc2l0aW9uSG9va18xID0gcmVxdWlyZShcIi4vdHJhbnNpdGlvbkhvb2tcIik7XG4vKipcbiAqIFRoaXMgY2xhc3MgcmV0dXJucyBhcHBsaWNhYmxlIFRyYW5zaXRpb25Ib29rcyBmb3IgYSBzcGVjaWZpYyBUcmFuc2l0aW9uIGluc3RhbmNlLlxuICpcbiAqIEhvb2tzIChbW1JlZ2lzdGVyZWRIb29rXV0pIG1heSBiZSByZWdpc3RlcmVkIGdsb2JhbGx5LCBlLmcuLCAkdHJhbnNpdGlvbnMub25FbnRlciguLi4pLCBvciBsb2NhbGx5LCBlLmcuXG4gKiBteVRyYW5zaXRpb24ub25FbnRlciguLi4pLiAgVGhlIEhvb2tCdWlsZGVyIGZpbmRzIG1hdGNoaW5nIFJlZ2lzdGVyZWRIb29rcyAod2hlcmUgdGhlIG1hdGNoIGNyaXRlcmlhIGlzXG4gKiBkZXRlcm1pbmVkIGJ5IHRoZSB0eXBlIG9mIGhvb2spXG4gKlxuICogVGhlIEhvb2tCdWlsZGVyIGFsc28gY29udmVydHMgUmVnaXN0ZXJlZEhvb2tzIG9iamVjdHMgdG8gVHJhbnNpdGlvbkhvb2sgb2JqZWN0cywgd2hpY2ggYXJlIHVzZWQgdG8gcnVuIGEgVHJhbnNpdGlvbi5cbiAqXG4gKiBUaGUgSG9va0J1aWxkZXIgY29uc3RydWN0b3IgaXMgZ2l2ZW4gdGhlICR0cmFuc2l0aW9ucyBzZXJ2aWNlIGFuZCBhIFRyYW5zaXRpb24gaW5zdGFuY2UuICBUaHVzLCBhIEhvb2tCdWlsZGVyXG4gKiBpbnN0YW5jZSBtYXkgb25seSBiZSB1c2VkIGZvciBvbmUgc3BlY2lmaWMgVHJhbnNpdGlvbiBvYmplY3QuIChzaWRlIG5vdGU6IHRoZSBfdHJlZUNoYW5nZXMgYWNjZXNzb3IgaXMgcHJpdmF0ZVxuICogaW4gdGhlIFRyYW5zaXRpb24gY2xhc3MsIHNvIHdlIG11c3QgYWxzbyBwcm92aWRlIHRoZSBUcmFuc2l0aW9uJ3MgX3RyZWVDaGFuZ2VzKVxuICpcbiAqL1xudmFyIEhvb2tCdWlsZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhvb2tCdWlsZGVyKHRyYW5zaXRpb24pIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICB9XG4gICAgSG9va0J1aWxkZXIucHJvdG90eXBlLmJ1aWxkSG9va3NGb3JQaGFzZSA9IGZ1bmN0aW9uIChwaGFzZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgJHRyYW5zaXRpb25zID0gdGhpcy50cmFuc2l0aW9uLnJvdXRlci50cmFuc2l0aW9uU2VydmljZTtcbiAgICAgICAgcmV0dXJuICR0cmFuc2l0aW9ucy5fcGx1Z2luYXBpLl9nZXRFdmVudHMocGhhc2UpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBfdGhpcy5idWlsZEhvb2tzKHR5cGUpOyB9KVxuICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcbiAgICAgICAgICAgIC5maWx0ZXIoY29tbW9uXzEuaWRlbnRpdHkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBuZXdseSBidWlsdCBUcmFuc2l0aW9uSG9vayBvYmplY3RzLlxuICAgICAqXG4gICAgICogLSBGaW5kcyBhbGwgUmVnaXN0ZXJlZEhvb2tzIHJlZ2lzdGVyZWQgZm9yIHRoZSBnaXZlbiBgaG9va1R5cGVgIHdoaWNoIG1hdGNoZWQgdGhlIHRyYW5zaXRpb24ncyBbW1RyZWVDaGFuZ2VzXV0uXG4gICAgICogLSBGaW5kcyBbW1BhdGhOb2RlXV0gKG9yIGBQYXRoTm9kZVtdYCkgdG8gdXNlIGFzIHRoZSBUcmFuc2l0aW9uSG9vayBjb250ZXh0KHMpXG4gICAgICogLSBGb3IgZWFjaCBvZiB0aGUgW1tQYXRoTm9kZV1dcywgY3JlYXRlcyBhIFRyYW5zaXRpb25Ib29rXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaG9va1R5cGUgdGhlIHR5cGUgb2YgdGhlIGhvb2sgcmVnaXN0cmF0aW9uIGZ1bmN0aW9uLCBlLmcuLCAnb25FbnRlcicsICdvbkZpbmlzaCcuXG4gICAgICovXG4gICAgSG9va0J1aWxkZXIucHJvdG90eXBlLmJ1aWxkSG9va3MgPSBmdW5jdGlvbiAoaG9va1R5cGUpIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb247XG4gICAgICAgIHZhciB0cmVlQ2hhbmdlcyA9IHRyYW5zaXRpb24udHJlZUNoYW5nZXMoKTtcbiAgICAgICAgLy8gRmluZCBhbGwgdGhlIG1hdGNoaW5nIHJlZ2lzdGVyZWQgaG9va3MgZm9yIGEgZ2l2ZW4gaG9vayB0eXBlXG4gICAgICAgIHZhciBtYXRjaGluZ0hvb2tzID0gdGhpcy5nZXRNYXRjaGluZ0hvb2tzKGhvb2tUeXBlLCB0cmVlQ2hhbmdlcyk7XG4gICAgICAgIGlmICghbWF0Y2hpbmdIb29rcylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgdmFyIGJhc2VIb29rT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG4gICAgICAgICAgICBjdXJyZW50OiB0cmFuc2l0aW9uLm9wdGlvbnMoKS5jdXJyZW50XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtYWtlVHJhbnNpdGlvbkhvb2tzID0gZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBOb2RlcyB0aGF0IGNhdXNlZCB0aGlzIGhvb2sgdG8gbWF0Y2guXG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGhvb2subWF0Y2hlcyh0cmVlQ2hhbmdlcyk7XG4gICAgICAgICAgICAvLyBTZWxlY3QgdGhlIFBhdGhOb2RlW10gdGhhdCB3aWxsIGJlIHVzZWQgYXMgVHJhbnNpdGlvbkhvb2sgY29udGV4dCBvYmplY3RzXG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmdOb2RlcyA9IG1hdGNoZXNbaG9va1R5cGUuY3JpdGVyaWFNYXRjaFBhdGgubmFtZV07XG4gICAgICAgICAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgSG9va1R1cGxlc1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nTm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9vcHRpb25zID0gY29tbW9uXzEuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgYmluZDogaG9vay5iaW5kLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZURhdGE6IHsgaG9va1R5cGU6IGhvb2tUeXBlLm5hbWUsIGNvbnRleHQ6IG5vZGUgfVxuICAgICAgICAgICAgICAgIH0sIGJhc2VIb29rT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gaG9va1R5cGUuY3JpdGVyaWFNYXRjaFBhdGguc2NvcGUgPT09IGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rU2NvcGUuU1RBVEUgPyBub2RlLnN0YXRlLnNlbGYgOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uSG9vayA9IG5ldyB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rKHRyYW5zaXRpb24sIHN0YXRlLCBob29rLCBfb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaG9vazogaG9vaywgbm9kZTogbm9kZSwgdHJhbnNpdGlvbkhvb2s6IHRyYW5zaXRpb25Ib29rIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nSG9va3MubWFwKG1ha2VUcmFuc2l0aW9uSG9va3MpXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKVxuICAgICAgICAgICAgLnNvcnQodHVwbGVTb3J0KGhvb2tUeXBlLnJldmVyc2VTb3J0KSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHR1cGxlKSB7IHJldHVybiB0dXBsZS50cmFuc2l0aW9uSG9vazsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kcyBhbGwgUmVnaXN0ZXJlZEhvb2tzIGZyb206XG4gICAgICogLSBUaGUgVHJhbnNpdGlvbiBvYmplY3QgaW5zdGFuY2UgaG9vayByZWdpc3RyeVxuICAgICAqIC0gVGhlIFRyYW5zaXRpb25TZXJ2aWNlICgkdHJhbnNpdGlvbnMpIGdsb2JhbCBob29rIHJlZ2lzdHJ5XG4gICAgICpcbiAgICAgKiB3aGljaCBtYXRjaGVkOlxuICAgICAqIC0gdGhlIGV2ZW50VHlwZVxuICAgICAqIC0gdGhlIG1hdGNoQ3JpdGVyaWEgKHRvLCBmcm9tLCBleGl0aW5nLCByZXRhaW5lZCwgZW50ZXJpbmcpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGVkIFtbUmVnaXN0ZXJlZEhvb2tdXXNcbiAgICAgKi9cbiAgICBIb29rQnVpbGRlci5wcm90b3R5cGUuZ2V0TWF0Y2hpbmdIb29rcyA9IGZ1bmN0aW9uIChob29rVHlwZSwgdHJlZUNoYW5nZXMpIHtcbiAgICAgICAgdmFyIGlzQ3JlYXRlID0gaG9va1R5cGUuaG9va1BoYXNlID09PSBpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1BoYXNlLkNSRUFURTtcbiAgICAgICAgLy8gSW5zdGFuY2UgYW5kIEdsb2JhbCBob29rIHJlZ2lzdHJpZXNcbiAgICAgICAgdmFyICR0cmFuc2l0aW9ucyA9IHRoaXMudHJhbnNpdGlvbi5yb3V0ZXIudHJhbnNpdGlvblNlcnZpY2U7XG4gICAgICAgIHZhciByZWdpc3RyaWVzID0gaXNDcmVhdGUgPyBbJHRyYW5zaXRpb25zXSA6IFt0aGlzLnRyYW5zaXRpb24sICR0cmFuc2l0aW9uc107XG4gICAgICAgIHJldHVybiByZWdpc3RyaWVzLm1hcChmdW5jdGlvbiAocmVnKSB7IHJldHVybiByZWcuZ2V0SG9va3MoaG9va1R5cGUubmFtZSk7IH0pIC8vIEdldCBuYW1lZCBob29rcyBmcm9tIHJlZ2lzdHJpZXNcbiAgICAgICAgICAgIC5maWx0ZXIoY29tbW9uXzEuYXNzZXJ0UHJlZGljYXRlKHByZWRpY2F0ZXNfMS5pc0FycmF5LCBcImJyb2tlbiBldmVudCBuYW1lZDogXCIgKyBob29rVHlwZS5uYW1lKSkgLy8gU2FuaXR5IGNoZWNrXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKSAvLyBVbi1uZXN0IFJlZ2lzdGVyZWRIb29rW11bXSB0byBSZWdpc3RlcmVkSG9va1tdIGFycmF5XG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBob29rLm1hdGNoZXModHJlZUNoYW5nZXMpOyB9KTsgLy8gT25seSB0aG9zZSBzYXRpc2Z5aW5nIG1hdGNoQ3JpdGVyaWFcbiAgICB9O1xuICAgIHJldHVybiBIb29rQnVpbGRlcjtcbn0oKSk7XG5leHBvcnRzLkhvb2tCdWlsZGVyID0gSG9va0J1aWxkZXI7XG4vKipcbiAqIEEgZmFjdG9yeSBmb3IgYSBzb3J0IGZ1bmN0aW9uIGZvciBIb29rVHVwbGVzLlxuICpcbiAqIFRoZSBzb3J0IGZ1bmN0aW9uIGZpcnN0IGNvbXBhcmVzIHRoZSBQYXRoTm9kZSBkZXB0aCAoaG93IGRlZXAgaW4gdGhlIHN0YXRlIHRyZWUgYSBub2RlIGlzKSwgdGhlbiBjb21wYXJlc1xuICogdGhlIEV2ZW50SG9vayBwcmlvcml0eS5cbiAqXG4gKiBAcGFyYW0gcmV2ZXJzZURlcHRoU29ydCBhIGJvb2xlYW4sIHdoZW4gdHJ1ZSwgcmV2ZXJzZXMgdGhlIHNvcnQgb3JkZXIgZm9yIHRoZSBub2RlIGRlcHRoXG4gKiBAcmV0dXJucyBhIHR1cGxlIHNvcnQgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gdHVwbGVTb3J0KHJldmVyc2VEZXB0aFNvcnQpIHtcbiAgICBpZiAocmV2ZXJzZURlcHRoU29ydCA9PT0gdm9pZCAwKSB7IHJldmVyc2VEZXB0aFNvcnQgPSBmYWxzZTsgfVxuICAgIHJldHVybiBmdW5jdGlvbiBub2RlRGVwdGhUaGVuUHJpb3JpdHkobCwgcikge1xuICAgICAgICB2YXIgZmFjdG9yID0gcmV2ZXJzZURlcHRoU29ydCA/IC0xIDogMTtcbiAgICAgICAgdmFyIGRlcHRoRGVsdGEgPSAobC5ub2RlLnN0YXRlLnBhdGgubGVuZ3RoIC0gci5ub2RlLnN0YXRlLnBhdGgubGVuZ3RoKSAqIGZhY3RvcjtcbiAgICAgICAgcmV0dXJuIGRlcHRoRGVsdGEgIT09IDAgPyBkZXB0aERlbHRhIDogci5ob29rLnByaW9yaXR5IC0gbC5ob29rLnByaW9yaXR5O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rQnVpbGRlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi9ob29rQnVpbGRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQGludGVybmFsYXBpICovXG5leHBvcnRzLnJlc29sdmVQb2xpY2llcyA9IHtcbiAgICB3aGVuOiB7XG4gICAgICAgIExBWlk6IFwiTEFaWVwiLFxuICAgICAgICBFQUdFUjogXCJFQUdFUlwiXG4gICAgfSxcbiAgICBhc3luYzoge1xuICAgICAgICBXQUlUOiBcIldBSVRcIixcbiAgICAgICAgTk9XQUlUOiBcIk5PV0FJVFwiLFxuICAgICAgICBSWFdBSVQ6IFwiUlhXQUlUXCJcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9yZXNvbHZlL2ludGVyZmFjZS5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHBhcmFtc1xuICovXG4vKiogKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XG52YXIgcGFyYW1UeXBlXzEgPSByZXF1aXJlKFwiLi9wYXJhbVR5cGVcIik7XG4vKipcbiAqIEEgcmVnaXN0cnkgZm9yIHBhcmFtZXRlciB0eXBlcy5cbiAqXG4gKiBUaGlzIHJlZ2lzdHJ5IG1hbmFnZXMgdGhlIGJ1aWx0LWluIChhbmQgY3VzdG9tKSBwYXJhbWV0ZXIgdHlwZXMuXG4gKlxuICogVGhlIGJ1aWx0LWluIHBhcmFtZXRlciB0eXBlcyBhcmU6XG4gKlxuICogLSBbW3N0cmluZ11dXG4gKiAtIFtbcGF0aF1dXG4gKiAtIFtbcXVlcnldXVxuICogLSBbW2hhc2hdXVxuICogLSBbW2ludF1dXG4gKiAtIFtbYm9vbF1dXG4gKiAtIFtbZGF0ZV1dXG4gKiAtIFtbanNvbl1dXG4gKiAtIFtbYW55XV1cbiAqL1xudmFyIFBhcmFtVHlwZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIGZ1bmN0aW9uIFBhcmFtVHlwZXMoKSB7XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuZW5xdWV1ZSA9IHRydWU7XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMudHlwZVF1ZXVlID0gW107XG4gICAgICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICAgICAgdGhpcy5kZWZhdWx0VHlwZXMgPSBjb21tb25fMS5waWNrKFBhcmFtVHlwZXMucHJvdG90eXBlLCBbXCJoYXNoXCIsIFwic3RyaW5nXCIsIFwicXVlcnlcIiwgXCJwYXRoXCIsIFwiaW50XCIsIFwiYm9vbFwiLCBcImRhdGVcIiwgXCJqc29uXCIsIFwiYW55XCJdKTtcbiAgICAgICAgLy8gUmVnaXN0ZXIgZGVmYXVsdCB0eXBlcy4gU3RvcmUgdGhlbSBpbiB0aGUgcHJvdG90eXBlIG9mIHRoaXMudHlwZXMuXG4gICAgICAgIHZhciBtYWtlVHlwZSA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHBhcmFtVHlwZV8xLlBhcmFtVHlwZShjb21tb25fMS5leHRlbmQoeyBuYW1lOiBuYW1lIH0sIGRlZmluaXRpb24pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50eXBlcyA9IGNvbW1vbl8xLmluaGVyaXQoY29tbW9uXzEubWFwKHRoaXMuZGVmYXVsdFR5cGVzLCBtYWtlVHlwZSksIHt9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIFBhcmFtVHlwZXMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB7fTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIHBhcmFtZXRlciB0eXBlXG4gICAgICpcbiAgICAgKiBFbmQgdXNlcnMgc2hvdWxkIGNhbGwgW1tVcmxNYXRjaGVyRmFjdG9yeS50eXBlXV0sIHdoaWNoIGRlbGVnYXRlcyB0byB0aGlzIG1ldGhvZC5cbiAgICAgKi9cbiAgICBQYXJhbVR5cGVzLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24sIGRlZmluaXRpb25Gbikge1xuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoZGVmaW5pdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlc1tuYW1lXTtcbiAgICAgICAgaWYgKHRoaXMudHlwZXMuaGFzT3duUHJvcGVydHkobmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIHR5cGUgbmFtZWQgJ1wiICsgbmFtZSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQuXCIpO1xuICAgICAgICB0aGlzLnR5cGVzW25hbWVdID0gbmV3IHBhcmFtVHlwZV8xLlBhcmFtVHlwZShjb21tb25fMS5leHRlbmQoeyBuYW1lOiBuYW1lIH0sIGRlZmluaXRpb24pKTtcbiAgICAgICAgaWYgKGRlZmluaXRpb25Gbikge1xuICAgICAgICAgICAgdGhpcy50eXBlUXVldWUucHVzaCh7IG5hbWU6IG5hbWUsIGRlZjogZGVmaW5pdGlvbkZuIH0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVucXVldWUpXG4gICAgICAgICAgICAgICAgdGhpcy5fZmx1c2hUeXBlUXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBQYXJhbVR5cGVzLnByb3RvdHlwZS5fZmx1c2hUeXBlUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnR5cGVRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlLnBhdHRlcm4pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBvdmVycmlkZSBhIHR5cGUncyAucGF0dGVybiBhdCBydW50aW1lLlwiKTtcbiAgICAgICAgICAgIGNvbW1vbl8xLmV4dGVuZCh0aGlzLnR5cGVzW3R5cGUubmFtZV0sIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRpbmplY3Rvci5pbnZva2UodHlwZS5kZWYpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFBhcmFtVHlwZXM7XG59KCkpO1xuZXhwb3J0cy5QYXJhbVR5cGVzID0gUGFyYW1UeXBlcztcbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBpbml0RGVmYXVsdFR5cGVzKCkge1xuICAgIHZhciBtYWtlRGVmYXVsdFR5cGUgPSBmdW5jdGlvbiAoZGVmKSB7XG4gICAgICAgIHZhciB2YWxUb1N0cmluZyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwgIT0gbnVsbCA/IHZhbC50b1N0cmluZygpIDogdmFsO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZGVmYXVsdFR5cGVCYXNlID0ge1xuICAgICAgICAgICAgZW5jb2RlOiB2YWxUb1N0cmluZyxcbiAgICAgICAgICAgIGRlY29kZTogdmFsVG9TdHJpbmcsXG4gICAgICAgICAgICBpczogaG9mXzEuaXMoU3RyaW5nKSxcbiAgICAgICAgICAgIHBhdHRlcm46IC8uKi8sXG4gICAgICAgICAgICBlcXVhbHM6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhID09IGI7IH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjb21tb25fMS5leHRlbmQoe30sIGRlZmF1bHRUeXBlQmFzZSwgZGVmKTtcbiAgICB9O1xuICAgIC8vIERlZmF1bHQgUGFyYW1ldGVyIFR5cGUgRGVmaW5pdGlvbnNcbiAgICBjb21tb25fMS5leHRlbmQoUGFyYW1UeXBlcy5wcm90b3R5cGUsIHtcbiAgICAgICAgc3RyaW5nOiBtYWtlRGVmYXVsdFR5cGUoe30pLFxuICAgICAgICBwYXRoOiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgICAgICAgcGF0dGVybjogL1teL10qLyxcbiAgICAgICAgfSksXG4gICAgICAgIHF1ZXJ5OiBtYWtlRGVmYXVsdFR5cGUoe30pLFxuICAgICAgICBoYXNoOiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgICAgICAgaW5oZXJpdDogZmFsc2UsXG4gICAgICAgIH0pLFxuICAgICAgICBpbnQ6IG1ha2VEZWZhdWx0VHlwZSh7XG4gICAgICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApOyB9LFxuICAgICAgICAgICAgaXM6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXByZWRpY2F0ZXNfMS5pc051bGxPclVuZGVmaW5lZCh2YWwpICYmIHRoaXMuZGVjb2RlKHZhbC50b1N0cmluZygpKSA9PT0gdmFsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdHRlcm46IC8tP1xcZCsvLFxuICAgICAgICB9KSxcbiAgICAgICAgYm9vbDogbWFrZURlZmF1bHRUeXBlKHtcbiAgICAgICAgICAgIGVuY29kZTogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsICYmIDEgfHwgMDsgfSxcbiAgICAgICAgICAgIGRlY29kZTogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCkgIT09IDA7IH0sXG4gICAgICAgICAgICBpczogaG9mXzEuaXMoQm9vbGVhbiksXG4gICAgICAgICAgICBwYXR0ZXJuOiAvMHwxLyxcbiAgICAgICAgfSksXG4gICAgICAgIGRhdGU6IG1ha2VEZWZhdWx0VHlwZSh7XG4gICAgICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMuaXModmFsKSA/IHVuZGVmaW5lZCA6IFtcbiAgICAgICAgICAgICAgICAgICAgdmFsLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICAgICAgICAgICgnMCcgKyAodmFsLmdldE1vbnRoKCkgKyAxKSkuc2xpY2UoLTIpLFxuICAgICAgICAgICAgICAgICAgICAoJzAnICsgdmFsLmdldERhdGUoKSkuc2xpY2UoLTIpLFxuICAgICAgICAgICAgICAgIF0uam9pbihcIi1cIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjb2RlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXModmFsKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSB0aGlzLmNhcHR1cmUuZXhlYyh2YWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaCA/IG5ldyBEYXRlKG1hdGNoWzFdLCBtYXRjaFsyXSAtIDEsIG1hdGNoWzNdKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpczogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4odmFsLnZhbHVlT2YoKSk7IH0sXG4gICAgICAgICAgICBlcXVhbHM6IGZ1bmN0aW9uIChsLCByKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnZ2V0RnVsbFllYXInLCAnZ2V0TW9udGgnLCAnZ2V0RGF0ZSddXG4gICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZm4pIHsgcmV0dXJuIGFjYyAmJiBsW2ZuXSgpID09PSByW2ZuXSgpOyB9LCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXR0ZXJuOiAvWzAtOV17NH0tKD86MFsxLTldfDFbMC0yXSktKD86MFsxLTldfFsxLTJdWzAtOV18M1swLTFdKS8sXG4gICAgICAgICAgICBjYXB0dXJlOiAvKFswLTldezR9KS0oMFsxLTldfDFbMC0yXSktKDBbMS05XXxbMS0yXVswLTldfDNbMC0xXSkvLFxuICAgICAgICB9KSxcbiAgICAgICAganNvbjogbWFrZURlZmF1bHRUeXBlKHtcbiAgICAgICAgICAgIGVuY29kZTogY29tbW9uXzEudG9Kc29uLFxuICAgICAgICAgICAgZGVjb2RlOiBjb21tb25fMS5mcm9tSnNvbixcbiAgICAgICAgICAgIGlzOiBob2ZfMS5pcyhPYmplY3QpLFxuICAgICAgICAgICAgZXF1YWxzOiBjb21tb25fMS5lcXVhbHMsXG4gICAgICAgICAgICBwYXR0ZXJuOiAvW14vXSovLFxuICAgICAgICB9KSxcbiAgICAgICAgLy8gZG9lcyBub3QgZW5jb2RlL2RlY29kZVxuICAgICAgICBhbnk6IG1ha2VEZWZhdWx0VHlwZSh7XG4gICAgICAgICAgICBlbmNvZGU6IGNvbW1vbl8xLmlkZW50aXR5LFxuICAgICAgICAgICAgZGVjb2RlOiBjb21tb25fMS5pZGVudGl0eSxcbiAgICAgICAgICAgIGlzOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgZXF1YWxzOiBjb21tb25fMS5lcXVhbHMsXG4gICAgICAgIH0pLFxuICAgIH0pO1xufVxuaW5pdERlZmF1bHRUeXBlcygpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyYW1UeXBlcy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvcGFyYW1zL3BhcmFtVHlwZXMuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBwYXJhbXNcbiAqL1xuLyoqICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbi8qKiBAaW50ZXJuYWxhcGkgKi9cbnZhciBTdGF0ZVBhcmFtcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHt9OyB9XG4gICAgICAgIGNvbW1vbl8xLmV4dGVuZCh0aGlzLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgYSBzZXQgb2YgcGFyYW1ldGVycyB3aXRoIGFsbCBwYXJhbWV0ZXJzIGluaGVyaXRlZCBiZXR3ZWVuIHRoZSBjb21tb24gcGFyZW50cyBvZiB0aGVcbiAgICAgKiBjdXJyZW50IHN0YXRlIGFuZCBhIGdpdmVuIGRlc3RpbmF0aW9uIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5ld1BhcmFtcyBUaGUgc2V0IG9mIHBhcmFtZXRlcnMgd2hpY2ggd2lsbCBiZSBjb21wb3NpdGVkIHdpdGggaW5oZXJpdGVkIHBhcmFtcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJGN1cnJlbnQgSW50ZXJuYWwgZGVmaW5pdGlvbiBvZiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkdG8gSW50ZXJuYWwgZGVmaW5pdGlvbiBvZiBvYmplY3QgcmVwcmVzZW50aW5nIHN0YXRlIHRvIHRyYW5zaXRpb24gdG8uXG4gICAgICovXG4gICAgU3RhdGVQYXJhbXMucHJvdG90eXBlLiRpbmhlcml0ID0gZnVuY3Rpb24gKG5ld1BhcmFtcywgJGN1cnJlbnQsICR0bykge1xuICAgICAgICB2YXIgcGFyZW50cyA9IGNvbW1vbl8xLmFuY2VzdG9ycygkY3VycmVudCwgJHRvKSwgcGFyZW50UGFyYW1zLCBpbmhlcml0ZWQgPSB7fSwgaW5oZXJpdExpc3QgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBwYXJlbnRzKSB7XG4gICAgICAgICAgICBpZiAoIXBhcmVudHNbaV0gfHwgIXBhcmVudHNbaV0ucGFyYW1zKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgcGFyZW50UGFyYW1zID0gT2JqZWN0LmtleXMocGFyZW50c1tpXS5wYXJhbXMpO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnRQYXJhbXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiBpbiBwYXJlbnRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5oZXJpdExpc3QuaW5kZXhPZihwYXJlbnRQYXJhbXNbal0pID49IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGluaGVyaXRMaXN0LnB1c2gocGFyZW50UGFyYW1zW2pdKTtcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWRbcGFyZW50UGFyYW1zW2pdXSA9IHRoaXNbcGFyZW50UGFyYW1zW2pdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKHt9LCBpbmhlcml0ZWQsIG5ld1BhcmFtcyk7XG4gICAgfTtcbiAgICA7XG4gICAgcmV0dXJuIFN0YXRlUGFyYW1zO1xufSgpKTtcbmV4cG9ydHMuU3RhdGVQYXJhbXMgPSBTdGF0ZVBhcmFtcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlUGFyYW1zLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9wYXJhbXMvc3RhdGVQYXJhbXMuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgc3RhdGUgKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zdHJpbmdzXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgcmVzb2x2YWJsZV8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmUvcmVzb2x2YWJsZVwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIHBhcnNlVXJsID0gZnVuY3Rpb24gKHVybCkge1xuICAgIGlmICghcHJlZGljYXRlc18xLmlzU3RyaW5nKHVybCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcm9vdCA9IHVybC5jaGFyQXQoMCkgPT09ICdeJztcbiAgICByZXR1cm4geyB2YWw6IHJvb3QgPyB1cmwuc3Vic3RyaW5nKDEpIDogdXJsLCByb290OiByb290IH07XG59O1xuZnVuY3Rpb24gbmFtZUJ1aWxkZXIoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUubmFtZTtcbn1cbmZ1bmN0aW9uIHNlbGZCdWlsZGVyKHN0YXRlKSB7XG4gICAgc3RhdGUuc2VsZi4kJHN0YXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RhdGU7IH07XG4gICAgcmV0dXJuIHN0YXRlLnNlbGY7XG59XG5mdW5jdGlvbiBkYXRhQnVpbGRlcihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5wYXJlbnQgJiYgc3RhdGUucGFyZW50LmRhdGEpIHtcbiAgICAgICAgc3RhdGUuZGF0YSA9IHN0YXRlLnNlbGYuZGF0YSA9IGNvbW1vbl8xLmluaGVyaXQoc3RhdGUucGFyZW50LmRhdGEsIHN0YXRlLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuZGF0YTtcbn1cbnZhciBnZXRVcmxCdWlsZGVyID0gZnVuY3Rpb24gKCR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyLCByb290KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVybEJ1aWxkZXIoc3RhdGUpIHtcbiAgICAgICAgdmFyIHN0YXRlRGVjID0gc3RhdGU7XG4gICAgICAgIC8vIEZvciBmdXR1cmUgc3RhdGVzLCBpLmUuLCBzdGF0ZXMgd2hvc2UgbmFtZSBlbmRzIHdpdGggYC4qKmAsXG4gICAgICAgIC8vIG1hdGNoIGFueXRoaW5nIHRoYXQgc3RhcnRzIHdpdGggdGhlIHVybCBwcmVmaXhcbiAgICAgICAgaWYgKHN0YXRlRGVjICYmIHN0YXRlRGVjLnVybCAmJiBzdGF0ZURlYy5uYW1lICYmIHN0YXRlRGVjLm5hbWUubWF0Y2goL1xcLlxcKlxcKiQvKSkge1xuICAgICAgICAgICAgc3RhdGVEZWMudXJsICs9IFwie3JlbWFpbmRlcjphbnl9XCI7IC8vIG1hdGNoIGFueSBwYXRoICguKilcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VVcmwoc3RhdGVEZWMudXJsKSwgcGFyZW50ID0gc3RhdGUucGFyZW50O1xuICAgICAgICB2YXIgdXJsID0gIXBhcnNlZCA/IHN0YXRlRGVjLnVybCA6ICR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyLmNvbXBpbGUocGFyc2VkLnZhbCwge1xuICAgICAgICAgICAgcGFyYW1zOiBzdGF0ZS5wYXJhbXMgfHwge30sXG4gICAgICAgICAgICBwYXJhbU1hcDogZnVuY3Rpb24gKHBhcmFtQ29uZmlnLCBpc1NlYXJjaCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZURlYy5yZWxvYWRPblNlYXJjaCA9PT0gZmFsc2UgJiYgaXNTZWFyY2gpXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtQ29uZmlnID0gY29tbW9uXzEuZXh0ZW5kKHBhcmFtQ29uZmlnIHx8IHt9LCB7IGR5bmFtaWM6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtQ29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF1cmwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCEkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlci5pc01hdGNoZXIodXJsKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdXJsICdcIiArIHVybCArIFwiJyBpbiBzdGF0ZSAnXCIgKyBzdGF0ZSArIFwiJ1wiKTtcbiAgICAgICAgcmV0dXJuIChwYXJzZWQgJiYgcGFyc2VkLnJvb3QpID8gdXJsIDogKChwYXJlbnQgJiYgcGFyZW50Lm5hdmlnYWJsZSkgfHwgcm9vdCgpKS51cmwuYXBwZW5kKHVybCk7XG4gICAgfTtcbn07XG52YXIgZ2V0TmF2aWdhYmxlQnVpbGRlciA9IGZ1bmN0aW9uIChpc1Jvb3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbmF2aWdhYmxlQnVpbGRlcihzdGF0ZSkge1xuICAgICAgICByZXR1cm4gIWlzUm9vdChzdGF0ZSkgJiYgc3RhdGUudXJsID8gc3RhdGUgOiAoc3RhdGUucGFyZW50ID8gc3RhdGUucGFyZW50Lm5hdmlnYWJsZSA6IG51bGwpO1xuICAgIH07XG59O1xudmFyIGdldFBhcmFtc0J1aWxkZXIgPSBmdW5jdGlvbiAocGFyYW1GYWN0b3J5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBhcmFtc0J1aWxkZXIoc3RhdGUpIHtcbiAgICAgICAgdmFyIG1ha2VDb25maWdQYXJhbSA9IGZ1bmN0aW9uIChjb25maWcsIGlkKSB7IHJldHVybiBwYXJhbUZhY3RvcnkuZnJvbUNvbmZpZyhpZCwgbnVsbCwgY29uZmlnKTsgfTtcbiAgICAgICAgdmFyIHVybFBhcmFtcyA9IChzdGF0ZS51cmwgJiYgc3RhdGUudXJsLnBhcmFtZXRlcnMoeyBpbmhlcml0OiBmYWxzZSB9KSkgfHwgW107XG4gICAgICAgIHZhciBub25VcmxQYXJhbXMgPSBjb21tb25fMS52YWx1ZXMoY29tbW9uXzEubWFwT2JqKGNvbW1vbl8xLm9taXQoc3RhdGUucGFyYW1zIHx8IHt9LCB1cmxQYXJhbXMubWFwKGhvZl8xLnByb3AoJ2lkJykpKSwgbWFrZUNvbmZpZ1BhcmFtKSk7XG4gICAgICAgIHJldHVybiB1cmxQYXJhbXMuY29uY2F0KG5vblVybFBhcmFtcykubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBbcC5pZCwgcF07IH0pLnJlZHVjZShjb21tb25fMS5hcHBseVBhaXJzLCB7fSk7XG4gICAgfTtcbn07XG5mdW5jdGlvbiBwYXRoQnVpbGRlcihzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5wYXJlbnQgPyBzdGF0ZS5wYXJlbnQucGF0aC5jb25jYXQoc3RhdGUpIDogLypyb290Ki8gW3N0YXRlXTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzQnVpbGRlcihzdGF0ZSkge1xuICAgIHZhciBpbmNsdWRlcyA9IHN0YXRlLnBhcmVudCA/IGNvbW1vbl8xLmV4dGVuZCh7fSwgc3RhdGUucGFyZW50LmluY2x1ZGVzKSA6IHt9O1xuICAgIGluY2x1ZGVzW3N0YXRlLm5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gaW5jbHVkZXM7XG59XG4vKipcbiAqIFRoaXMgaXMgYSBbW1N0YXRlQnVpbGRlci5idWlsZGVyXV0gZnVuY3Rpb24gZm9yIHRoZSBgcmVzb2x2ZTpgIGJsb2NrIG9uIGEgW1tTdGF0ZURlY2xhcmF0aW9uXV0uXG4gKlxuICogV2hlbiB0aGUgW1tTdGF0ZUJ1aWxkZXJdXSBidWlsZHMgYSBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0IGZyb20gYSByYXcgW1tTdGF0ZURlY2xhcmF0aW9uXV0sIHRoaXMgYnVpbGRlclxuICogdmFsaWRhdGVzIHRoZSBgcmVzb2x2ZWAgcHJvcGVydHkgYW5kIGNvbnZlcnRzIGl0IHRvIGEgW1tSZXNvbHZhYmxlXV0gYXJyYXkuXG4gKlxuICogcmVzb2x2ZTogaW5wdXQgdmFsdWUgY2FuIGJlOlxuICpcbiAqIHtcbiAqICAgLy8gYW5hbHl6ZWQgYnV0IG5vdCBpbmplY3RlZFxuICogICBteUZvb1Jlc29sdmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJteUZvb0RhdGFcIjsgfSxcbiAqXG4gKiAgIC8vIGZ1bmN0aW9uLnRvU3RyaW5nKCkgcGFyc2VkLCBcIkRlcGVuZGVuY3lOYW1lXCIgZGVwIGFzIHN0cmluZyAobm90IG1pbi1zYWZlKVxuICogICBteUJhclJlc29sdmU6IGZ1bmN0aW9uKERlcGVuZGVuY3lOYW1lKSB7IHJldHVybiBEZXBlbmRlbmN5TmFtZS5mZXRjaFNvbWV0aGluZ0FzUHJvbWlzZSgpIH0sXG4gKlxuICogICAvLyBBcnJheSBzcGxpdDsgXCJEZXBlbmRlbmN5TmFtZVwiIGRlcCBhcyBzdHJpbmdcbiAqICAgbXlCYXpSZXNvbHZlOiBbIFwiRGVwZW5kZW5jeU5hbWVcIiwgZnVuY3Rpb24oZGVwKSB7IHJldHVybiBkZXAuZmV0Y2hTb21ldGhpbmdBc1Byb21pc2UoKSB9LFxuICpcbiAqICAgLy8gQXJyYXkgc3BsaXQ7IERlcGVuZGVuY3lUeXBlIGRlcCBhcyB0b2tlbiAoY29tcGFyZWQgdXNpbmcgPT09KVxuICogICBteVF1eFJlc29sdmU6IFsgRGVwZW5kZW5jeVR5cGUsIGZ1bmN0aW9uKGRlcCkgeyByZXR1cm4gZGVwLmZldGNoU29tZXRpbmdBc1Byb21pc2UoKSB9LFxuICpcbiAqICAgLy8gdmFsLiRpbmplY3QgdXNlZCBhcyBkZXBzXG4gKiAgIC8vIHdoZXJlOlxuICogICAvLyAgICAgY29yZ2VSZXNvbHZlLiRpbmplY3QgPSBbXCJEZXBlbmRlbmN5TmFtZVwiXTtcbiAqICAgLy8gICAgIGZ1bmN0aW9uIGNvcmdlUmVzb2x2ZShkZXApIHsgZGVwLmZldGNoU29tZXRpbmdBc1Byb21pc2UoKSB9XG4gKiAgIC8vIHRoZW4gXCJEZXBlbmRlbmN5TmFtZVwiIGRlcCBhcyBzdHJpbmdcbiAqICAgbXlDb3JnZVJlc29sdmU6IGNvcmdlUmVzb2x2ZSxcbiAqXG4gKiAgLy8gaW5qZWN0IHNlcnZpY2UgYnkgbmFtZVxuICogIC8vIFdoZW4gYSBzdHJpbmcgaXMgZm91bmQsIGRlc3VnYXIgY3JlYXRpbmcgYSByZXNvbHZlIHRoYXQgaW5qZWN0cyB0aGUgbmFtZWQgc2VydmljZVxuICogICBteUdyYXVsdFJlc29sdmU6IFwiU29tZVNlcnZpY2VcIlxuICogfVxuICpcbiAqIG9yOlxuICpcbiAqIFtcbiAqICAgbmV3IFJlc29sdmFibGUoXCJteUZvb1Jlc29sdmVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBcIm15Rm9vRGF0YVwiIH0pLFxuICogICBuZXcgUmVzb2x2YWJsZShcIm15QmFyUmVzb2x2ZVwiLCBmdW5jdGlvbihkZXApIHsgcmV0dXJuIGRlcC5mZXRjaFNvbWV0aGluZ0FzUHJvbWlzZSgpIH0sIFsgXCJEZXBlbmRlbmN5TmFtZVwiIF0pLFxuICogICB7IHByb3ZpZGU6IFwibXlCYXpSZXNvbHZlXCIsIHVzZUZhY3Rvcnk6IGZ1bmN0aW9uKGRlcCkgeyBkZXAuZmV0Y2hTb21ldGhpbmdBc1Byb21pc2UoKSB9LCBkZXBzOiBbIFwiRGVwZW5kZW5jeU5hbWVcIiBdIH1cbiAqIF1cbiAqL1xuZnVuY3Rpb24gcmVzb2x2YWJsZXNCdWlsZGVyKHN0YXRlKSB7XG4gICAgLyoqIGNvbnZlcnQgcmVzb2x2ZToge30gYW5kIHJlc29sdmVQb2xpY3k6IHt9IG9iamVjdHMgdG8gYW4gYXJyYXkgb2YgdHVwbGVzICovXG4gICAgdmFyIG9iamVjdHMyVHVwbGVzID0gZnVuY3Rpb24gKHJlc29sdmVPYmosIHJlc29sdmVQb2xpY2llcykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVzb2x2ZU9iaiB8fCB7fSkubWFwKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gKHsgdG9rZW46IHRva2VuLCB2YWw6IHJlc29sdmVPYmpbdG9rZW5dLCBkZXBzOiB1bmRlZmluZWQsIHBvbGljeTogcmVzb2x2ZVBvbGljaWVzW3Rva2VuXSB9KTsgfSk7XG4gICAgfTtcbiAgICAvKiogZmV0Y2ggREkgYW5ub3RhdGlvbnMgZnJvbSBhIGZ1bmN0aW9uIG9yIG5nMS1zdHlsZSBhcnJheSAqL1xuICAgIHZhciBhbm5vdGF0ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgJGluamVjdG9yID0gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yO1xuICAgICAgICAvLyBuZzEgZG9lc24ndCBoYXZlIGFuICRpbmplY3RvciB1bnRpbCBydW50aW1lLlxuICAgICAgICAvLyBJZiB0aGUgJGluamVjdG9yIGRvZXNuJ3QgZXhpc3QsIHVzZSBcImRlZmVycmVkXCIgbGl0ZXJhbCBhcyBhXG4gICAgICAgIC8vIG1hcmtlciBpbmRpY2F0aW5nIHRoZXkgc2hvdWxkIGJlIGFubm90YXRlZCB3aGVuIHJ1bnRpbWUgc3RhcnRzXG4gICAgICAgIHJldHVybiBmblsnJGluamVjdCddIHx8ICgkaW5qZWN0b3IgJiYgJGluamVjdG9yLmFubm90YXRlKGZuLCAkaW5qZWN0b3Iuc3RyaWN0RGkpKSB8fCBcImRlZmVycmVkXCI7XG4gICAgfTtcbiAgICAvKiogdHJ1ZSBpZiB0aGUgb2JqZWN0IGhhcyBib3RoIGB0b2tlbmAgYW5kIGByZXNvbHZlRm5gLCBhbmQgaXMgcHJvYmFibHkgYSBbW1Jlc29sdmVMaXRlcmFsXV0gKi9cbiAgICB2YXIgaXNSZXNvbHZlTGl0ZXJhbCA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuICEhKG9iai50b2tlbiAmJiBvYmoucmVzb2x2ZUZuKTsgfTtcbiAgICAvKiogdHJ1ZSBpZiB0aGUgb2JqZWN0IGxvb2tzIGxpa2UgYSBwcm92aWRlIGxpdGVyYWwsIG9yIGEgbmcyIFByb3ZpZGVyICovXG4gICAgdmFyIGlzTGlrZU5nMlByb3ZpZGVyID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gISEoKG9iai5wcm92aWRlIHx8IG9iai50b2tlbikgJiYgKG9iai51c2VWYWx1ZSB8fCBvYmoudXNlRmFjdG9yeSB8fCBvYmoudXNlRXhpc3RpbmcgfHwgb2JqLnVzZUNsYXNzKSk7IH07XG4gICAgLyoqIHRydWUgaWYgdGhlIG9iamVjdCBsb29rcyBsaWtlIGEgdHVwbGUgZnJvbSBvYmoyVHVwbGVzICovXG4gICAgdmFyIGlzVHVwbGVGcm9tT2JqID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gISEob2JqICYmIG9iai52YWwgJiYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhvYmoudmFsKSB8fCBwcmVkaWNhdGVzXzEuaXNBcnJheShvYmoudmFsKSB8fCBwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihvYmoudmFsKSkpOyB9O1xuICAgIC8qKiBleHRyYWN0cyB0aGUgdG9rZW4gZnJvbSBhIFByb3ZpZGVyIG9yIHByb3ZpZGUgbGl0ZXJhbCAqL1xuICAgIHZhciB0b2tlbiA9IGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnByb3ZpZGUgfHwgcC50b2tlbjsgfTtcbiAgICAvKiogR2l2ZW4gYSBsaXRlcmFsIHJlc29sdmUgb3IgcHJvdmlkZXIgb2JqZWN0LCByZXR1cm5zIGEgUmVzb2x2YWJsZSAqL1xuICAgIHZhciBsaXRlcmFsMlJlc29sdmFibGUgPSBob2ZfMS5wYXR0ZXJuKFtcbiAgICAgICAgW2hvZl8xLnByb3AoJ3Jlc29sdmVGbicpLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKHRva2VuKHApLCBwLnJlc29sdmVGbiwgcC5kZXBzLCBwLnBvbGljeSk7IH1dLFxuICAgICAgICBbaG9mXzEucHJvcCgndXNlRmFjdG9yeScpLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKHRva2VuKHApLCBwLnVzZUZhY3RvcnksIChwLmRlcHMgfHwgcC5kZXBlbmRlbmNpZXMpLCBwLnBvbGljeSk7IH1dLFxuICAgICAgICBbaG9mXzEucHJvcCgndXNlQ2xhc3MnKSwgZnVuY3Rpb24gKHApIHsgcmV0dXJuIG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZSh0b2tlbihwKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IHAudXNlQ2xhc3MoKTsgfSwgW10sIHAucG9saWN5KTsgfV0sXG4gICAgICAgIFtob2ZfMS5wcm9wKCd1c2VWYWx1ZScpLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKHRva2VuKHApLCBmdW5jdGlvbiAoKSB7IHJldHVybiBwLnVzZVZhbHVlOyB9LCBbXSwgcC5wb2xpY3ksIHAudXNlVmFsdWUpOyB9XSxcbiAgICAgICAgW2hvZl8xLnByb3AoJ3VzZUV4aXN0aW5nJyksIGZ1bmN0aW9uIChwKSB7IHJldHVybiBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUodG9rZW4ocCksIGNvbW1vbl8xLmlkZW50aXR5LCBbcC51c2VFeGlzdGluZ10sIHAucG9saWN5KTsgfV0sXG4gICAgXSk7XG4gICAgdmFyIHR1cGxlMlJlc29sdmFibGUgPSBob2ZfMS5wYXR0ZXJuKFtcbiAgICAgICAgW2hvZl8xLnBpcGUoaG9mXzEucHJvcChcInZhbFwiKSwgcHJlZGljYXRlc18xLmlzU3RyaW5nKSwgZnVuY3Rpb24gKHR1cGxlKSB7IHJldHVybiBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUodHVwbGUudG9rZW4sIGNvbW1vbl8xLmlkZW50aXR5LCBbdHVwbGUudmFsXSwgdHVwbGUucG9saWN5KTsgfV0sXG4gICAgICAgIFtob2ZfMS5waXBlKGhvZl8xLnByb3AoXCJ2YWxcIiksIHByZWRpY2F0ZXNfMS5pc0FycmF5KSwgZnVuY3Rpb24gKHR1cGxlKSB7IHJldHVybiBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUodHVwbGUudG9rZW4sIGNvbW1vbl8xLnRhaWwodHVwbGUudmFsKSwgdHVwbGUudmFsLnNsaWNlKDAsIC0xKSwgdHVwbGUucG9saWN5KTsgfV0sXG4gICAgICAgIFtob2ZfMS5waXBlKGhvZl8xLnByb3AoXCJ2YWxcIiksIHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKSwgZnVuY3Rpb24gKHR1cGxlKSB7IHJldHVybiBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUodHVwbGUudG9rZW4sIHR1cGxlLnZhbCwgYW5ub3RhdGUodHVwbGUudmFsKSwgdHVwbGUucG9saWN5KTsgfV0sXG4gICAgXSk7XG4gICAgdmFyIGl0ZW0yUmVzb2x2YWJsZSA9IGhvZl8xLnBhdHRlcm4oW1xuICAgICAgICBbaG9mXzEuaXMocmVzb2x2YWJsZV8xLlJlc29sdmFibGUpLCBmdW5jdGlvbiAocikgeyByZXR1cm4gcjsgfV0sXG4gICAgICAgIFtpc1Jlc29sdmVMaXRlcmFsLCBsaXRlcmFsMlJlc29sdmFibGVdLFxuICAgICAgICBbaXNMaWtlTmcyUHJvdmlkZXIsIGxpdGVyYWwyUmVzb2x2YWJsZV0sXG4gICAgICAgIFtpc1R1cGxlRnJvbU9iaiwgdHVwbGUyUmVzb2x2YWJsZV0sXG4gICAgICAgIFtob2ZfMS52YWwodHJ1ZSksIGZ1bmN0aW9uIChvYmopIHsgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNvbHZlIHZhbHVlOiBcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkob2JqKSk7IH1dXG4gICAgXSk7XG4gICAgLy8gSWYgcmVzb2x2ZUJsb2NrIGlzIGFscmVhZHkgYW4gYXJyYXksIHVzZSBpdCBhcy1pcy5cbiAgICAvLyBPdGhlcndpc2UsIGFzc3VtZSBpdCdzIGFuIG9iamVjdCBhbmQgY29udmVydCB0byBhbiBBcnJheSBvZiB0dXBsZXNcbiAgICB2YXIgZGVjbCA9IHN0YXRlLnJlc29sdmU7XG4gICAgdmFyIGl0ZW1zID0gcHJlZGljYXRlc18xLmlzQXJyYXkoZGVjbCkgPyBkZWNsIDogb2JqZWN0czJUdXBsZXMoZGVjbCwgc3RhdGUucmVzb2x2ZVBvbGljeSB8fCB7fSk7XG4gICAgcmV0dXJuIGl0ZW1zLm1hcChpdGVtMlJlc29sdmFibGUpO1xufVxuZXhwb3J0cy5yZXNvbHZhYmxlc0J1aWxkZXIgPSByZXNvbHZhYmxlc0J1aWxkZXI7XG4vKipcbiAqIEBpbnRlcm5hbGFwaSBBIGludGVybmFsIGdsb2JhbCBzZXJ2aWNlXG4gKlxuICogU3RhdGVCdWlsZGVyIGlzIGEgZmFjdG9yeSBmb3IgdGhlIGludGVybmFsIFtbU3RhdGVPYmplY3RdXSBvYmplY3RzLlxuICpcbiAqIFdoZW4geW91IHJlZ2lzdGVyIGEgc3RhdGUgd2l0aCB0aGUgW1tTdGF0ZVJlZ2lzdHJ5XV0sIHlvdSByZWdpc3RlciBhIHBsYWluIG9sZCBqYXZhc2NyaXB0IG9iamVjdCB3aGljaFxuICogY29uZm9ybXMgdG8gdGhlIFtbU3RhdGVEZWNsYXJhdGlvbl1dIGludGVyZmFjZS4gIFRoaXMgZmFjdG9yeSB0YWtlcyB0aGF0IG9iamVjdCBhbmQgYnVpbGRzIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0LCB3aGljaCBoYXMgYW4gQVBJIGFuZCBpcyB1c2VkIGludGVybmFsbHkuXG4gKlxuICogQ3VzdG9tIHByb3BlcnRpZXMgb3IgQVBJIG1heSBiZSBhZGRlZCB0byB0aGUgaW50ZXJuYWwgW1tTdGF0ZU9iamVjdF1dIG9iamVjdCBieSByZWdpc3RlcmluZyBhIGRlY29yYXRvciBmdW5jdGlvblxuICogdXNpbmcgdGhlIFtbYnVpbGRlcl1dIG1ldGhvZC5cbiAqL1xudmFyIFN0YXRlQnVpbGRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZUJ1aWxkZXIobWF0Y2hlciwgdXJsTWF0Y2hlckZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5tYXRjaGVyID0gbWF0Y2hlcjtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcm9vdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGNoZXIuZmluZChcIlwiKTsgfTtcbiAgICAgICAgdmFyIGlzUm9vdCA9IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGUubmFtZSA9PT0gXCJcIjsgfTtcbiAgICAgICAgZnVuY3Rpb24gcGFyZW50QnVpbGRlcihzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKGlzUm9vdChzdGF0ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlci5maW5kKHNlbGYucGFyZW50TmFtZShzdGF0ZSkpIHx8IHJvb3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1aWxkZXJzID0ge1xuICAgICAgICAgICAgbmFtZTogW25hbWVCdWlsZGVyXSxcbiAgICAgICAgICAgIHNlbGY6IFtzZWxmQnVpbGRlcl0sXG4gICAgICAgICAgICBwYXJlbnQ6IFtwYXJlbnRCdWlsZGVyXSxcbiAgICAgICAgICAgIGRhdGE6IFtkYXRhQnVpbGRlcl0sXG4gICAgICAgICAgICAvLyBCdWlsZCBhIFVSTE1hdGNoZXIgaWYgbmVjZXNzYXJ5LCBlaXRoZXIgdmlhIGEgcmVsYXRpdmUgb3IgYWJzb2x1dGUgVVJMXG4gICAgICAgICAgICB1cmw6IFtnZXRVcmxCdWlsZGVyKHVybE1hdGNoZXJGYWN0b3J5LCByb290KV0sXG4gICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHN0YXRlIHRoYXQgaGFzIGEgVVJMIChpLmUuIGlzIG5hdmlnYWJsZSlcbiAgICAgICAgICAgIG5hdmlnYWJsZTogW2dldE5hdmlnYWJsZUJ1aWxkZXIoaXNSb290KV0sXG4gICAgICAgICAgICBwYXJhbXM6IFtnZXRQYXJhbXNCdWlsZGVyKHVybE1hdGNoZXJGYWN0b3J5LnBhcmFtRmFjdG9yeSldLFxuICAgICAgICAgICAgLy8gRWFjaCBmcmFtZXdvcmstc3BlY2lmaWMgdWktcm91dGVyIGltcGxlbWVudGF0aW9uIHNob3VsZCBkZWZpbmUgaXRzIG93biBgdmlld3NgIGJ1aWxkZXJcbiAgICAgICAgICAgIC8vIGUuZy4sIHNyYy9uZzEvc3RhdGVidWlsZGVycy92aWV3cy50c1xuICAgICAgICAgICAgdmlld3M6IFtdLFxuICAgICAgICAgICAgLy8gS2VlcCBhIGZ1bGwgcGF0aCBmcm9tIHRoZSByb290IGRvd24gdG8gdGhpcyBzdGF0ZSBhcyB0aGlzIGlzIG5lZWRlZCBmb3Igc3RhdGUgYWN0aXZhdGlvbi5cbiAgICAgICAgICAgIHBhdGg6IFtwYXRoQnVpbGRlcl0sXG4gICAgICAgICAgICAvLyBTcGVlZCB1cCAkc3RhdGUuaW5jbHVkZXMoKSBhcyBpdCdzIHVzZWQgYSBsb3RcbiAgICAgICAgICAgIGluY2x1ZGVzOiBbaW5jbHVkZXNCdWlsZGVyXSxcbiAgICAgICAgICAgIHJlc29sdmFibGVzOiBbcmVzb2x2YWJsZXNCdWlsZGVyXVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBbW0J1aWxkZXJGdW5jdGlvbl1dIGZvciBhIHNwZWNpZmljIFtbU3RhdGVPYmplY3RdXSBwcm9wZXJ0eSAoZS5nLiwgYHBhcmVudGAsIGB1cmxgLCBvciBgcGF0aGApLlxuICAgICAqIE1vcmUgdGhhbiBvbmUgQnVpbGRlckZ1bmN0aW9uIGNhbiBiZSByZWdpc3RlcmVkIGZvciBhIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhlIEJ1aWxkZXJGdW5jdGlvbihzKSB3aWxsIGJlIHVzZWQgdG8gZGVmaW5lIHRoZSBwcm9wZXJ0eSBvbiBhbnkgc3Vic2VxdWVudGx5IGJ1aWx0IFtbU3RhdGVPYmplY3RdXSBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIFN0YXRlIHByb3BlcnR5IGJlaW5nIHJlZ2lzdGVyZWQgZm9yLlxuICAgICAqIEBwYXJhbSBmbiBUaGUgQnVpbGRlckZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBidWlsZCB0aGUgU3RhdGUgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGRlcmVnaXN0ZXJzIHRoZSBCdWlsZGVyRnVuY3Rpb25cbiAgICAgKi9cbiAgICBTdGF0ZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkZXIgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICAgICAgdmFyIGJ1aWxkZXJzID0gdGhpcy5idWlsZGVycztcbiAgICAgICAgdmFyIGFycmF5ID0gYnVpbGRlcnNbbmFtZV0gfHwgW107XG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXQ6IGlmIG9ubHkgb25lIGJ1aWxkZXIgZXhpc3RzLCByZXR1cm4gaXQsIGVsc2UgcmV0dXJuIHdob2xlIGFyYXJ5LlxuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzU3RyaW5nKG5hbWUpICYmICFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGZuKSlcbiAgICAgICAgICAgIHJldHVybiBhcnJheS5sZW5ndGggPiAxID8gYXJyYXkgOiBhcnJheVswXTtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNTdHJpbmcobmFtZSkgfHwgIXByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKGZuKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgYnVpbGRlcnNbbmFtZV0gPSBhcnJheTtcbiAgICAgICAgYnVpbGRlcnNbbmFtZV0ucHVzaChmbik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWlsZGVyc1tuYW1lXS5zcGxpY2UoYnVpbGRlcnNbbmFtZV0uaW5kZXhPZihmbiwgMSkpICYmIG51bGw7IH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIG9uIGFuIGVzc2VudGlhbGx5IGJsYW5rIFN0YXRlIG9iamVjdCwgcmV0dXJuaW5nIGEgU3RhdGUgb2JqZWN0IHdoaWNoIGhhcyBhbGwgaXRzXG4gICAgICogcHJvcGVydGllcyBhbmQgQVBJIGJ1aWx0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlIGFuIHVuaW5pdGlhbGl6ZWQgU3RhdGUgb2JqZWN0XG4gICAgICogQHJldHVybnMgdGhlIGJ1aWx0IFN0YXRlIG9iamVjdFxuICAgICAqL1xuICAgIFN0YXRlQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgbWF0Y2hlciA9IF9hLm1hdGNoZXIsIGJ1aWxkZXJzID0gX2EuYnVpbGRlcnM7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5hbWUoc3RhdGUpO1xuICAgICAgICBpZiAocGFyZW50ICYmICFtYXRjaGVyLmZpbmQocGFyZW50LCB1bmRlZmluZWQsIGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGJ1aWxkZXJzKSB7XG4gICAgICAgICAgICBpZiAoIWJ1aWxkZXJzLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YXIgY2hhaW4gPSBidWlsZGVyc1trZXldLnJlZHVjZShmdW5jdGlvbiAocGFyZW50Rm4sIHN0ZXApIHsgcmV0dXJuIGZ1bmN0aW9uIChfc3RhdGUpIHsgcmV0dXJuIHN0ZXAoX3N0YXRlLCBwYXJlbnRGbik7IH07IH0sIGNvbW1vbl8xLm5vb3ApO1xuICAgICAgICAgICAgc3RhdGVba2V5XSA9IGNoYWluKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcbiAgICBTdGF0ZUJ1aWxkZXIucHJvdG90eXBlLnBhcmVudE5hbWUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgLy8gbmFtZSA9ICdmb28uYmFyLmJhei4qKidcbiAgICAgICAgdmFyIG5hbWUgPSBzdGF0ZS5uYW1lIHx8IFwiXCI7XG4gICAgICAgIC8vIHNlZ21lbnRzID0gWydmb28nLCAnYmFyJywgJ2JheicsICcuKionXVxuICAgICAgICB2YXIgc2VnbWVudHMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgIC8vIHNlZ21lbnRzID0gWydmb28nLCAnYmFyJywgJ2JheiddXG4gICAgICAgIHZhciBsYXN0U2VnbWVudCA9IHNlZ21lbnRzLnBvcCgpO1xuICAgICAgICAvLyBzZWdtZW50cyA9IFsnZm9vJywgJ2JhciddIChpZ25vcmUgLioqIHNlZ21lbnQgZm9yIGZ1dHVyZSBzdGF0ZXMpXG4gICAgICAgIGlmIChsYXN0U2VnbWVudCA9PT0gJyoqJylcbiAgICAgICAgICAgIHNlZ21lbnRzLnBvcCgpO1xuICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGVzIHRoYXQgc3BlY2lmeSB0aGUgJ3BhcmVudDonIHByb3BlcnR5IHNob3VsZCBub3QgaGF2ZSBhICcuJyBpbiB0aGVpciBuYW1lIChcIiArIG5hbWUgKyBcIilcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAnZm9vLmJhcidcbiAgICAgICAgICAgIHJldHVybiBzZWdtZW50cy5qb2luKFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YXRlLnBhcmVudClcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzU3RyaW5nKHN0YXRlLnBhcmVudCkgPyBzdGF0ZS5wYXJlbnQgOiBzdGF0ZS5wYXJlbnQubmFtZTtcbiAgICB9O1xuICAgIFN0YXRlQnVpbGRlci5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgbmFtZSA9IHN0YXRlLm5hbWU7XG4gICAgICAgIGlmIChuYW1lLmluZGV4T2YoJy4nKSAhPT0gLTEgfHwgIXN0YXRlLnBhcmVudClcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB2YXIgcGFyZW50TmFtZSA9IHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzdGF0ZS5wYXJlbnQpID8gc3RhdGUucGFyZW50IDogc3RhdGUucGFyZW50Lm5hbWU7XG4gICAgICAgIHJldHVybiBwYXJlbnROYW1lID8gcGFyZW50TmFtZSArIFwiLlwiICsgbmFtZSA6IG5hbWU7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVCdWlsZGVyO1xufSgpKTtcbmV4cG9ydHMuU3RhdGVCdWlsZGVyID0gU3RhdGVCdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVCdWlsZGVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZUJ1aWxkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgc3RhdGUgKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgU3RhdGVNYXRjaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlTWF0Y2hlcihfc3RhdGVzKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlcyA9IF9zdGF0ZXM7XG4gICAgfVxuICAgIFN0YXRlTWF0Y2hlci5wcm90b3R5cGUuaXNSZWxhdGl2ZSA9IGZ1bmN0aW9uIChzdGF0ZU5hbWUpIHtcbiAgICAgICAgc3RhdGVOYW1lID0gc3RhdGVOYW1lIHx8IFwiXCI7XG4gICAgICAgIHJldHVybiBzdGF0ZU5hbWUuaW5kZXhPZihcIi5cIikgPT09IDAgfHwgc3RhdGVOYW1lLmluZGV4T2YoXCJeXCIpID09PSAwO1xuICAgIH07XG4gICAgU3RhdGVNYXRjaGVyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHN0YXRlT3JOYW1lLCBiYXNlLCBtYXRjaEdsb2IpIHtcbiAgICAgICAgaWYgKG1hdGNoR2xvYiA9PT0gdm9pZCAwKSB7IG1hdGNoR2xvYiA9IHRydWU7IH1cbiAgICAgICAgaWYgKCFzdGF0ZU9yTmFtZSAmJiBzdGF0ZU9yTmFtZSAhPT0gXCJcIilcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBpc1N0ciA9IHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzdGF0ZU9yTmFtZSk7XG4gICAgICAgIHZhciBuYW1lID0gaXNTdHIgPyBzdGF0ZU9yTmFtZSA6IHN0YXRlT3JOYW1lLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLmlzUmVsYXRpdmUobmFtZSkpXG4gICAgICAgICAgICBuYW1lID0gdGhpcy5yZXNvbHZlUGF0aChuYW1lLCBiYXNlKTtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGVzW25hbWVdO1xuICAgICAgICBpZiAoc3RhdGUgJiYgKGlzU3RyIHx8ICghaXNTdHIgJiYgKHN0YXRlID09PSBzdGF0ZU9yTmFtZSB8fCBzdGF0ZS5zZWxmID09PSBzdGF0ZU9yTmFtZSkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU3RyICYmIG1hdGNoR2xvYikge1xuICAgICAgICAgICAgdmFyIF9zdGF0ZXMgPSBjb21tb25fMS52YWx1ZXModGhpcy5fc3RhdGVzKTtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gX3N0YXRlcy5maWx0ZXIoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLl9fc3RhdGVPYmplY3RDYWNoZS5uYW1lR2xvYiAmJlxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5fX3N0YXRlT2JqZWN0Q2FjaGUubmFtZUdsb2IubWF0Y2hlcyhuYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic3RhdGVNYXRjaGVyLmZpbmQ6IEZvdW5kIG11bHRpcGxlIG1hdGNoZXMgZm9yIFwiICsgbmFtZSArIFwiIHVzaW5nIGdsb2I6IFwiLCBtYXRjaGVzLm1hcChmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIG1hdGNoLm5hbWU7IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBTdGF0ZU1hdGNoZXIucHJvdG90eXBlLnJlc29sdmVQYXRoID0gZnVuY3Rpb24gKG5hbWUsIGJhc2UpIHtcbiAgICAgICAgaWYgKCFiYXNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVmZXJlbmNlIHBvaW50IGdpdmVuIGZvciBwYXRoICdcIiArIG5hbWUgKyBcIidcIik7XG4gICAgICAgIHZhciBiYXNlU3RhdGUgPSB0aGlzLmZpbmQoYmFzZSk7XG4gICAgICAgIHZhciBzcGxpdE5hbWUgPSBuYW1lLnNwbGl0KFwiLlwiKSwgaSA9IDAsIHBhdGhMZW5ndGggPSBzcGxpdE5hbWUubGVuZ3RoLCBjdXJyZW50ID0gYmFzZVN0YXRlO1xuICAgICAgICBmb3IgKDsgaSA8IHBhdGhMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNwbGl0TmFtZVtpXSA9PT0gXCJcIiAmJiBpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGJhc2VTdGF0ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGxpdE5hbWVbaV0gPT09IFwiXlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50LnBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0aCAnXCIgKyBuYW1lICsgXCInIG5vdCB2YWxpZCBmb3Igc3RhdGUgJ1wiICsgYmFzZVN0YXRlLm5hbWUgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbE5hbWUgPSBzcGxpdE5hbWUuc2xpY2UoaSkuam9pbihcIi5cIik7XG4gICAgICAgIHJldHVybiBjdXJyZW50Lm5hbWUgKyAoY3VycmVudC5uYW1lICYmIHJlbE5hbWUgPyBcIi5cIiA6IFwiXCIpICsgcmVsTmFtZTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZU1hdGNoZXI7XG59KCkpO1xuZXhwb3J0cy5TdGF0ZU1hdGNoZXIgPSBTdGF0ZU1hdGNoZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0ZU1hdGNoZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlTWF0Y2hlci5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQG1vZHVsZSBzdGF0ZSAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBzdGF0ZU9iamVjdF8xID0gcmVxdWlyZShcIi4vc3RhdGVPYmplY3RcIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbi8qKiBAaW50ZXJuYWxhcGkgKi9cbnZhciBTdGF0ZVF1ZXVlTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZVF1ZXVlTWFuYWdlcigkcmVnaXN0cnksICR1cmxSb3V0ZXIsIHN0YXRlcywgYnVpbGRlciwgbGlzdGVuZXJzKSB7XG4gICAgICAgIHRoaXMuJHJlZ2lzdHJ5ID0gJHJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLiR1cmxSb3V0ZXIgPSAkdXJsUm91dGVyO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHN0YXRlcztcbiAgICAgICAgdGhpcy5idWlsZGVyID0gYnVpbGRlcjtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5tYXRjaGVyID0gJHJlZ2lzdHJ5Lm1hdGNoZXI7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBTdGF0ZVF1ZXVlTWFuYWdlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIH07XG4gICAgU3RhdGVRdWV1ZU1hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHN0YXRlRGVjbCkge1xuICAgICAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlO1xuICAgICAgICB2YXIgc3RhdGUgPSBzdGF0ZU9iamVjdF8xLlN0YXRlT2JqZWN0LmNyZWF0ZShzdGF0ZURlY2wpO1xuICAgICAgICB2YXIgbmFtZSA9IHN0YXRlLm5hbWU7XG4gICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzU3RyaW5nKG5hbWUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGUgbXVzdCBoYXZlIGEgdmFsaWQgbmFtZVwiKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVzLmhhc093blByb3BlcnR5KG5hbWUpIHx8IGNvbW1vbl8xLmluQXJyYXkocXVldWUubWFwKGhvZl8xLnByb3AoJ25hbWUnKSksIG5hbWUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGUgJ1wiICsgbmFtZSArIFwiJyBpcyBhbHJlYWR5IGRlZmluZWRcIik7XG4gICAgICAgIHF1ZXVlLnB1c2goc3RhdGUpO1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9O1xuICAgIFN0YXRlUXVldWVNYW5hZ2VyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcXVldWUgPSBfYS5xdWV1ZSwgc3RhdGVzID0gX2Euc3RhdGVzLCBidWlsZGVyID0gX2EuYnVpbGRlcjtcbiAgICAgICAgdmFyIHJlZ2lzdGVyZWQgPSBbXSwgLy8gc3RhdGVzIHRoYXQgZ290IHJlZ2lzdGVyZWRcbiAgICAgICAgb3JwaGFucyA9IFtdLCAvLyBzdGF0ZXMgdGhhdCBkb24ndCB5ZXQgaGF2ZSBhIHBhcmVudCByZWdpc3RlcmVkXG4gICAgICAgIHByZXZpb3VzUXVldWVMZW5ndGggPSB7fTsgLy8ga2VlcCB0cmFjayBvZiBob3cgbG9uZyB0aGUgcXVldWUgd2hlbiBhbiBvcnBoYW4gd2FzIGZpcnN0IGVuY291bnRlcmVkXG4gICAgICAgIHZhciBnZXRTdGF0ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc3RhdGVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIF90aGlzLnN0YXRlc1tuYW1lXTtcbiAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gc3RhdGUubmFtZTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBidWlsZGVyLmJ1aWxkKHN0YXRlKTtcbiAgICAgICAgICAgIHZhciBvcnBoYW5JZHggPSBvcnBoYW5zLmluZGV4T2Yoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ1N0YXRlID0gZ2V0U3RhdGUobmFtZV8xKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdTdGF0ZSAmJiBleGlzdGluZ1N0YXRlLm5hbWUgPT09IG5hbWVfMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSAnXCIgKyBuYW1lXzEgKyBcIicgaXMgYWxyZWFkeSBkZWZpbmVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdGdXR1cmVTdGF0ZSA9IGdldFN0YXRlKG5hbWVfMSArIFwiLioqXCIpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0Z1dHVyZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmdXR1cmUgc3RhdGUgb2YgdGhlIHNhbWUgbmFtZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRyZWdpc3RyeS5kZXJlZ2lzdGVyKGV4aXN0aW5nRnV0dXJlU3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZXNbbmFtZV8xXSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoUm91dGUoc3RhdGUpO1xuICAgICAgICAgICAgICAgIGlmIChvcnBoYW5JZHggPj0gMClcbiAgICAgICAgICAgICAgICAgICAgb3JwaGFucy5zcGxpY2Uob3JwaGFuSWR4LCAxKTtcbiAgICAgICAgICAgICAgICByZWdpc3RlcmVkLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZXYgPSBwcmV2aW91c1F1ZXVlTGVuZ3RoW25hbWVfMV07XG4gICAgICAgICAgICBwcmV2aW91c1F1ZXVlTGVuZ3RoW25hbWVfMV0gPSBxdWV1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAob3JwaGFuSWR4ID49IDAgJiYgcHJldiA9PT0gcXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCB0d28gY29uc2VjdXRpdmUgaXRlcmF0aW9ucyB3aGVyZSBubyBhZGRpdGlvbmFsIHN0YXRlcyB3ZXJlIGRlcXVldWVkIHN1Y2Nlc3NmdWxseS5cbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZWdpc3RlciBvcnBoYW5lZCBzdGF0ZSAnJHtuYW1lfSdgKTtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3JwaGFuSWR4IDwgMCkge1xuICAgICAgICAgICAgICAgIG9ycGhhbnMucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVnaXN0ZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lcihcInJlZ2lzdGVyZWRcIiwgcmVnaXN0ZXJlZC5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuc2VsZjsgfSkpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGVzO1xuICAgIH07XG4gICAgU3RhdGVRdWV1ZU1hbmFnZXIucHJvdG90eXBlLmF0dGFjaFJvdXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZS5hYnN0cmFjdCB8fCAhc3RhdGUudXJsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiR1cmxSb3V0ZXIucnVsZSh0aGlzLiR1cmxSb3V0ZXIudXJsUnVsZUZhY3RvcnkuY3JlYXRlKHN0YXRlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVRdWV1ZU1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5TdGF0ZVF1ZXVlTWFuYWdlciA9IFN0YXRlUXVldWVNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVRdWV1ZU1hbmFnZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlUXVldWVNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgc3RhdGVcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzdGF0ZU1hdGNoZXJfMSA9IHJlcXVpcmUoXCIuL3N0YXRlTWF0Y2hlclwiKTtcbnZhciBzdGF0ZUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL3N0YXRlQnVpbGRlclwiKTtcbnZhciBzdGF0ZVF1ZXVlTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vc3RhdGVRdWV1ZU1hbmFnZXJcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIFN0YXRlUmVnaXN0cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIGZ1bmN0aW9uIFN0YXRlUmVnaXN0cnkoX3JvdXRlcikge1xuICAgICAgICB0aGlzLl9yb3V0ZXIgPSBfcm91dGVyO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHt9O1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLm1hdGNoZXIgPSBuZXcgc3RhdGVNYXRjaGVyXzEuU3RhdGVNYXRjaGVyKHRoaXMuc3RhdGVzKTtcbiAgICAgICAgdGhpcy5idWlsZGVyID0gbmV3IHN0YXRlQnVpbGRlcl8xLlN0YXRlQnVpbGRlcih0aGlzLm1hdGNoZXIsIF9yb3V0ZXIudXJsTWF0Y2hlckZhY3RvcnkpO1xuICAgICAgICB0aGlzLnN0YXRlUXVldWUgPSBuZXcgc3RhdGVRdWV1ZU1hbmFnZXJfMS5TdGF0ZVF1ZXVlTWFuYWdlcih0aGlzLCBfcm91dGVyLnVybFJvdXRlciwgdGhpcy5zdGF0ZXMsIHRoaXMuYnVpbGRlciwgdGhpcy5saXN0ZW5lcnMpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlclJvb3QoKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLl9yZWdpc3RlclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb290U3RhdGVEZWYgPSB7XG4gICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgIHVybDogJ14nLFxuICAgICAgICAgICAgdmlld3M6IG51bGwsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAnIyc6IHsgdmFsdWU6IG51bGwsIHR5cGU6ICdoYXNoJywgZHluYW1pYzogdHJ1ZSB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWJzdHJhY3Q6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9yb290ID0gdGhpcy5fcm9vdCA9IHRoaXMuc3RhdGVRdWV1ZS5yZWdpc3Rlcihyb290U3RhdGVEZWYpO1xuICAgICAgICBfcm9vdC5uYXZpZ2FibGUgPSBudWxsO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RhdGVRdWV1ZS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuZ2V0KCkuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIF90aGlzLmdldChzdGF0ZSkgJiYgX3RoaXMuZGVyZWdpc3RlcihzdGF0ZSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTGlzdGVuIGZvciBhIFN0YXRlIFJlZ2lzdHJ5IGV2ZW50c1xuICAgICAqXG4gICAgICogQWRkcyBhIGNhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuIHN0YXRlcyBhcmUgcmVnaXN0ZXJlZCBvciBkZXJlZ2lzdGVyZWQgd2l0aCB0aGUgU3RhdGVSZWdpc3RyeS5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIGxldCBhbGxTdGF0ZXMgPSByZWdpc3RyeS5nZXQoKTtcbiAgICAgKlxuICAgICAqIC8vIExhdGVyLCBpbnZva2UgZGVyZWdpc3RlckZuKCkgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lclxuICAgICAqIGxldCBkZXJlZ2lzdGVyRm4gPSByZWdpc3RyeS5vblN0YXRlc0NoYW5nZWQoKGV2ZW50LCBzdGF0ZXMpID0+IHtcbiAgICAgKiAgIHN3aXRjaChldmVudCkge1xuICAgICAqICAgICBjYXNlOiAncmVnaXN0ZXJlZCc6XG4gICAgICogICAgICAgc3RhdGVzLmZvckVhY2goc3RhdGUgPT4gYWxsU3RhdGVzLnB1c2goc3RhdGUpKTtcbiAgICAgKiAgICAgICBicmVhaztcbiAgICAgKiAgICAgY2FzZTogJ2RlcmVnaXN0ZXJlZCc6XG4gICAgICogICAgICAgc3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xuICAgICAqICAgICAgICAgbGV0IGlkeCA9IGFsbFN0YXRlcy5pbmRleE9mKHN0YXRlKTtcbiAgICAgKiAgICAgICAgIGlmIChpZHggIT09IC0xKSBhbGxTdGF0ZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICogICAgICAgfSk7XG4gICAgICogICAgICAgYnJlYWs7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgYSBjYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIHdoZW4gdGhlIHJlZ2lzdGVyZWQgc3RhdGVzIGNoYW5nZXMuXG4gICAgICogICAgICAgIFRoZSBmdW5jdGlvbiByZWNlaXZlcyB0d28gcGFyYW1ldGVycywgYGV2ZW50YCBhbmQgYHN0YXRlYC5cbiAgICAgKiAgICAgICAgU2VlIFtbU3RhdGVSZWdpc3RyeUxpc3RlbmVyXV1cbiAgICAgKiBAcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBkZXJlZ2lzdGVycyB0aGUgbGlzdGVuZXJcbiAgICAgKi9cbiAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5vblN0YXRlc0NoYW5nZWQgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBkZXJlZ2lzdGVyTGlzdGVuZXIoKSB7XG4gICAgICAgICAgICBjb21tb25fMS5yZW1vdmVGcm9tKHRoaXMubGlzdGVuZXJzKShsaXN0ZW5lcik7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGltcGxpY2l0IHJvb3Qgc3RhdGVcbiAgICAgKlxuICAgICAqIEdldHMgdGhlIHJvb3Qgb2YgdGhlIHN0YXRlIHRyZWUuXG4gICAgICogVGhlIHJvb3Qgc3RhdGUgaXMgaW1wbGljaXRseSBjcmVhdGVkIGJ5IFVJLVJvdXRlci5cbiAgICAgKiBOb3RlOiB0aGlzIHJldHVybnMgdGhlIGludGVybmFsIFtbU3RhdGVPYmplY3RdXSByZXByZXNlbnRhdGlvbiwgbm90IGEgW1tTdGF0ZURlY2xhcmF0aW9uXV1cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhlIHJvb3QgW1tTdGF0ZU9iamVjdF1dXG4gICAgICovXG4gICAgU3RhdGVSZWdpc3RyeS5wcm90b3R5cGUucm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc3RhdGUgdG8gdGhlIHJlZ2lzdHJ5XG4gICAgICpcbiAgICAgKiBSZWdpc3RlcnMgYSBbW1N0YXRlRGVjbGFyYXRpb25dXSBvciBxdWV1ZXMgaXQgZm9yIHJlZ2lzdHJhdGlvbi5cbiAgICAgKlxuICAgICAqIE5vdGU6IGEgc3RhdGUgd2lsbCBiZSBxdWV1ZWQgaWYgdGhlIHN0YXRlJ3MgcGFyZW50IGlzbid0IHlldCByZWdpc3RlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlRGVmaW5pdGlvbiB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgc3RhdGUgdG8gcmVnaXN0ZXIuXG4gICAgICogQHJldHVybnMgdGhlIGludGVybmFsIFtbU3RhdGVPYmplY3RdXSBvYmplY3QuXG4gICAgICogICAgICAgICAgSWYgdGhlIHN0YXRlIHdhcyBzdWNjZXNzZnVsbHkgcmVnaXN0ZXJlZCwgdGhlbiB0aGUgb2JqZWN0IGlzIGZ1bGx5IGJ1aWx0IChTZWU6IFtbU3RhdGVCdWlsZGVyXV0pLlxuICAgICAqICAgICAgICAgIElmIHRoZSBzdGF0ZSB3YXMgb25seSBxdWV1ZWQsIHRoZW4gdGhlIG9iamVjdCBpcyBub3QgZnVsbHkgYnVpbHQuXG4gICAgICovXG4gICAgU3RhdGVSZWdpc3RyeS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoc3RhdGVEZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlUXVldWUucmVnaXN0ZXIoc3RhdGVEZWZpbml0aW9uKTtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgU3RhdGVSZWdpc3RyeS5wcm90b3R5cGUuX2RlcmVnaXN0ZXJUcmVlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhbGwgPSB0aGlzLmdldCgpLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy4kJHN0YXRlKCk7IH0pO1xuICAgICAgICB2YXIgZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAoc3RhdGVzKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBhbGwuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzdGF0ZXMuaW5kZXhPZihzLnBhcmVudCkgIT09IC0xOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbi5sZW5ndGggPT09IDAgPyBjaGlsZHJlbiA6IGNoaWxkcmVuLmNvbmNhdChnZXRDaGlsZHJlbihjaGlsZHJlbikpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbihbc3RhdGVdKTtcbiAgICAgICAgdmFyIGRlcmVnaXN0ZXJlZCA9IFtzdGF0ZV0uY29uY2F0KGNoaWxkcmVuKS5yZXZlcnNlKCk7XG4gICAgICAgIGRlcmVnaXN0ZXJlZC5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgdmFyICR1ciA9IF90aGlzLl9yb3V0ZXIudXJsUm91dGVyO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIFVSTCBydWxlXG4gICAgICAgICAgICAkdXIucnVsZXMoKS5maWx0ZXIoaG9mXzEucHJvcEVxKFwic3RhdGVcIiwgc3RhdGUpKS5mb3JFYWNoKCR1ci5yZW1vdmVSdWxlLmJpbmQoJHVyKSk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgc3RhdGUgZnJvbSByZWdpc3RyeVxuICAgICAgICAgICAgZGVsZXRlIF90aGlzLnN0YXRlc1tzdGF0ZS5uYW1lXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZXJlZ2lzdGVyZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc3RhdGUgZnJvbSB0aGUgcmVnaXN0cnlcbiAgICAgKlxuICAgICAqIFRoaXMgcmVtb3ZlcyBhIHN0YXRlIGZyb20gdGhlIHJlZ2lzdHJ5LlxuICAgICAqIElmIHRoZSBzdGF0ZSBoYXMgY2hpbGRyZW4sIHRoZXkgYXJlIGFyZSBhbHNvIHJlbW92ZWQgZnJvbSB0aGUgcmVnaXN0cnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGVPck5hbWUgdGhlIHN0YXRlJ3MgbmFtZSBvciBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAcmV0dXJucyB7U3RhdGVPYmplY3RbXX0gYSBsaXN0IG9mIHJlbW92ZWQgc3RhdGVzXG4gICAgICovXG4gICAgU3RhdGVSZWdpc3RyeS5wcm90b3R5cGUuZGVyZWdpc3RlciA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSkge1xuICAgICAgICB2YXIgX3N0YXRlID0gdGhpcy5nZXQoc3RhdGVPck5hbWUpO1xuICAgICAgICBpZiAoIV9zdGF0ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGRlcmVnaXN0ZXIgc3RhdGU7IG5vdCBmb3VuZDogXCIgKyBzdGF0ZU9yTmFtZSk7XG4gICAgICAgIHZhciBkZXJlZ2lzdGVyZWRTdGF0ZXMgPSB0aGlzLl9kZXJlZ2lzdGVyVHJlZShfc3RhdGUuJCRzdGF0ZSgpKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIGxpc3RlbmVyKFwiZGVyZWdpc3RlcmVkXCIsIGRlcmVnaXN0ZXJlZFN0YXRlcy5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuc2VsZjsgfSkpOyB9KTtcbiAgICAgICAgcmV0dXJuIGRlcmVnaXN0ZXJlZFN0YXRlcztcbiAgICB9O1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSwgYmFzZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN0YXRlcykubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5zdGF0ZXNbbmFtZV0uc2VsZjsgfSk7XG4gICAgICAgIHZhciBmb3VuZCA9IHRoaXMubWF0Y2hlci5maW5kKHN0YXRlT3JOYW1lLCBiYXNlKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kICYmIGZvdW5kLnNlbGYgfHwgbnVsbDtcbiAgICB9O1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLmRlY29yYXRvciA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkZXIuYnVpbGRlcihuYW1lLCBmdW5jKTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZVJlZ2lzdHJ5O1xufSgpKTtcbmV4cG9ydHMuU3RhdGVSZWdpc3RyeSA9IFN0YXRlUmVnaXN0cnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0ZVJlZ2lzdHJ5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZVJlZ2lzdHJ5LmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgc3RhdGVcbiAqL1xuLyoqICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgcXVldWVfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcXVldWVcIik7XG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcbnZhciBwYXRoRmFjdG9yeV8xID0gcmVxdWlyZShcIi4uL3BhdGgvcGF0aEZhY3RvcnlcIik7XG52YXIgcGF0aE5vZGVfMSA9IHJlcXVpcmUoXCIuLi9wYXRoL3BhdGhOb2RlXCIpO1xudmFyIHRyYW5zaXRpb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uU2VydmljZVwiKTtcbnZhciByZWplY3RGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi4vdHJhbnNpdGlvbi9yZWplY3RGYWN0b3J5XCIpO1xudmFyIHRhcmdldFN0YXRlXzEgPSByZXF1aXJlKFwiLi90YXJnZXRTdGF0ZVwiKTtcbnZhciBwYXJhbV8xID0gcmVxdWlyZShcIi4uL3BhcmFtcy9wYXJhbVwiKTtcbnZhciBnbG9iXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2dsb2JcIik7XG52YXIgcmVzb2x2ZUNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9yZXNvbHZlL3Jlc29sdmVDb250ZXh0XCIpO1xudmFyIGxhenlMb2FkXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvbGF6eUxvYWRcIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbi8qKlxuICogUHJvdmlkZXMgc3RhdGUgcmVsYXRlZCBzZXJ2aWNlIGZ1bmN0aW9uc1xuICpcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgc2VydmljZXMgcmVsYXRlZCB0byB1aS1yb3V0ZXIgc3RhdGVzLlxuICogQW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBpcyBsb2NhdGVkIG9uIHRoZSBnbG9iYWwgW1tVSVJvdXRlcl1dIG9iamVjdC5cbiAqL1xudmFyIFN0YXRlU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgZnVuY3Rpb24gU3RhdGVTZXJ2aWNlKHJvdXRlcikge1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgICAgICB0aGlzLmludmFsaWRDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5fZGVmYXVsdEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uICRkZWZhdWx0RXJyb3JIYW5kbGVyKCRlcnJvciQpIHtcbiAgICAgICAgICAgIGlmICgkZXJyb3IkIGluc3RhbmNlb2YgRXJyb3IgJiYgJGVycm9yJC5zdGFjaykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJGVycm9yJCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigkZXJyb3IkLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCRlcnJvciQgaW5zdGFuY2VvZiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigkZXJyb3IkLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGlmICgkZXJyb3IkLmRldGFpbCAmJiAkZXJyb3IkLmRldGFpbC5zdGFjaylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigkZXJyb3IkLmRldGFpbC5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCRlcnJvciQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0dGVycyA9IFsnY3VycmVudCcsICckY3VycmVudCcsICdwYXJhbXMnLCAndHJhbnNpdGlvbiddO1xuICAgICAgICB2YXIgYm91bmRGbnMgPSBPYmplY3Qua2V5cyhTdGF0ZVNlcnZpY2UucHJvdG90eXBlKS5maWx0ZXIoaG9mXzEubm90KGNvbW1vbl8xLmluQXJyYXkoZ2V0dGVycykpKTtcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnMoaG9mXzEudmFsKFN0YXRlU2VydmljZS5wcm90b3R5cGUpLCB0aGlzLCBob2ZfMS52YWwodGhpcyksIGJvdW5kRm5zKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlU2VydmljZS5wcm90b3R5cGUsIFwidHJhbnNpdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgW1tUcmFuc2l0aW9uXV0gY3VycmVudGx5IGluIHByb2dyZXNzIChvciBudWxsKVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIGEgcGFzc3Rocm91Z2ggdGhyb3VnaCB0byBbW1VJUm91dGVyR2xvYmFscy50cmFuc2l0aW9uXV1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yb3V0ZXIuZ2xvYmFscy50cmFuc2l0aW9uOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVTZXJ2aWNlLnByb3RvdHlwZSwgXCJwYXJhbXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxhdGVzdCBzdWNjZXNzZnVsIHN0YXRlIHBhcmFtZXRlcnNcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBhIHBhc3N0aHJvdWdoIHRocm91Z2ggdG8gW1tVSVJvdXRlckdsb2JhbHMucGFyYW1zXV1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yb3V0ZXIuZ2xvYmFscy5wYXJhbXM7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZVNlcnZpY2UucHJvdG90eXBlLCBcImN1cnJlbnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgW1tTdGF0ZURlY2xhcmF0aW9uXV1cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBhIHBhc3N0aHJvdWdoIHRocm91Z2ggdG8gW1tVSVJvdXRlckdsb2JhbHMuY3VycmVudF1dXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucm91dGVyLmdsb2JhbHMuY3VycmVudDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlU2VydmljZS5wcm90b3R5cGUsIFwiJGN1cnJlbnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgW1tTdGF0ZU9iamVjdF1dXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgYSBwYXNzdGhyb3VnaCB0aHJvdWdoIHRvIFtbVUlSb3V0ZXJHbG9iYWxzLiRjdXJyZW50XV1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yb3V0ZXIuZ2xvYmFscy4kY3VycmVudDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0RXJyb3JIYW5kbGVyKGNvbW1vbl8xLm5vb3ApO1xuICAgICAgICB0aGlzLmludmFsaWRDYWxsYmFja3MgPSBbXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yIHdoZW4gW1t0cmFuc2l0aW9uVG9dXSBpcyBjYWxsZWQgd2l0aCBhbiBpbnZhbGlkIHN0YXRlLlxuICAgICAqXG4gICAgICogSW52b2tlcyB0aGUgW1tvbkludmFsaWRdXSBjYWxsYmFja3MsIGluIG5hdHVyYWwgb3JkZXIuXG4gICAgICogRWFjaCBjYWxsYmFjaydzIHJldHVybiB2YWx1ZSBpcyBjaGVja2VkIGluIHNlcXVlbmNlIHVudGlsIG9uZSBvZiB0aGVtIHJldHVybnMgYW4gaW5zdGFuY2Ugb2YgVGFyZ2V0U3RhdGUuXG4gICAgICogVGhlIHJlc3VsdHMgb2YgdGhlIGNhbGxiYWNrcyBhcmUgd3JhcHBlZCBpbiAkcS53aGVuKCksIHNvIHRoZSBjYWxsYmFja3MgbWF5IHJldHVybiBwcm9taXNlcy5cbiAgICAgKlxuICAgICAqIElmIGEgY2FsbGJhY2sgcmV0dXJucyBhbiBUYXJnZXRTdGF0ZSwgdGhlbiBpdCBpcyB1c2VkIGFzIGFyZ3VtZW50cyB0byAkc3RhdGUudHJhbnNpdGlvblRvKCkgYW5kIHRoZSByZXN1bHQgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxhcGlcbiAgICAgKi9cbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLl9oYW5kbGVJbnZhbGlkVGFyZ2V0U3RhdGUgPSBmdW5jdGlvbiAoZnJvbVBhdGgsIHRvU3RhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZyb21TdGF0ZSA9IHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLm1ha2VUYXJnZXRTdGF0ZSh0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5LCBmcm9tUGF0aCk7XG4gICAgICAgIHZhciBnbG9iYWxzID0gdGhpcy5yb3V0ZXIuZ2xvYmFscztcbiAgICAgICAgdmFyIGxhdGVzdFRoaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2xvYmFscy50cmFuc2l0aW9uSGlzdG9yeS5wZWVrVGFpbCgpOyB9O1xuICAgICAgICB2YXIgbGF0ZXN0ID0gbGF0ZXN0VGhpbmcoKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrUXVldWUgPSBuZXcgcXVldWVfMS5RdWV1ZSh0aGlzLmludmFsaWRDYWxsYmFja3Muc2xpY2UoKSk7XG4gICAgICAgIHZhciBpbmplY3RvciA9IG5ldyByZXNvbHZlQ29udGV4dF8xLlJlc29sdmVDb250ZXh0KGZyb21QYXRoKS5pbmplY3RvcigpO1xuICAgICAgICB2YXIgY2hlY2tGb3JSZWRpcmVjdCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICghKHJlc3VsdCBpbnN0YW5jZW9mIHRhcmdldFN0YXRlXzEuVGFyZ2V0U3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHJlc3VsdDtcbiAgICAgICAgICAgIC8vIFJlY3JlYXRlIHRoZSBUYXJnZXRTdGF0ZSwgaW4gY2FzZSB0aGUgc3RhdGUgaXMgbm93IGRlZmluZWQuXG4gICAgICAgICAgICB0YXJnZXQgPSBfdGhpcy50YXJnZXQodGFyZ2V0LmlkZW50aWZpZXIoKSwgdGFyZ2V0LnBhcmFtcygpLCB0YXJnZXQub3B0aW9ucygpKTtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0LnZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5pbnZhbGlkKHRhcmdldC5lcnJvcigpKS50b1Byb21pc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXRlc3RUaGluZygpICE9PSBsYXRlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5zdXBlcnNlZGVkKCkudG9Qcm9taXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNpdGlvblRvKHRhcmdldC5pZGVudGlmaWVyKCksIHRhcmdldC5wYXJhbXMoKSwgdGFyZ2V0Lm9wdGlvbnMoKSk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGludm9rZU5leHRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHZhciBuZXh0Q2FsbGJhY2sgPSBjYWxsYmFja1F1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgICAgIGlmIChuZXh0Q2FsbGJhY2sgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5pbnZhbGlkKHRvU3RhdGUuZXJyb3IoKSkudG9Qcm9taXNlKCk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tSZXN1bHQgPSBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS53aGVuKG5leHRDYWxsYmFjayh0b1N0YXRlLCBmcm9tU3RhdGUsIGluamVjdG9yKSk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2tSZXN1bHQudGhlbihjaGVja0ZvclJlZGlyZWN0KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdCB8fCBpbnZva2VOZXh0Q2FsbGJhY2soKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludm9rZU5leHRDYWxsYmFjaygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIEludmFsaWQgU3RhdGUgaGFuZGxlclxuICAgICAqXG4gICAgICogUmVnaXN0ZXJzIGEgW1tPbkludmFsaWRDYWxsYmFja11dIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiBbW1N0YXRlU2VydmljZS50cmFuc2l0aW9uVG9dXVxuICAgICAqIGhhcyBiZWVuIGNhbGxlZCB3aXRoIGFuIGludmFsaWQgc3RhdGUgcmVmZXJlbmNlIHBhcmFtZXRlclxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIHN0YXRlU2VydmljZS5vbkludmFsaWQoZnVuY3Rpb24odG8sIGZyb20sIGluamVjdG9yKSB7XG4gICAgICogICBpZiAodG8ubmFtZSgpID09PSAnZm9vJykge1xuICAgICAqICAgICBsZXQgbGF6eUxvYWRlciA9IGluamVjdG9yLmdldCgnTGF6eUxvYWRTZXJ2aWNlJyk7XG4gICAgICogICAgIHJldHVybiBsYXp5TG9hZGVyLmxvYWQoJ2ZvbycpXG4gICAgICogICAgICAgICAudGhlbigoKSA9PiBzdGF0ZVNlcnZpY2UudGFyZ2V0KCdmb28nKSk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBpbnZva2VkIHdoZW4gdGhlIHRvU3RhdGUgaXMgaW52YWxpZFxuICAgICAqICAgVGhpcyBmdW5jdGlvbiByZWNlaXZlcyB0aGUgKGludmFsaWQpIHRvU3RhdGUsIHRoZSBmcm9tU3RhdGUsIGFuZCBhbiBpbmplY3Rvci5cbiAgICAgKiAgIFRoZSBmdW5jdGlvbiBtYXkgb3B0aW9uYWxseSByZXR1cm4gYSBbW1RhcmdldFN0YXRlXV0gb3IgYSBQcm9taXNlIGZvciBhIFRhcmdldFN0YXRlLlxuICAgICAqICAgSWYgb25lIGlzIHJldHVybmVkLCBpdCBpcyB0cmVhdGVkIGFzIGEgcmVkaXJlY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGRlcmVnaXN0ZXJzIHRoZSBjYWxsYmFja1xuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUub25JbnZhbGlkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaW52YWxpZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRlcmVnaXN0ZXJMaXN0ZW5lcigpIHtcbiAgICAgICAgICAgIGNvbW1vbl8xLnJlbW92ZUZyb20odGhpcy5pbnZhbGlkQ2FsbGJhY2tzKShjYWxsYmFjayk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbG9hZHMgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgKlxuICAgICAqIEEgbWV0aG9kIHRoYXQgZm9yY2UgcmVsb2FkcyB0aGUgY3VycmVudCBzdGF0ZSwgb3IgYSBwYXJ0aWFsIHN0YXRlIGhpZXJhcmNoeS5cbiAgICAgKiBBbGwgcmVzb2x2ZXMgYXJlIHJlLXJlc29sdmVkLCBhbmQgY29tcG9uZW50cyByZWluc3RhbnRpYXRlZC5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIGxldCBhcHAgYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyJ10pO1xuICAgICAqXG4gICAgICogYXBwLmNvbnRyb2xsZXIoJ2N0cmwnLCBmdW5jdGlvbiAoJHNjb3BlLCAkc3RhdGUpIHtcbiAgICAgKiAgICRzY29wZS5yZWxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAqICAgICAkc3RhdGUucmVsb2FkKCk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBOb3RlOiBgcmVsb2FkKClgIGlzIGp1c3QgYW4gYWxpYXMgZm9yOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiAkc3RhdGUudHJhbnNpdGlvblRvKCRzdGF0ZS5jdXJyZW50LCAkc3RhdGUucGFyYW1zLCB7XG4gICAgICogICByZWxvYWQ6IHRydWUsIGluaGVyaXQ6IGZhbHNlXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVsb2FkU3RhdGUgQSBzdGF0ZSBuYW1lIG9yIGEgc3RhdGUgb2JqZWN0LlxuICAgICAqICAgIElmIHByZXNlbnQsIHRoaXMgc3RhdGUgYW5kIGFsbCBpdHMgY2hpbGRyZW4gd2lsbCBiZSByZWxvYWRlZCwgYnV0IGFuY2VzdG9ycyB3aWxsIG5vdCByZWxvYWQuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiAvL2Fzc3VtaW5nIGFwcCBhcHBsaWNhdGlvbiBjb25zaXN0cyBvZiAzIHN0YXRlczogJ2NvbnRhY3RzJywgJ2NvbnRhY3RzLmRldGFpbCcsICdjb250YWN0cy5kZXRhaWwuaXRlbSdcbiAgICAgKiAvL2FuZCBjdXJyZW50IHN0YXRlIGlzICdjb250YWN0cy5kZXRhaWwuaXRlbSdcbiAgICAgKiBsZXQgYXBwIGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKTtcbiAgICAgKlxuICAgICAqIGFwcC5jb250cm9sbGVyKCdjdHJsJywgZnVuY3Rpb24gKCRzY29wZSwgJHN0YXRlKSB7XG4gICAgICogICAkc2NvcGUucmVsb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgKiAgICAgLy93aWxsIHJlbG9hZCAnY29udGFjdC5kZXRhaWwnIGFuZCBuZXN0ZWQgJ2NvbnRhY3QuZGV0YWlsLml0ZW0nIHN0YXRlc1xuICAgICAqICAgICAkc3RhdGUucmVsb2FkKCdjb250YWN0LmRldGFpbCcpO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2YgdGhlIG5ldyB0cmFuc2l0aW9uLiBTZWUgW1tTdGF0ZVNlcnZpY2UuZ29dXVxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUucmVsb2FkID0gZnVuY3Rpb24gKHJlbG9hZFN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyh0aGlzLmN1cnJlbnQsIHRoaXMucGFyYW1zLCB7XG4gICAgICAgICAgICByZWxvYWQ6IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQocmVsb2FkU3RhdGUpID8gcmVsb2FkU3RhdGUgOiB0cnVlLFxuICAgICAgICAgICAgaW5oZXJpdDogZmFsc2UsXG4gICAgICAgICAgICBub3RpZnk6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBUcmFuc2l0aW9uIHRvIGEgZGlmZmVyZW50IHN0YXRlIGFuZC9vciBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIHRyYW5zaXRpb25pbmcgdG8gYSBuZXcgc3RhdGUuXG4gICAgICpcbiAgICAgKiBgJHN0YXRlLmdvYCBjYWxscyBgJHN0YXRlLnRyYW5zaXRpb25Ub2AgaW50ZXJuYWxseSBidXQgYXV0b21hdGljYWxseSBzZXRzIG9wdGlvbnMgdG9cbiAgICAgKiBgeyBsb2NhdGlvbjogdHJ1ZSwgaW5oZXJpdDogdHJ1ZSwgcmVsYXRpdmU6IHJvdXRlci5nbG9iYWxzLiRjdXJyZW50LCBub3RpZnk6IHRydWUgfWAuXG4gICAgICogVGhpcyBhbGxvd3MgeW91IHRvIHVzZSBlaXRoZXIgYW4gYWJzb2x1dGUgb3IgcmVsYXRpdmUgYHRvYCBhcmd1bWVudCAoYmVjYXVzZSBvZiBgcmVsYXRpdmU6IHJvdXRlci5nbG9iYWxzLiRjdXJyZW50YCkuXG4gICAgICogSXQgYWxzbyBhbGxvd3MgeW91IHRvIHNwZWNpZnkgKiBvbmx5IHRoZSBwYXJhbWV0ZXJzIHlvdSdkIGxpa2UgdG8gdXBkYXRlLCB3aGlsZSBsZXR0aW5nIHVuc3BlY2lmaWVkIHBhcmFtZXRlcnNcbiAgICAgKiBpbmhlcml0IGZyb20gdGhlIGN1cnJlbnQgcGFyYW1ldGVyIHZhbHVlcyAoYmVjYXVzZSBvZiBgaW5oZXJpdDogdHJ1ZWApLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogbGV0IGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKTtcbiAgICAgKlxuICAgICAqIGFwcC5jb250cm9sbGVyKCdjdHJsJywgZnVuY3Rpb24gKCRzY29wZSwgJHN0YXRlKSB7XG4gICAgICogICAkc2NvcGUuY2hhbmdlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICogICAgICRzdGF0ZS5nbygnY29udGFjdC5kZXRhaWwnKTtcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG8gQWJzb2x1dGUgc3RhdGUgbmFtZSwgc3RhdGUgb2JqZWN0LCBvciByZWxhdGl2ZSBzdGF0ZSBwYXRoIChyZWxhdGl2ZSB0byBjdXJyZW50IHN0YXRlKS5cbiAgICAgKlxuICAgICAqIFNvbWUgZXhhbXBsZXM6XG4gICAgICpcbiAgICAgKiAtIGAkc3RhdGUuZ28oJ2NvbnRhY3QuZGV0YWlsJylgIC0gd2lsbCBnbyB0byB0aGUgYGNvbnRhY3QuZGV0YWlsYCBzdGF0ZVxuICAgICAqIC0gYCRzdGF0ZS5nbygnXicpYCAtIHdpbGwgZ28gdG8gdGhlIHBhcmVudCBzdGF0ZVxuICAgICAqIC0gYCRzdGF0ZS5nbygnXi5zaWJsaW5nJylgIC0gaWYgY3VycmVudCBzdGF0ZSBpcyBgaG9tZS5jaGlsZGAsIHdpbGwgZ28gdG8gdGhlIGBob21lLnNpYmxpbmdgIHN0YXRlXG4gICAgICogLSBgJHN0YXRlLmdvKCcuY2hpbGQuZ3JhbmRjaGlsZCcpYCAtIGlmIGN1cnJlbnQgc3RhdGUgaXMgaG9tZSwgd2lsbCBnbyB0byB0aGUgYGhvbWUuY2hpbGQuZ3JhbmRjaGlsZGAgc3RhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgQSBtYXAgb2YgdGhlIHBhcmFtZXRlcnMgdGhhdCB3aWxsIGJlIHNlbnQgdG8gdGhlIHN0YXRlLCB3aWxsIHBvcHVsYXRlICRzdGF0ZVBhcmFtcy5cbiAgICAgKlxuICAgICAqICAgIEFueSBwYXJhbWV0ZXJzIHRoYXQgYXJlIG5vdCBzcGVjaWZpZWQgd2lsbCBiZSBpbmhlcml0ZWQgZnJvbSBjdXJyZW50IHBhcmFtZXRlciB2YWx1ZXMgKGJlY2F1c2Ugb2YgYGluaGVyaXQ6IHRydWVgKS5cbiAgICAgKiAgICBUaGlzIGFsbG93cywgZm9yIGV4YW1wbGUsIGdvaW5nIHRvIGEgc2libGluZyBzdGF0ZSB0aGF0IHNoYXJlcyBwYXJhbWV0ZXJzIGRlZmluZWQgYnkgYSBwYXJlbnQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUcmFuc2l0aW9uIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtwcm9taXNlfSBBIHByb21pc2UgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgbmV3IHRyYW5zaXRpb24uXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uICh0bywgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdXRHb09wdHMgPSB7IHJlbGF0aXZlOiB0aGlzLiRjdXJyZW50LCBpbmhlcml0OiB0cnVlIH07XG4gICAgICAgIHZhciB0cmFuc09wdHMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRpb25zLCBkZWZhdXRHb09wdHMsIHRyYW5zaXRpb25TZXJ2aWNlXzEuZGVmYXVsdFRyYW5zT3B0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyh0bywgcGFyYW1zLCB0cmFuc09wdHMpO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBbW1RhcmdldFN0YXRlXV1cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBmYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBUYXJnZXRTdGF0ZVxuICAgICAqXG4gICAgICogVGhpcyBtYXkgYmUgcmV0dXJuZWQgZnJvbSBhIFRyYW5zaXRpb24gSG9vayB0byByZWRpcmVjdCBhIHRyYW5zaXRpb24sIGZvciBleGFtcGxlLlxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUudGFyZ2V0ID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAvLyBJZiB3ZSdyZSByZWxvYWRpbmcsIGZpbmQgdGhlIHN0YXRlIG9iamVjdCB0byByZWxvYWQgZnJvbVxuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzT2JqZWN0KG9wdGlvbnMucmVsb2FkKSAmJiAhb3B0aW9ucy5yZWxvYWQubmFtZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZWxvYWQgc3RhdGUgb2JqZWN0Jyk7XG4gICAgICAgIHZhciByZWcgPSB0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5O1xuICAgICAgICBvcHRpb25zLnJlbG9hZFN0YXRlID0gb3B0aW9ucy5yZWxvYWQgPT09IHRydWUgPyByZWcucm9vdCgpIDogcmVnLm1hdGNoZXIuZmluZChvcHRpb25zLnJlbG9hZCwgb3B0aW9ucy5yZWxhdGl2ZSk7XG4gICAgICAgIGlmIChvcHRpb25zLnJlbG9hZCAmJiAhb3B0aW9ucy5yZWxvYWRTdGF0ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN1Y2ggcmVsb2FkIHN0YXRlICdcIiArIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcob3B0aW9ucy5yZWxvYWQpID8gb3B0aW9ucy5yZWxvYWQgOiBvcHRpb25zLnJlbG9hZC5uYW1lKSArIFwiJ1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnksIGlkZW50aWZpZXIsIHBhcmFtcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICA7XG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5nZXRDdXJyZW50UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGdsb2JhbHMgPSB0aGlzLnJvdXRlci5nbG9iYWxzO1xuICAgICAgICB2YXIgbGF0ZXN0U3VjY2VzcyA9IGdsb2JhbHMuc3VjY2Vzc2Z1bFRyYW5zaXRpb25zLnBlZWtUYWlsKCk7XG4gICAgICAgIHZhciByb290UGF0aCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtuZXcgcGF0aE5vZGVfMS5QYXRoTm9kZShfdGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeS5yb290KCkpXTsgfTtcbiAgICAgICAgcmV0dXJuIGxhdGVzdFN1Y2Nlc3MgPyBsYXRlc3RTdWNjZXNzLnRyZWVDaGFuZ2VzKCkudG8gOiByb290UGF0aCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG93LWxldmVsIG1ldGhvZCBmb3IgdHJhbnNpdGlvbmluZyB0byBhIG5ldyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIFRoZSBbW2dvXV0gbWV0aG9kICh3aGljaCB1c2VzIGB0cmFuc2l0aW9uVG9gIGludGVybmFsbHkpIGlzIHJlY29tbWVuZGVkIGluIG1vc3Qgc2l0dWF0aW9ucy5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIGxldCBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSk7XG4gICAgICpcbiAgICAgKiBhcHAuY29udHJvbGxlcignY3RybCcsIGZ1bmN0aW9uICgkc2NvcGUsICRzdGF0ZSkge1xuICAgICAqICAgJHNjb3BlLmNoYW5nZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAqICAgICAkc3RhdGUudHJhbnNpdGlvblRvKCdjb250YWN0LmRldGFpbCcpO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0byBTdGF0ZSBuYW1lIG9yIHN0YXRlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gdG9QYXJhbXMgQSBtYXAgb2YgdGhlIHBhcmFtZXRlcnMgdGhhdCB3aWxsIGJlIHNlbnQgdG8gdGhlIHN0YXRlLFxuICAgICAqICAgICAgd2lsbCBwb3B1bGF0ZSAkc3RhdGVQYXJhbXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVHJhbnNpdGlvbiBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgbmV3IHRyYW5zaXRpb24uIFNlZSBbW2dvXV1cbiAgICAgKi9cbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLnRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uICh0bywgdG9QYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRvUGFyYW1zID09PSB2b2lkIDApIHsgdG9QYXJhbXMgPSB7fTsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgcm91dGVyID0gdGhpcy5yb3V0ZXI7XG4gICAgICAgIHZhciBnbG9iYWxzID0gcm91dGVyLmdsb2JhbHM7XG4gICAgICAgIG9wdGlvbnMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRpb25zLCB0cmFuc2l0aW9uU2VydmljZV8xLmRlZmF1bHRUcmFuc09wdHMpO1xuICAgICAgICB2YXIgZ2V0Q3VycmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxzLnRyYW5zaXRpb247XG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMgPSBjb21tb25fMS5leHRlbmQob3B0aW9ucywgeyBjdXJyZW50OiBnZXRDdXJyZW50IH0pO1xuICAgICAgICB2YXIgcmVmID0gdGhpcy50YXJnZXQodG8sIHRvUGFyYW1zLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIGN1cnJlbnRQYXRoID0gdGhpcy5nZXRDdXJyZW50UGF0aCgpO1xuICAgICAgICBpZiAoIXJlZi5leGlzdHMoKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVJbnZhbGlkVGFyZ2V0U3RhdGUoY3VycmVudFBhdGgsIHJlZik7XG4gICAgICAgIGlmICghcmVmLnZhbGlkKCkpXG4gICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuc2lsZW50UmVqZWN0aW9uKHJlZi5lcnJvcigpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpYWwgaGFuZGxpbmcgZm9yIElnbm9yZWQsIEFib3J0ZWQsIGFuZCBSZWRpcmVjdGVkIHRyYW5zaXRpb25zXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBzZW1hbnRpY3MgZm9yIHRoZSB0cmFuc2l0aW9uLnJ1bigpIHByb21pc2UgYW5kIHRoZSBTdGF0ZVNlcnZpY2UudHJhbnNpdGlvblRvKClcbiAgICAgICAgICogcHJvbWlzZSBkaWZmZXIuIEZvciBpbnN0YW5jZSwgdGhlIHJ1bigpIHByb21pc2UgbWF5IGJlIHJlamVjdGVkIGJlY2F1c2UgaXQgd2FzXG4gICAgICAgICAqIElHTk9SRUQsIGJ1dCB0aGUgdHJhbnNpdGlvblRvKCkgcHJvbWlzZSBpcyByZXNvbHZlZCBiZWNhdXNlIGZyb20gdGhlIHVzZXIgcGVyc3BlY3RpdmVcbiAgICAgICAgICogbm8gZXJyb3Igb2NjdXJyZWQuICBMaWtld2lzZSwgdGhlIHRyYW5zaXRpb24ucnVuKCkgcHJvbWlzZSBtYXkgYmUgcmVqZWN0ZWQgYmVjYXVzZSBvZlxuICAgICAgICAgKiBhIFJlZGlyZWN0LCBidXQgdGhlIHRyYW5zaXRpb25UbygpIHByb21pc2UgaXMgY2hhaW5lZCB0byB0aGUgbmV3IFRyYW5zaXRpb24ncyBwcm9taXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHJlamVjdGVkVHJhbnNpdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAodHJhbnNpdGlvbikgeyByZXR1cm4gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzTGF0ZXN0ID0gcm91dGVyLmdsb2JhbHMubGFzdFN0YXJ0ZWRUcmFuc2l0aW9uSWQgPT09IHRyYW5zaXRpb24uJGlkO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci50eXBlID09PSByZWplY3RGYWN0b3J5XzEuUmVqZWN0VHlwZS5JR05PUkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzTGF0ZXN0ICYmIHJvdXRlci51cmxSb3V0ZXIudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIGlnbm9yZWQgYFRyYW5zaXRpb24ucnVuKClgIGFzIGEgc3VjY2Vzc2Z1bCBgdHJhbnNpdGlvblRvYFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEud2hlbihnbG9iYWxzLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGV0YWlsID0gZXJyb3IuZGV0YWlsO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci50eXBlID09PSByZWplY3RGYWN0b3J5XzEuUmVqZWN0VHlwZS5TVVBFUlNFREVEICYmIGVycm9yLnJlZGlyZWN0ZWQgJiYgZGV0YWlsIGluc3RhbmNlb2YgdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBgVHJhbnNpdGlvbi5ydW4oKWAgd2FzIHJlZGlyZWN0ZWQsIGFsbG93IHRoZSBgdHJhbnNpdGlvblRvKClgIHByb21pc2UgdG8gcmVzb2x2ZSBzdWNjZXNzZnVsbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gYnkgcmV0dXJuaW5nIHRoZSBwcm9taXNlIGZvciB0aGUgbmV3IChyZWRpcmVjdCkgYFRyYW5zaXRpb24ucnVuKClgLlxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVkaXJlY3QgPSB0cmFuc2l0aW9uLnJlZGlyZWN0KGRldGFpbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWRpcmVjdC5ydW4oKS5jYXRjaChyZWplY3RlZFRyYW5zaXRpb25IYW5kbGVyKHJlZGlyZWN0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnJvci50eXBlID09PSByZWplY3RGYWN0b3J5XzEuUmVqZWN0VHlwZS5BQk9SVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzTGF0ZXN0ICYmIHJvdXRlci51cmxSb3V0ZXIudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSBfdGhpcy5kZWZhdWx0RXJyb3JIYW5kbGVyKCk7XG4gICAgICAgICAgICBlcnJvckhhbmRsZXIoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLnJlamVjdChlcnJvcik7XG4gICAgICAgIH07IH07XG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcy5yb3V0ZXIudHJhbnNpdGlvblNlcnZpY2UuY3JlYXRlKGN1cnJlbnRQYXRoLCByZWYpO1xuICAgICAgICB2YXIgdHJhbnNpdGlvblRvUHJvbWlzZSA9IHRyYW5zaXRpb24ucnVuKCkuY2F0Y2gocmVqZWN0ZWRUcmFuc2l0aW9uSGFuZGxlcih0cmFuc2l0aW9uKSk7XG4gICAgICAgIGNvbW1vbl8xLnNpbGVuY2VVbmNhdWdodEluUHJvbWlzZSh0cmFuc2l0aW9uVG9Qcm9taXNlKTsgLy8gaXNzdWUgIzI2NzZcbiAgICAgICAgLy8gUmV0dXJuIGEgcHJvbWlzZSBmb3IgdGhlIHRyYW5zaXRpb24sIHdoaWNoIGFsc28gaGFzIHRoZSB0cmFuc2l0aW9uIG9iamVjdCBvbiBpdC5cbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZCh0cmFuc2l0aW9uVG9Qcm9taXNlLCB7IHRyYW5zaXRpb246IHRyYW5zaXRpb24gfSk7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHN0YXRlICppcyogdGhlIHByb3ZpZGVkIHN0YXRlXG4gICAgICpcbiAgICAgKiBTaW1pbGFyIHRvIFtbaW5jbHVkZXNdXSBidXQgb25seSBjaGVja3MgZm9yIHRoZSBmdWxsIHN0YXRlIG5hbWUuXG4gICAgICogSWYgcGFyYW1zIGlzIHN1cHBsaWVkIHRoZW4gaXQgd2lsbCBiZSB0ZXN0ZWQgZm9yIHN0cmljdCBlcXVhbGl0eSBhZ2FpbnN0IHRoZSBjdXJyZW50XG4gICAgICogYWN0aXZlIHBhcmFtcyBvYmplY3QsIHNvIGFsbCBwYXJhbXMgbXVzdCBtYXRjaCB3aXRoIG5vbmUgbWlzc2luZyBhbmQgbm8gZXh0cmFzLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogJHN0YXRlLiRjdXJyZW50Lm5hbWUgPSAnY29udGFjdHMuZGV0YWlscy5pdGVtJztcbiAgICAgKlxuICAgICAqIC8vIGFic29sdXRlIG5hbWVcbiAgICAgKiAkc3RhdGUuaXMoJ2NvbnRhY3QuZGV0YWlscy5pdGVtJyk7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICRzdGF0ZS5pcyhjb250YWN0RGV0YWlsSXRlbVN0YXRlT2JqZWN0KTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAvLyByZWxhdGl2ZSBuYW1lICguIGFuZCBeKSwgdHlwaWNhbGx5IGZyb20gYSB0ZW1wbGF0ZVxuICAgICAqIC8vIEUuZy4gZnJvbSB0aGUgJ2NvbnRhY3RzLmRldGFpbHMnIHRlbXBsYXRlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgbmctY2xhc3M9XCJ7aGlnaGxpZ2h0ZWQ6ICRzdGF0ZS5pcygnLml0ZW0nKX1cIj5JdGVtPC9kaXY+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGVPck5hbWUgVGhlIHN0YXRlIG5hbWUgKGFic29sdXRlIG9yIHJlbGF0aXZlKSBvciBzdGF0ZSBvYmplY3QgeW91J2QgbGlrZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIEEgcGFyYW0gb2JqZWN0LCBlLmcuIGB7c2VjdGlvbklkOiBzZWN0aW9uLmlkfWAsIHRoYXQgeW91J2QgbGlrZVxuICAgICAqIHRvIHRlc3QgYWdhaW5zdCB0aGUgY3VycmVudCBhY3RpdmUgc3RhdGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQW4gb3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcbiAgICAgKiAgIC0gYHJlbGF0aXZlYDogSWYgYHN0YXRlT3JOYW1lYCBpcyBhIHJlbGF0aXZlIHN0YXRlIG5hbWUgYW5kIGBvcHRpb25zLnJlbGF0aXZlYCBpcyBzZXQsIC5pcyB3aWxsXG4gICAgICogICAgIHRlc3QgcmVsYXRpdmUgdG8gYG9wdGlvbnMucmVsYXRpdmVgIHN0YXRlIChvciBuYW1lKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiBpdCBpcyB0aGUgc3RhdGUuXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRpb25zLCB7IHJlbGF0aXZlOiB0aGlzLiRjdXJyZW50IH0pO1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5Lm1hdGNoZXIuZmluZChzdGF0ZU9yTmFtZSwgb3B0aW9ucy5yZWxhdGl2ZSk7XG4gICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzRGVmaW5lZChzdGF0ZSkpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy4kY3VycmVudCAhPT0gc3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghcGFyYW1zKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHZhciBzY2hlbWEgPSBzdGF0ZS5wYXJhbWV0ZXJzKHsgaW5oZXJpdDogdHJ1ZSwgbWF0Y2hpbmdLZXlzOiBwYXJhbXMgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbV8xLlBhcmFtLmVxdWFscyhzY2hlbWEsIHBhcmFtXzEuUGFyYW0udmFsdWVzKHNjaGVtYSwgcGFyYW1zKSwgdGhpcy5wYXJhbXMpO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBzdGF0ZSAqaW5jbHVkZXMqIHRoZSBwcm92aWRlZCBzdGF0ZVxuICAgICAqXG4gICAgICogQSBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZSBpcyBlcXVhbCB0byBvciBpcyB0aGUgY2hpbGQgb2YgdGhlXG4gICAgICogc3RhdGUgc3RhdGVOYW1lLiBJZiBhbnkgcGFyYW1zIGFyZSBwYXNzZWQgdGhlbiB0aGV5IHdpbGwgYmUgdGVzdGVkIGZvciBhIG1hdGNoIGFzIHdlbGwuXG4gICAgICogTm90IGFsbCB0aGUgcGFyYW1ldGVycyBuZWVkIHRvIGJlIHBhc3NlZCwganVzdCB0aGUgb25lcyB5b3UnZCBsaWtlIHRvIHRlc3QgZm9yIGVxdWFsaXR5LlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlIHdoZW4gYCRzdGF0ZS4kY3VycmVudC5uYW1lID09PSAnY29udGFjdHMuZGV0YWlscy5pdGVtJ2BcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vIFVzaW5nIHBhcnRpYWwgbmFtZXNcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJjb250YWN0c1wiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiY29udGFjdHMuZGV0YWlsc1wiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiY29udGFjdHMuZGV0YWlscy5pdGVtXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJjb250YWN0cy5saXN0XCIpOyAvLyByZXR1cm5zIGZhbHNlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiYWJvdXRcIik7IC8vIHJldHVybnMgZmFsc2VcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyMgR2xvYiBFeGFtcGxlcyB3aGVuIGAqICRzdGF0ZS4kY3VycmVudC5uYW1lID09PSAnY29udGFjdHMuZGV0YWlscy5pdGVtLnVybCdgOlxuICAgICAqIGBgYGpzXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLiouKlwiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLioqXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqKi5pdGVtLioqXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqLmRldGFpbHMuaXRlbS51cmxcIik7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcIiouZGV0YWlscy4qLnVybFwiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLipcIik7IC8vIHJldHVybnMgZmFsc2VcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJpdGVtLioqXCIpOyAvLyByZXR1cm5zIGZhbHNlXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGVPck5hbWUgQSBwYXJ0aWFsIG5hbWUsIHJlbGF0aXZlIG5hbWUsIGdsb2IgcGF0dGVybixcbiAgICAgKiAgIG9yIHN0YXRlIG9iamVjdCB0byBiZSBzZWFyY2hlZCBmb3Igd2l0aGluIHRoZSBjdXJyZW50IHN0YXRlIG5hbWUuXG4gICAgICogQHBhcmFtIHBhcmFtcyBBIHBhcmFtIG9iamVjdCwgZS5nLiBge3NlY3Rpb25JZDogc2VjdGlvbi5pZH1gLFxuICAgICAqICAgdGhhdCB5b3UnZCBsaWtlIHRvIHRlc3QgYWdhaW5zdCB0aGUgY3VycmVudCBhY3RpdmUgc3RhdGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQW4gb3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcbiAgICAgKiAgIC0gYHJlbGF0aXZlYDogSWYgYHN0YXRlT3JOYW1lYCBpcyBhIHJlbGF0aXZlIHN0YXRlIG5hbWUgYW5kIGBvcHRpb25zLnJlbGF0aXZlYCBpcyBzZXQsIC5pcyB3aWxsXG4gICAgICogICAgIHRlc3QgcmVsYXRpdmUgdG8gYG9wdGlvbnMucmVsYXRpdmVgIHN0YXRlIChvciBuYW1lKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgaXQgZG9lcyBpbmNsdWRlIHRoZSBzdGF0ZVxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gY29tbW9uXzEuZGVmYXVsdHMob3B0aW9ucywgeyByZWxhdGl2ZTogdGhpcy4kY3VycmVudCB9KTtcbiAgICAgICAgdmFyIGdsb2IgPSBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc3RhdGVPck5hbWUpICYmIGdsb2JfMS5HbG9iLmZyb21TdHJpbmcoc3RhdGVPck5hbWUpO1xuICAgICAgICBpZiAoZ2xvYikge1xuICAgICAgICAgICAgaWYgKCFnbG9iLm1hdGNoZXModGhpcy4kY3VycmVudC5uYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBzdGF0ZU9yTmFtZSA9IHRoaXMuJGN1cnJlbnQubmFtZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5Lm1hdGNoZXIuZmluZChzdGF0ZU9yTmFtZSwgb3B0aW9ucy5yZWxhdGl2ZSksIGluY2x1ZGUgPSB0aGlzLiRjdXJyZW50LmluY2x1ZGVzO1xuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoc3RhdGUpKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGluY2x1ZGVbc3RhdGUubmFtZV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgc2NoZW1hID0gc3RhdGUucGFyYW1ldGVycyh7IGluaGVyaXQ6IHRydWUsIG1hdGNoaW5nS2V5czogcGFyYW1zIH0pO1xuICAgICAgICByZXR1cm4gcGFyYW1fMS5QYXJhbS5lcXVhbHMoc2NoZW1hLCBwYXJhbV8xLlBhcmFtLnZhbHVlcyhzY2hlbWEsIHBhcmFtcyksIHRoaXMucGFyYW1zKTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBVUkwgZm9yIGEgc3RhdGUgYW5kIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIFJldHVybnMgdGhlIHVybCBmb3IgdGhlIGdpdmVuIHN0YXRlIHBvcHVsYXRlZCB3aXRoIHRoZSBnaXZlbiBwYXJhbXMuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBleHBlY3QoJHN0YXRlLmhyZWYoXCJhYm91dC5wZXJzb25cIiwgeyBwZXJzb246IFwiYm9iXCIgfSkpLnRvRXF1YWwoXCIvYWJvdXQvYm9iXCIpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlT3JOYW1lIFRoZSBzdGF0ZSBuYW1lIG9yIHN0YXRlIG9iamVjdCB5b3UnZCBsaWtlIHRvIGdlbmVyYXRlIGEgdXJsIGZyb20uXG4gICAgICogQHBhcmFtIHBhcmFtcyBBbiBvYmplY3Qgb2YgcGFyYW1ldGVyIHZhbHVlcyB0byBmaWxsIHRoZSBzdGF0ZSdzIHJlcXVpcmVkIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGNvbXBpbGVkIHN0YXRlIHVybFxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUuaHJlZiA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdWx0SHJlZk9wdHMgPSB7XG4gICAgICAgICAgICBsb3NzeTogdHJ1ZSxcbiAgICAgICAgICAgIGluaGVyaXQ6IHRydWUsXG4gICAgICAgICAgICBhYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgICByZWxhdGl2ZTogdGhpcy4kY3VycmVudCxcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucyA9IGNvbW1vbl8xLmRlZmF1bHRzKG9wdGlvbnMsIGRlZmF1bHRIcmVmT3B0cyk7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeS5tYXRjaGVyLmZpbmQoc3RhdGVPck5hbWUsIG9wdGlvbnMucmVsYXRpdmUpO1xuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoc3RhdGUpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChvcHRpb25zLmluaGVyaXQpXG4gICAgICAgICAgICBwYXJhbXMgPSB0aGlzLnBhcmFtcy4kaW5oZXJpdChwYXJhbXMsIHRoaXMuJGN1cnJlbnQsIHN0YXRlKTtcbiAgICAgICAgdmFyIG5hdiA9IChzdGF0ZSAmJiBvcHRpb25zLmxvc3N5KSA/IHN0YXRlLm5hdmlnYWJsZSA6IHN0YXRlO1xuICAgICAgICBpZiAoIW5hdiB8fCBuYXYudXJsID09PSB1bmRlZmluZWQgfHwgbmF2LnVybCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucm91dGVyLnVybFJvdXRlci5ocmVmKG5hdi51cmwsIHBhcmFtcywge1xuICAgICAgICAgICAgYWJzb2x1dGU6IG9wdGlvbnMuYWJzb2x1dGUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgZGVmYXVsdCBbW3RyYW5zaXRpb25Ub11dIGVycm9yIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBUaGUgZXJyb3IgaGFuZGxlciBpcyBjYWxsZWQgd2hlbiBhIFtbVHJhbnNpdGlvbl1dIGlzIHJlamVjdGVkIG9yIHdoZW4gYW55IGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgVHJhbnNpdGlvbi5cbiAgICAgKiBUaGlzIGluY2x1ZGVzIGVycm9ycyBjYXVzZWQgYnkgcmVzb2x2ZXMgYW5kIHRyYW5zaXRpb24gaG9va3MuXG4gICAgICpcbiAgICAgKiBOb3RlOlxuICAgICAqIFRoaXMgaGFuZGxlciBkb2VzIG5vdCByZWNlaXZlIGNlcnRhaW4gVHJhbnNpdGlvbiByZWplY3Rpb25zLlxuICAgICAqIFJlZGlyZWN0ZWQgYW5kIElnbm9yZWQgVHJhbnNpdGlvbnMgYXJlIG5vdCBjb25zaWRlcmVkIHRvIGJlIGVycm9ycyBieSBbW1N0YXRlU2VydmljZS50cmFuc2l0aW9uVG9dXS5cbiAgICAgKlxuICAgICAqIFRoZSBidWlsdC1pbiBkZWZhdWx0IGVycm9yIGhhbmRsZXIgbG9ncyB0aGUgZXJyb3IgdG8gdGhlIGNvbnNvbGUuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHByb3ZpZGUgeW91ciBvd24gY3VzdG9tIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBzdGF0ZVNlcnZpY2UuZGVmYXVsdEVycm9ySGFuZGxlcihmdW5jdGlvbigpIHtcbiAgICAgKiAgIC8vIERvIG5vdCBsb2cgdHJhbnNpdGlvblRvIGVycm9yc1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGhhbmRsZXIgYSBnbG9iYWwgZXJyb3IgaGFuZGxlciBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IGdsb2JhbCBlcnJvciBoYW5kbGVyXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5kZWZhdWx0RXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRFcnJvckhhbmRsZXIgPSBoYW5kbGVyIHx8IHRoaXMuX2RlZmF1bHRFcnJvckhhbmRsZXI7XG4gICAgfTtcbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSwgYmFzZSkge1xuICAgICAgICB2YXIgcmVnID0gdGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gcmVnLmdldCgpO1xuICAgICAgICByZXR1cm4gcmVnLmdldChzdGF0ZU9yTmFtZSwgYmFzZSB8fCB0aGlzLiRjdXJyZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExhenkgbG9hZHMgYSBzdGF0ZVxuICAgICAqXG4gICAgICogRXhwbGljaXRseSBydW5zIGEgc3RhdGUncyBbW1N0YXRlRGVjbGFyYXRpb24ubGF6eUxvYWRdXSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZU9yTmFtZSB0aGUgc3RhdGUgdGhhdCBzaG91bGQgYmUgbGF6eSBsb2FkZWRcbiAgICAgKiBAcGFyYW0gdHJhbnNpdGlvbiB0aGUgb3B0aW9uYWwgVHJhbnNpdGlvbiBjb250ZXh0IHRvIHVzZSAoaWYgdGhlIGxhenlMb2FkIGZ1bmN0aW9uIHJlcXVpcmVzIGFuIGluamVjdG9yLCBldGMpXG4gICAgICogTm90ZTogSWYgbm8gdHJhbnNpdGlvbiBpcyBwcm92aWRlZCwgYSBub29wIHRyYW5zaXRpb24gaXMgY3JlYXRlZCB1c2luZyB0aGUgZnJvbSB0aGUgY3VycmVudCBzdGF0ZSB0byB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgKiBUaGlzIG5vb3AgdHJhbnNpdGlvbiBpcyBub3QgYWN0dWFsbHkgcnVuLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBwcm9taXNlIHRvIGxhenkgbG9hZFxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUubGF6eUxvYWQgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUsIHRyYW5zaXRpb24pIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXQoc3RhdGVPck5hbWUpO1xuICAgICAgICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5sYXp5TG9hZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgbGF6eSBsb2FkIFwiICsgc3RhdGVPck5hbWUpO1xuICAgICAgICB2YXIgY3VycmVudFBhdGggPSB0aGlzLmdldEN1cnJlbnRQYXRoKCk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBwYXRoRmFjdG9yeV8xLlBhdGhVdGlscy5tYWtlVGFyZ2V0U3RhdGUodGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeSwgY3VycmVudFBhdGgpO1xuICAgICAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbiB8fCB0aGlzLnJvdXRlci50cmFuc2l0aW9uU2VydmljZS5jcmVhdGUoY3VycmVudFBhdGgsIHRhcmdldCk7XG4gICAgICAgIHJldHVybiBsYXp5TG9hZF8xLmxhenlMb2FkU3RhdGUodHJhbnNpdGlvbiwgc3RhdGUpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLlN0YXRlU2VydmljZSA9IFN0YXRlU2VydmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlU2VydmljZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvc3RhdGUvc3RhdGVTZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgY29yZVxuICovIC8qKiAqL1xudmFyIHVybE1hdGNoZXJGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi91cmwvdXJsTWF0Y2hlckZhY3RvcnlcIik7XG52YXIgdXJsUm91dGVyXzEgPSByZXF1aXJlKFwiLi91cmwvdXJsUm91dGVyXCIpO1xudmFyIHRyYW5zaXRpb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi90cmFuc2l0aW9uL3RyYW5zaXRpb25TZXJ2aWNlXCIpO1xudmFyIHZpZXdfMSA9IHJlcXVpcmUoXCIuL3ZpZXcvdmlld1wiKTtcbnZhciBzdGF0ZVJlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi9zdGF0ZS9zdGF0ZVJlZ2lzdHJ5XCIpO1xudmFyIHN0YXRlU2VydmljZV8xID0gcmVxdWlyZShcIi4vc3RhdGUvc3RhdGVTZXJ2aWNlXCIpO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIHVybFNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3VybC91cmxTZXJ2aWNlXCIpO1xudmFyIHRyYWNlXzEgPSByZXF1aXJlKFwiLi9jb21tb24vdHJhY2VcIik7XG4vKiogQGhpZGRlbiAqL1xudmFyIF9yb3V0ZXJJbnN0YW5jZSA9IDA7XG4vKipcbiAqIFRoZSBtYXN0ZXIgY2xhc3MgdXNlZCB0byBpbnN0YW50aWF0ZSBhbiBpbnN0YW5jZSBvZiBVSS1Sb3V0ZXIuXG4gKlxuICogVUktUm91dGVyIChmb3IgZWFjaCBzcGVjaWZpYyBmcmFtZXdvcmspIHdpbGwgY3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZHVyaW5nIGJvb3RzdHJhcC5cbiAqIFRoaXMgY2xhc3MgaW5zdGFudGlhdGVzIGFuZCB3aXJlcyB0aGUgVUktUm91dGVyIHNlcnZpY2VzIHRvZ2V0aGVyLlxuICpcbiAqIEFmdGVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBVSVJvdXRlciBjbGFzcyBpcyBjcmVhdGVkLCBpdCBzaG91bGQgYmUgY29uZmlndXJlZCBmb3IgeW91ciBhcHAuXG4gKiBGb3IgaW5zdGFuY2UsIGFwcCBzdGF0ZXMgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUgW1tVSVJvdXRlci5zdGF0ZVJlZ2lzdHJ5XV0uXG4gKlxuICogLS0tXG4gKlxuICogTm9ybWFsbHkgdGhlIGZyYW1ld29yayBjb2RlIHdpbGwgYm9vdHN0cmFwIFVJLVJvdXRlci5cbiAqIElmIHlvdSBhcmUgYm9vdHN0cmFwcGluZyBVSVJvdXRlciBtYW51YWxseSwgdGVsbCBpdCB0byBtb25pdG9yIHRoZSBVUkwgYnkgY2FsbGluZ1xuICogW1tVcmxTZXJ2aWNlLmxpc3Rlbl1dIHRoZW4gW1tVcmxTZXJ2aWNlLnN5bmNdXS5cbiAqL1xudmFyIFVJUm91dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYFVJUm91dGVyYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhdGlvblNlcnZpY2UgYSBbW0xvY2F0aW9uU2VydmljZXNdXSBpbXBsZW1lbnRhdGlvblxuICAgICAqIEBwYXJhbSBsb2NhdGlvbkNvbmZpZyBhIFtbTG9jYXRpb25Db25maWddXSBpbXBsZW1lbnRhdGlvblxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVJUm91dGVyKGxvY2F0aW9uU2VydmljZSwgbG9jYXRpb25Db25maWcpIHtcbiAgICAgICAgaWYgKGxvY2F0aW9uU2VydmljZSA9PT0gdm9pZCAwKSB7IGxvY2F0aW9uU2VydmljZSA9IHVybFNlcnZpY2VfMS5VcmxTZXJ2aWNlLmxvY2F0aW9uU2VydmljZVN0dWI7IH1cbiAgICAgICAgaWYgKGxvY2F0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgbG9jYXRpb25Db25maWcgPSB1cmxTZXJ2aWNlXzEuVXJsU2VydmljZS5sb2NhdGlvbkNvbmZpZ1N0dWI7IH1cbiAgICAgICAgdGhpcy5sb2NhdGlvblNlcnZpY2UgPSBsb2NhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubG9jYXRpb25Db25maWcgPSBsb2NhdGlvbkNvbmZpZztcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy4kaWQgPSBfcm91dGVySW5zdGFuY2UrKztcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5fZGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5fZGlzcG9zYWJsZXMgPSBbXTtcbiAgICAgICAgLyoqIFByb3ZpZGVzIHRyYWNlIGluZm9ybWF0aW9uIHRvIHRoZSBjb25zb2xlICovXG4gICAgICAgIHRoaXMudHJhY2UgPSB0cmFjZV8xLnRyYWNlO1xuICAgICAgICAvKiogUHJvdmlkZXMgc2VydmljZXMgcmVsYXRlZCB0byB1aS12aWV3IHN5bmNocm9uaXphdGlvbiAqL1xuICAgICAgICB0aGlzLnZpZXdTZXJ2aWNlID0gbmV3IHZpZXdfMS5WaWV3U2VydmljZSgpO1xuICAgICAgICAvKiogUHJvdmlkZXMgc2VydmljZXMgcmVsYXRlZCB0byBUcmFuc2l0aW9ucyAqL1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25TZXJ2aWNlID0gbmV3IHRyYW5zaXRpb25TZXJ2aWNlXzEuVHJhbnNpdGlvblNlcnZpY2UodGhpcyk7XG4gICAgICAgIC8qKiBHbG9iYWwgcm91dGVyIHN0YXRlICovXG4gICAgICAgIHRoaXMuZ2xvYmFscyA9IG5ldyBnbG9iYWxzXzEuVUlSb3V0ZXJHbG9iYWxzKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXByZWNhdGVkIGZvciBwdWJsaWMgdXNlLiBVc2UgW1t1cmxTZXJ2aWNlXV0gaW5zdGVhZC5cbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIFtbdXJsU2VydmljZV1dIGluc3RlYWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXJsTWF0Y2hlckZhY3RvcnkgPSBuZXcgdXJsTWF0Y2hlckZhY3RvcnlfMS5VcmxNYXRjaGVyRmFjdG9yeSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVwcmVjYXRlZCBmb3IgcHVibGljIHVzZS4gVXNlIFtbdXJsU2VydmljZV1dIGluc3RlYWQuXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBbW3VybFNlcnZpY2VdXSBpbnN0ZWFkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVybFJvdXRlciA9IG5ldyB1cmxSb3V0ZXJfMS5VcmxSb3V0ZXIodGhpcyk7XG4gICAgICAgIC8qKiBQcm92aWRlcyBhIHJlZ2lzdHJ5IGZvciBzdGF0ZXMsIGFuZCByZWxhdGVkIHJlZ2lzdHJhdGlvbiBzZXJ2aWNlcyAqL1xuICAgICAgICB0aGlzLnN0YXRlUmVnaXN0cnkgPSBuZXcgc3RhdGVSZWdpc3RyeV8xLlN0YXRlUmVnaXN0cnkodGhpcyk7XG4gICAgICAgIC8qKiBQcm92aWRlcyBzZXJ2aWNlcyByZWxhdGVkIHRvIHN0YXRlcyAqL1xuICAgICAgICB0aGlzLnN0YXRlU2VydmljZSA9IG5ldyBzdGF0ZVNlcnZpY2VfMS5TdGF0ZVNlcnZpY2UodGhpcyk7XG4gICAgICAgIC8qKiBQcm92aWRlcyBzZXJ2aWNlcyByZWxhdGVkIHRvIHRoZSBVUkwgKi9cbiAgICAgICAgdGhpcy51cmxTZXJ2aWNlID0gbmV3IHVybFNlcnZpY2VfMS5VcmxTZXJ2aWNlKHRoaXMpO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9wbHVnaW5zID0ge307XG4gICAgICAgIHRoaXMudmlld1NlcnZpY2UuX3BsdWdpbmFwaS5fcm9vdFZpZXdDb250ZXh0KHRoaXMuc3RhdGVSZWdpc3RyeS5yb290KCkpO1xuICAgICAgICB0aGlzLmdsb2JhbHMuJGN1cnJlbnQgPSB0aGlzLnN0YXRlUmVnaXN0cnkucm9vdCgpO1xuICAgICAgICB0aGlzLmdsb2JhbHMuY3VycmVudCA9IHRoaXMuZ2xvYmFscy4kY3VycmVudC5zZWxmO1xuICAgICAgICB0aGlzLmRpc3Bvc2FibGUodGhpcy5nbG9iYWxzKTtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlKHRoaXMuc3RhdGVTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlKHRoaXMuc3RhdGVSZWdpc3RyeSk7XG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZSh0aGlzLnRyYW5zaXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlKHRoaXMudXJsUm91dGVyKTtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlKGxvY2F0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZShsb2NhdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIC8qKiBSZWdpc3RlcnMgYW4gb2JqZWN0IHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHJvdXRlciBpcyBkaXNwb3NlZCAqL1xuICAgIFVJUm91dGVyLnByb3RvdHlwZS5kaXNwb3NhYmxlID0gZnVuY3Rpb24gKGRpc3Bvc2FibGUpIHtcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZXMucHVzaChkaXNwb3NhYmxlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIHRoaXMgcm91dGVyIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBXaGVuIGNhbGxlZCwgY2xlYXJzIHJlc291cmNlcyByZXRhaW5lZCBieSB0aGUgcm91dGVyIGJ5IGNhbGxpbmcgYGRpc3Bvc2UodGhpcylgIG9uIGFsbFxuICAgICAqIHJlZ2lzdGVyZWQgW1tkaXNwb3NhYmxlXV0gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIE9yLCBpZiBhIGBkaXNwb3NhYmxlYCBvYmplY3QgaXMgcHJvdmlkZWQsIGNhbGxzIGBkaXNwb3NlKHRoaXMpYCBvbiB0aGF0IG9iamVjdCBvbmx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRpc3Bvc2FibGUgKG9wdGlvbmFsKSB0aGUgZGlzcG9zYWJsZSB0byBkaXNwb3NlXG4gICAgICovXG4gICAgVUlSb3V0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoZGlzcG9zYWJsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZGlzcG9zYWJsZSAmJiBwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihkaXNwb3NhYmxlLmRpc3Bvc2UpKSB7XG4gICAgICAgICAgICBkaXNwb3NhYmxlLmRpc3Bvc2UodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZXMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHR5cGVvZiBkLmRpc3Bvc2UgPT09ICdmdW5jdGlvbicgJiYgZC5kaXNwb3NlKF90aGlzKTtcbiAgICAgICAgICAgICAgICBjb21tb25fMS5yZW1vdmVGcm9tKF90aGlzLl9kaXNwb3NhYmxlcywgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWdub3JlZCkgeyB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHBsdWdpbiB0byBVSS1Sb3V0ZXJcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFkZHMgYSBVSS1Sb3V0ZXIgUGx1Z2luLlxuICAgICAqIEEgcGx1Z2luIGNhbiBlbmhhbmNlIG9yIGNoYW5nZSBVSS1Sb3V0ZXIgYmVoYXZpb3IgdXNpbmcgYW55IHB1YmxpYyBBUEkuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQgeyBNeUNvb2xQbHVnaW4gfSBmcm9tIFwidWktcm91dGVyLWNvb2wtcGx1Z2luXCI7XG4gICAgICpcbiAgICAgKiB2YXIgcGx1Z2luID0gcm91dGVyLmFkZFBsdWdpbihNeUNvb2xQbHVnaW4pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIFBsdWdpbiBhdXRob3JpbmdcbiAgICAgKlxuICAgICAqIEEgcGx1Z2luIGlzIHNpbXBseSBhIGNsYXNzIChvciBjb25zdHJ1Y3RvciBmdW5jdGlvbikgd2hpY2ggYWNjZXB0cyBhIFtbVUlSb3V0ZXJdXSBpbnN0YW5jZSBhbmQgKG9wdGlvbmFsbHkpIGFuIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhlIHBsdWdpbiBjYW4gaW1wbGVtZW50IGl0cyBmdW5jdGlvbmFsaXR5IHVzaW5nIGFueSBvZiB0aGUgcHVibGljIEFQSXMgb2YgW1tVSVJvdXRlcl1dLlxuICAgICAqIEZvciBleGFtcGxlLCBpdCBtYXkgY29uZmlndXJlIHJvdXRlciBvcHRpb25zIG9yIGFkZCBhIFRyYW5zaXRpb24gSG9vay5cbiAgICAgKlxuICAgICAqIFRoZSBwbHVnaW4gY2FuIHRoZW4gYmUgcHVibGlzaGVkIGFzIGEgc2VwYXJhdGUgbW9kdWxlLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogZXhwb3J0IGNsYXNzIE15QXV0aFBsdWdpbiBpbXBsZW1lbnRzIFVJUm91dGVyUGx1Z2luIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHJvdXRlcjogVUlSb3V0ZXIsIG9wdGlvbnM6IGFueSkge1xuICAgICAqICAgICB0aGlzLm5hbWUgPSBcIk15QXV0aFBsdWdpblwiO1xuICAgICAqICAgICBsZXQgJHRyYW5zaXRpb25zID0gcm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlO1xuICAgICAqICAgICBsZXQgJHN0YXRlID0gcm91dGVyLnN0YXRlU2VydmljZTtcbiAgICAgKlxuICAgICAqICAgICBsZXQgYXV0aENyaXRlcmlhID0ge1xuICAgICAqICAgICAgIHRvOiAoc3RhdGUpID0+IHN0YXRlLmRhdGEgJiYgc3RhdGUuZGF0YS5yZXF1aXJlc0F1dGhcbiAgICAgKiAgICAgfTtcbiAgICAgKlxuICAgICAqICAgICBmdW5jdGlvbiBhdXRoSG9vayh0cmFuc2l0aW9uOiBUcmFuc2l0aW9uKSB7XG4gICAgICogICAgICAgbGV0IGF1dGhTZXJ2aWNlID0gdHJhbnNpdGlvbi5pbmplY3RvcigpLmdldCgnQXV0aFNlcnZpY2UnKTtcbiAgICAgKiAgICAgICBpZiAoIWF1dGhTZXJ2aWNlLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICogICAgICAgICByZXR1cm4gJHN0YXRlLnRhcmdldCgnbG9naW4nKTtcbiAgICAgKiAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqICAgICAkdHJhbnNpdGlvbnMub25TdGFydChhdXRoQ3JpdGVyaWEsIGF1dGhIb29rKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGx1Z2luIG9uZSBvZjpcbiAgICAgKiAgICAgICAgLSBhIHBsdWdpbiBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIFtbVUlSb3V0ZXJQbHVnaW5dXVxuICAgICAqICAgICAgICAtIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIGEgW1tVSVJvdXRlclBsdWdpbl1dIHdoaWNoIGFjY2VwdHMgYSBbW1VJUm91dGVyXV0gaW5zdGFuY2VcbiAgICAgKiAgICAgICAgLSBhIGZhY3RvcnkgZnVuY3Rpb24gd2hpY2ggYWNjZXB0cyBhIFtbVUlSb3V0ZXJdXSBpbnN0YW5jZSBhbmQgcmV0dXJucyBhIFtbVUlSb3V0ZXJQbHVnaW5dXSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgcGx1Z2luIGNsYXNzL2ZhY3RvcnlcbiAgICAgKiBAcmV0dXJucyB0aGUgcmVnaXN0ZXJlZCBwbHVnaW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBVSVJvdXRlci5wcm90b3R5cGUucGx1Z2luID0gZnVuY3Rpb24gKHBsdWdpbiwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgcGx1Z2luSW5zdGFuY2UgPSBuZXcgcGx1Z2luKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXBsdWdpbkluc3RhbmNlLm5hbWUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXF1aXJlZCBwcm9wZXJ0eSBgbmFtZWAgbWlzc2luZyBvbiBwbHVnaW46IFwiICsgcGx1Z2luSW5zdGFuY2UpO1xuICAgICAgICB0aGlzLl9kaXNwb3NhYmxlcy5wdXNoKHBsdWdpbkluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BsdWdpbnNbcGx1Z2luSW5zdGFuY2UubmFtZV0gPSBwbHVnaW5JbnN0YW5jZTtcbiAgICB9O1xuICAgIFVJUm91dGVyLnByb3RvdHlwZS5nZXRQbHVnaW4gPSBmdW5jdGlvbiAocGx1Z2luTmFtZSkge1xuICAgICAgICByZXR1cm4gcGx1Z2luTmFtZSA/IHRoaXMuX3BsdWdpbnNbcGx1Z2luTmFtZV0gOiBjb21tb25fMS52YWx1ZXModGhpcy5fcGx1Z2lucyk7XG4gICAgfTtcbiAgICByZXR1cm4gVUlSb3V0ZXI7XG59KCkpO1xuZXhwb3J0cy5VSVJvdXRlciA9IFVJUm91dGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9yb3V0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBtb2R1bGUgdXJsXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgdXJsTWF0Y2hlcl8xID0gcmVxdWlyZShcIi4vdXJsTWF0Y2hlclwiKTtcbnZhciBwYXJhbV8xID0gcmVxdWlyZShcIi4uL3BhcmFtcy9wYXJhbVwiKTtcbnZhciBwYXJhbVR5cGVzXzEgPSByZXF1aXJlKFwiLi4vcGFyYW1zL3BhcmFtVHlwZXNcIik7XG4vKipcbiAqIEZhY3RvcnkgZm9yIFtbVXJsTWF0Y2hlcl1dIGluc3RhbmNlcy5cbiAqXG4gKiBUaGUgZmFjdG9yeSBpcyBhdmFpbGFibGUgdG8gbmcxIHNlcnZpY2VzIGFzXG4gKiBgJHVybE1hdGNoZXJGYWN0b3J5YCBvciBuZzEgcHJvdmlkZXJzIGFzIGAkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlcmAuXG4gKi9cbnZhciBVcmxNYXRjaGVyRmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVcmxNYXRjaGVyRmFjdG9yeSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5wYXJhbVR5cGVzID0gbmV3IHBhcmFtVHlwZXNfMS5QYXJhbVR5cGVzKCk7XG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuX2lzQ2FzZUluc2Vuc2l0aXZlID0gZmFsc2U7XG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuX2lzU3RyaWN0TW9kZSA9IHRydWU7XG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuX2RlZmF1bHRTcXVhc2hQb2xpY3kgPSBmYWxzZTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZCh7IHN0cmljdDogX3RoaXMuX2lzU3RyaWN0TW9kZSwgY2FzZUluc2Vuc2l0aXZlOiBfdGhpcy5faXNDYXNlSW5zZW5zaXRpdmUgfSwgY29uZmlnKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbGFwaSBDcmVhdGVzIGEgbmV3IFtbUGFyYW1dXSBmb3IgYSBnaXZlbiBsb2NhdGlvbiAoRGVmVHlwZSkgKi9cbiAgICAgICAgdGhpcy5wYXJhbUZhY3RvcnkgPSB7XG4gICAgICAgICAgICAvKiogQ3JlYXRlcyBhIG5ldyBbW1BhcmFtXV0gZnJvbSBhIENPTkZJRyBibG9jayAqL1xuICAgICAgICAgICAgZnJvbUNvbmZpZzogZnVuY3Rpb24gKGlkLCB0eXBlLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHBhcmFtXzEuUGFyYW0oaWQsIHR5cGUsIGNvbmZpZywgcGFyYW1fMS5EZWZUeXBlLkNPTkZJRywgX3RoaXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKiBDcmVhdGVzIGEgbmV3IFtbUGFyYW1dXSBmcm9tIGEgdXJsIFBBVEggKi9cbiAgICAgICAgICAgIGZyb21QYXRoOiBmdW5jdGlvbiAoaWQsIHR5cGUsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcGFyYW1fMS5QYXJhbShpZCwgdHlwZSwgY29uZmlnLCBwYXJhbV8xLkRlZlR5cGUuUEFUSCwgX3RoaXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKiBDcmVhdGVzIGEgbmV3IFtbUGFyYW1dXSBmcm9tIGEgdXJsIFNFQVJDSCAqL1xuICAgICAgICAgICAgZnJvbVNlYXJjaDogZnVuY3Rpb24gKGlkLCB0eXBlLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHBhcmFtXzEuUGFyYW0oaWQsIHR5cGUsIGNvbmZpZywgcGFyYW1fMS5EZWZUeXBlLlNFQVJDSCwgX3RoaXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMsIHsgVXJsTWF0Y2hlcjogdXJsTWF0Y2hlcl8xLlVybE1hdGNoZXIsIFBhcmFtOiBwYXJhbV8xLlBhcmFtIH0pO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxNYXRjaGVyRmFjdG9yeS5wcm90b3R5cGUuY2FzZUluc2Vuc2l0aXZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0Nhc2VJbnNlbnNpdGl2ZSA9IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQodmFsdWUpID8gdmFsdWUgOiB0aGlzLl9pc0Nhc2VJbnNlbnNpdGl2ZTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybE1hdGNoZXJGYWN0b3J5LnByb3RvdHlwZS5zdHJpY3RNb2RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1N0cmljdE1vZGUgPSBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHZhbHVlKSA/IHZhbHVlIDogdGhpcy5faXNTdHJpY3RNb2RlO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsTWF0Y2hlckZhY3RvcnkucHJvdG90eXBlLmRlZmF1bHRTcXVhc2hQb2xpY3kgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc0RlZmluZWQodmFsdWUpICYmIHZhbHVlICE9PSB0cnVlICYmIHZhbHVlICE9PSBmYWxzZSAmJiAhcHJlZGljYXRlc18xLmlzU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3F1YXNoIHBvbGljeTogXCIgKyB2YWx1ZSArIFwiLiBWYWxpZCBwb2xpY2llczogZmFsc2UsIHRydWUsIGFyYml0cmFyeS1zdHJpbmdcIik7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0U3F1YXNoUG9saWN5ID0gcHJlZGljYXRlc18xLmlzRGVmaW5lZCh2YWx1ZSkgPyB2YWx1ZSA6IHRoaXMuX2RlZmF1bHRTcXVhc2hQb2xpY3k7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgW1tVcmxNYXRjaGVyXV0gZm9yIHRoZSBzcGVjaWZpZWQgcGF0dGVybi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXR0ZXJuICBUaGUgVVJMIHBhdHRlcm4uXG4gICAgICogQHBhcmFtIGNvbmZpZyAgVGhlIGNvbmZpZyBvYmplY3QgaGFzaC5cbiAgICAgKiBAcmV0dXJucyBUaGUgVXJsTWF0Y2hlci5cbiAgICAgKi9cbiAgICBVcmxNYXRjaGVyRmFjdG9yeS5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB1cmxNYXRjaGVyXzEuVXJsTWF0Y2hlcihwYXR0ZXJuLCB0aGlzLnBhcmFtVHlwZXMsIHRoaXMucGFyYW1GYWN0b3J5LCB0aGlzLl9nZXRDb25maWcoY29uZmlnKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBbW1VybE1hdGNoZXJdXSwgb3IgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9iamVjdCAgVGhlIG9iamVjdCB0byBwZXJmb3JtIHRoZSB0eXBlIGNoZWNrIGFnYWluc3QuXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3QgbWF0Y2hlcyB0aGUgYFVybE1hdGNoZXJgIGludGVyZmFjZSwgYnlcbiAgICAgKiAgICAgICAgICBpbXBsZW1lbnRpbmcgYWxsIHRoZSBzYW1lIG1ldGhvZHMuXG4gICAgICovXG4gICAgVXJsTWF0Y2hlckZhY3RvcnkucHJvdG90eXBlLmlzTWF0Y2hlciA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgLy8gVE9ETzogdHlwZW9mP1xuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc09iamVjdChvYmplY3QpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgY29tbW9uXzEuZm9yRWFjaCh1cmxNYXRjaGVyXzEuVXJsTWF0Y2hlci5wcm90b3R5cGUsIGZ1bmN0aW9uICh2YWwsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbih2YWwpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCAmJiAocHJlZGljYXRlc18xLmlzRGVmaW5lZChvYmplY3RbbmFtZV0pICYmIHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKG9iamVjdFtuYW1lXSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCByZWdpc3RlcnMgYSBjdXN0b20gW1tQYXJhbVR5cGVdXSBvYmplY3RcbiAgICAgKlxuICAgICAqIEEgW1tQYXJhbVR5cGVdXSBjYW4gYmUgdXNlZCB0byBnZW5lcmF0ZSBVUkxzIHdpdGggdHlwZWQgcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lICBUaGUgdHlwZSBuYW1lLlxuICAgICAqIEBwYXJhbSBkZWZpbml0aW9uIFRoZSB0eXBlIGRlZmluaXRpb24uIFNlZSBbW1BhcmFtVHlwZURlZmluaXRpb25dXSBmb3IgaW5mb3JtYXRpb24gb24gdGhlIHZhbHVlcyBhY2NlcHRlZC5cbiAgICAgKiBAcGFyYW0gZGVmaW5pdGlvbkZuIEEgZnVuY3Rpb24gdGhhdCBpcyBpbmplY3RlZCBiZWZvcmUgdGhlIGFwcCBydW50aW1lIHN0YXJ0cy5cbiAgICAgKiAgICAgICAgVGhlIHJlc3VsdCBvZiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBhIFtbUGFyYW1UeXBlRGVmaW5pdGlvbl1dLlxuICAgICAqICAgICAgICBUaGUgcmVzdWx0IGlzIG1lcmdlZCBpbnRvIHRoZSBleGlzdGluZyBgZGVmaW5pdGlvbmAuXG4gICAgICogICAgICAgIFNlZSBbW1BhcmFtVHlwZV1dIGZvciBpbmZvcm1hdGlvbiBvbiB0aGUgdmFsdWVzIGFjY2VwdGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBpZiBhIHR5cGUgd2FzIHJlZ2lzdGVyZWQ6IHRoZSBbW1VybE1hdGNoZXJGYWN0b3J5XV1cbiAgICAgKiAgIC0gaWYgb25seSB0aGUgYG5hbWVgIHBhcmFtZXRlciB3YXMgc3BlY2lmaWVkOiB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgW1tQYXJhbVR5cGVdXSBvYmplY3QsIG9yIHVuZGVmaW5lZFxuICAgICAqXG4gICAgICogTm90ZTogUmVnaXN0ZXIgY3VzdG9tIHR5cGVzICpiZWZvcmUgdXNpbmcgdGhlbSogaW4gYSBzdGF0ZSBkZWZpbml0aW9uLlxuICAgICAqXG4gICAgICogU2VlIFtbUGFyYW1UeXBlRGVmaW5pdGlvbl1dIGZvciBleGFtcGxlc1xuICAgICAqL1xuICAgIFVybE1hdGNoZXJGYWN0b3J5LnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24sIGRlZmluaXRpb25Gbikge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMucGFyYW1UeXBlcy50eXBlKG5hbWUsIGRlZmluaXRpb24sIGRlZmluaXRpb25Gbik7XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlc18xLmlzRGVmaW5lZChkZWZpbml0aW9uKSA/IHR5cGUgOiB0aGlzO1xuICAgIH07XG4gICAgO1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVXJsTWF0Y2hlckZhY3RvcnkucHJvdG90eXBlLiRnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGFyYW1UeXBlcy5lbnF1ZXVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFyYW1UeXBlcy5fZmx1c2hUeXBlUXVldWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIFVybE1hdGNoZXJGYWN0b3J5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhcmFtVHlwZXMuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFVybE1hdGNoZXJGYWN0b3J5O1xufSgpKTtcbmV4cG9ydHMuVXJsTWF0Y2hlckZhY3RvcnkgPSBVcmxNYXRjaGVyRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybE1hdGNoZXJGYWN0b3J5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsTWF0Y2hlckZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBtb2R1bGUgdXJsXG4gKi9cbi8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIHVybE1hdGNoZXJfMSA9IHJlcXVpcmUoXCIuL3VybE1hdGNoZXJcIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciB1cmxSdWxlXzEgPSByZXF1aXJlKFwiLi91cmxSdWxlXCIpO1xudmFyIHRhcmdldFN0YXRlXzEgPSByZXF1aXJlKFwiLi4vc3RhdGUvdGFyZ2V0U3RhdGVcIik7XG52YXIgY29tbW9uXzIgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGFwcGVuZEJhc2VQYXRoKHVybCwgaXNIdG1sNSwgYWJzb2x1dGUsIGJhc2VIcmVmKSB7XG4gICAgaWYgKGJhc2VIcmVmID09PSAnLycpXG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgaWYgKGlzSHRtbDUpXG4gICAgICAgIHJldHVybiBjb21tb25fMi5zdHJpcEZpbGUoYmFzZUhyZWYpICsgdXJsO1xuICAgIGlmIChhYnNvbHV0ZSlcbiAgICAgICAgcmV0dXJuIGJhc2VIcmVmLnNsaWNlKDEpICsgdXJsO1xuICAgIHJldHVybiB1cmw7XG59XG4vKiogQGhpZGRlbiAqL1xudmFyIHByaW9yaXR5U29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIChiLnByaW9yaXR5IHx8IDApIC0gKGEucHJpb3JpdHkgfHwgMCk7XG59O1xuLyoqIEBoaWRkZW4gKi9cbnZhciB0eXBlU29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIHdlaWdodHMgPSB7IFwiU1RBVEVcIjogNCwgXCJVUkxNQVRDSEVSXCI6IDQsIFwiUkVHRVhQXCI6IDMsIFwiUkFXXCI6IDIsIFwiT1RIRVJcIjogMSB9O1xuICAgIHJldHVybiAod2VpZ2h0c1thLnR5cGVdIHx8IDApIC0gKHdlaWdodHNbYi50eXBlXSB8fCAwKTtcbn07XG4vKiogQGhpZGRlbiAqL1xudmFyIHVybE1hdGNoZXJTb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gIWEudXJsTWF0Y2hlciB8fCAhYi51cmxNYXRjaGVyID8gMCA6IHVybE1hdGNoZXJfMS5VcmxNYXRjaGVyLmNvbXBhcmUoYS51cmxNYXRjaGVyLCBiLnVybE1hdGNoZXIpO1xufTtcbi8qKiBAaGlkZGVuICovXG52YXIgaWRTb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAvLyBJZGVudGljYWxseSBzb3J0ZWQgU1RBVEUgYW5kIFVSTE1BVENIRVIgYmVzdCBydWxlIHdpbGwgYmUgY2hvc2VuIGJ5IGBtYXRjaFByaW9yaXR5YCBhZnRlciBlYWNoIHJ1bGUgbWF0Y2hlcyB0aGUgVVJMXG4gICAgdmFyIHVzZU1hdGNoUHJpb3JpdHkgPSB7IFNUQVRFOiB0cnVlLCBVUkxNQVRDSEVSOiB0cnVlIH07XG4gICAgdmFyIGVxdWFsID0gdXNlTWF0Y2hQcmlvcml0eVthLnR5cGVdICYmIHVzZU1hdGNoUHJpb3JpdHlbYi50eXBlXTtcbiAgICByZXR1cm4gZXF1YWwgPyAwIDogKGEuJGlkIHx8IDApIC0gKGIuJGlkIHx8IDApO1xufTtcbi8qKlxuICogRGVmYXVsdCBydWxlIHByaW9yaXR5IHNvcnRpbmcgZnVuY3Rpb24uXG4gKlxuICogU29ydHMgcnVsZXMgYnk6XG4gKlxuICogLSBFeHBsaWNpdCBwcmlvcml0eSAoc2V0IHJ1bGUgcHJpb3JpdHkgdXNpbmcgW1tVcmxSdWxlc0FwaS53aGVuXV0pXG4gKiAtIFJ1bGUgdHlwZSAoU1RBVEU6IDQsIFVSTE1BVENIRVI6IDQsIFJFR0VYUDogMywgUkFXOiAyLCBPVEhFUjogMSlcbiAqIC0gYFVybE1hdGNoZXJgIHNwZWNpZmljaXR5IChbW1VybE1hdGNoZXIuY29tcGFyZV1dKTogd29ya3MgZm9yIFNUQVRFIGFuZCBVUkxNQVRDSEVSIHR5cGVzIHRvIHBpY2sgdGhlIG1vc3Qgc3BlY2lmaWMgcnVsZS5cbiAqIC0gUnVsZSByZWdpc3RyYXRpb24gb3JkZXIgKGZvciBydWxlIHR5cGVzIG90aGVyIHRoYW4gU1RBVEUgYW5kIFVSTE1BVENIRVIpXG4gKiAgIC0gRXF1YWxseSBzb3J0ZWQgU3RhdGUgYW5kIFVybE1hdGNoZXIgcnVsZXMgd2lsbCBlYWNoIG1hdGNoIHRoZSBVUkwuXG4gKiAgICAgVGhlbiwgdGhlICpiZXN0KiBtYXRjaCBpcyBjaG9zZW4gYmFzZWQgb24gaG93IG1hbnkgcGFyYW1ldGVyIHZhbHVlcyB3ZXJlIG1hdGNoZWQuXG4gKlxuICogQGNvcmVhcGlcbiAqL1xudmFyIGRlZmF1bHRSdWxlU29ydEZuO1xuZGVmYXVsdFJ1bGVTb3J0Rm4gPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBjbXAgPSBwcmlvcml0eVNvcnQoYSwgYik7XG4gICAgaWYgKGNtcCAhPT0gMClcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICBjbXAgPSB0eXBlU29ydChhLCBiKTtcbiAgICBpZiAoY21wICE9PSAwKVxuICAgICAgICByZXR1cm4gY21wO1xuICAgIGNtcCA9IHVybE1hdGNoZXJTb3J0KGEsIGIpO1xuICAgIGlmIChjbXAgIT09IDApXG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgcmV0dXJuIGlkU29ydChhLCBiKTtcbn07XG4vKipcbiAqIFVwZGF0ZXMgVVJMIGFuZCByZXNwb25kcyB0byBVUkwgY2hhbmdlc1xuICpcbiAqICMjIyBEZXByZWNhdGlvbiB3YXJuaW5nOlxuICogVGhpcyBjbGFzcyBpcyBub3cgY29uc2lkZXJlZCB0byBiZSBhbiBpbnRlcm5hbCBBUElcbiAqIFVzZSB0aGUgW1tVcmxTZXJ2aWNlXV0gaW5zdGVhZC5cbiAqIEZvciBjb25maWd1cmluZyBVUkwgcnVsZXMsIHVzZSB0aGUgW1tVcmxSdWxlc0FwaV1dIHdoaWNoIGNhbiBiZSBmb3VuZCBhcyBbW1VybFNlcnZpY2UucnVsZXNdXS5cbiAqXG4gKiBUaGlzIGNsYXNzIHVwZGF0ZXMgdGhlIFVSTCB3aGVuIHRoZSBzdGF0ZSBjaGFuZ2VzLlxuICogSXQgYWxzbyByZXNwb25kcyB0byBjaGFuZ2VzIGluIHRoZSBVUkwuXG4gKi9cbnZhciBVcmxSb3V0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBmdW5jdGlvbiBVcmxSb3V0ZXIocm91dGVyKSB7XG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuX3NvcnRGbiA9IGRlZmF1bHRSdWxlU29ydEZuO1xuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLl9ydWxlcyA9IFtdO1xuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLmludGVyY2VwdERlZmVycmVkID0gZmFsc2U7XG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuX2lkID0gMDtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy51cmxSdWxlRmFjdG9yeSA9IG5ldyB1cmxSdWxlXzEuVXJsUnVsZUZhY3Rvcnkocm91dGVyKTtcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnMoaG9mXzEudmFsKFVybFJvdXRlci5wcm90b3R5cGUpLCB0aGlzLCBob2ZfMS52YWwodGhpcykpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxpc3RlbihmYWxzZSk7XG4gICAgICAgIHRoaXMuX3J1bGVzID0gW107XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9vdGhlcndpc2VGbjtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIChjb21wYXJlRm4pIHtcbiAgICAgICAgdGhpcy5fcnVsZXMgPSB0aGlzLnN0YWJsZVNvcnQodGhpcy5fcnVsZXMsIHRoaXMuX3NvcnRGbiA9IGNvbXBhcmVGbiB8fCB0aGlzLl9zb3J0Rm4pO1xuICAgICAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5lbnN1cmVTb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NvcnRlZCB8fCB0aGlzLnNvcnQoKTtcbiAgICB9O1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUuc3RhYmxlU29ydCA9IGZ1bmN0aW9uIChhcnIsIGNvbXBhcmVGbikge1xuICAgICAgICB2YXIgYXJyT2ZXcmFwcGVyID0gYXJyLm1hcChmdW5jdGlvbiAoZWxlbSwgaWR4KSB7IHJldHVybiAoeyBlbGVtOiBlbGVtLCBpZHg6IGlkeCB9KTsgfSk7XG4gICAgICAgIGFyck9mV3JhcHBlci5zb3J0KGZ1bmN0aW9uICh3cmFwcGVyQSwgd3JhcHBlckIpIHtcbiAgICAgICAgICAgIHZhciBjbXBEaWZmID0gY29tcGFyZUZuKHdyYXBwZXJBLmVsZW0sIHdyYXBwZXJCLmVsZW0pO1xuICAgICAgICAgICAgcmV0dXJuIGNtcERpZmYgPT09IDBcbiAgICAgICAgICAgICAgICA/IHdyYXBwZXJBLmlkeCAtIHdyYXBwZXJCLmlkeFxuICAgICAgICAgICAgICAgIDogY21wRGlmZjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhcnJPZldyYXBwZXIubWFwKGZ1bmN0aW9uICh3cmFwcGVyKSB7IHJldHVybiB3cmFwcGVyLmVsZW07IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBVUkwsIGNoZWNrIGFsbCBydWxlcyBhbmQgcmV0dXJuIHRoZSBiZXN0IFtbTWF0Y2hSZXN1bHRdXVxuICAgICAqIEBwYXJhbSB1cmxcbiAgICAgKiBAcmV0dXJucyB7TWF0Y2hSZXN1bHR9XG4gICAgICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5lbnN1cmVTb3J0ZWQoKTtcbiAgICAgICAgdXJsID0gY29tbW9uXzEuZXh0ZW5kKHsgcGF0aDogJycsIHNlYXJjaDoge30sIGhhc2g6ICcnIH0sIHVybCk7XG4gICAgICAgIHZhciBydWxlcyA9IHRoaXMucnVsZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuX290aGVyd2lzZUZuKVxuICAgICAgICAgICAgcnVsZXMucHVzaCh0aGlzLl9vdGhlcndpc2VGbik7XG4gICAgICAgIC8vIENoZWNrcyBhIHNpbmdsZSBydWxlLiBSZXR1cm5zIHsgcnVsZTogcnVsZSwgbWF0Y2g6IG1hdGNoLCB3ZWlnaHQ6IHdlaWdodCB9IGlmIGl0IG1hdGNoZWQsIG9yIHVuZGVmaW5lZFxuICAgICAgICB2YXIgY2hlY2tSdWxlID0gZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHJ1bGUubWF0Y2godXJsLCBfdGhpcy5fcm91dGVyKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaCAmJiB7IG1hdGNoOiBtYXRjaCwgcnVsZTogcnVsZSwgd2VpZ2h0OiBydWxlLm1hdGNoUHJpb3JpdHkobWF0Y2gpIH07XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoZSBydWxlcyBhcmUgcHJlLXNvcnRlZC5cbiAgICAgICAgLy8gLSBGaW5kIHRoZSBmaXJzdCBtYXRjaGluZyBydWxlLlxuICAgICAgICAvLyAtIEZpbmQgYW55IG90aGVyIG1hdGNoaW5nIHJ1bGUgdGhhdCBzb3J0ZWQgKmV4YWN0bHkgdGhlIHNhbWUqLCBhY2NvcmRpbmcgdG8gYC5zb3J0KClgLlxuICAgICAgICAvLyAtIENob29zZSB0aGUgcnVsZSB3aXRoIHRoZSBoaWdoZXN0IG1hdGNoIHdlaWdodC5cbiAgICAgICAgdmFyIGJlc3Q7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFN0b3Agd2hlbiB0aGVyZSBpcyBhICdiZXN0JyBydWxlIGFuZCB0aGUgbmV4dCBydWxlIHNvcnRzIGRpZmZlcmVudGx5IHRoYW4gaXQuXG4gICAgICAgICAgICBpZiAoYmVzdCAmJiB0aGlzLl9zb3J0Rm4ocnVsZXNbaV0sIGJlc3QucnVsZSkgIT09IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IGNoZWNrUnVsZShydWxlc1tpXSk7XG4gICAgICAgICAgICAvLyBQaWNrIHRoZSBiZXN0IE1hdGNoUmVzdWx0XG4gICAgICAgICAgICBiZXN0ID0gKCFiZXN0IHx8IGN1cnJlbnQgJiYgY3VycmVudC53ZWlnaHQgPiBiZXN0LndlaWdodCkgPyBjdXJyZW50IDogYmVzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdDtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgaWYgKGV2dCAmJiBldnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHJvdXRlciA9IHRoaXMuX3JvdXRlciwgJHVybCA9IHJvdXRlci51cmxTZXJ2aWNlLCAkc3RhdGUgPSByb3V0ZXIuc3RhdGVTZXJ2aWNlO1xuICAgICAgICB2YXIgdXJsID0ge1xuICAgICAgICAgICAgcGF0aDogJHVybC5wYXRoKCksIHNlYXJjaDogJHVybC5zZWFyY2goKSwgaGFzaDogJHVybC5oYXNoKCksXG4gICAgICAgIH07XG4gICAgICAgIHZhciBiZXN0ID0gdGhpcy5tYXRjaCh1cmwpO1xuICAgICAgICB2YXIgYXBwbHlSZXN1bHQgPSBob2ZfMS5wYXR0ZXJuKFtcbiAgICAgICAgICAgIFtwcmVkaWNhdGVzXzEuaXNTdHJpbmcsIGZ1bmN0aW9uIChuZXd1cmwpIHsgcmV0dXJuICR1cmwudXJsKG5ld3VybCwgdHJ1ZSk7IH1dLFxuICAgICAgICAgICAgW3RhcmdldFN0YXRlXzEuVGFyZ2V0U3RhdGUuaXNEZWYsIGZ1bmN0aW9uIChkZWYpIHsgcmV0dXJuICRzdGF0ZS5nbyhkZWYuc3RhdGUsIGRlZi5wYXJhbXMsIGRlZi5vcHRpb25zKTsgfV0sXG4gICAgICAgICAgICBbaG9mXzEuaXModGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZSksIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuICRzdGF0ZS5nbyh0YXJnZXQuc3RhdGUoKSwgdGFyZ2V0LnBhcmFtcygpLCB0YXJnZXQub3B0aW9ucygpKTsgfV0sXG4gICAgICAgIF0pO1xuICAgICAgICBhcHBseVJlc3VsdChiZXN0ICYmIGJlc3QucnVsZS5oYW5kbGVyKGJlc3QubWF0Y2gsIHVybCwgcm91dGVyKSk7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChlbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fc3RvcEZuICYmIHRoaXMuX3N0b3BGbigpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N0b3BGbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wRm4gPSB0aGlzLl9zdG9wRm4gfHwgdGhpcy5fcm91dGVyLnVybFNlcnZpY2Uub25DaGFuZ2UoZnVuY3Rpb24gKGV2dCkgeyByZXR1cm4gX3RoaXMuc3luYyhldnQpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgQVBJLlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqL1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHJlYWQpIHtcbiAgICAgICAgdmFyICR1cmwgPSB0aGlzLl9yb3V0ZXIubG9jYXRpb25TZXJ2aWNlO1xuICAgICAgICBpZiAocmVhZCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9ICR1cmwucGF0aCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkdXJsLnBhdGgoKSA9PT0gdGhpcy5sb2NhdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgJHVybC51cmwodGhpcy5sb2NhdGlvbiwgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBBUEkuXG4gICAgICpcbiAgICAgKiBQdXNoZXMgYSBuZXcgbG9jYXRpb24gdG8gdGhlIGJyb3dzZXIgaGlzdG9yeS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqIEBwYXJhbSB1cmxNYXRjaGVyXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHVybE1hdGNoZXIsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVwbGFjZSA9IG9wdGlvbnMgJiYgISFvcHRpb25zLnJlcGxhY2U7XG4gICAgICAgIHRoaXMuX3JvdXRlci51cmxTZXJ2aWNlLnVybCh1cmxNYXRjaGVyLmZvcm1hdChwYXJhbXMgfHwge30pLCByZXBsYWNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhbmQgcmV0dXJucyBhIFVSTCB3aXRoIGludGVycG9sYXRlZCBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBtYXRjaGVyID0gJHVtZi5jb21waWxlKFwiL2Fib3V0LzpwZXJzb25cIik7XG4gICAgICogcGFyYW1zID0geyBwZXJzb246IFwiYm9iXCIgfTtcbiAgICAgKiAkYm9iID0gJHVybFJvdXRlci5ocmVmKG1hdGNoZXIsIHBhcmFtcyk7XG4gICAgICogLy8gJGJvYiA9PSBcIi9hYm91dC9ib2JcIjtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmxNYXRjaGVyIFRoZSBbW1VybE1hdGNoZXJdXSBvYmplY3Qgd2hpY2ggaXMgdXNlZCBhcyB0aGUgdGVtcGxhdGUgb2YgdGhlIFVSTCB0byBnZW5lcmF0ZS5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIEFuIG9iamVjdCBvZiBwYXJhbWV0ZXIgdmFsdWVzIHRvIGZpbGwgdGhlIG1hdGNoZXIncyByZXF1aXJlZCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0LiBUaGUgb3B0aW9ucyBhcmU6XG4gICAgICpcbiAgICAgKiAtICoqYGFic29sdXRlYCoqIC0ge2Jvb2xlYW49ZmFsc2V9LCAgSWYgdHJ1ZSB3aWxsIGdlbmVyYXRlIGFuIGFic29sdXRlIHVybCwgZS5nLiBcImh0dHA6Ly93d3cuZXhhbXBsZS5jb20vZnVsbHVybFwiLlxuICAgICAqXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgZnVsbHkgY29tcGlsZWQgVVJMLCBvciBgbnVsbGAgaWYgYHBhcmFtc2AgZmFpbCB2YWxpZGF0aW9uIGFnYWluc3QgYHVybE1hdGNoZXJgXG4gICAgICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5ocmVmID0gZnVuY3Rpb24gKHVybE1hdGNoZXIsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgdXJsID0gdXJsTWF0Y2hlci5mb3JtYXQocGFyYW1zKTtcbiAgICAgICAgaWYgKHVybCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgYWJzb2x1dGU6IGZhbHNlIH07XG4gICAgICAgIHZhciBjZmcgPSB0aGlzLl9yb3V0ZXIudXJsU2VydmljZS5jb25maWc7XG4gICAgICAgIHZhciBpc0h0bWw1ID0gY2ZnLmh0bWw1TW9kZSgpO1xuICAgICAgICBpZiAoIWlzSHRtbDUgJiYgdXJsICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1cmwgPSBcIiNcIiArIGNmZy5oYXNoUHJlZml4KCkgKyB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gYXBwZW5kQmFzZVBhdGgodXJsLCBpc0h0bWw1LCBvcHRpb25zLmFic29sdXRlLCBjZmcuYmFzZUhyZWYoKSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5hYnNvbHV0ZSB8fCAhdXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzbGFzaCA9ICghaXNIdG1sNSAmJiB1cmwgPyAnLycgOiAnJyksIHBvcnQgPSBjZmcucG9ydCgpO1xuICAgICAgICBwb3J0ID0gKHBvcnQgPT09IDgwIHx8IHBvcnQgPT09IDQ0MyA/ICcnIDogJzonICsgcG9ydCk7XG4gICAgICAgIHJldHVybiBbY2ZnLnByb3RvY29sKCksICc6Ly8nLCBjZmcuaG9zdCgpLCBwb3J0LCBzbGFzaCwgdXJsXS5qb2luKCcnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1hbnVhbGx5IGFkZHMgYSBVUkwgUnVsZS5cbiAgICAgKlxuICAgICAqIFVzdWFsbHksIGEgdXJsIHJ1bGUgaXMgYWRkZWQgdXNpbmcgW1tTdGF0ZURlY2xhcmF0aW9uLnVybF1dIG9yIFtbd2hlbl1dLlxuICAgICAqIFRoaXMgYXBpIGNhbiBiZSB1c2VkIGRpcmVjdGx5IGZvciBtb3JlIGNvbnRyb2wgKHRvIHJlZ2lzdGVyIGEgW1tCYXNlVXJsUnVsZV1dLCBmb3IgZXhhbXBsZSkuXG4gICAgICogUnVsZXMgY2FuIGJlIGNyZWF0ZWQgdXNpbmcgW1tVcmxSb3V0ZXIudXJsUnVsZUZhY3RvcnldXSwgb3IgY3JlYXRlIG1hbnVhbGx5IGFzIHNpbXBsZSBvYmplY3RzLlxuICAgICAqXG4gICAgICogQSBydWxlIHNob3VsZCBoYXZlIGEgYG1hdGNoYCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRydXRoeSBpZiB0aGUgcnVsZSBtYXRjaGVkLlxuICAgICAqIEl0IHNob3VsZCBhbHNvIGhhdmUgYSBgaGFuZGxlcmAgZnVuY3Rpb24gd2hpY2ggaXMgaW52b2tlZCBpZiB0aGUgcnVsZSBpcyB0aGUgYmVzdCBtYXRjaC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGRlcmVnaXN0ZXJzIHRoZSBydWxlXG4gICAgICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5ydWxlID0gZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF1cmxSdWxlXzEuVXJsUnVsZUZhY3RvcnkuaXNVcmxSdWxlKHJ1bGUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBydWxlXCIpO1xuICAgICAgICBydWxlLiRpZCA9IHRoaXMuX2lkKys7XG4gICAgICAgIHJ1bGUucHJpb3JpdHkgPSBydWxlLnByaW9yaXR5IHx8IDA7XG4gICAgICAgIHRoaXMuX3J1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucmVtb3ZlUnVsZShydWxlKTsgfTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUucmVtb3ZlUnVsZSA9IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgIGNvbW1vbl8xLnJlbW92ZUZyb20odGhpcy5fcnVsZXMsIHJ1bGUpO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5ydWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVTb3J0ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1bGVzLnNsaWNlKCk7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLm90aGVyd2lzZSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHZhciBoYW5kbGVyRm4gPSBnZXRIYW5kbGVyRm4oaGFuZGxlcik7XG4gICAgICAgIHRoaXMuX290aGVyd2lzZUZuID0gdGhpcy51cmxSdWxlRmFjdG9yeS5jcmVhdGUoaG9mXzEudmFsKHRydWUpLCBoYW5kbGVyRm4pO1xuICAgICAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIDtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmluaXRpYWwgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICB2YXIgaGFuZGxlckZuID0gZ2V0SGFuZGxlckZuKGhhbmRsZXIpO1xuICAgICAgICB2YXIgbWF0Y2hGbiA9IGZ1bmN0aW9uICh1cmxQYXJ0cywgcm91dGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbkhpc3Rvcnkuc2l6ZSgpID09PSAwICYmICEhL15cXC8/JC8uZXhlYyh1cmxQYXJ0cy5wYXRoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydWxlKHRoaXMudXJsUnVsZUZhY3RvcnkuY3JlYXRlKG1hdGNoRm4sIGhhbmRsZXJGbikpO1xuICAgIH07XG4gICAgO1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUud2hlbiA9IGZ1bmN0aW9uIChtYXRjaGVyLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBydWxlID0gdGhpcy51cmxSdWxlRmFjdG9yeS5jcmVhdGUobWF0Y2hlciwgaGFuZGxlcik7XG4gICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKG9wdGlvbnMgJiYgb3B0aW9ucy5wcmlvcml0eSkpXG4gICAgICAgICAgICBydWxlLnByaW9yaXR5ID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgICAgICAgdGhpcy5ydWxlKHJ1bGUpO1xuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICB9O1xuICAgIDtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmRlZmVySW50ZXJjZXB0ID0gZnVuY3Rpb24gKGRlZmVyKSB7XG4gICAgICAgIGlmIChkZWZlciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZGVmZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLmludGVyY2VwdERlZmVycmVkID0gZGVmZXI7XG4gICAgfTtcbiAgICA7XG4gICAgcmV0dXJuIFVybFJvdXRlcjtcbn0oKSk7XG5leHBvcnRzLlVybFJvdXRlciA9IFVybFJvdXRlcjtcbmZ1bmN0aW9uIGdldEhhbmRsZXJGbihoYW5kbGVyKSB7XG4gICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihoYW5kbGVyKSAmJiAhcHJlZGljYXRlc18xLmlzU3RyaW5nKGhhbmRsZXIpICYmICFob2ZfMS5pcyh0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKShoYW5kbGVyKSAmJiAhdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZS5pc0RlZihoYW5kbGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInaGFuZGxlcicgbXVzdCBiZSBhIHN0cmluZywgZnVuY3Rpb24sIFRhcmdldFN0YXRlLCBvciBoYXZlIGEgc3RhdGU6ICduZXd0YXJnZXQnIHByb3BlcnR5XCIpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzRnVuY3Rpb24oaGFuZGxlcikgPyBoYW5kbGVyIDogaG9mXzEudmFsKGhhbmRsZXIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsUm91dGVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgdXJsXG4gKi8gLyoqICovXG52YXIgdXJsTWF0Y2hlcl8xID0gcmVxdWlyZShcIi4vdXJsTWF0Y2hlclwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xuLyoqXG4gKiBDcmVhdGVzIGEgW1tVcmxSdWxlXV1cbiAqXG4gKiBDcmVhdGVzIGEgW1tVcmxSdWxlXV0gZnJvbSBhOlxuICpcbiAqIC0gYHN0cmluZ2BcbiAqIC0gW1tVcmxNYXRjaGVyXV1cbiAqIC0gYFJlZ0V4cGBcbiAqIC0gW1tTdGF0ZU9iamVjdF1dXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xudmFyIFVybFJ1bGVGYWN0b3J5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVybFJ1bGVGYWN0b3J5KHJvdXRlcikge1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICB9XG4gICAgVXJsUnVsZUZhY3RvcnkucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdXRlci51cmxNYXRjaGVyRmFjdG9yeS5jb21waWxlKHN0cik7XG4gICAgfTtcbiAgICBVcmxSdWxlRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHdoYXQsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG1ha2VSdWxlID0gaG9mXzEucGF0dGVybihbXG4gICAgICAgICAgICBbcHJlZGljYXRlc18xLmlzU3RyaW5nLCBmdW5jdGlvbiAoX3doYXQpIHsgcmV0dXJuIG1ha2VSdWxlKF90aGlzLmNvbXBpbGUoX3doYXQpKTsgfV0sXG4gICAgICAgICAgICBbaG9mXzEuaXModXJsTWF0Y2hlcl8xLlVybE1hdGNoZXIpLCBmdW5jdGlvbiAoX3doYXQpIHsgcmV0dXJuIF90aGlzLmZyb21VcmxNYXRjaGVyKF93aGF0LCBoYW5kbGVyKTsgfV0sXG4gICAgICAgICAgICBbcHJlZGljYXRlc18xLmlzU3RhdGUsIGZ1bmN0aW9uIChfd2hhdCkgeyByZXR1cm4gX3RoaXMuZnJvbVN0YXRlKF93aGF0LCBfdGhpcy5yb3V0ZXIpOyB9XSxcbiAgICAgICAgICAgIFtob2ZfMS5pcyhSZWdFeHApLCBmdW5jdGlvbiAoX3doYXQpIHsgcmV0dXJuIF90aGlzLmZyb21SZWdFeHAoX3doYXQsIGhhbmRsZXIpOyB9XSxcbiAgICAgICAgICAgIFtwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbiwgZnVuY3Rpb24gKF93aGF0KSB7IHJldHVybiBuZXcgQmFzZVVybFJ1bGUoX3doYXQsIGhhbmRsZXIpOyB9XSxcbiAgICAgICAgXSk7XG4gICAgICAgIHZhciBydWxlID0gbWFrZVJ1bGUod2hhdCk7XG4gICAgICAgIGlmICghcnVsZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgJ3doYXQnIGluIHdoZW4oKVwiKTtcbiAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIFVybFJ1bGUgd2hpY2ggbWF0Y2hlcyBiYXNlZCBvbiBhIFVybE1hdGNoZXJcbiAgICAgKlxuICAgICAqIFRoZSBgaGFuZGxlcmAgbWF5IGJlIGVpdGhlciBhIGBzdHJpbmdgLCBhIFtbVXJsUnVsZUhhbmRsZXJGbl1dIG9yIGFub3RoZXIgW1tVcmxNYXRjaGVyXV1cbiAgICAgKlxuICAgICAqICMjIEhhbmRsZXIgYXMgYSBmdW5jdGlvblxuICAgICAqXG4gICAgICogSWYgYGhhbmRsZXJgIGlzIGEgZnVuY3Rpb24sIHRoZSBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGg6XG4gICAgICpcbiAgICAgKiAtIG1hdGNoZWQgcGFyYW1ldGVyIHZhbHVlcyAoW1tSYXdQYXJhbXNdXSBmcm9tIFtbVXJsTWF0Y2hlci5leGVjXV0pXG4gICAgICogLSB1cmw6IHRoZSBjdXJyZW50IFVybCAoW1tVcmxQYXJ0c11dKVxuICAgICAqIC0gcm91dGVyOiB0aGUgcm91dGVyIG9iamVjdCAoW1tVSVJvdXRlcl1dKVxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIHVybE1hdGNoZXIgPSAkdW1mLmNvbXBpbGUoXCIvZm9vLzpmb29JZC86YmFySWRcIik7XG4gICAgICogdmFyIHJ1bGUgPSBmYWN0b3J5LmZyb21VcmxNYXRjaGVyKHVybE1hdGNoZXIsIG1hdGNoID0+IFwiL2hvbWUvXCIgKyBtYXRjaC5mb29JZCArIFwiL1wiICsgbWF0Y2guYmFySWQpO1xuICAgICAqIHZhciBtYXRjaCA9IHJ1bGUubWF0Y2goJy9mb28vMTIzLzQ1NicpOyAvLyByZXN1bHRzIGluIHsgZm9vSWQ6ICcxMjMnLCBiYXJJZDogJzQ1NicgfVxuICAgICAqIHZhciByZXN1bHQgPSBydWxlLmhhbmRsZXIobWF0Y2gpOyAvLyAnL2hvbWUvMTIzLzQ1NidcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIEhhbmRsZXIgYXMgVXJsTWF0Y2hlclxuICAgICAqXG4gICAgICogSWYgYGhhbmRsZXJgIGlzIGEgVXJsTWF0Y2hlciwgdGhlIGhhbmRsZXIgbWF0Y2hlciBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgbmV3IHVybC5cbiAgICAgKiBUaGUgYGhhbmRsZXJgIFVybE1hdGNoZXIgaXMgZm9ybWF0dGVkIHVzaW5nIHRoZSBtYXRjaGVkIHBhcmFtIGZyb20gdGhlIGZpcnN0IG1hdGNoZXIuXG4gICAgICogVGhlIHVybCBpcyByZXBsYWNlZCB3aXRoIHRoZSByZXN1bHQuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB2YXIgdXJsTWF0Y2hlciA9ICR1bWYuY29tcGlsZShcIi9mb28vOmZvb0lkLzpiYXJJZFwiKTtcbiAgICAgKiB2YXIgaGFuZGxlciA9ICR1bWYuY29tcGlsZShcIi9ob21lLzpmb29JZC86YmFySWRcIik7XG4gICAgICogdmFyIHJ1bGUgPSBmYWN0b3J5LmZyb21VcmxNYXRjaGVyKHVybE1hdGNoZXIsIGhhbmRsZXIpO1xuICAgICAqIHZhciBtYXRjaCA9IHJ1bGUubWF0Y2goJy9mb28vMTIzLzQ1NicpOyAvLyByZXN1bHRzIGluIHsgZm9vSWQ6ICcxMjMnLCBiYXJJZDogJzQ1NicgfVxuICAgICAqIHZhciByZXN1bHQgPSBydWxlLmhhbmRsZXIobWF0Y2gpOyAvLyAnL2hvbWUvMTIzLzQ1NidcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBVcmxSdWxlRmFjdG9yeS5wcm90b3R5cGUuZnJvbVVybE1hdGNoZXIgPSBmdW5jdGlvbiAodXJsTWF0Y2hlciwgaGFuZGxlcikge1xuICAgICAgICB2YXIgX2hhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzU3RyaW5nKGhhbmRsZXIpKVxuICAgICAgICAgICAgaGFuZGxlciA9IHRoaXMucm91dGVyLnVybE1hdGNoZXJGYWN0b3J5LmNvbXBpbGUoaGFuZGxlcik7XG4gICAgICAgIGlmIChob2ZfMS5pcyh1cmxNYXRjaGVyXzEuVXJsTWF0Y2hlcikoaGFuZGxlcikpXG4gICAgICAgICAgICBfaGFuZGxlciA9IGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gaGFuZGxlci5mb3JtYXQobWF0Y2gpOyB9O1xuICAgICAgICBmdW5jdGlvbiBtYXRjaCh1cmwpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHVybE1hdGNoZXIuZXhlYyh1cmwucGF0aCwgdXJsLnNlYXJjaCwgdXJsLmhhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIHVybE1hdGNoZXIudmFsaWRhdGVzKG1hdGNoKSAmJiBtYXRjaDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmlvcml0aXplIFVSTHMsIGxvd2VzdCB0byBoaWdoZXN0OlxuICAgICAgICAvLyAtIFNvbWUgb3B0aW9uYWwgVVJMIHBhcmFtZXRlcnMsIGJ1dCBub25lIG1hdGNoZWRcbiAgICAgICAgLy8gLSBObyBvcHRpb25hbCBwYXJhbWV0ZXJzIGluIFVSTFxuICAgICAgICAvLyAtIFNvbWUgb3B0aW9uYWwgcGFyYW1ldGVycywgc29tZSBtYXRjaGVkXG4gICAgICAgIC8vIC0gU29tZSBvcHRpb25hbCBwYXJhbWV0ZXJzLCBhbGwgbWF0Y2hlZFxuICAgICAgICBmdW5jdGlvbiBtYXRjaFByaW9yaXR5KHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIG9wdGlvbmFsID0gdXJsTWF0Y2hlci5wYXJhbWV0ZXJzKCkuZmlsdGVyKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0uaXNPcHRpb25hbDsgfSk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbmFsLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gMC4wMDAwMDE7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IG9wdGlvbmFsLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtc1twYXJhbS5pZF07IH0pO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQubGVuZ3RoIC8gb3B0aW9uYWwubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZXRhaWxzID0geyB1cmxNYXRjaGVyOiB1cmxNYXRjaGVyLCBtYXRjaFByaW9yaXR5OiBtYXRjaFByaW9yaXR5LCB0eXBlOiBcIlVSTE1BVENIRVJcIiB9O1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKG5ldyBCYXNlVXJsUnVsZShtYXRjaCwgX2hhbmRsZXIpLCBkZXRhaWxzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgVXJsUnVsZSB3aGljaCBtYXRjaGVzIGEgc3RhdGUgYnkgaXRzIHVybFxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIHJ1bGUgPSBmYWN0b3J5LmZyb21TdGF0ZSgkc3RhdGUuZ2V0KCdmb28nKSwgcm91dGVyKTtcbiAgICAgKiB2YXIgbWF0Y2ggPSBydWxlLm1hdGNoKCcvZm9vLzEyMy80NTYnKTsgLy8gcmVzdWx0cyBpbiB7IGZvb0lkOiAnMTIzJywgYmFySWQ6ICc0NTYnIH1cbiAgICAgKiB2YXIgcmVzdWx0ID0gcnVsZS5oYW5kbGVyKG1hdGNoKTtcbiAgICAgKiAvLyBTdGFydHMgYSB0cmFuc2l0aW9uIHRvICdmb28nIHdpdGggcGFyYW1zOiB7IGZvb0lkOiAnMTIzJywgYmFySWQ6ICc0NTYnIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBVcmxSdWxlRmFjdG9yeS5wcm90b3R5cGUuZnJvbVN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCByb3V0ZXIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgbWF0Y2ggYnkgdHJhbnNpdGlvbmluZyB0byBtYXRjaGVkIHN0YXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEZpcnN0IGNoZWNrcyBpZiB0aGUgcm91dGVyIHNob3VsZCBzdGFydCBhIG5ldyB0cmFuc2l0aW9uLlxuICAgICAgICAgKiBBIG5ldyB0cmFuc2l0aW9uIGlzIG5vdCByZXF1aXJlZCBpZiB0aGUgY3VycmVudCBzdGF0ZSdzIFVSTFxuICAgICAgICAgKiBhbmQgdGhlIG5ldyBVUkwgYXJlIGFscmVhZHkgaWRlbnRpY2FsXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyICRzdGF0ZSA9IHJvdXRlci5zdGF0ZVNlcnZpY2U7XG4gICAgICAgICAgICB2YXIgZ2xvYmFscyA9IHJvdXRlci5nbG9iYWxzO1xuICAgICAgICAgICAgaWYgKCRzdGF0ZS5ocmVmKHN0YXRlLCBtYXRjaCkgIT09ICRzdGF0ZS5ocmVmKGdsb2JhbHMuY3VycmVudCwgZ2xvYmFscy5wYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgJHN0YXRlLnRyYW5zaXRpb25UbyhzdGF0ZSwgbWF0Y2gsIHsgaW5oZXJpdDogdHJ1ZSwgc291cmNlOiBcInVybFwiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZGV0YWlscyA9IHsgc3RhdGU6IHN0YXRlLCB0eXBlOiBcIlNUQVRFXCIgfTtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZCh0aGlzLmZyb21VcmxNYXRjaGVyKHN0YXRlLnVybCwgaGFuZGxlciksIGRldGFpbHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBVcmxSdWxlIHdoaWNoIG1hdGNoZXMgYmFzZWQgb24gYSByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAgKlxuICAgICAqIFRoZSBgaGFuZGxlcmAgbWF5IGJlIGVpdGhlciBhIFtbVXJsUnVsZUhhbmRsZXJGbl1dIG9yIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogIyMgSGFuZGxlciBhcyBhIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBJZiBgaGFuZGxlcmAgaXMgYSBmdW5jdGlvbiwgdGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aDpcbiAgICAgKlxuICAgICAqIC0gcmVnZXhwIG1hdGNoIGFycmF5IChmcm9tIGByZWdleHBgKVxuICAgICAqIC0gdXJsOiB0aGUgY3VycmVudCBVcmwgKFtbVXJsUGFydHNdXSlcbiAgICAgKiAtIHJvdXRlcjogdGhlIHJvdXRlciBvYmplY3QgKFtbVUlSb3V0ZXJdXSlcbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciBydWxlID0gZmFjdG9yeS5mcm9tUmVnRXhwKC9eXFwvZm9vXFwvKGJhcnxiYXopJC8sIG1hdGNoID0+IFwiL2hvbWUvXCIgKyBtYXRjaFsxXSlcbiAgICAgKiB2YXIgbWF0Y2ggPSBydWxlLm1hdGNoKCcvZm9vL2JhcicpOyAvLyByZXN1bHRzIGluIFsgJy9mb28vYmFyJywgJ2JhcicgXVxuICAgICAqIHZhciByZXN1bHQgPSBydWxlLmhhbmRsZXIobWF0Y2gpOyAvLyAnL2hvbWUvYmFyJ1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMgSGFuZGxlciBhcyBzdHJpbmdcbiAgICAgKlxuICAgICAqIElmIGBoYW5kbGVyYCBpcyBhIHN0cmluZywgdGhlIHVybCBpcyAqcmVwbGFjZWQgYnkgdGhlIHN0cmluZyogd2hlbiB0aGUgUnVsZSBpcyBpbnZva2VkLlxuICAgICAqIFRoZSBzdHJpbmcgaXMgZmlyc3QgaW50ZXJwb2xhdGVkIHVzaW5nIGBzdHJpbmcucmVwbGFjZSgpYCBzdHlsZSBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIHJ1bGUgPSBmYWN0b3J5LmZyb21SZWdFeHAoL15cXC9mb29cXC8oYmFyfGJheikkLywgXCIvaG9tZS8kMVwiKVxuICAgICAqIHZhciBtYXRjaCA9IHJ1bGUubWF0Y2goJy9mb28vYmFyJyk7IC8vIHJlc3VsdHMgaW4gWyAnL2Zvby9iYXInLCAnYmFyJyBdXG4gICAgICogdmFyIHJlc3VsdCA9IHJ1bGUuaGFuZGxlcihtYXRjaCk7IC8vICcvaG9tZS9iYXInXG4gICAgICogYGBgXG4gICAgICovXG4gICAgVXJsUnVsZUZhY3RvcnkucHJvdG90eXBlLmZyb21SZWdFeHAgPSBmdW5jdGlvbiAocmVnZXhwLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChyZWdleHAuZ2xvYmFsIHx8IHJlZ2V4cC5zdGlja3kpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdWxlIFJlZ0V4cCBtdXN0IG5vdCBiZSBnbG9iYWwgb3Igc3RpY2t5XCIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgaGFuZGxlciBpcyBhIHN0cmluZywgdGhlIHVybCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBzdHJpbmcuXG4gICAgICAgICAqIElmIHRoZSBzdHJpbmcgaGFzIGFueSBTdHJpbmcucmVwbGFjZSgpIHN0eWxlIHZhcmlhYmxlcyBpbiBpdCAobGlrZSBgJDJgKSxcbiAgICAgICAgICogdGhleSB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBjYXB0dXJlcyBmcm9tIFtbbWF0Y2hdXVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHJlZGlyZWN0VXJsVG8gPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIEludGVycG9sYXRlcyBtYXRjaGVkIHZhbHVlcyBpbnRvICQxICQyLCBldGMgdXNpbmcgYSBTdHJpbmcucmVwbGFjZSgpLXN0eWxlIHBhdHRlcm5cbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLnJlcGxhY2UoL1xcJChcXCR8XFxkezEsMn0pLywgZnVuY3Rpb24gKG0sIHdoYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hbd2hhdCA9PT0gJyQnID8gMCA6IE51bWJlcih3aGF0KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9oYW5kbGVyID0gcHJlZGljYXRlc18xLmlzU3RyaW5nKGhhbmRsZXIpID8gcmVkaXJlY3RVcmxUbyA6IGhhbmRsZXI7XG4gICAgICAgIHZhciBtYXRjaCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdleHAuZXhlYyh1cmwucGF0aCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBkZXRhaWxzID0geyByZWdleHA6IHJlZ2V4cCwgdHlwZTogXCJSRUdFWFBcIiB9O1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKG5ldyBCYXNlVXJsUnVsZShtYXRjaCwgX2hhbmRsZXIpLCBkZXRhaWxzKTtcbiAgICB9O1xuICAgIFVybFJ1bGVGYWN0b3J5LmlzVXJsUnVsZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiBbJ3R5cGUnLCAnbWF0Y2gnLCAnaGFuZGxlciddLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0RlZmluZWQob2JqW2tleV0pOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBVcmxSdWxlRmFjdG9yeTtcbn0oKSk7XG5leHBvcnRzLlVybFJ1bGVGYWN0b3J5ID0gVXJsUnVsZUZhY3Rvcnk7XG4vKipcbiAqIEEgYmFzZSBydWxlIHdoaWNoIGNhbGxzIGBtYXRjaGBcbiAqXG4gKiBUaGUgdmFsdWUgZnJvbSB0aGUgYG1hdGNoYCBmdW5jdGlvbiBpcyBwYXNzZWQgdGhyb3VnaCB0byB0aGUgYGhhbmRsZXJgLlxuICogQGludGVybmFsYXBpXG4gKi9cbnZhciBCYXNlVXJsUnVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlVXJsUnVsZShtYXRjaCwgaGFuZGxlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm1hdGNoID0gbWF0Y2g7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiUkFXXCI7XG4gICAgICAgIHRoaXMubWF0Y2hQcmlvcml0eSA9IGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gMCAtIF90aGlzLiRpZDsgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlciB8fCBjb21tb25fMS5pZGVudGl0eTtcbiAgICB9XG4gICAgcmV0dXJuIEJhc2VVcmxSdWxlO1xufSgpKTtcbmV4cG9ydHMuQmFzZVVybFJ1bGUgPSBCYXNlVXJsUnVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybFJ1bGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxSdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgdmlld1xuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgdHJhY2VfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vdHJhY2VcIik7XG4vKipcbiAqIFRoZSBWaWV3IHNlcnZpY2VcbiAqXG4gKiBUaGlzIHNlcnZpY2UgcGFpcnMgZXhpc3RpbmcgYHVpLXZpZXdgIGNvbXBvbmVudHMgKHdoaWNoIGxpdmUgaW4gdGhlIERPTSlcbiAqIHdpdGggdmlldyBjb25maWdzIChmcm9tIHRoZSBzdGF0ZSBkZWNsYXJhdGlvbiBvYmplY3RzOiBbW1N0YXRlRGVjbGFyYXRpb24udmlld3NdXSkuXG4gKlxuICogLSBBZnRlciBhIHN1Y2Nlc3NmdWwgVHJhbnNpdGlvbiwgdGhlIHZpZXdzIGZyb20gdGhlIG5ld2x5IGVudGVyZWQgc3RhdGVzIGFyZSBhY3RpdmF0ZWQgdmlhIFtbYWN0aXZhdGVWaWV3Q29uZmlnXV0uXG4gKiAgIFRoZSB2aWV3cyBmcm9tIGV4aXRlZCBzdGF0ZXMgYXJlIGRlYWN0aXZhdGVkIHZpYSBbW2RlYWN0aXZhdGVWaWV3Q29uZmlnXV0uXG4gKiAgIChTZWU6IHRoZSBbW3JlZ2lzdGVyQWN0aXZhdGVWaWV3c11dIFRyYW5zaXRpb24gSG9vaylcbiAqXG4gKiAtIEFzIGB1aS12aWV3YCBjb21wb25lbnRzIHBvcCBpbiBhbmQgb3V0IG9mIGV4aXN0ZW5jZSwgdGhleSByZWdpc3RlciB0aGVtc2VsdmVzIHVzaW5nIFtbcmVnaXN0ZXJVSVZpZXddXS5cbiAqXG4gKiAtIFdoZW4gdGhlIFtbc3luY11dIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHJlZ2lzdGVyZWQgYHVpLXZpZXdgKHMpIChbW0FjdGl2ZVVJVmlld11dKVxuICogYXJlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgbWF0Y2hpbmcgW1tWaWV3Q29uZmlnXV0ocylcbiAqXG4gKi9cbnZhciBWaWV3U2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3U2VydmljZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdWlWaWV3cyA9IFtdO1xuICAgICAgICB0aGlzLl92aWV3Q29uZmlncyA9IFtdO1xuICAgICAgICB0aGlzLl92aWV3Q29uZmlnRmFjdG9yaWVzID0ge307XG4gICAgICAgIHRoaXMuX3BsdWdpbmFwaSA9IHtcbiAgICAgICAgICAgIF9yb290Vmlld0NvbnRleHQ6IHRoaXMuX3Jvb3RWaWV3Q29udGV4dC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX3ZpZXdDb25maWdGYWN0b3J5OiB0aGlzLl92aWV3Q29uZmlnRmFjdG9yeS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX3JlZ2lzdGVyZWRVSVZpZXdzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdWlWaWV3czsgfSxcbiAgICAgICAgICAgIF9hY3RpdmVWaWV3Q29uZmlnczogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3ZpZXdDb25maWdzOyB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuX3Jvb3RWaWV3Q29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290Q29udGV4dCA9IGNvbnRleHQgfHwgdGhpcy5fcm9vdENvbnRleHQ7XG4gICAgfTtcbiAgICA7XG4gICAgVmlld1NlcnZpY2UucHJvdG90eXBlLl92aWV3Q29uZmlnRmFjdG9yeSA9IGZ1bmN0aW9uICh2aWV3VHlwZSwgZmFjdG9yeSkge1xuICAgICAgICB0aGlzLl92aWV3Q29uZmlnRmFjdG9yaWVzW3ZpZXdUeXBlXSA9IGZhY3Rvcnk7XG4gICAgfTtcbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuY3JlYXRlVmlld0NvbmZpZyA9IGZ1bmN0aW9uIChwYXRoLCBkZWNsKSB7XG4gICAgICAgIHZhciBjZmdGYWN0b3J5ID0gdGhpcy5fdmlld0NvbmZpZ0ZhY3Rvcmllc1tkZWNsLiR0eXBlXTtcbiAgICAgICAgaWYgKCFjZmdGYWN0b3J5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmlld1NlcnZpY2U6IE5vIHZpZXcgY29uZmlnIGZhY3RvcnkgcmVnaXN0ZXJlZCBmb3IgdHlwZSBcIiArIGRlY2wuJHR5cGUpO1xuICAgICAgICB2YXIgY2ZncyA9IGNmZ0ZhY3RvcnkocGF0aCwgZGVjbCk7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNBcnJheShjZmdzKSA/IGNmZ3MgOiBbY2Znc107XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWFjdGl2YXRlcyBhIFZpZXdDb25maWcuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGRlYWN0aXZhdGVzIGEgYFZpZXdDb25maWdgLlxuICAgICAqIEFmdGVyIGNhbGxpbmcgW1tzeW5jXV0sIGl0IHdpbGwgdW4tcGFpciBmcm9tIGFueSBgdWktdmlld2Agd2l0aCB3aGljaCBpdCBpcyBjdXJyZW50bHkgcGFpcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZpZXdDb25maWcgVGhlIFZpZXdDb25maWcgdmlldyB0byBkZXJlZ2lzdGVyLlxuICAgICAqL1xuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5kZWFjdGl2YXRlVmlld0NvbmZpZyA9IGZ1bmN0aW9uICh2aWV3Q29uZmlnKSB7XG4gICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VWaWV3U2VydmljZUV2ZW50KFwiPC0gUmVtb3ZpbmdcIiwgdmlld0NvbmZpZyk7XG4gICAgICAgIGNvbW1vbl8xLnJlbW92ZUZyb20odGhpcy5fdmlld0NvbmZpZ3MsIHZpZXdDb25maWcpO1xuICAgIH07XG4gICAgVmlld1NlcnZpY2UucHJvdG90eXBlLmFjdGl2YXRlVmlld0NvbmZpZyA9IGZ1bmN0aW9uICh2aWV3Q29uZmlnKSB7XG4gICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VWaWV3U2VydmljZUV2ZW50KFwiLT4gUmVnaXN0ZXJpbmdcIiwgdmlld0NvbmZpZyk7XG4gICAgICAgIHRoaXMuX3ZpZXdDb25maWdzLnB1c2godmlld0NvbmZpZyk7XG4gICAgfTtcbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHVpVmlld3NCeUZxbiA9IHRoaXMuX3VpVmlld3MubWFwKGZ1bmN0aW9uICh1aXYpIHsgcmV0dXJuIFt1aXYuZnFuLCB1aXZdOyB9KS5yZWR1Y2UoY29tbW9uXzEuYXBwbHlQYWlycywge30pO1xuICAgICAgICAvLyBSZXR1cm4gYSB3ZWlnaHRlZCBkZXB0aCB2YWx1ZSBmb3IgYSB1aVZpZXcuXG4gICAgICAgIC8vIFRoZSBkZXB0aCBpcyB0aGUgbmVzdGluZyBkZXB0aCBvZiB1aS12aWV3cyAoYmFzZWQgb24gRlFOOyB0aW1lcyAxMCwwMDApXG4gICAgICAgIC8vIHBsdXMgdGhlIGRlcHRoIG9mIHRoZSBzdGF0ZSB0aGF0IGlzIHBvcHVsYXRpbmcgdGhlIHVpVmlld1xuICAgICAgICBmdW5jdGlvbiB1aVZpZXdEZXB0aCh1aVZpZXcpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZURlcHRoID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dCAmJiBjb250ZXh0LnBhcmVudCA/IHN0YXRlRGVwdGgoY29udGV4dC5wYXJlbnQpICsgMSA6IDE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuICh1aVZpZXcuZnFuLnNwbGl0KFwiLlwiKS5sZW5ndGggKiAxMDAwMCkgKyBzdGF0ZURlcHRoKHVpVmlldy5jcmVhdGlvbkNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgVmlld0NvbmZpZydzIGNvbnRleHQncyBkZXB0aCBpbiB0aGUgY29udGV4dCB0cmVlLlxuICAgICAgICBmdW5jdGlvbiB2aWV3Q29uZmlnRGVwdGgoY29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGNvbmZpZy52aWV3RGVjbC4kY29udGV4dCwgY291bnQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKCsrY291bnQgJiYgY29udGV4dC5wYXJlbnQpXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIEdpdmVuIGEgZGVwdGggZnVuY3Rpb24sIHJldHVybnMgYSBjb21wYXJlIGZ1bmN0aW9uIHdoaWNoIGNhbiByZXR1cm4gZWl0aGVyIGFzY2VuZGluZyBvciBkZXNjZW5kaW5nIG9yZGVyXG4gICAgICAgIHZhciBkZXB0aENvbXBhcmUgPSBob2ZfMS5jdXJyeShmdW5jdGlvbiAoZGVwdGhGbiwgcG9zTmVnLCBsZWZ0LCByaWdodCkgeyByZXR1cm4gcG9zTmVnICogKGRlcHRoRm4obGVmdCkgLSBkZXB0aEZuKHJpZ2h0KSk7IH0pO1xuICAgICAgICB2YXIgbWF0Y2hpbmdDb25maWdQYWlyID0gZnVuY3Rpb24gKHVpVmlldykge1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nQ29uZmlncyA9IF90aGlzLl92aWV3Q29uZmlncy5maWx0ZXIoVmlld1NlcnZpY2UubWF0Y2hlcyh1aVZpZXdzQnlGcW4sIHVpVmlldykpO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nQ29uZmlncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBPSy4gIENoaWxkIHN0YXRlcyBjYW4gdGFyZ2V0IGEgdWktdmlldyB0aGF0IHRoZSBwYXJlbnQgc3RhdGUgYWxzbyB0YXJnZXRzICh0aGUgY2hpbGQgd2lucylcbiAgICAgICAgICAgICAgICAvLyBTb3J0IGJ5IGRlcHRoIGFuZCByZXR1cm4gdGhlIG1hdGNoIGZyb20gdGhlIGRlZXBlc3QgY2hpbGRcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgTXVsdGlwbGUgbWF0Y2hpbmcgdmlldyBjb25maWdzIGZvciAke3VpVmlldy5mcW59YCwgbWF0Y2hpbmdDb25maWdzKTtcbiAgICAgICAgICAgICAgICBtYXRjaGluZ0NvbmZpZ3Muc29ydChkZXB0aENvbXBhcmUodmlld0NvbmZpZ0RlcHRoLCAtMSkpOyAvLyBkZXNjZW5kaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3VpVmlldywgbWF0Y2hpbmdDb25maWdzWzBdXTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvbmZpZ3VyZVVJVmlldyA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHVpVmlldyA9IF9hWzBdLCB2aWV3Q29uZmlnID0gX2FbMV07XG4gICAgICAgICAgICAvLyBJZiBhIHBhcmVudCB1aS12aWV3IGlzIHJlY29uZmlndXJlZCwgaXQgY291bGQgZGVzdHJveSBjaGlsZCB1aS12aWV3cy5cbiAgICAgICAgICAgIC8vIEJlZm9yZSBjb25maWd1cmluZyBhIGNoaWxkIHVpLXZpZXcsIG1ha2Ugc3VyZSBpdCdzIHN0aWxsIGluIHRoZSBhY3RpdmUgdWlWaWV3cyBhcnJheS5cbiAgICAgICAgICAgIGlmIChfdGhpcy5fdWlWaWV3cy5pbmRleE9mKHVpVmlldykgIT09IC0xKVxuICAgICAgICAgICAgICAgIHVpVmlldy5jb25maWdVcGRhdGVkKHZpZXdDb25maWcpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBTb3J0IHZpZXdzIGJ5IEZRTiBhbmQgc3RhdGUgZGVwdGguIFByb2Nlc3MgdWl2aWV3cyBuZWFyZXN0IHRoZSByb290IGZpcnN0LlxuICAgICAgICB2YXIgcGFpcnMgPSB0aGlzLl91aVZpZXdzLnNvcnQoZGVwdGhDb21wYXJlKHVpVmlld0RlcHRoLCAxKSkubWFwKG1hdGNoaW5nQ29uZmlnUGFpcik7XG4gICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VWaWV3U3luYyhwYWlycyk7XG4gICAgICAgIHBhaXJzLmZvckVhY2goY29uZmlndXJlVUlWaWV3KTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBgdWktdmlld2AgY29tcG9uZW50XG4gICAgICpcbiAgICAgKiBXaGVuIGEgYHVpLXZpZXdgIGNvbXBvbmVudCBpcyBjcmVhdGVkLCBpdCB1c2VzIHRoaXMgbWV0aG9kIHRvIHJlZ2lzdGVyIGl0c2VsZi5cbiAgICAgKiBBZnRlciByZWdpc3RyYXRpb24gdGhlIFtbc3luY11dIG1ldGhvZCBpcyB1c2VkIHRvIGVuc3VyZSBhbGwgYHVpLXZpZXdgIGFyZSBjb25maWd1cmVkIHdpdGggdGhlIHByb3BlciBbW1ZpZXdDb25maWddXS5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoZSBgdWktdmlld2AgY29tcG9uZW50IHVzZXMgdGhlIGBWaWV3Q29uZmlnYCB0byBkZXRlcm1pbmUgd2hhdCB2aWV3IHNob3VsZCBiZSBsb2FkZWQgaW5zaWRlIHRoZSBgdWktdmlld2AsXG4gICAgICogYW5kIHdoYXQgdGhlIHZpZXcncyBzdGF0ZSBjb250ZXh0IGlzLlxuICAgICAqXG4gICAgICogTm90ZTogVGhlcmUgaXMgbm8gY29ycmVzcG9uZGluZyBgZGVyZWdpc3RlclVJVmlld2AuXG4gICAgICogICAgICAgQSBgdWktdmlld2Agc2hvdWxkIGhhbmcgb24gdG8gdGhlIHJldHVybiB2YWx1ZSBvZiBgcmVnaXN0ZXJVSVZpZXdgIGFuZCBpbnZva2UgaXQgdG8gZGVyZWdpc3RlciBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdWlWaWV3IFRoZSBtZXRhZGF0YSBmb3IgYSBVSVZpZXdcbiAgICAgKiBAcmV0dXJuIGEgZGUtcmVnaXN0cmF0aW9uIGZ1bmN0aW9uIHVzZWQgd2hlbiB0aGUgdmlldyBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgVmlld1NlcnZpY2UucHJvdG90eXBlLnJlZ2lzdGVyVUlWaWV3ID0gZnVuY3Rpb24gKHVpVmlldykge1xuICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudChcIi0+IFJlZ2lzdGVyaW5nXCIsIHVpVmlldyk7XG4gICAgICAgIHZhciB1aVZpZXdzID0gdGhpcy5fdWlWaWV3cztcbiAgICAgICAgdmFyIGZxbkFuZFR5cGVNYXRjaGVzID0gZnVuY3Rpb24gKHVpdikgeyByZXR1cm4gdWl2LmZxbiA9PT0gdWlWaWV3LmZxbiAmJiB1aXYuJHR5cGUgPT09IHVpVmlldy4kdHlwZTsgfTtcbiAgICAgICAgaWYgKHVpVmlld3MuZmlsdGVyKGZxbkFuZFR5cGVNYXRjaGVzKS5sZW5ndGgpXG4gICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudChcIiEhISEgZHVwbGljYXRlIHVpVmlldyBuYW1lZDpcIiwgdWlWaWV3KTtcbiAgICAgICAgdWlWaWV3cy5wdXNoKHVpVmlldyk7XG4gICAgICAgIHRoaXMuc3luYygpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IHVpVmlld3MuaW5kZXhPZih1aVZpZXcpO1xuICAgICAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudChcIlRyaWVkIHJlbW92aW5nIG5vbi1yZWdpc3RlcmVkIHVpVmlld1wiLCB1aVZpZXcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VWaWV3U2VydmljZVVJVmlld0V2ZW50KFwiPC0gRGVyZWdpc3RlcmluZ1wiLCB1aVZpZXcpO1xuICAgICAgICAgICAgY29tbW9uXzEucmVtb3ZlRnJvbSh1aVZpZXdzKSh1aVZpZXcpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2Ygdmlld3MgY3VycmVudGx5IGF2YWlsYWJsZSBvbiB0aGUgcGFnZSwgYnkgZnVsbHktcXVhbGlmaWVkIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBmdWxseS1xdWFsaWZpZWQgdmlldyBuYW1lcy5cbiAgICAgKi9cbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuYXZhaWxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdWlWaWV3cy5tYXAoaG9mXzEucHJvcChcImZxblwiKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHZpZXdzIG9uIHRoZSBwYWdlIGNvbnRhaW5pbmcgbG9hZGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBmdWxseS1xdWFsaWZpZWQgdmlldyBuYW1lcy5cbiAgICAgKi9cbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuYWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdWlWaWV3cy5maWx0ZXIoaG9mXzEucHJvcChcIiRjb25maWdcIikpLm1hcChob2ZfMS5wcm9wKFwibmFtZVwiKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemVzIGEgdmlldydzIG5hbWUgZnJvbSBhIHN0YXRlLnZpZXdzIGNvbmZpZ3VyYXRpb24gYmxvY2suXG4gICAgICpcbiAgICAgKiBUaGlzIHNob3VsZCBiZSB1c2VkIGJ5IGEgZnJhbWV3b3JrIGltcGxlbWVudGF0aW9uIHRvIGNhbGN1bGF0ZSB0aGUgdmFsdWVzIGZvclxuICAgICAqIFtbX1ZpZXdEZWNsYXJhdGlvbi4kdWlWaWV3TmFtZV1dIGFuZCBbW19WaWV3RGVjbGFyYXRpb24uJHVpVmlld0NvbnRleHRBbmNob3JdXS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250ZXh0IHRoZSBjb250ZXh0IG9iamVjdCAoc3RhdGUgZGVjbGFyYXRpb24pIHRoYXQgdGhlIHZpZXcgYmVsb25ncyB0b1xuICAgICAqIEBwYXJhbSByYXdWaWV3TmFtZSB0aGUgbmFtZSBvZiB0aGUgdmlldywgYXMgZGVjbGFyZWQgaW4gdGhlIFtbU3RhdGVEZWNsYXJhdGlvbi52aWV3c11dXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgbm9ybWFsaXplZCB1aVZpZXdOYW1lIGFuZCB1aVZpZXdDb250ZXh0QW5jaG9yIHRoYXQgdGhlIHZpZXcgdGFyZ2V0c1xuICAgICAqL1xuICAgIFZpZXdTZXJ2aWNlLm5vcm1hbGl6ZVVJVmlld1RhcmdldCA9IGZ1bmN0aW9uIChjb250ZXh0LCByYXdWaWV3TmFtZSkge1xuICAgICAgICBpZiAocmF3Vmlld05hbWUgPT09IHZvaWQgMCkgeyByYXdWaWV3TmFtZSA9IFwiXCI7IH1cbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgaW5jb21pbmcgdmlldyBuYW1lIHdpdGggYSByZWdleHAgdG8gYWxsb3c6XG4gICAgICAgIC8vIGV4OiBcInZpZXcubmFtZUBmb28uYmFyXCIgLCBcIl4uXi52aWV3Lm5hbWVcIiAsIFwidmlldy5uYW1lQF4uXlwiICwgXCJcIiAsXG4gICAgICAgIC8vIFwiQFwiICwgXCIkZGVmYXVsdEBeXCIgLCBcIiEkZGVmYXVsdC4kZGVmYXVsdFwiICwgXCIhZm9vLmJhclwiXG4gICAgICAgIHZhciB2aWV3QXRDb250ZXh0ID0gcmF3Vmlld05hbWUuc3BsaXQoXCJAXCIpO1xuICAgICAgICB2YXIgdWlWaWV3TmFtZSA9IHZpZXdBdENvbnRleHRbMF0gfHwgXCIkZGVmYXVsdFwiOyAvLyBkZWZhdWx0IHRvIHVubmFtZWQgdmlld1xuICAgICAgICB2YXIgdWlWaWV3Q29udGV4dEFuY2hvciA9IHByZWRpY2F0ZXNfMS5pc1N0cmluZyh2aWV3QXRDb250ZXh0WzFdKSA/IHZpZXdBdENvbnRleHRbMV0gOiBcIl5cIjsgLy8gZGVmYXVsdCB0byBwYXJlbnQgY29udGV4dFxuICAgICAgICAvLyBIYW5kbGUgcmVsYXRpdmUgdmlldy1uYW1lIHN1Z2FyIHN5bnRheC5cbiAgICAgICAgLy8gTWF0Y2hlcyByYXdWaWV3TmFtZSBcIl4uXi5eLmZvby5iYXJcIiBpbnRvIGFycmF5OiBbXCJeLl4uXi5mb28uYmFyXCIsIFwiXi5eLl5cIiwgXCJmb28uYmFyXCJdLFxuICAgICAgICB2YXIgcmVsYXRpdmVWaWV3TmFtZVN1Z2FyID0gL14oXFxeKD86XFwuXFxeKSopXFwuKC4qJCkvLmV4ZWModWlWaWV3TmFtZSk7XG4gICAgICAgIGlmIChyZWxhdGl2ZVZpZXdOYW1lU3VnYXIpIHtcbiAgICAgICAgICAgIC8vIENsb2JiZXJzIGV4aXN0aW5nIGNvbnRleHRBbmNob3IgKHJhd1ZpZXdOYW1lIHZhbGlkYXRpb24gd2lsbCBmaXggdGhpcylcbiAgICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3IgPSByZWxhdGl2ZVZpZXdOYW1lU3VnYXJbMV07IC8vIHNldCBhbmNob3IgdG8gXCJeLl4uXlwiXG4gICAgICAgICAgICB1aVZpZXdOYW1lID0gcmVsYXRpdmVWaWV3TmFtZVN1Z2FyWzJdOyAvLyBzZXQgdmlldy1uYW1lIHRvIFwiZm9vLmJhclwiXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpVmlld05hbWUuY2hhckF0KDApID09PSAnIScpIHtcbiAgICAgICAgICAgIHVpVmlld05hbWUgPSB1aVZpZXdOYW1lLnN1YnN0cigxKTtcbiAgICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3IgPSBcIlwiOyAvLyB0YXJnZXQgYWJzb2x1dGVseSBmcm9tIHJvb3RcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgcGFyZW50IHJlbGF0aXZlIHRhcmdldGluZyBcIl4uXi5eXCJcbiAgICAgICAgdmFyIHJlbGF0aXZlTWF0Y2ggPSAvXihcXF4oPzpcXC5cXF4pKikkLztcbiAgICAgICAgaWYgKHJlbGF0aXZlTWF0Y2guZXhlYyh1aVZpZXdDb250ZXh0QW5jaG9yKSkge1xuICAgICAgICAgICAgdmFyIGFuY2hvciA9IHVpVmlld0NvbnRleHRBbmNob3Iuc3BsaXQoXCIuXCIpLnJlZHVjZSgoZnVuY3Rpb24gKGFuY2hvciwgeCkgeyByZXR1cm4gYW5jaG9yLnBhcmVudDsgfSksIGNvbnRleHQpO1xuICAgICAgICAgICAgdWlWaWV3Q29udGV4dEFuY2hvciA9IGFuY2hvci5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVpVmlld0NvbnRleHRBbmNob3IgPT09ICcuJykge1xuICAgICAgICAgICAgdWlWaWV3Q29udGV4dEFuY2hvciA9IGNvbnRleHQubmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB1aVZpZXdOYW1lOiB1aVZpZXdOYW1lLCB1aVZpZXdDb250ZXh0QW5jaG9yOiB1aVZpZXdDb250ZXh0QW5jaG9yIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHVpLXZpZXcgYW5kIGEgVmlld0NvbmZpZywgZGV0ZXJtaW5lcyBpZiB0aGV5IFwibWF0Y2hcIi5cbiAgICAgKlxuICAgICAqIEEgdWktdmlldyBoYXMgYSBmdWxseSBxdWFsaWZpZWQgbmFtZSAoZnFuKSBhbmQgYSBjb250ZXh0IG9iamVjdC4gIFRoZSBmcW4gaXMgYnVpbHQgZnJvbSBpdHMgb3ZlcmFsbCBsb2NhdGlvbiBpblxuICAgICAqIHRoZSBET00sIGRlc2NyaWJpbmcgaXRzIG5lc3RpbmcgcmVsYXRpb25zaGlwIHRvIGFueSBwYXJlbnQgdWktdmlldyB0YWdzIGl0IGlzIG5lc3RlZCBpbnNpZGUgb2YuXG4gICAgICpcbiAgICAgKiBBIFZpZXdDb25maWcgaGFzIGEgdGFyZ2V0IHVpLXZpZXcgbmFtZSBhbmQgYSBjb250ZXh0IGFuY2hvci4gIFRoZSB1aS12aWV3IG5hbWUgY2FuIGJlIGEgc2ltcGxlIG5hbWUsIG9yXG4gICAgICogY2FuIGJlIGEgc2VnbWVudGVkIHVpLXZpZXcgcGF0aCwgZGVzY3JpYmluZyBhIHBvcnRpb24gb2YgYSB1aS12aWV3IGZxbi5cbiAgICAgKlxuICAgICAqIEluIG9yZGVyIGZvciBhIHVpLXZpZXcgdG8gbWF0Y2ggVmlld0NvbmZpZywgdWktdmlldydzICR0eXBlIG11c3QgbWF0Y2ggdGhlIFZpZXdDb25maWcncyAkdHlwZVxuICAgICAqXG4gICAgICogSWYgdGhlIFZpZXdDb25maWcncyB0YXJnZXQgdWktdmlldyBuYW1lIGlzIGEgc2ltcGxlIG5hbWUgKG5vIGRvdHMpLCB0aGVuIGEgdWktdmlldyBtYXRjaGVzIGlmOlxuICAgICAqIC0gdGhlIHVpLXZpZXcncyBuYW1lIG1hdGNoZXMgdGhlIFZpZXdDb25maWcncyB0YXJnZXQgbmFtZVxuICAgICAqIC0gdGhlIHVpLXZpZXcncyBjb250ZXh0IG1hdGNoZXMgdGhlIFZpZXdDb25maWcncyBhbmNob3JcbiAgICAgKlxuICAgICAqIElmIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IHVpLXZpZXcgbmFtZSBpcyBhIHNlZ21lbnRlZCBuYW1lICh3aXRoIGRvdHMpLCB0aGVuIGEgdWktdmlldyBtYXRjaGVzIGlmOlxuICAgICAqIC0gVGhlcmUgZXhpc3RzIGEgcGFyZW50IHVpLXZpZXcgd2hlcmU6XG4gICAgICogICAgLSB0aGUgcGFyZW50IHVpLXZpZXcncyBuYW1lIG1hdGNoZXMgdGhlIGZpcnN0IHNlZ21lbnQgKGluZGV4IDApIG9mIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IG5hbWVcbiAgICAgKiAgICAtIHRoZSBwYXJlbnQgdWktdmlldydzIGNvbnRleHQgbWF0Y2hlcyB0aGUgVmlld0NvbmZpZydzIGFuY2hvclxuICAgICAqIC0gQW5kIHRoZSByZW1haW5pbmcgc2VnbWVudHMgKGluZGV4IDEuLm4pIG9mIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IG5hbWUgbWF0Y2ggdGhlIHRhaWwgb2YgdGhlIHVpLXZpZXcncyBmcW5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBET006XG4gICAgICogPHVpLXZpZXc+ICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBjcmVhdGVkIGluIHRoZSByb290IGNvbnRleHQgKG5hbWU6IFwiXCIpIC0tPlxuICAgICAqICAgPHVpLXZpZXcgbmFtZT1cImZvb1wiPiAgICAgICAgICAgICAgICA8IS0tIGNyZWF0ZWQgaW4gdGhlIGNvbnRleHQgbmFtZWQ6IFwiQVwiICAgICAgLS0+XG4gICAgICogICAgIDx1aS12aWV3PiAgICAgICAgICAgICAgICAgICAgPCEtLSBjcmVhdGVkIGluIHRoZSBjb250ZXh0IG5hbWVkOiBcIkEuQlwiICAgIC0tPlxuICAgICAqICAgICAgIDx1aS12aWV3IG5hbWU9XCJiYXJcIj4gICAgICAgICAgICA8IS0tIGNyZWF0ZWQgaW4gdGhlIGNvbnRleHQgbmFtZWQ6IFwiQS5CLkNcIiAgLS0+XG4gICAgICogICAgICAgPC91aS12aWV3PlxuICAgICAqICAgICA8L3VpLXZpZXc+XG4gICAgICogICA8L3VpLXZpZXc+XG4gICAgICogPC91aS12aWV3PlxuICAgICAqXG4gICAgICogdWlWaWV3czogW1xuICAgICAqICB7IGZxbjogXCIkZGVmYXVsdFwiLCAgICAgICAgICAgICAgICAgIGNyZWF0aW9uQ29udGV4dDogeyBuYW1lOiBcIlwiIH0gfSxcbiAgICAgKiAgeyBmcW46IFwiJGRlZmF1bHQuZm9vXCIsICAgICAgICAgICAgICBjcmVhdGlvbkNvbnRleHQ6IHsgbmFtZTogXCJBXCIgfSB9LFxuICAgICAqICB7IGZxbjogXCIkZGVmYXVsdC5mb28uJGRlZmF1bHRcIiwgICAgIGNyZWF0aW9uQ29udGV4dDogeyBuYW1lOiBcIkEuQlwiIH0gfVxuICAgICAqICB7IGZxbjogXCIkZGVmYXVsdC5mb28uJGRlZmF1bHQuYmFyXCIsIGNyZWF0aW9uQ29udGV4dDogeyBuYW1lOiBcIkEuQi5DXCIgfSB9XG4gICAgICogXVxuICAgICAqXG4gICAgICogVGhlc2UgZm91ciB2aWV3IGNvbmZpZ3MgYWxsIG1hdGNoIHRoZSB1aS12aWV3IHdpdGggdGhlIGZxbjogXCIkZGVmYXVsdC5mb28uJGRlZmF1bHQuYmFyXCI6XG4gICAgICpcbiAgICAgKiAtIFZpZXdDb25maWcxOiB7IHVpVmlld05hbWU6IFwiYmFyXCIsICAgICAgICAgICAgICAgICAgICAgICB1aVZpZXdDb250ZXh0QW5jaG9yOiBcIkEuQi5DXCIgfVxuICAgICAqIC0gVmlld0NvbmZpZzI6IHsgdWlWaWV3TmFtZTogXCIkZGVmYXVsdC5iYXJcIiwgICAgICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3I6IFwiQS5CXCIgfVxuICAgICAqIC0gVmlld0NvbmZpZzM6IHsgdWlWaWV3TmFtZTogXCJmb28uJGRlZmF1bHQuYmFyXCIsICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3I6IFwiQVwiIH1cbiAgICAgKiAtIFZpZXdDb25maWc0OiB7IHVpVmlld05hbWU6IFwiJGRlZmF1bHQuZm9vLiRkZWZhdWx0LmJhclwiLCB1aVZpZXdDb250ZXh0QW5jaG9yOiBcIlwiIH1cbiAgICAgKlxuICAgICAqIFVzaW5nIFZpZXdDb25maWczIGFzIGFuIGV4YW1wbGUsIGl0IG1hdGNoZXMgdGhlIHVpLXZpZXcgd2l0aCBmcW4gXCIkZGVmYXVsdC5mb28uJGRlZmF1bHQuYmFyXCIgYmVjYXVzZTpcbiAgICAgKiAtIFRoZSBWaWV3Q29uZmlnJ3Mgc2VnbWVudGVkIHRhcmdldCBuYW1lIGlzOiBbIFwiZm9vXCIsIFwiJGRlZmF1bHRcIiwgXCJiYXJcIiBdXG4gICAgICogLSBUaGVyZSBleGlzdHMgYSBwYXJlbnQgdWktdmlldyAod2hpY2ggaGFzIGZxbjogXCIkZGVmYXVsdC5mb29cIikgd2hlcmU6XG4gICAgICogICAgLSB0aGUgcGFyZW50IHVpLXZpZXcncyBuYW1lIFwiZm9vXCIgbWF0Y2hlcyB0aGUgZmlyc3Qgc2VnbWVudCBcImZvb1wiIG9mIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IG5hbWVcbiAgICAgKiAgICAtIHRoZSBwYXJlbnQgdWktdmlldydzIGNvbnRleHQgXCJBXCIgbWF0Y2hlcyB0aGUgVmlld0NvbmZpZydzIGFuY2hvciBjb250ZXh0IFwiQVwiXG4gICAgICogLSBBbmQgdGhlIHJlbWFpbmluZyBzZWdtZW50cyBbIFwiJGRlZmF1bHRcIiwgXCJiYXJcIiBdLmpvaW4oXCIuXCJfIG9mIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IG5hbWUgbWF0Y2hcbiAgICAgKiAgIHRoZSB0YWlsIG9mIHRoZSB1aS12aWV3J3MgZnFuIFwiZGVmYXVsdC5iYXJcIlxuICAgICAqXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICovXG4gICAgVmlld1NlcnZpY2UubWF0Y2hlcyA9IGZ1bmN0aW9uICh1aVZpZXdzQnlGcW4sIHVpVmlldykgeyByZXR1cm4gZnVuY3Rpb24gKHZpZXdDb25maWcpIHtcbiAgICAgICAgLy8gRG9uJ3Qgc3VwcGx5IGFuIG5nMSB1aS12aWV3IHdpdGggYW4gbmcyIFZpZXdDb25maWcsIGV0Y1xuICAgICAgICBpZiAodWlWaWV3LiR0eXBlICE9PSB2aWV3Q29uZmlnLnZpZXdEZWNsLiR0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBTcGxpdCBuYW1lcyBhcGFydCBmcm9tIGJvdGggdmlld0NvbmZpZyBhbmQgdWlWaWV3IGludG8gc2VnbWVudHNcbiAgICAgICAgdmFyIHZjID0gdmlld0NvbmZpZy52aWV3RGVjbDtcbiAgICAgICAgdmFyIHZjU2VnbWVudHMgPSB2Yy4kdWlWaWV3TmFtZS5zcGxpdChcIi5cIik7XG4gICAgICAgIHZhciB1aXZTZWdtZW50cyA9IHVpVmlldy5mcW4uc3BsaXQoXCIuXCIpO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgdGFpbHMgb2YgdGhlIHNlZ21lbnQgYXJyYXlzIG1hdGNoLiBleCwgdGhlc2UgYXJyYXlzJyB0YWlscyBtYXRjaDpcbiAgICAgICAgLy8gdmM6IFtcImZvb1wiLCBcImJhclwiXSwgdWl2IGZxbjogW1wiJGRlZmF1bHRcIiwgXCJmb29cIiwgXCJiYXJcIl1cbiAgICAgICAgaWYgKCFjb21tb25fMS5lcXVhbHModmNTZWdtZW50cywgdWl2U2VnbWVudHMuc2xpY2UoMCAtIHZjU2VnbWVudHMubGVuZ3RoKSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIE5vdyBjaGVjayBpZiB0aGUgZnFuIGVuZGluZyBhdCB0aGUgZmlyc3Qgc2VnbWVudCBvZiB0aGUgdmlld0NvbmZpZyBtYXRjaGVzIHRoZSBjb250ZXh0OlxuICAgICAgICAvLyBbXCIkZGVmYXVsdFwiLCBcImZvb1wiXS5qb2luKFwiLlwiKSA9PSBcIiRkZWZhdWx0LmZvb1wiLCBkb2VzIHRoZSB1aS12aWV3ICRkZWZhdWx0LmZvbyBjb250ZXh0IG1hdGNoP1xuICAgICAgICB2YXIgbmVnT2Zmc2V0ID0gKDEgLSB2Y1NlZ21lbnRzLmxlbmd0aCkgfHwgdW5kZWZpbmVkO1xuICAgICAgICB2YXIgZnFuVG9GaXJzdFNlZ21lbnQgPSB1aXZTZWdtZW50cy5zbGljZSgwLCBuZWdPZmZzZXQpLmpvaW4oXCIuXCIpO1xuICAgICAgICB2YXIgdWlWaWV3Q29udGV4dCA9IHVpVmlld3NCeUZxbltmcW5Ub0ZpcnN0U2VnbWVudF0uY3JlYXRpb25Db250ZXh0O1xuICAgICAgICByZXR1cm4gdmMuJHVpVmlld0NvbnRleHRBbmNob3IgPT09ICh1aVZpZXdDb250ZXh0ICYmIHVpVmlld0NvbnRleHQubmFtZSk7XG4gICAgfTsgfTtcbiAgICByZXR1cm4gVmlld1NlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5WaWV3U2VydmljZSA9IFZpZXdTZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlldy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmlldy92aWV3LmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgY29yZVxuICovIC8qKiAqL1xudmFyIHN0YXRlUGFyYW1zXzEgPSByZXF1aXJlKFwiLi9wYXJhbXMvc3RhdGVQYXJhbXNcIik7XG52YXIgcXVldWVfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9xdWV1ZVwiKTtcbi8qKlxuICogR2xvYmFsIHJvdXRlciBzdGF0ZVxuICpcbiAqIFRoaXMgaXMgd2hlcmUgd2UgaG9sZCB0aGUgZ2xvYmFsIG11dGFibGUgc3RhdGUgc3VjaCBhcyBjdXJyZW50IHN0YXRlLCBjdXJyZW50XG4gKiBwYXJhbXMsIGN1cnJlbnQgdHJhbnNpdGlvbiwgZXRjLlxuICovXG52YXIgVUlSb3V0ZXJHbG9iYWxzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVJUm91dGVyR2xvYmFscygpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgcGFyYW1ldGVyIHZhbHVlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcGFyYW1ldGVyIHZhbHVlcyBmcm9tIHRoZSBsYXRlc3Qgc3VjY2Vzc2Z1bCB0cmFuc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcmFtcyA9IG5ldyBzdGF0ZVBhcmFtc18xLlN0YXRlUGFyYW1zKCk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICAgICAgdGhpcy5sYXN0U3RhcnRlZFRyYW5zaXRpb25JZCA9IC0xO1xuICAgICAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbkhpc3RvcnkgPSBuZXcgcXVldWVfMS5RdWV1ZShbXSwgMSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICAgICAgdGhpcy5zdWNjZXNzZnVsVHJhbnNpdGlvbnMgPSBuZXcgcXVldWVfMS5RdWV1ZShbXSwgMSk7XG4gICAgfVxuICAgIFVJUm91dGVyR2xvYmFscy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uSGlzdG9yeS5jbGVhcigpO1xuICAgICAgICB0aGlzLnN1Y2Nlc3NmdWxUcmFuc2l0aW9ucy5jbGVhcigpO1xuICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFVJUm91dGVyR2xvYmFscztcbn0oKSk7XG5leHBvcnRzLlVJUm91dGVyR2xvYmFscyA9IFVJUm91dGVyR2xvYmFscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2JhbHMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2dsb2JhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSB1cmxcbiAqLyAvKiogKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG4vKiogQGhpZGRlbiAqL1xudmFyIG1ha2VTdHViID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7IHJldHVybiAoYWNjW2tleV0gPSBjb3Jlc2VydmljZXNfMS5ub3RJbXBsZW1lbnRlZChrZXkpLCBhY2MpOyB9LCB7IGRpc3Bvc2U6IGNvbW1vbl8xLm5vb3AgfSk7XG59O1xuLyoqIEBoaWRkZW4gKi8gdmFyIGxvY2F0aW9uU2VydmljZXNGbnMgPSBbXCJ1cmxcIiwgXCJwYXRoXCIsIFwic2VhcmNoXCIsIFwiaGFzaFwiLCBcIm9uQ2hhbmdlXCJdO1xuLyoqIEBoaWRkZW4gKi8gdmFyIGxvY2F0aW9uQ29uZmlnRm5zID0gW1wicG9ydFwiLCBcInByb3RvY29sXCIsIFwiaG9zdFwiLCBcImJhc2VIcmVmXCIsIFwiaHRtbDVNb2RlXCIsIFwiaGFzaFByZWZpeFwiXTtcbi8qKiBAaGlkZGVuICovIHZhciB1bWZGbnMgPSBbXCJ0eXBlXCIsIFwiY2FzZUluc2Vuc2l0aXZlXCIsIFwic3RyaWN0TW9kZVwiLCBcImRlZmF1bHRTcXVhc2hQb2xpY3lcIl07XG4vKiogQGhpZGRlbiAqLyB2YXIgcnVsZXNGbnMgPSBbXCJzb3J0XCIsIFwid2hlblwiLCBcImluaXRpYWxcIiwgXCJvdGhlcndpc2VcIiwgXCJydWxlc1wiLCBcInJ1bGVcIiwgXCJyZW1vdmVSdWxlXCJdO1xuLyoqIEBoaWRkZW4gKi8gdmFyIHN5bmNGbnMgPSBbXCJkZWZlckludGVyY2VwdFwiLCBcImxpc3RlblwiLCBcInN5bmNcIiwgXCJtYXRjaFwiXTtcbi8qKlxuICogQVBJIGZvciBVUkwgbWFuYWdlbWVudFxuICovXG52YXIgVXJsU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGZ1bmN0aW9uIFVybFNlcnZpY2Uocm91dGVyLCBsYXRlQmluZCkge1xuICAgICAgICBpZiAobGF0ZUJpbmQgPT09IHZvaWQgMCkgeyBsYXRlQmluZCA9IHRydWU7IH1cbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHRoaXMucnVsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5jb25maWcgPSB7fTtcbiAgICAgICAgLy8gcHJveHkgZnVuY3Rpb24gY2FsbHMgZnJvbSBVcmxTZXJ2aWNlIHRvIHRoZSBMb2NhdGlvblNlcnZpY2UvTG9jYXRpb25Db25maWdcbiAgICAgICAgdmFyIGxvY2F0aW9uU2VydmljZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIubG9jYXRpb25TZXJ2aWNlOyB9O1xuICAgICAgICBjb21tb25fMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhsb2NhdGlvblNlcnZpY2VzLCB0aGlzLCBsb2NhdGlvblNlcnZpY2VzLCBsb2NhdGlvblNlcnZpY2VzRm5zLCBsYXRlQmluZCk7XG4gICAgICAgIHZhciBsb2NhdGlvbkNvbmZpZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci5sb2NhdGlvbkNvbmZpZzsgfTtcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnMobG9jYXRpb25Db25maWcsIHRoaXMuY29uZmlnLCBsb2NhdGlvbkNvbmZpZywgbG9jYXRpb25Db25maWdGbnMsIGxhdGVCaW5kKTtcbiAgICAgICAgdmFyIHVtZiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci51cmxNYXRjaGVyRmFjdG9yeTsgfTtcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnModW1mLCB0aGlzLmNvbmZpZywgdW1mLCB1bWZGbnMpO1xuICAgICAgICB2YXIgdXJsUm91dGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLnVybFJvdXRlcjsgfTtcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnModXJsUm91dGVyLCB0aGlzLnJ1bGVzLCB1cmxSb3V0ZXIsIHJ1bGVzRm5zKTtcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnModXJsUm91dGVyLCB0aGlzLCB1cmxSb3V0ZXIsIHN5bmNGbnMpO1xuICAgIH1cbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS51cmwgPSBmdW5jdGlvbiAobmV3dXJsLCByZXBsYWNlLCBzdGF0ZSkgeyByZXR1cm47IH07XG4gICAgO1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcbiAgICA7XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsU2VydmljZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XG4gICAgO1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcbiAgICA7XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsU2VydmljZS5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuOyB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IFVSTCBwYXJ0c1xuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgY3VycmVudCBVUkwgY29tcG9uZW50cyBhcyBhIFtbVXJsUGFydHNdXSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cmwgcGFydHNcbiAgICAgKi9cbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5wYXJ0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgcGF0aDogdGhpcy5wYXRoKCksIHNlYXJjaDogdGhpcy5zZWFyY2goKSwgaGFzaDogdGhpcy5oYXNoKCkgfTtcbiAgICB9O1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsU2VydmljZS5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uIChldnQpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChlbmFibGVkKSB7IHJldHVybjsgfTtcbiAgICA7XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsU2VydmljZS5wcm90b3R5cGUuZGVmZXJJbnRlcmNlcHQgPSBmdW5jdGlvbiAoZGVmZXIpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHVybFBhcnRzKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFVybFNlcnZpY2UubG9jYXRpb25TZXJ2aWNlU3R1YiA9IG1ha2VTdHViKGxvY2F0aW9uU2VydmljZXNGbnMpO1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVXJsU2VydmljZS5sb2NhdGlvbkNvbmZpZ1N0dWIgPSBtYWtlU3R1Yihsb2NhdGlvbkNvbmZpZ0Zucyk7XG4gICAgcmV0dXJuIFVybFNlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5VcmxTZXJ2aWNlID0gVXJsU2VydmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybFNlcnZpY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxTZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHRoYXQgcGVyZm9ybXMgbGF6eSBsb2FkaW5nXG4gKlxuICogV2hlbiBlbnRlcmluZyBhIHN0YXRlIFwiYWJjXCIgd2hpY2ggaGFzIGEgYGxhenlMb2FkYCBmdW5jdGlvbiBkZWZpbmVkOlxuICogLSBJbnZva2UgdGhlIGBsYXp5TG9hZGAgZnVuY3Rpb24gKHVubGVzcyBpdCBpcyBhbHJlYWR5IGluIHByb2Nlc3MpXG4gKiAgIC0gRmxhZyB0aGUgaG9vayBmdW5jdGlvbiBhcyBcImluIHByb2Nlc3NcIlxuICogICAtIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgcHJvbWlzZSAodGhhdCByZXNvbHZlcyB3aGVuIGxhenkgbG9hZGluZyBpcyBjb21wbGV0ZSlcbiAqIC0gV2FpdCBmb3IgdGhlIHByb21pc2UgdG8gc2V0dGxlXG4gKiAgIC0gSWYgdGhlIHByb21pc2UgcmVzb2x2ZXMgdG8gYSBbW0xhenlMb2FkUmVzdWx0XV0sIHRoZW4gcmVnaXN0ZXIgdGhvc2Ugc3RhdGVzXG4gKiAgIC0gRmxhZyB0aGUgaG9vayBmdW5jdGlvbiBhcyBcIm5vdCBpbiBwcm9jZXNzXCJcbiAqIC0gSWYgdGhlIGhvb2sgd2FzIHN1Y2Nlc3NmdWxcbiAqICAgLSBSZW1vdmUgdGhlIGBsYXp5TG9hZGAgZnVuY3Rpb24gZnJvbSB0aGUgc3RhdGUgZGVjbGFyYXRpb25cbiAqIC0gSWYgYWxsIHRoZSBob29rcyB3ZXJlIHN1Y2Nlc3NmdWxcbiAqICAgLSBSZXRyeSB0aGUgdHJhbnNpdGlvbiAoYnkgcmV0dXJuaW5nIGEgVGFyZ2V0U3RhdGUpXG4gKlxuICogYGBgXG4gKiAuc3RhdGUoJ2FiYycsIHtcbiAqICAgY29tcG9uZW50OiAnZm9vQ29tcG9uZW50JyxcbiAqICAgbGF6eUxvYWQ6ICgpID0+IFN5c3RlbS5pbXBvcnQoJy4vZm9vQ29tcG9uZW50JylcbiAqICAgfSk7XG4gKiBgYGBcbiAqXG4gKiBTZWUgW1tTdGF0ZURlY2xhcmF0aW9uLmxhenlMb2FkXV1cbiAqL1xudmFyIGxhenlMb2FkSG9vayA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG4gICAgdmFyIHJvdXRlciA9IHRyYW5zaXRpb24ucm91dGVyO1xuICAgIGZ1bmN0aW9uIHJldHJ5VHJhbnNpdGlvbigpIHtcbiAgICAgICAgaWYgKHRyYW5zaXRpb24ub3JpZ2luYWxUcmFuc2l0aW9uKCkub3B0aW9ucygpLnNvdXJjZSAhPT0gJ3VybCcpIHtcbiAgICAgICAgICAgIC8vIFRoZSBvcmlnaW5hbCB0cmFuc2l0aW9uIHdhcyBub3QgdHJpZ2dlcmVkIHZpYSB1cmwgc3luY1xuICAgICAgICAgICAgLy8gVGhlIGxhenkgc3RhdGUgc2hvdWxkIGJlIGxvYWRlZCBub3csIHNvIHJlLXRyeSB0aGUgb3JpZ2luYWwgdHJhbnNpdGlvblxuICAgICAgICAgICAgdmFyIG9yaWcgPSB0cmFuc2l0aW9uLnRhcmdldFN0YXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gcm91dGVyLnN0YXRlU2VydmljZS50YXJnZXQob3JpZy5pZGVudGlmaWVyKCksIG9yaWcucGFyYW1zKCksIG9yaWcub3B0aW9ucygpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgb3JpZ2luYWwgdHJhbnNpdGlvbiB3YXMgdHJpZ2dlcmVkIHZpYSB1cmwgc3luY1xuICAgICAgICAvLyBSdW4gdGhlIFVSTCBydWxlcyBhbmQgZmluZCB0aGUgYmVzdCBtYXRjaFxuICAgICAgICB2YXIgJHVybCA9IHJvdXRlci51cmxTZXJ2aWNlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJHVybC5tYXRjaCgkdXJsLnBhcnRzKCkpO1xuICAgICAgICB2YXIgcnVsZSA9IHJlc3VsdCAmJiByZXN1bHQucnVsZTtcbiAgICAgICAgLy8gSWYgdGhlIGJlc3QgbWF0Y2ggaXMgYSBzdGF0ZSwgcmVkaXJlY3QgdGhlIHRyYW5zaXRpb24gKGluc3RlYWRcbiAgICAgICAgLy8gb2YgY2FsbGluZyBzeW5jKCkgd2hpY2ggc3VwZXJzZWRlcyB0aGUgY3VycmVudCB0cmFuc2l0aW9uKVxuICAgICAgICBpZiAocnVsZSAmJiBydWxlLnR5cGUgPT09IFwiU1RBVEVcIikge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gcnVsZS5zdGF0ZTtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSByZXN1bHQubWF0Y2g7XG4gICAgICAgICAgICByZXR1cm4gcm91dGVyLnN0YXRlU2VydmljZS50YXJnZXQoc3RhdGUsIHBhcmFtcywgdHJhbnNpdGlvbi5vcHRpb25zKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG1hdGNoaW5nIHN0YXRlIGZvdW5kLCBzbyBsZXQgLnN5bmMoKSBjaG9vc2UgdGhlIGJlc3Qgbm9uLXN0YXRlIG1hdGNoL290aGVyd2lzZVxuICAgICAgICByb3V0ZXIudXJsU2VydmljZS5zeW5jKCk7XG4gICAgfVxuICAgIHZhciBwcm9taXNlcyA9IHRyYW5zaXRpb24uZW50ZXJpbmcoKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gISFzdGF0ZS4kJHN0YXRlKCkubGF6eUxvYWQ7IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBsYXp5TG9hZFN0YXRlKHRyYW5zaXRpb24sIHN0YXRlKTsgfSk7XG4gICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLmFsbChwcm9taXNlcykudGhlbihyZXRyeVRyYW5zaXRpb24pO1xufTtcbmV4cG9ydHMucmVnaXN0ZXJMYXp5TG9hZEhvb2sgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25CZWZvcmUoeyBlbnRlcmluZzogZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAhIXN0YXRlLmxhenlMb2FkOyB9IH0sIGxhenlMb2FkSG9vayk7XG59O1xuLyoqXG4gKiBJbnZva2VzIGEgc3RhdGUncyBsYXp5IGxvYWQgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gdHJhbnNpdGlvbiBhIFRyYW5zaXRpb24gY29udGV4dFxuICogQHBhcmFtIHN0YXRlIHRoZSBzdGF0ZSB0byBsYXp5IGxvYWRcbiAqIEByZXR1cm5zIEEgcHJvbWlzZSBmb3IgdGhlIGxhenkgbG9hZCByZXN1bHRcbiAqL1xuZnVuY3Rpb24gbGF6eUxvYWRTdGF0ZSh0cmFuc2l0aW9uLCBzdGF0ZSkge1xuICAgIHZhciBsYXp5TG9hZEZuID0gc3RhdGUuJCRzdGF0ZSgpLmxhenlMb2FkO1xuICAgIC8vIFN0b3JlL2dldCB0aGUgbGF6eSBsb2FkIHByb21pc2Ugb24vZnJvbSB0aGUgaG9va2ZuIHNvIGl0IGRvZXNuJ3QgZ2V0IHJlLWludm9rZWRcbiAgICB2YXIgcHJvbWlzZSA9IGxhenlMb2FkRm5bJ19wcm9taXNlJ107XG4gICAgaWYgKCFwcm9taXNlKSB7XG4gICAgICAgIHZhciBzdWNjZXNzID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmxhenlMb2FkO1xuICAgICAgICAgICAgZGVsZXRlIHN0YXRlLiQkc3RhdGUoKS5sYXp5TG9hZDtcbiAgICAgICAgICAgIGRlbGV0ZSBsYXp5TG9hZEZuWydfcHJvbWlzZSddO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgZGVsZXRlIGxhenlMb2FkRm5bJ19wcm9taXNlJ107XG4gICAgICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEucmVqZWN0KGVycik7XG4gICAgICAgIH07XG4gICAgICAgIHByb21pc2UgPSBsYXp5TG9hZEZuWydfcHJvbWlzZSddID1cbiAgICAgICAgICAgIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4obGF6eUxvYWRGbih0cmFuc2l0aW9uLCBzdGF0ZSkpXG4gICAgICAgICAgICAgICAgLnRoZW4odXBkYXRlU3RhdGVSZWdpc3RyeSlcbiAgICAgICAgICAgICAgICAudGhlbihzdWNjZXNzLCBlcnJvcik7XG4gICAgfVxuICAgIC8qKiBSZWdpc3RlciBhbnkgbGF6eSBsb2FkZWQgc3RhdGUgZGVmaW5pdGlvbnMgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVTdGF0ZVJlZ2lzdHJ5KHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0ICYmIEFycmF5LmlzQXJyYXkocmVzdWx0LnN0YXRlcykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIHRyYW5zaXRpb24ucm91dGVyLnN0YXRlUmVnaXN0cnkucmVnaXN0ZXIoc3RhdGUpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmV4cG9ydHMubGF6eUxvYWRTdGF0ZSA9IGxhenlMb2FkU3RhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXp5TG9hZC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvbGF6eUxvYWQuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRyYW5zaXRpb25Ib29rXzEgPSByZXF1aXJlKFwiLi90cmFuc2l0aW9uSG9va1wiKTtcbi8qKlxuICogVGhpcyBjbGFzcyBkZWZpbmVzIGEgdHlwZSBvZiBob29rLCBzdWNoIGFzIGBvbkJlZm9yZWAgb3IgYG9uRW50ZXJgLlxuICogUGx1Z2lucyBjYW4gZGVmaW5lIGN1c3RvbSBob29rIHR5cGVzLCBzdWNoIGFzIHN0aWNreSBzdGF0ZXMgZG9lcyBmb3IgYG9uSW5hY3RpdmVgLlxuICpcbiAqIEBpbnRlcmFsYXBpXG4gKi9cbnZhciBUcmFuc2l0aW9uRXZlbnRUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25FdmVudFR5cGUobmFtZSwgaG9va1BoYXNlLCBob29rT3JkZXIsIGNyaXRlcmlhTWF0Y2hQYXRoLCByZXZlcnNlU29ydCwgZ2V0UmVzdWx0SGFuZGxlciwgZ2V0RXJyb3JIYW5kbGVyLCBzeW5jaHJvbm91cykge1xuICAgICAgICBpZiAocmV2ZXJzZVNvcnQgPT09IHZvaWQgMCkgeyByZXZlcnNlU29ydCA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChnZXRSZXN1bHRIYW5kbGVyID09PSB2b2lkIDApIHsgZ2V0UmVzdWx0SGFuZGxlciA9IHRyYW5zaXRpb25Ib29rXzEuVHJhbnNpdGlvbkhvb2suSEFORExFX1JFU1VMVDsgfVxuICAgICAgICBpZiAoZ2V0RXJyb3JIYW5kbGVyID09PSB2b2lkIDApIHsgZ2V0RXJyb3JIYW5kbGVyID0gdHJhbnNpdGlvbkhvb2tfMS5UcmFuc2l0aW9uSG9vay5SRUpFQ1RfRVJST1I7IH1cbiAgICAgICAgaWYgKHN5bmNocm9ub3VzID09PSB2b2lkIDApIHsgc3luY2hyb25vdXMgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmhvb2tQaGFzZSA9IGhvb2tQaGFzZTtcbiAgICAgICAgdGhpcy5ob29rT3JkZXIgPSBob29rT3JkZXI7XG4gICAgICAgIHRoaXMuY3JpdGVyaWFNYXRjaFBhdGggPSBjcml0ZXJpYU1hdGNoUGF0aDtcbiAgICAgICAgdGhpcy5yZXZlcnNlU29ydCA9IHJldmVyc2VTb3J0O1xuICAgICAgICB0aGlzLmdldFJlc3VsdEhhbmRsZXIgPSBnZXRSZXN1bHRIYW5kbGVyO1xuICAgICAgICB0aGlzLmdldEVycm9ySGFuZGxlciA9IGdldEVycm9ySGFuZGxlcjtcbiAgICAgICAgdGhpcy5zeW5jaHJvbm91cyA9IHN5bmNocm9ub3VzO1xuICAgIH1cbiAgICByZXR1cm4gVHJhbnNpdGlvbkV2ZW50VHlwZTtcbn0oKSk7XG5leHBvcnRzLlRyYW5zaXRpb25FdmVudFR5cGUgPSBUcmFuc2l0aW9uRXZlbnRUeXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNpdGlvbkV2ZW50VHlwZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi90cmFuc2l0aW9uRXZlbnRUeXBlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKiBAbW9kdWxlIHZhbmlsbGFcbiAqL1xuLyoqICovXG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaW5kZXhcIik7XG4vKipcbiAqIEFuIGFuZ3VsYXIxLWxpa2UgcHJvbWlzZSBhcGlcbiAqXG4gKiBUaGlzIG9iamVjdCBpbXBsZW1lbnRzIGZvdXIgbWV0aG9kcyBzaW1pbGFyIHRvIHRoZVxuICogW2FuZ3VsYXIgMSBwcm9taXNlIGFwaV0oaHR0cHM6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL25nL3NlcnZpY2UvJHEpXG4gKlxuICogVUktUm91dGVyIGV2b2x2ZWQgZnJvbSBhbiBhbmd1bGFyIDEgbGlicmFyeSB0byBhIGZyYW1ld29yayBhZ25vc3RpYyBsaWJyYXJ5LlxuICogSG93ZXZlciwgc29tZSBvZiB0aGUgYEB1aXJvdXRlci9jb3JlYCBjb2RlIHVzZXMgdGhlc2UgbmcxIHN0eWxlIEFQSXMgdG8gc3VwcG9ydCBuZzEgc3R5bGUgZGVwZW5kZW5jeSBpbmplY3Rpb24uXG4gKlxuICogVGhpcyBBUEkgcHJvdmlkZXMgbmF0aXZlIEVTNiBwcm9taXNlIHN1cHBvcnQgd3JhcHBlZCBhcyBhICRxLWxpa2UgQVBJLlxuICogSW50ZXJuYWxseSwgVUktUm91dGVyIHVzZXMgdGhpcyAkcSBvYmplY3QgdG8gcGVyZm9ybSBwcm9taXNlIG9wZXJhdGlvbnMuXG4gKiBUaGUgYGFuZ3VsYXItdWktcm91dGVyYCAodWktcm91dGVyIGZvciBhbmd1bGFyIDEpIHVzZXMgdGhlICRxIEFQSSBwcm92aWRlZCBieSBhbmd1bGFyLlxuICpcbiAqICRxLWxpa2UgcHJvbWlzZSBhcGlcbiAqL1xuZXhwb3J0cy4kcSA9IHtcbiAgICAvKiogTm9ybWFsaXplcyBhIHZhbHVlIGFzIGEgcHJvbWlzZSAqL1xuICAgIHdoZW46IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgcmV0dXJuIHJlc29sdmUodmFsKTsgfSk7IH0sXG4gICAgLyoqIE5vcm1hbGl6ZXMgYSB2YWx1ZSBhcyBhIHByb21pc2UgcmVqZWN0aW9uICovXG4gICAgcmVqZWN0OiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHJlamVjdCh2YWwpOyB9KTsgfSxcbiAgICAvKiogQHJldHVybnMgYSBkZWZlcnJlZCBvYmplY3QsIHdoaWNoIGhhcyBgcmVzb2x2ZWAgYW5kIGByZWplY3RgIGZ1bmN0aW9ucyAqL1xuICAgIGRlZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IHt9O1xuICAgICAgICBkZWZlcnJlZC5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQ7XG4gICAgfSxcbiAgICAvKiogTGlrZSBQcm9taXNlLmFsbCgpLCBidXQgYWxzbyBzdXBwb3J0cyBvYmplY3Qga2V5L3Byb21pc2Ugbm90YXRpb24gbGlrZSAkcSAqL1xuICAgIGFsbDogZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIGlmIChpbmRleF8xLmlzQXJyYXkocHJvbWlzZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleF8xLmlzT2JqZWN0KHByb21pc2VzKSkge1xuICAgICAgICAgICAgLy8gQ29udmVydCBwcm9taXNlcyBtYXAgdG8gcHJvbWlzZXMgYXJyYXkuXG4gICAgICAgICAgICAvLyBXaGVuIGVhY2ggcHJvbWlzZSByZXNvbHZlcywgbWFwIGl0IHRvIGEgdHVwbGUgeyBrZXk6IGtleSwgdmFsOiB2YWwgfVxuICAgICAgICAgICAgdmFyIGNoYWluID0gT2JqZWN0LmtleXMocHJvbWlzZXMpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBwcm9taXNlc1trZXldLnRoZW4oZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gKHsga2V5OiBrZXksIHZhbDogdmFsIH0pOyB9KTsgfSk7XG4gICAgICAgICAgICAvLyBUaGVuIHdhaXQgZm9yIGFsbCBwcm9taXNlcyB0byByZXNvbHZlLCBhbmQgY29udmVydCB0aGVtIGJhY2sgdG8gYW4gb2JqZWN0XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy4kcS5hbGwoY2hhaW4pLnRoZW4oZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHR1cGxlKSB7IGFjY1t0dXBsZS5rZXldID0gdHVwbGUudmFsOyByZXR1cm4gYWNjOyB9LCB7fSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL3EuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBtb2R1bGUgdmFuaWxsYVxuICovXG4vKiogKi9cbnZhciBpbmRleF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9pbmRleFwiKTtcbi8vIGdsb2JhbGx5IGF2YWlsYWJsZSBpbmplY3RhYmxlc1xudmFyIGdsb2JhbHMgPSB7fTtcbnZhciBTVFJJUF9DT01NRU5UUyA9IC8oKFxcL1xcLy4qJCl8KFxcL1xcKltcXHNcXFNdKj9cXCpcXC8pKS9tZztcbnZhciBBUkdVTUVOVF9OQU1FUyA9IC8oW15cXHMsXSspL2c7XG4vKipcbiAqIEEgYmFzaWMgYW5ndWxhcjEtbGlrZSBpbmplY3RvciBhcGlcbiAqXG4gKiBUaGlzIG9iamVjdCBpbXBsZW1lbnRzIGZvdXIgbWV0aG9kcyBzaW1pbGFyIHRvIHRoZVxuICogW2FuZ3VsYXIgMSBkZXBlbmRlbmN5IGluamVjdG9yXShodHRwczovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvYXV0by9zZXJ2aWNlLyRpbmplY3RvcilcbiAqXG4gKiBVSS1Sb3V0ZXIgZXZvbHZlZCBmcm9tIGFuIGFuZ3VsYXIgMSBsaWJyYXJ5IHRvIGEgZnJhbWV3b3JrIGFnbm9zdGljIGxpYnJhcnkuXG4gKiBIb3dldmVyLCBzb21lIG9mIHRoZSBgQHVpcm91dGVyL2NvcmVgIGNvZGUgdXNlcyB0aGVzZSBuZzEgc3R5bGUgQVBJcyB0byBzdXBwb3J0IG5nMSBzdHlsZSBkZXBlbmRlbmN5IGluamVjdGlvbi5cbiAqXG4gKiBUaGlzIG9iamVjdCBwcm92aWRlcyBhIG5haXZlIGltcGxlbWVudGF0aW9uIG9mIGEgZ2xvYmFsbHkgc2NvcGVkIGRlcGVuZGVuY3kgaW5qZWN0aW9uIHN5c3RlbS5cbiAqIEl0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgREkgYXBwcm9hY2hlczpcbiAqXG4gKiAjIyMgRnVuY3Rpb24gcGFyYW1ldGVyIG5hbWVzXG4gKlxuICogQSBmdW5jdGlvbidzIGAudG9TdHJpbmcoKWAgaXMgY2FsbGVkLCBhbmQgdGhlIHBhcmFtZXRlciBuYW1lcyBhcmUgcGFyc2VkLlxuICogVGhpcyBvbmx5IHdvcmtzIHdoZW4gdGhlIHBhcmFtZXRlciBuYW1lcyBhcmVuJ3QgXCJtYW5nbGVkXCIgYnkgYSBtaW5pZmllciBzdWNoIGFzIFVnbGlmeUpTLlxuICpcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbiBpbmplY3RlZEZ1bmN0aW9uKEZvb1NlcnZpY2UsIEJhclNlcnZpY2UpIHtcbiAqICAgLy8gRm9vU2VydmljZSBhbmQgQmFyU2VydmljZSBhcmUgaW5qZWN0ZWRcbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIyBGdW5jdGlvbiBhbm5vdGF0aW9uXG4gKlxuICogQSBmdW5jdGlvbiBtYXkgYmUgYW5ub3RhdGVkIHdpdGggYW4gYXJyYXkgb2YgZGVwZW5kZW5jeSBuYW1lcyBhcyB0aGUgYCRpbmplY3RgIHByb3BlcnR5LlxuICpcbiAqIGBgYGpzXG4gKiBpbmplY3RlZEZ1bmN0aW9uLiRpbmplY3QgPSBbICdGb29TZXJ2aWNlJywgJ0JhclNlcnZpY2UnIF07XG4gKiBmdW5jdGlvbiBpbmplY3RlZEZ1bmN0aW9uKGZzLCBicykge1xuICogICAvLyBGb29TZXJ2aWNlIGFuZCBCYXJTZXJ2aWNlIGFyZSBpbmplY3RlZCBhcyBmcyBhbmQgYnMgcGFyYW1ldGVyc1xuICogfVxuICogYGBgXG4gKlxuICogIyMjIEFycmF5IG5vdGF0aW9uXG4gKlxuICogQW4gYXJyYXkgcHJvdmlkZXMgdGhlIG5hbWVzIG9mIHRoZSBkZXBlbmRlbmNpZXMgdG8gaW5qZWN0IChhcyBzdHJpbmdzKS5cbiAqIFRoZSBmdW5jdGlvbiBpcyB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBhcnJheS5cbiAqXG4gKiBgYGBqc1xuICogWyAnRm9vU2VydmljZScsICdCYXJTZXJ2aWNlJywgZnVuY3Rpb24gKGZzLCBicykge1xuICogICAvLyBGb29TZXJ2aWNlIGFuZCBCYXJTZXJ2aWNlIGFyZSBpbmplY3RlZCBhcyBmcyBhbmQgYnMgcGFyYW1ldGVyc1xuICogfV1cbiAqIGBgYFxuICpcbiAqIEB0eXBlIHskSW5qZWN0b3JMaWtlfVxuICovXG5leHBvcnRzLiRpbmplY3RvciA9IHtcbiAgICAvKiogR2V0cyBhbiBvYmplY3QgZnJvbSBESSBiYXNlZCBvbiBhIHN0cmluZyB0b2tlbiAqL1xuICAgIGdldDogZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGdsb2JhbHNbbmFtZV07IH0sXG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiBhbiBvYmplY3QgbmFtZWQgYG5hbWVgIGV4aXN0cyBpbiBnbG9iYWwgREkgKi9cbiAgICBoYXM6IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBleHBvcnRzLiRpbmplY3Rvci5nZXQobmFtZSkgIT0gbnVsbDsgfSxcbiAgICAvKipcbiAgICAgKiBJbmplY3RzIGEgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiB0aGUgZnVuY3Rpb24gdG8gaW5qZWN0XG4gICAgICogQHBhcmFtIGNvbnRleHQgdGhlIGZ1bmN0aW9uJ3MgYHRoaXNgIGJpbmRpbmdcbiAgICAgKiBAcGFyYW0gbG9jYWxzIEFuIG9iamVjdCB3aXRoIGFkZGl0aW9uYWwgREkgdG9rZW5zIGFuZCB2YWx1ZXMsIHN1Y2ggYXMgYHsgc29tZVRva2VuOiB7IGZvbzogMSB9IH1gXG4gICAgICovXG4gICAgaW52b2tlOiBmdW5jdGlvbiAoZm4sIGNvbnRleHQsIGxvY2Fscykge1xuICAgICAgICB2YXIgYWxsID0gaW5kZXhfMS5leHRlbmQoe30sIGdsb2JhbHMsIGxvY2FscyB8fCB7fSk7XG4gICAgICAgIHZhciBwYXJhbXMgPSBleHBvcnRzLiRpbmplY3Rvci5hbm5vdGF0ZShmbik7XG4gICAgICAgIHZhciBlbnN1cmVFeGlzdCA9IGluZGV4XzEuYXNzZXJ0UHJlZGljYXRlKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGFsbC5oYXNPd25Qcm9wZXJ0eShrZXkpOyB9LCBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBcIkRJIGNhbid0IGZpbmQgaW5qZWN0YWJsZTogJ1wiICsga2V5ICsgXCInXCI7IH0pO1xuICAgICAgICB2YXIgYXJncyA9IHBhcmFtcy5maWx0ZXIoZW5zdXJlRXhpc3QpLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gYWxsW3hdOyB9KTtcbiAgICAgICAgaWYgKGluZGV4XzEuaXNGdW5jdGlvbihmbikpXG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmbi5zbGljZSgtMSlbMF0uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24ncyBkZXBlbmRlbmNpZXNcbiAgICAgKlxuICAgICAqIEFuYWx5emVzIGEgZnVuY3Rpb24gKG9yIGFycmF5KSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBESSB0b2tlbnMgdGhhdCB0aGUgZnVuY3Rpb24gcmVxdWlyZXMuXG4gICAgICogQHJldHVybiBhbiBhcnJheSBvZiBgc3RyaW5nYHNcbiAgICAgKi9cbiAgICBhbm5vdGF0ZTogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGlmICghaW5kZXhfMS5pc0luamVjdGFibGUoZm4pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGFuIGluamVjdGFibGUgZnVuY3Rpb246IFwiICsgZm4pO1xuICAgICAgICBpZiAoZm4gJiYgZm4uJGluamVjdClcbiAgICAgICAgICAgIHJldHVybiBmbi4kaW5qZWN0O1xuICAgICAgICBpZiAoaW5kZXhfMS5pc0FycmF5KGZuKSlcbiAgICAgICAgICAgIHJldHVybiBmbi5zbGljZSgwLCAtMSk7XG4gICAgICAgIHZhciBmblN0ciA9IGZuLnRvU3RyaW5nKCkucmVwbGFjZShTVFJJUF9DT01NRU5UUywgJycpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZm5TdHIuc2xpY2UoZm5TdHIuaW5kZXhPZignKCcpICsgMSwgZm5TdHIuaW5kZXhPZignKScpKS5tYXRjaChBUkdVTUVOVF9OQU1FUyk7XG4gICAgICAgIHJldHVybiByZXN1bHQgfHwgW107XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluamVjdG9yLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL2luamVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBtb2R1bGUgdmFuaWxsYVxuICovXG4vKiogKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG52YXIgYmFzZUxvY2F0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vYmFzZUxvY2F0aW9uU2VydmljZVwiKTtcbi8qKiBBIGBMb2NhdGlvblNlcnZpY2VzYCB0aGF0IHVzZXMgdGhlIGJyb3dzZXIgaGFzaCBcIiNcIiB0byBnZXQvc2V0IHRoZSBjdXJyZW50IGxvY2F0aW9uICovXG52YXIgSGFzaExvY2F0aW9uU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSGFzaExvY2F0aW9uU2VydmljZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIYXNoTG9jYXRpb25TZXJ2aWNlKHJvdXRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByb3V0ZXIsIGZhbHNlKSB8fCB0aGlzO1xuICAgICAgICBjb21tb25fMS5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCBfdGhpcy5fbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBIYXNoTG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEudHJpbUhhc2hWYWwodGhpcy5fbG9jYXRpb24uaGFzaCk7XG4gICAgfTtcbiAgICBIYXNoTG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgdXJsLCByZXBsYWNlKSB7XG4gICAgICAgIHRoaXMuX2xvY2F0aW9uLmhhc2ggPSB1cmw7XG4gICAgfTtcbiAgICBIYXNoTG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzLCByb3V0ZXIpO1xuICAgICAgICBjb21tb25fMS5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9saXN0ZW5lcik7XG4gICAgfTtcbiAgICByZXR1cm4gSGFzaExvY2F0aW9uU2VydmljZTtcbn0oYmFzZUxvY2F0aW9uU2VydmljZV8xLkJhc2VMb2NhdGlvblNlcnZpY2VzKSk7XG5leHBvcnRzLkhhc2hMb2NhdGlvblNlcnZpY2UgPSBIYXNoTG9jYXRpb25TZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaExvY2F0aW9uU2VydmljZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9oYXNoTG9jYXRpb25TZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBtb2R1bGUgdmFuaWxsYVxuICovXG4vKiogKi9cbnZhciBiYXNlTG9jYXRpb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9iYXNlTG9jYXRpb25TZXJ2aWNlXCIpO1xuLyoqIEEgYExvY2F0aW9uU2VydmljZXNgIHRoYXQgZ2V0cy9zZXRzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGZyb20gYW4gaW4tbWVtb3J5IG9iamVjdCAqL1xudmFyIE1lbW9yeUxvY2F0aW9uU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVtb3J5TG9jYXRpb25TZXJ2aWNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lbW9yeUxvY2F0aW9uU2VydmljZShyb3V0ZXIpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHJvdXRlciwgdHJ1ZSkgfHwgdGhpcztcbiAgICB9XG4gICAgTWVtb3J5TG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJsO1xuICAgIH07XG4gICAgTWVtb3J5TG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgdXJsLCByZXBsYWNlKSB7XG4gICAgICAgIHRoaXMuX3VybCA9IHVybDtcbiAgICB9O1xuICAgIHJldHVybiBNZW1vcnlMb2NhdGlvblNlcnZpY2U7XG59KGJhc2VMb2NhdGlvblNlcnZpY2VfMS5CYXNlTG9jYXRpb25TZXJ2aWNlcykpO1xuZXhwb3J0cy5NZW1vcnlMb2NhdGlvblNlcnZpY2UgPSBNZW1vcnlMb2NhdGlvblNlcnZpY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW1vcnlMb2NhdGlvblNlcnZpY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvbWVtb3J5TG9jYXRpb25TZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJhc2VMb2NhdGlvblNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2Jhc2VMb2NhdGlvblNlcnZpY2VcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuLyoqXG4gKiBBIGBMb2NhdGlvblNlcnZpY2VzYCB0aGF0IGdldHMvc2V0cyB0aGUgY3VycmVudCBsb2NhdGlvbiB1c2luZyB0aGUgYnJvd3NlcidzIGBsb2NhdGlvbmAgYW5kIGBoaXN0b3J5YCBhcGlzXG4gKlxuICogVXNlcyBgaGlzdG9yeS5wdXNoU3RhdGVgIGFuZCBgaGlzdG9yeS5yZXBsYWNlU3RhdGVgXG4gKi9cbnZhciBQdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQdXNoU3RhdGVMb2NhdGlvblNlcnZpY2Uocm91dGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJvdXRlciwgdHJ1ZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2NvbmZpZyA9IHJvdXRlci51cmxTZXJ2aWNlLmNvbmZpZztcbiAgICAgICAgY29tbW9uXzEucm9vdC5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIF90aGlzLl9saXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBiYXNlIHByZWZpeCB3aXRob3V0OlxuICAgICAqIC0gdHJhaWxpbmcgc2xhc2hcbiAgICAgKiAtIHRyYWlsaW5nIGZpbGVuYW1lXG4gICAgICogLSBwcm90b2NvbCBhbmQgaG9zdG5hbWVcbiAgICAgKlxuICAgICAqIElmIDxiYXNlIGhyZWY9Jy9iYXNlL2luZGV4Lmh0bWwnPiwgdGhpcyByZXR1cm5zICcvYmFzZScuXG4gICAgICogSWYgPGJhc2UgaHJlZj0naHR0cDovL2xvY2FsaG9zdDo4MDgwL2Jhc2UvaW5kZXguaHRtbCc+LCB0aGlzIHJldHVybnMgJy9iYXNlJy5cbiAgICAgKlxuICAgICAqIFNlZTogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9kZXYvc2VtYW50aWNzLmh0bWwjdGhlLWJhc2UtZWxlbWVudFxuICAgICAqL1xuICAgIFB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZS5wcm90b3R5cGUuX2dldEJhc2VQcmVmaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb21tb25fMS5zdHJpcEZpbGUodGhpcy5fY29uZmlnLmJhc2VIcmVmKCkpO1xuICAgIH07XG4gICAgUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9sb2NhdGlvbiwgcGF0aG5hbWUgPSBfYS5wYXRobmFtZSwgaGFzaCA9IF9hLmhhc2gsIHNlYXJjaCA9IF9hLnNlYXJjaDtcbiAgICAgICAgc2VhcmNoID0gY29tbW9uXzEuc3BsaXRRdWVyeShzZWFyY2gpWzFdOyAvLyBzdHJpcCA/IGlmIGZvdW5kXG4gICAgICAgIGhhc2ggPSBjb21tb25fMS5zcGxpdEhhc2goaGFzaClbMV07IC8vIHN0cmlwICMgaWYgZm91bmRcbiAgICAgICAgdmFyIGJhc2VQcmVmaXggPSB0aGlzLl9nZXRCYXNlUHJlZml4KCk7XG4gICAgICAgIHZhciBleGFjdE1hdGNoID0gcGF0aG5hbWUgPT09IHRoaXMuX2NvbmZpZy5iYXNlSHJlZigpO1xuICAgICAgICB2YXIgc3RhcnRzV2l0aCA9IHBhdGhuYW1lLnN0YXJ0c1dpdGgoYmFzZVByZWZpeCk7XG4gICAgICAgIHBhdGhuYW1lID0gZXhhY3RNYXRjaCA/ICcvJyA6IHN0YXJ0c1dpdGggPyBwYXRobmFtZS5zdWJzdHJpbmcoYmFzZVByZWZpeC5sZW5ndGgpIDogcGF0aG5hbWU7XG4gICAgICAgIHJldHVybiBwYXRobmFtZSArIChzZWFyY2ggPyAnPycgKyBzZWFyY2ggOiAnJykgKyAoaGFzaCA/ICcjJyArIGhhc2ggOiAnJyk7XG4gICAgfTtcbiAgICBQdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UucHJvdG90eXBlLl9zZXQgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCB1cmwsIHJlcGxhY2UpIHtcbiAgICAgICAgdmFyIGZ1bGxVcmwgPSB0aGlzLl9nZXRCYXNlUHJlZml4KCkgKyB1cmw7XG4gICAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgICAgICB0aGlzLl9oaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIGZ1bGxVcmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCBmdWxsVXJsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzLCByb3V0ZXIpO1xuICAgICAgICBjb21tb25fMS5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5fbGlzdGVuZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIFB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZTtcbn0oYmFzZUxvY2F0aW9uU2VydmljZV8xLkJhc2VMb2NhdGlvblNlcnZpY2VzKSk7XG5leHBvcnRzLlB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZSA9IFB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9wdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xuLyoqIEEgYExvY2F0aW9uQ29uZmlnYCBtb2NrIHRoYXQgZ2V0cy9zZXRzIGFsbCBjb25maWcgZnJvbSBhbiBpbi1tZW1vcnkgb2JqZWN0ICovXG52YXIgTWVtb3J5TG9jYXRpb25Db25maWcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVtb3J5TG9jYXRpb25Db25maWcoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2Jhc2VIcmVmID0gJyc7XG4gICAgICAgIHRoaXMuX3BvcnQgPSA4MDtcbiAgICAgICAgdGhpcy5fcHJvdG9jb2wgPSBcImh0dHBcIjtcbiAgICAgICAgdGhpcy5faG9zdCA9IFwibG9jYWxob3N0XCI7XG4gICAgICAgIHRoaXMuX2hhc2hQcmVmaXggPSBcIlwiO1xuICAgICAgICB0aGlzLnBvcnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fcG9ydDsgfTtcbiAgICAgICAgdGhpcy5wcm90b2NvbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9wcm90b2NvbDsgfTtcbiAgICAgICAgdGhpcy5ob3N0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2hvc3Q7IH07XG4gICAgICAgIHRoaXMuYmFzZUhyZWYgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fYmFzZUhyZWY7IH07XG4gICAgICAgIHRoaXMuaHRtbDVNb2RlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgICAgIHRoaXMuaGFzaFByZWZpeCA9IGZ1bmN0aW9uIChuZXd2YWwpIHsgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0RlZmluZWQobmV3dmFsKSA/IF90aGlzLl9oYXNoUHJlZml4ID0gbmV3dmFsIDogX3RoaXMuX2hhc2hQcmVmaXg7IH07XG4gICAgICAgIHRoaXMuZGlzcG9zZSA9IGNvbW1vbl8xLm5vb3A7XG4gICAgfVxuICAgIHJldHVybiBNZW1vcnlMb2NhdGlvbkNvbmZpZztcbn0oKSk7XG5leHBvcnRzLk1lbW9yeUxvY2F0aW9uQ29uZmlnID0gTWVtb3J5TG9jYXRpb25Db25maWc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW1vcnlMb2NhdGlvbkNvbmZpZy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9tZW1vcnlMb2NhdGlvbkNvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSB2YW5pbGxhXG4gKi9cbi8qKiAqL1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbi8qKiBBIGBMb2NhdGlvbkNvbmZpZ2AgdGhhdCBkZWxlZ2F0ZXMgdG8gdGhlIGJyb3dzZXIncyBgbG9jYXRpb25gIG9iamVjdCAqL1xudmFyIEJyb3dzZXJMb2NhdGlvbkNvbmZpZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCcm93c2VyTG9jYXRpb25Db25maWcocm91dGVyLCBfaXNIdG1sNSkge1xuICAgICAgICBpZiAoX2lzSHRtbDUgPT09IHZvaWQgMCkgeyBfaXNIdG1sNSA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuX2lzSHRtbDUgPSBfaXNIdG1sNTtcbiAgICAgICAgdGhpcy5fYmFzZUhyZWYgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2hhc2hQcmVmaXggPSBcIlwiO1xuICAgIH1cbiAgICBCcm93c2VyTG9jYXRpb25Db25maWcucHJvdG90eXBlLnBvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChsb2NhdGlvbi5wb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKGxvY2F0aW9uLnBvcnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3RvY29sKCkgPT09ICdodHRwcycgPyA0NDMgOiA4MDtcbiAgICB9O1xuICAgIEJyb3dzZXJMb2NhdGlvbkNvbmZpZy5wcm90b3R5cGUucHJvdG9jb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbi5wcm90b2NvbC5yZXBsYWNlKC86L2csICcnKTtcbiAgICB9O1xuICAgIEJyb3dzZXJMb2NhdGlvbkNvbmZpZy5wcm90b3R5cGUuaG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmhvc3RuYW1lO1xuICAgIH07XG4gICAgQnJvd3NlckxvY2F0aW9uQ29uZmlnLnByb3RvdHlwZS5odG1sNU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0h0bWw1O1xuICAgIH07XG4gICAgQnJvd3NlckxvY2F0aW9uQ29uZmlnLnByb3RvdHlwZS5oYXNoUHJlZml4ID0gZnVuY3Rpb24gKG5ld3ByZWZpeCkge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzRGVmaW5lZChuZXdwcmVmaXgpID8gdGhpcy5faGFzaFByZWZpeCA9IG5ld3ByZWZpeCA6IHRoaXMuX2hhc2hQcmVmaXg7XG4gICAgfTtcbiAgICA7XG4gICAgQnJvd3NlckxvY2F0aW9uQ29uZmlnLnByb3RvdHlwZS5iYXNlSHJlZiA9IGZ1bmN0aW9uIChocmVmKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGhyZWYpID8gdGhpcy5fYmFzZUhyZWYgPSBocmVmIDpcbiAgICAgICAgICAgIHByZWRpY2F0ZXNfMS5pc0RlZmluZWQodGhpcy5fYmFzZUhyZWYpID8gdGhpcy5fYmFzZUhyZWYgOiB0aGlzLmFwcGx5RG9jdW1lbnRCYXNlSHJlZigpO1xuICAgIH07XG4gICAgQnJvd3NlckxvY2F0aW9uQ29uZmlnLnByb3RvdHlwZS5hcHBseURvY3VtZW50QmFzZUhyZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiYXNlVGFnID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJiYXNlXCIpWzBdO1xuICAgICAgICByZXR1cm4gdGhpcy5fYmFzZUhyZWYgPSBiYXNlVGFnID8gYmFzZVRhZy5ocmVmLnN1YnN0cihsb2NhdGlvbi5vcmlnaW4ubGVuZ3RoKSA6IFwiXCI7XG4gICAgfTtcbiAgICBCcm93c2VyTG9jYXRpb25Db25maWcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIEJyb3dzZXJMb2NhdGlvbkNvbmZpZztcbn0oKSk7XG5leHBvcnRzLkJyb3dzZXJMb2NhdGlvbkNvbmZpZyA9IEJyb3dzZXJMb2NhdGlvbkNvbmZpZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXJMb2NhdGlvbkNvbmZpZy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9icm93c2VyTG9jYXRpb25Db25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogVGhlIFVJLVJvdXRlciBmb3IgQW5ndWxhciBkaXJlY3RpdmVzOlxuICpcbiAqIC0gW1tVSVZpZXddXTogQSB2aWV3cG9ydCBmb3Igcm91dGVkIGNvbXBvbmVudHNcbiAqIC0gW1tVSVNyZWZdXTogQSBzdGF0ZSByZWYgdG8gYSB0YXJnZXQgc3RhdGU7IG5hdmlnYXRlcyB3aGVuIGNsaWNrZWRcbiAqIC0gW1tVSVNyZWZBY3RpdmVdXTogKGFuZCBgVUlTcmVmQWN0aXZlRXFgKSBBZGRzIGEgY3NzIGNsYXNzIHdoZW4gYSBVSVNyZWYncyB0YXJnZXQgc3RhdGUgKG9yIGEgY2hpbGQgc3RhdGUpIGlzIGFjdGl2ZVxuICpcbiAqIEBuZzJhcGlcbiAqIEBwcmVmZXJyZWRcbiAqIEBtb2R1bGUgZGlyZWN0aXZlc1xuICovIC8qKiAqL1xuaW1wb3J0IHsgVUlTcmVmLCBBbmNob3JVSVNyZWYgfSBmcm9tIFwiLi91aVNyZWZcIjtcbmltcG9ydCB7IFVJU3JlZkFjdGl2ZSB9IGZyb20gXCIuL3VpU3JlZkFjdGl2ZVwiO1xuaW1wb3J0IHsgVUlWaWV3IH0gZnJvbSBcIi4vdWlWaWV3XCI7XG5pbXBvcnQgeyBVSVNyZWZTdGF0dXMgfSBmcm9tIFwiLi91aVNyZWZTdGF0dXNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3VpVmlld1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vdWlTcmVmXCI7XG5leHBvcnQgKiBmcm9tIFwiLi91aVNyZWZTdGF0dXNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3VpU3JlZkFjdGl2ZVwiO1xuLyoqIEBpbnRlcm5hbGFwaSAqL1xuZXhwb3J0IHZhciBfVUlST1VURVJfRElSRUNUSVZFUyA9IFtVSVNyZWYsIEFuY2hvclVJU3JlZiwgVUlWaWV3LCBVSVNyZWZBY3RpdmUsIFVJU3JlZlN0YXR1c107XG4vKipcbiAqIFJlZmVyZW5jZXMgdG8gdGhlIFVJLVJvdXRlciBkaXJlY3RpdmUgY2xhc3NlcywgZm9yIHVzZSB3aXRoaW4gYSBAQ29tcG9uZW50J3MgYGRpcmVjdGl2ZXM6YCBwcm9wZXJ0eVxuICogQGRlcHJlY2F0ZWQgdXNlIFtbVUlSb3V0ZXJNb2R1bGVdXVxuICogQGludGVybmFsYXBpXG4gKi9cbmV4cG9ydCB2YXIgVUlST1VURVJfRElSRUNUSVZFUyA9IF9VSVJPVVRFUl9ESVJFQ1RJVkVTO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlyZWN0aXZlcy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvYW5ndWxhci9saWIvZGlyZWN0aXZlcy9kaXJlY3RpdmVzLmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogQG5nMmFwaSBAbW9kdWxlIGRpcmVjdGl2ZXMgKi8gLyoqICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBFbGVtZW50UmVmLCBIb3N0LCBSZW5kZXJlciB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBVSVNyZWZTdGF0dXMgfSBmcm9tIFwiLi91aVNyZWZTdGF0dXNcIjtcbi8qKlxuICogQSBkaXJlY3RpdmUgdGhhdCBhZGRzIGEgQ1NTIGNsYXNzIHdoZW4gaXRzIGFzc29jaWF0ZWQgYHVpU3JlZmAgbGluayBpcyBhY3RpdmUuXG4gKlxuICogIyMjIFB1cnBvc2VcbiAqXG4gKiBUaGlzIGRpcmVjdGl2ZSBzaG91bGQgYmUgcGFpcmVkIHdpdGggb25lIChvciBtb3JlKSBbW1VJU3JlZl1dIGRpcmVjdGl2ZXMuXG4gKiBJdCB3aWxsIGFwcGx5IGEgQ1NTIGNsYXNzIHRvIGl0cyBlbGVtZW50IHdoZW4gdGhlIHN0YXRlIHRoZSBgdWlTcmVmYCB0YXJnZXRzIGlzIGFjdGl2YXRlZC5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBuYXZpZ2F0aW9uIFVJIHdoZXJlIHRoZSBhY3RpdmUgbGluayBpcyBoaWdobGlnaHRlZC5cbiAqXG4gKiAjIyMgU2VsZWN0b3JzXG4gKlxuICogLSBgW3VpU3JlZkFjdGl2ZV1gOiBXaGVuIHRoaXMgc2VsZWN0b3IgaXMgdXNlZCwgdGhlIGNsYXNzIGlzIGFkZGVkIHdoZW4gdGhlIHRhcmdldCBzdGF0ZSBvciBhbnlcbiAqIGNoaWxkIG9mIHRoZSB0YXJnZXQgc3RhdGUgaXMgYWN0aXZlXG4gKiAtIGBbdWlTcmVmQWN0aXZlRXFdYDogV2hlbiB0aGlzIHNlbGVjdG9yIGlzIHVzZWQsIHRoZSBjbGFzcyBpcyBhZGRlZCB3aGVuIHRoZSB0YXJnZXQgc3RhdGUgaXNcbiAqIGV4YWN0bHkgYWN0aXZlICh0aGUgY2xhc3MgaXMgbm90IGFkZGVkIGlmIGEgY2hpbGQgb2YgdGhlIHRhcmdldCBzdGF0ZSBpcyBhY3RpdmUpLlxuICpcbiAqICMjIyBJbnB1dHNcbiAqXG4gKiAtIGB1aVNyZWZBY3RpdmVgL2B1aVNyZWZBY3RpdmVFcWA6IG9uZSBvciBtb3JlIENTUyBjbGFzc2VzIHRvIGFkZCB0byB0aGUgZWxlbWVudCwgd2hlbiB0aGUgYHVpU3JlZmAgaXMgYWN0aXZlXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogVGhlIGFuY2hvciB0YWcgaGFzIHRoZSBgYWN0aXZlYCBjbGFzcyBhZGRlZCB3aGVuIHRoZSBgZm9vYCBzdGF0ZSBpcyBhY3RpdmUuXG4gKiBgYGBodG1sXG4gKiA8YSB1aVNyZWY9XCJmb29cIiB1aVNyZWZBY3RpdmU9XCJhY3RpdmVcIj5Gb288L2E+XG4gKiBgYGBcbiAqXG4gKiAjIyMgTWF0Y2hpbmcgcGFyYW1ldGVyc1xuICpcbiAqIElmIHRoZSBgdWlTcmVmYCBpbmNsdWRlcyBwYXJhbWV0ZXJzLCB0aGUgY3VycmVudCBzdGF0ZSBtdXN0IGJlIGFjdGl2ZSwgKmFuZCogdGhlIHBhcmFtZXRlciB2YWx1ZXMgbXVzdCBtYXRjaC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBUaGUgZmlyc3QgYW5jaG9yIHRhZyBoYXMgdGhlIGBhY3RpdmVgIGNsYXNzIGFkZGVkIHdoZW4gdGhlIGBmb28uYmFyYCBzdGF0ZSBpcyBhY3RpdmUgYW5kIHRoZSBgaWRgIHBhcmFtZXRlclxuICogZXF1YWxzIDI1LlxuICogVGhlIHNlY29uZCBhbmNob3IgdGFnIGhhcyB0aGUgYGFjdGl2ZWAgY2xhc3MgYWRkZWQgd2hlbiB0aGUgYGZvby5iYXJgIHN0YXRlIGlzIGFjdGl2ZSBhbmQgdGhlIGBpZGAgcGFyYW1ldGVyXG4gKiBlcXVhbHMgMzIuXG4gKiBgYGBodG1sXG4gKiA8YSB1aVNyZWY9XCJmb28uYmFyXCIgW3VpUGFyYW1zXT1cInsgaWQ6IDI1IH1cIiB1aVNyZWZBY3RpdmU9XCJhY3RpdmVcIj5CYXIgIzI1PC9hPlxuICogPGEgdWlTcmVmPVwiZm9vLmJhclwiIFt1aVBhcmFtc109XCJ7IGlkOiAzMiB9XCIgdWlTcmVmQWN0aXZlPVwiYWN0aXZlXCI+QmFyICMzMjwvYT5cbiAqIGBgYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIEEgbGlzdCBvZiBhbmNob3IgdGFncyBhcmUgY3JlYXRlZCBmb3IgYSBsaXN0IG9mIGBiYXJgIG9iamVjdHMuXG4gKiBBbiBhbmNob3IgdGFnIHdpbGwgaGF2ZSB0aGUgYGFjdGl2ZWAgY2xhc3Mgd2hlbiBgZm9vLmJhcmAgc3RhdGUgaXMgYWN0aXZlIGFuZCB0aGUgYGlkYCBwYXJhbWV0ZXIgbWF0Y2hlc1xuICogdGhhdCBvYmplY3QncyBgaWRgLlxuICogYGBgaHRtbFxuICogPGxpICpuZ0Zvcj1cImxldCBiYXIgb2YgYmFyc1wiPlxuICogICA8YSB1aVNyZWY9XCJmb28uYmFyXCIgW3VpUGFyYW1zXT1cInsgaWQ6IGJhci5pZCB9XCIgdWlTcmVmQWN0aXZlPVwiYWN0aXZlXCI+QmFyICN7eyBiYXIuaWQgfX08L2E+XG4gKiA8L2xpPlxuICogYGBgXG4gKlxuICogIyMjIE11bHRpcGxlIHVpU3JlZnNcbiAqXG4gKiBBIHNpbmdsZSBgdWlTcmVmQWN0aXZlYCBjYW4gYmUgdXNlZCBmb3IgbXVsdGlwbGUgYHVpU3JlZmAgbGlua3MuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSAoZm9yIGV4YW1wbGUpIGEgZHJvcCBkb3duIG5hdmlnYXRpb24gbWVudSwgd2hlcmUgdGhlIG1lbnVpIGlzIGhpZ2hsaWdodGVkXG4gKiBpZiAqYW55KiBvZiBpdHMgaW5uZXIgbGlua3MgYXJlIGFjdGl2ZS5cbiAqXG4gKiBUaGUgYHVpU3JlZkFjdGl2ZWAgc2hvdWxkIGJlIHBsYWNlZCBvbiBhbiBhbmNlc3RvciBlbGVtZW50IG9mIHRoZSBgdWlTcmVmYCBsaXN0LlxuICogSWYgYW55b2YgdGhlIGB1aVNyZWZgIGxpbmtzIGFyZSBhY3RpdmF0ZWQsIHRoZSBjbGFzcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBhbmNlc3RvciBlbGVtZW50LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIFRoaXMgaXMgYSBkcm9wZG93biBuYWdpdmF0aW9uIG1lbnUgZm9yIFwiQWRtaW5cIiBzdGF0ZXMuXG4gKiBXaGVuIGFueSBvZiBgYWRtaW4udXNlcnNgLCBgYWRtaW4uZ3JvdXBzYCwgYGFkbWluLnNldHRpbmdzYCBhcmUgYWN0aXZlLCB0aGUgYDxsaT5gIGZvciB0aGUgZHJvcGRvd25cbiAqIGhhcyB0aGUgYGRyb3Bkb3duLWNoaWxkLWFjdGl2ZWAgY2xhc3MgYXBwbGllZC5cbiAqIEFkZGl0aW9uYWxseSwgdGhlIGFjdGl2ZSBhbmNob3IgdGFnIGhhcyB0aGUgYGFjdGl2ZWAgY2xhc3MgYXBwbGllZC5cbiAqIGBgYGh0bWxcbiAqIDx1bCBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIj5cbiAqICAgPGxpIHVpU3JlZkFjdGl2ZT1cImRyb3Bkb3duLWNoaWxkLWFjdGl2ZVwiIGNsYXNzPVwiZHJvcGRvd24gYWRtaW5cIj5cbiAqICAgICBBZG1pblxuICogICAgIDx1bD5cbiAqICAgICAgIDxsaT48YSB1aVNyZWY9XCJhZG1pbi51c2Vyc1wiIHVpU3JlZkFjdGl2ZT1cImFjdGl2ZVwiPlVzZXJzPC9hPjwvbGk+XG4gKiAgICAgICA8bGk+PGEgdWlTcmVmPVwiYWRtaW4uZ3JvdXBzXCIgdWlTcmVmQWN0aXZlPVwiYWN0aXZlXCI+R3JvdXBzPC9hPjwvbGk+XG4gKiAgICAgICA8bGk+PGEgdWlTcmVmPVwiYWRtaW4uc2V0dGluZ3NcIiB1aVNyZWZBY3RpdmU9XCJhY3RpdmVcIj5TZXR0aW5nczwvYT48L2xpPlxuICogICAgIDwvdWw+XG4gKiAgIDwvbGk+XG4gKiA8L3VsPlxuICogYGBgXG4gKi9cbnZhciBVSVNyZWZBY3RpdmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVJU3JlZkFjdGl2ZSh1aVNyZWZTdGF0dXMsIHJuZCwgaG9zdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9jbGFzc2VzID0gW107XG4gICAgICAgIHRoaXMuX2NsYXNzZXNFcSA9IFtdO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB1aVNyZWZTdGF0dXMudWlTcmVmU3RhdHVzLnN1YnNjcmliZShmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICAgICAgX3RoaXMuX2NsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJldHVybiBybmQuc2V0RWxlbWVudENsYXNzKGhvc3QubmF0aXZlRWxlbWVudCwgY2xzLCBuZXh0LmFjdGl2ZSk7IH0pO1xuICAgICAgICAgICAgX3RoaXMuX2NsYXNzZXNFcS5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmV0dXJuIHJuZC5zZXRFbGVtZW50Q2xhc3MoaG9zdC5uYXRpdmVFbGVtZW50LCBjbHMsIG5leHQuZXhhY3QpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVSVNyZWZBY3RpdmUucHJvdG90eXBlLCBcImFjdGl2ZVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLl9jbGFzc2VzID0gdmFsLnNwbGl0KFwiXFxzK1wiKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVSVNyZWZBY3RpdmUucHJvdG90eXBlLCBcImFjdGl2ZUVxXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuX2NsYXNzZXNFcSA9IHZhbC5zcGxpdChcIlxccytcIik7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIDtcbiAgICBVSVNyZWZBY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBVSVNyZWZBY3RpdmU7XG59KCkpO1xuZXhwb3J0IHsgVUlTcmVmQWN0aXZlIH07XG5VSVNyZWZBY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1t1aVNyZWZBY3RpdmVdLFt1aVNyZWZBY3RpdmVFcV0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblVJU3JlZkFjdGl2ZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IFVJU3JlZlN0YXR1cywgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyLCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgZGVjb3JhdG9yczogW3sgdHlwZTogSG9zdCB9LF0gfSxcbl07IH07XG5VSVNyZWZBY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgJ2FjdGl2ZSc6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ3VpU3JlZkFjdGl2ZScsXSB9LF0sXG4gICAgJ2FjdGl2ZUVxJzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsndWlTcmVmQWN0aXZlRXEnLF0gfSxdLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpU3JlZkFjdGl2ZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvYW5ndWxhci9saWIvZGlyZWN0aXZlcy91aVNyZWZBY3RpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGxvYWROZ01vZHVsZSB9IGZyb20gXCIuLi9sYXp5TG9hZC9sYXp5TG9hZE5nTW9kdWxlXCI7XG4vKipcbiAqIFRoaXMgaXMgYSBbW1N0YXRlQnVpbGRlci5idWlsZGVyXV0gZnVuY3Rpb24gZm9yIG5nTW9kdWxlIGxhenkgbG9hZGluZyBpbiBBbmd1bGFyLlxuICpcbiAqIFdoZW4gdGhlIFtbU3RhdGVCdWlsZGVyXV0gYnVpbGRzIGEgW1tTdGF0ZV1dIG9iamVjdCBmcm9tIGEgcmF3IFtbU3RhdGVEZWNsYXJhdGlvbl1dLCB0aGlzIGJ1aWxkZXJcbiAqIGRlY29yYXRlcyB0aGUgYGxhenlMb2FkYCBwcm9wZXJ0eSBmb3Igc3RhdGVzIHRoYXQgaGF2ZSBhIFtbTmcyU3RhdGVEZWNsYXJhdGlvbi5uZ01vZHVsZV1dIGRlY2xhcmF0aW9uLlxuICpcbiAqIElmIHRoZSBzdGF0ZSBoYXMgYSBbW05nMlN0YXRlRGVjbGFyYXRpb24ubmdNb2R1bGVdXSwgaXQgd2lsbCBjcmVhdGUgYSBgbGF6eUxvYWRgIGZ1bmN0aW9uXG4gKiB0aGF0IGluIHR1cm4gY2FsbHMgYGxvYWROZ01vZHVsZShsb2FkTmdNb2R1bGVGbilgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIEEgc3RhdGUgdGhhdCBoYXMgYSBgbmdNb2R1bGVgXG4gKiBgYGBqc1xuICogdmFyIGRlY2wgPSB7XG4gKiAgIG5nTW9kdWxlOiAoKSA9PiBTeXN0ZW0uaW1wb3J0KCcuL2NoaWxkTW9kdWxlLnRzJylcbiAqIH1cbiAqIGBgYFxuICogd291bGQgYnVpbGQgYSBzdGF0ZSB3aXRoIGEgYGxhenlMb2FkYCBmdW5jdGlvbiBsaWtlOlxuICogYGBganNcbiAqIGltcG9ydCB7IGxvYWROZ01vZHVsZSB9IGZyb20gXCJAdWlyb3V0ZXIvYW5ndWxhclwiO1xuICogdmFyIGRlY2wgPSB7XG4gKiAgIGxhenlMb2FkOiBsb2FkTmdNb2R1bGUoKCkgPT4gU3lzdGVtLmltcG9ydCgnLi9jaGlsZE1vZHVsZS50cycpXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBJZiB0aGUgc3RhdGUgaGFzIGJvdGggYSBgbmdNb2R1bGU6YCAqYW5kKiBhIGBsYXp5TG9hZGAsIHRoZW4gdGhlIGBsYXp5TG9hZGAgaXMgcnVuIGZpcnN0LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiB2YXIgZGVjbCA9IHtcbiAqICAgbGF6eUxvYWQ6ICgpID0+IFN5c3RlbS5pbXBvcnQoJ3RoaXJkLXBhcnR5LWxpYnJhcnknKSxcbiAqICAgbmdNb2R1bGU6ICgpID0+IFN5c3RlbS5pbXBvcnQoJy4vY2hpbGRNb2R1bGUudHMnKVxuICogfVxuICogYGBgXG4gKiB3b3VsZCBidWlsZCBhIHN0YXRlIHdpdGggYSBgbGF6eUxvYWRgIGZ1bmN0aW9uIGxpa2U6XG4gKiBgYGBqc1xuICogaW1wb3J0IHsgbG9hZE5nTW9kdWxlIH0gZnJvbSBcIkB1aXJvdXRlci9hbmd1bGFyXCI7XG4gKiB2YXIgZGVjbCA9IHtcbiAqICAgbGF6eUxvYWQ6ICgpID0+IFN5c3RlbS5pbXBvcnQoJ3RoaXJkLXBhcnR5LWxpYnJhcnknKVxuICogICAgICAgLnRoZW4oKCkgPT4gbG9hZE5nTW9kdWxlKCgpID0+IFN5c3RlbS5pbXBvcnQoJy4vY2hpbGRNb2R1bGUudHMnKSlcbiAqIH1cbiAqIGBgYFxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5nMkxhenlMb2FkQnVpbGRlcihzdGF0ZSwgcGFyZW50KSB7XG4gICAgdmFyIGxvYWROZ01vZHVsZUZuID0gc3RhdGVbJ2xvYWRDaGlsZHJlbiddO1xuICAgIHJldHVybiBsb2FkTmdNb2R1bGVGbiA/IGxvYWROZ01vZHVsZShsb2FkTmdNb2R1bGVGbikgOiBzdGF0ZS5sYXp5TG9hZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhenlMb2FkLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9hbmd1bGFyL2xpYi9zdGF0ZWJ1aWxkZXJzL2xhenlMb2FkLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogQG5nMmFwaSBAbW9kdWxlIGNvcmUgKi9cbi8qKiAqL1xuaW1wb3J0IHsgQ29tcGlsZXIsIE5nTW9kdWxlRmFjdG9yeUxvYWRlciB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBVSVJvdXRlciwgUmVzb2x2YWJsZSwgTkFUSVZFX0lOSkVDVE9SX1RPS0VOLCBpc1N0cmluZywgdW5uZXN0UiwgaW5BcnJheSwgdW5pcVIgfSBmcm9tIFwiQHVpcm91dGVyL2NvcmVcIjtcbmltcG9ydCB7IFVJUk9VVEVSX1JPT1RfTU9EVUxFLCBVSVJPVVRFUl9NT0RVTEVfVE9LRU4gfSBmcm9tIFwiLi4vdWlSb3V0ZXJOZ01vZHVsZVwiO1xuaW1wb3J0IHsgYXBwbHlNb2R1bGVDb25maWcgfSBmcm9tIFwiLi4vdWlSb3V0ZXJDb25maWdcIjtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGxhenkgbG9hZHMgYSBuZXN0ZWQgbW9kdWxlXG4gKlxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZCBieSB0aGUgW1tuZzJMYXp5TG9hZEJ1aWxkZXJdXSB3aGVuIHByb2Nlc3NpbmcgW1tOZzJTdGF0ZURlY2xhcmF0aW9uLmxvYWRDaGlsZHJlbl1dLlxuICpcbiAqIEl0IGNvdWxkIGFsc28gYmUgdXNlZCBtYW51YWxseSBhcyBhIFtbU3RhdGVEZWNsYXJhdGlvbi5sYXp5TG9hZF1dIHByb3BlcnR5IHRvIGxhenkgbG9hZCBhbiBgTmdNb2R1bGVgIGFuZCBpdHMgc3RhdGUocykuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogVXNpbmcgYFN5c3RlbS5pbXBvcnQoKWAgYW5kIG5hbWVkIGV4cG9ydCBvZiBgSG9tZU1vZHVsZWBcbiAqIGBgYGpzXG4gKiBkZWNsYXJlIHZhciBTeXN0ZW07XG4gKiB2YXIgZnV0dXJlU3RhdGUgPSB7XG4gKiAgIG5hbWU6ICdob21lLioqJyxcbiAqICAgdXJsOiAnL2hvbWUnLFxuICogICBsYXp5TG9hZDogbG9hZE5nTW9kdWxlKCgpID0+IFN5c3RlbS5pbXBvcnQoJy4vaG9tZS9ob21lLm1vZHVsZScpLnRoZW4ocmVzdWx0ID0+IHJlc3VsdC5Ib21lTW9kdWxlKSlcbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIFVzaW5nIGEgcGF0aCAoc3RyaW5nKSB0byB0aGUgbW9kdWxlXG4gKiBgYGBqc1xuICogdmFyIGZ1dHVyZVN0YXRlID0ge1xuICogICBuYW1lOiAnaG9tZS4qKicsXG4gKiAgIHVybDogJy9ob21lJyxcbiAqICAgbGF6eUxvYWQ6IGxvYWROZ01vZHVsZSgnLi9ob21lL2hvbWUubW9kdWxlI0hvbWVNb2R1bGUnKVxuICogfVxuICogYGBgXG4gKlxuICpcbiAqIEBwYXJhbSBtb2R1bGVUb0xvYWQgYSBwYXRoIChzdHJpbmcpIHRvIHRoZSBOZ01vZHVsZSB0byBsb2FkLlxuICogICAgT3IgYSBmdW5jdGlvbiB3aGljaCBsb2FkcyB0aGUgTmdNb2R1bGUgY29kZSB3aGljaCBzaG91bGRcbiAqICAgIHJldHVybiBhIHJlZmVyZW5jZSB0byAgdGhlIGBOZ01vZHVsZWAgY2xhc3MgYmVpbmcgbG9hZGVkIChvciBhIGBQcm9taXNlYCBmb3IgaXQpLlxuICpcbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYSB0cmFuc2l0aW9uLCB3aGljaDpcbiAqIC0gR2V0cyB0aGUgSW5qZWN0b3IgKHNjb3BlZCBwcm9wZXJseSBmb3IgdGhlIGRlc3RpbmF0aW9uIHN0YXRlKVxuICogLSBMb2FkcyBhbmQgY3JlYXRlcyB0aGUgTmdNb2R1bGVcbiAqIC0gRmluZHMgdGhlIFwicmVwbGFjZW1lbnQgc3RhdGVcIiBmb3IgdGhlIHRhcmdldCBzdGF0ZSwgYW5kIGFkZHMgdGhlIG5ldyBOZ01vZHVsZSBJbmplY3RvciB0byBpdCAoYXMgYSByZXNvbHZlKVxuICogLSBSZXR1cm5zIHRoZSBuZXcgc3RhdGVzIGFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkTmdNb2R1bGUobW9kdWxlVG9Mb2FkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHZhciBuZzJJbmplY3RvciA9IHRyYW5zaXRpb24uaW5qZWN0b3IoKS5nZXQoTkFUSVZFX0lOSkVDVE9SX1RPS0VOKTtcbiAgICAgICAgdmFyIGNyZWF0ZU1vZHVsZSA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGUobmcySW5qZWN0b3IpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYXBwbHlNb2R1bGUgPSBmdW5jdGlvbiAobW9kdWxlUmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHlOZ01vZHVsZSh0cmFuc2l0aW9uLCBtb2R1bGVSZWYpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbG9hZE1vZHVsZUZhY3RvcnkobW9kdWxlVG9Mb2FkLCBuZzJJbmplY3RvcilcbiAgICAgICAgICAgIC50aGVuKGNyZWF0ZU1vZHVsZSlcbiAgICAgICAgICAgIC50aGVuKGFwcGx5TW9kdWxlKTtcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtb2R1bGUgZmFjdG9yeSB0aGF0IGNhbiBiZSB1c2VkIHRvIGluc3RhbnRpYXRlIGEgbW9kdWxlXG4gKlxuICogRm9yIHN0cmluZ3MgdGhpczpcbiAqIC0gRmluZHMgdGhlIGNvcnJlY3QgTmdNb2R1bGVGYWN0b3J5TG9hZGVyXG4gKiAtIExvYWRzIHRoZSBuZXcgTmdNb2R1bGVGYWN0b3J5IGZyb20gdGhlIHBhdGggc3RyaW5nIChhc3luYylcbiAqXG4gKiBGb3IgYSBUeXBlPGFueT4gb3IgUHJvbWlzZTxUeXBlPGFueT4+IHRoaXM6XG4gKiAtIENvbXBpbGVzIHRoZSBjb21wb25lbnQgdHlwZSAoaWYgbm90IHJ1bm5pbmcgd2l0aCBBT1QpXG4gKiAtIFJldHVybnMgdGhlIE5nTW9kdWxlRmFjdG9yeSByZXN1bHRpbmcgZnJvbSBjb21waWxhdGlvbiAob3IgZGlyZWN0IGxvYWRpbmcgaWYgdXNpbmcgQU9UKSBhcyBhIFByb21pc2VcbiAqXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWRNb2R1bGVGYWN0b3J5KG1vZHVsZVRvTG9hZCwgbmcySW5qZWN0b3IpIHtcbiAgICBpZiAoaXNTdHJpbmcobW9kdWxlVG9Mb2FkKSkge1xuICAgICAgICByZXR1cm4gbmcySW5qZWN0b3IuZ2V0KE5nTW9kdWxlRmFjdG9yeUxvYWRlcikubG9hZChtb2R1bGVUb0xvYWQpO1xuICAgIH1cbiAgICB2YXIgY29tcGlsZXIgPSBuZzJJbmplY3Rvci5nZXQoQ29tcGlsZXIpO1xuICAgIHZhciBvZmZsaW5lTW9kZSA9IGNvbXBpbGVyIGluc3RhbmNlb2YgQ29tcGlsZXI7XG4gICAgdmFyIHVud3JhcEVzTW9kdWxlRGVmYXVsdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiB4WydkZWZhdWx0J10gPyB4WydkZWZhdWx0J10gOiB4O1xuICAgIH07XG4gICAgdmFyIGNvbXBpbGVBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHJldHVybiBjb21waWxlci5jb21waWxlTW9kdWxlQXN5bmMobW9kdWxlVHlwZSk7XG4gICAgfTtcbiAgICB2YXIgbG9hZENoaWxkcmVuUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShtb2R1bGVUb0xvYWQoKSkudGhlbih1bndyYXBFc01vZHVsZURlZmF1bHQpO1xuICAgIHJldHVybiBvZmZsaW5lTW9kZSA/IGxvYWRDaGlsZHJlblByb21pc2UgOiBsb2FkQ2hpbGRyZW5Qcm9taXNlLnRoZW4oY29tcGlsZUFzeW5jKTtcbn1cbi8qKlxuICogQXBwbHkgdGhlIFVJLVJvdXRlciBNb2R1bGVzIGZvdW5kIGluIHRoZSBsYXp5IGxvYWRlZCBtb2R1bGUuXG4gKlxuICogQXBwbHkgdGhlIExhenkgTG9hZGVkIE5nTW9kdWxlJ3MgbmV3bHkgY3JlYXRlZCBJbmplY3RvciB0byB0aGUgcmlnaHQgc3RhdGUgaW4gdGhlIHN0YXRlIHRyZWUuXG4gKlxuICogTGF6eSBsb2FkaW5nIHVzZXMgYSBwbGFjZWhvbGRlciBzdGF0ZSB3aGljaCBpcyByZW1vdmVkIChhbmQgcmVwbGFjZWQpIGFmdGVyIHRoZSBtb2R1bGUgaXMgbG9hZGVkLlxuICogVGhlIE5nTW9kdWxlIHNob3VsZCBpbmNsdWRlIGEgc3RhdGUgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBwbGFjZWhvbGRlci5cbiAqXG4gKiBGaW5kIHRoZSAqbmV3bHkgbG9hZGVkIHN0YXRlKiB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlICpwbGFjZWhvbGRlciBzdGF0ZSouXG4gKiBUaGUgTmdNb2R1bGUncyBJbmplY3RvciAoYW5kIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikgd2lsbCBiZSBhZGRlZCB0byB0aGF0IHN0YXRlLlxuICogVGhlIEluamVjdG9yL0ZhY3RvcnkgYXJlIHVzZWQgd2hlbiBjcmVhdGluZyBDb21wb25lbnRzIGZvciB0aGUgYHJlcGxhY2VtZW50YCBzdGF0ZSBhbmQgYWxsIGl0cyBjaGlsZHJlbi5cbiAqXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5TmdNb2R1bGUodHJhbnNpdGlvbiwgbmcyTW9kdWxlKSB7XG4gICAgdmFyIGluamVjdG9yID0gbmcyTW9kdWxlLmluamVjdG9yO1xuICAgIHZhciBwYXJlbnRJbmplY3RvciA9IG5nMk1vZHVsZS5pbmplY3RvclsncGFyZW50J10gfHwgbmcyTW9kdWxlLmluamVjdG9yWydfcGFyZW50J107XG4gICAgdmFyIHVpUm91dGVyID0gaW5qZWN0b3IuZ2V0KFVJUm91dGVyKTtcbiAgICB2YXIgcmVnaXN0cnkgPSB1aVJvdXRlci5zdGF0ZVJlZ2lzdHJ5O1xuICAgIHZhciBvcmlnaW5hbE5hbWUgPSB0cmFuc2l0aW9uLnRvKCkubmFtZTtcbiAgICB2YXIgb3JpZ2luYWxTdGF0ZSA9IHJlZ2lzdHJ5LmdldChvcmlnaW5hbE5hbWUpO1xuICAgIC8vIENoZWNrIGlmIGl0J3MgYSBmdXR1cmUgc3RhdGUgKGVuZHMgd2l0aCAuKiopXG4gICAgdmFyIGlzRnV0dXJlID0gL14oLiopXFwuXFwqXFwqJC8uZXhlYyhvcmlnaW5hbE5hbWUpO1xuICAgIC8vIEZpbmFsIG5hbWUgKHdpdGhvdXQgdGhlIC4qKilcbiAgICB2YXIgcmVwbGFjZW1lbnROYW1lID0gaXNGdXR1cmUgJiYgaXNGdXR1cmVbMV07XG4gICAgdmFyIG5ld1Jvb3RNb2R1bGVzID0gbXVsdGlQcm92aWRlclBhcmVudENoaWxkRGVsdGEocGFyZW50SW5qZWN0b3IsIGluamVjdG9yLCBVSVJPVVRFUl9ST09UX01PRFVMRSlcbiAgICAgICAgLnJlZHVjZSh1bmlxUiwgW10pO1xuICAgIHZhciBuZXdDaGlsZE1vZHVsZXMgPSBtdWx0aVByb3ZpZGVyUGFyZW50Q2hpbGREZWx0YShwYXJlbnRJbmplY3RvciwgaW5qZWN0b3IsIFVJUk9VVEVSX01PRFVMRV9UT0tFTilcbiAgICAgICAgLnJlZHVjZSh1bmlxUiwgW10pO1xuICAgIGlmIChuZXdSb290TW9kdWxlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS5sb2cobmV3Um9vdE1vZHVsZXMpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xhenkgbG9hZGVkIG1vZHVsZXMgc2hvdWxkIG5vdCBjb250YWluIGEgVUlSb3V0ZXJNb2R1bGUuZm9yUm9vdCgpIG1vZHVsZScpO1xuICAgIH1cbiAgICB2YXIgbmV3U3RhdGVPYmplY3RzID0gbmV3Q2hpbGRNb2R1bGVzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKG1vZHVsZSkgeyByZXR1cm4gYXBwbHlNb2R1bGVDb25maWcodWlSb3V0ZXIsIGluamVjdG9yLCBtb2R1bGUpOyB9KVxuICAgICAgICAucmVkdWNlKHVubmVzdFIsIFtdKVxuICAgICAgICAucmVkdWNlKHVuaXFSLCBbXSk7XG4gICAgdmFyIHJlcGxhY2VtZW50U3RhdGUgPSByZWdpc3RyeS5nZXQocmVwbGFjZW1lbnROYW1lKTtcbiAgICBpZiAoIXJlcGxhY2VtZW50U3RhdGUgfHwgcmVwbGFjZW1lbnRTdGF0ZSA9PT0gb3JpZ2luYWxTdGF0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgRnV0dXJlIFN0YXRlIG5hbWVkICdcIiArIG9yaWdpbmFsTmFtZSArIFwiJyBsYXp5IGxvYWRlZCBhbiBOZ01vZHVsZS4gXCIgK1xuICAgICAgICAgICAgKFwiVGhlIGxhenkgbG9hZGVkIE5nTW9kdWxlIG11c3QgaGF2ZSBhIHN0YXRlIG5hbWVkICdcIiArIHJlcGxhY2VtZW50TmFtZSArIFwiJyBcIikgK1xuICAgICAgICAgICAgKFwid2hpY2ggcmVwbGFjZXMgdGhlIChwbGFjZWhvbGRlcikgJ1wiICsgb3JpZ2luYWxOYW1lICsgXCInIEZ1dHVyZSBTdGF0ZS4gXCIpICtcbiAgICAgICAgICAgIChcIkFkZCBhICdcIiArIHJlcGxhY2VtZW50TmFtZSArIFwiJyBzdGF0ZSB0byB0aGUgbGF6eSBsb2FkZWQgTmdNb2R1bGUgXCIpICtcbiAgICAgICAgICAgIFwidXNpbmcgVUlSb3V0ZXJNb2R1bGUuZm9yQ2hpbGQoeyBzdGF0ZXM6IENISUxEX1NUQVRFUyB9KS5cIik7XG4gICAgfVxuICAgIC8vIFN1cHBseSB0aGUgbmV3bHkgbG9hZGVkIHN0YXRlcyB3aXRoIHRoZSBJbmplY3RvciBmcm9tIHRoZSBsYXp5IGxvYWRlZCBOZ01vZHVsZS5cbiAgICAvLyBJZiBhIHRyZWUgb2Ygc3RhdGVzIGlzIGxhenkgbG9hZGVkLCBvbmx5IGFkZCB0aGUgaW5qZWN0b3IgdG8gdGhlIHJvb3Qgb2YgdGhlIGxhenkgbG9hZGVkIHRyZWUuXG4gICAgLy8gVGhlIGNoaWxkcmVuIHdpbGwgZ2V0IHRoZSBpbmplY3RvciBieSByZXNvbHZlIGluaGVyaXRhbmNlLlxuICAgIHZhciBuZXdQYXJlbnRTdGF0ZXMgPSBuZXdTdGF0ZU9iamVjdHMuZmlsdGVyKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gIWluQXJyYXkobmV3U3RhdGVPYmplY3RzLCBzdGF0ZS5wYXJlbnQpOyB9KTtcbiAgICAvLyBBZGQgdGhlIEluamVjdG9yIHRvIHRoZSB0b3Agb2YgdGhlIGxhenkgbG9hZGVkIHN0YXRlIHRyZWUgYXMgYSByZXNvbHZlXG4gICAgbmV3UGFyZW50U3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5yZXNvbHZhYmxlcy5wdXNoKFJlc29sdmFibGUuZnJvbURhdGEoTkFUSVZFX0lOSkVDVE9SX1RPS0VOLCBpbmplY3RvcikpOyB9KTtcbiAgICByZXR1cm4ge307XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG5ldyBkZXBlbmRlbmN5IGluamVjdGlvbiB2YWx1ZXMgZnJvbSB0aGUgQ2hpbGQgSW5qZWN0b3JcbiAqXG4gKiBXaGVuIGEgREkgdG9rZW4gaXMgZGVmaW5lZCBhcyBtdWx0aTogdHJ1ZSwgdGhlIGNoaWxkIGluamVjdG9yXG4gKiBjYW4gYWRkIG5ldyB2YWx1ZXMgZm9yIHRoZSB0b2tlbi5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHZhbHVlcyBhZGRlZCBieSB0aGUgY2hpbGQgaW5qZWN0b3IsICBhbmQgZXhjbHVkZXMgYWxsIHZhbHVlcyBmcm9tIHRoZSBwYXJlbnQgaW5qZWN0b3IuXG4gKlxuICogQGludGVybmFsYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aVByb3ZpZGVyUGFyZW50Q2hpbGREZWx0YShwYXJlbnQsIGNoaWxkLCB0b2tlbikge1xuICAgIHZhciBjaGlsZFZhbHMgPSBjaGlsZC5nZXQodG9rZW4sIFtdKTtcbiAgICB2YXIgcGFyZW50VmFscyA9IHBhcmVudC5nZXQodG9rZW4sIFtdKTtcbiAgICByZXR1cm4gY2hpbGRWYWxzLmZpbHRlcihmdW5jdGlvbiAodmFsKSB7IHJldHVybiBwYXJlbnRWYWxzLmluZGV4T2YodmFsKSA9PT0gLTE7IH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGF6eUxvYWROZ01vZHVsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvYW5ndWxhci9saWIvbGF6eUxvYWQvbGF6eUxvYWROZ01vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7ICB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAob1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEluamVjdGFibGUsIElucHV0LCBFbGVtZW50UmVmLCBBZnRlckNvbnRlbnRJbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBFdmVudE1hbmFnZXIgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbi8vIGltcG9ydCB7IGdldERPTSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvc3JjL2RvbS9kb21fYWRhcHRlcic7XG5cbmltcG9ydCB7IEFuZ3VsYXJ0aWNzMiB9IGZyb20gJy4vYW5ndWxhcnRpY3MyJztcblxuQEluamVjdGFibGUoKVxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2FuZ3VsYXJ0aWNzMk9uXSdcbn0pXG5leHBvcnQgY2xhc3MgQW5ndWxhcnRpY3MyT24gaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcbiAgQElucHV0KCdhbmd1bGFydGljczJPbicpIGFuZ3VsYXJ0aWNzMk9uOiBzdHJpbmc7XG4gIEBJbnB1dCgpIGFuZ3VsYXJ0aWNzRXZlbnQ6IHN0cmluZztcbiAgQElucHV0KCkgYW5ndWxhcnRpY3NDYXRlZ29yeTogc3RyaW5nO1xuICBASW5wdXQoKSBhbmd1bGFydGljc1Byb3BlcnRpZXM6IGFueTtcblxuICBwcml2YXRlIGVsOiBhbnk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBlbFJlZjogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIGFuZ3VsYXJ0aWNzMjogQW5ndWxhcnRpY3MyLFxuICAgIHByaXZhdGUgZXZlbnRNYW5hZ2VyOiBFdmVudE1hbmFnZXJcbiAgKSB7XG4gICAgdGhpcy5lbCA9IHRoaXMuZWxSZWYubmF0aXZlRWxlbWVudDtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAvLyBEb24ndCBsaXN0ZW4gaW4gc2VydmVyLXNpZGVcbiAgICBpZiAodGhpcy5pc0Jyb3dzZXIoKSkge1xuICAgICAgdGhpcy5ldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmVsLCB0aGlzLmFuZ3VsYXJ0aWNzMk9uIHx8ICdjbGljaycsIChldmVudDogYW55KSA9PiB0aGlzLmV2ZW50VHJhY2soZXZlbnQpKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgaXNCcm93c2VyKCkge1xuICAgIHJldHVybiB0eXBlb2Yod2luZG93KSAhPT0gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBwdWJsaWMgZXZlbnRUcmFjayhldmVudDogYW55KSB7XG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5hbmd1bGFydGljc0V2ZW50OyAvLyB8fCB0aGlzLmluZmVyRXZlbnROYW1lKCk7XG4gICAgbGV0IHByb3BlcnRpZXM6IGFueSA9IHtcbiAgICAgIGV2ZW50VHlwZTogZXZlbnQudHlwZVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5hbmd1bGFydGljc0NhdGVnb3J5KSB7XG4gICAgICBwcm9wZXJ0aWVzLmNhdGVnb3J5ID0gdGhpcy5hbmd1bGFydGljc0NhdGVnb3J5O1xuICAgIH1cblxuICAgIC8vIEFsbG93IGNvbXBvbmVudHMgdG8gcGFzcyB0aHJvdWdoIGFuIGV4cHJlc3Npb24gdGhhdCBnZXRzIG1lcmdlZCBvbiB0byB0aGUgZXZlbnQgcHJvcGVydGllc1xuICAgIC8vIGVnLiBhbmd1bGFydGljcy1wcm9wZXJpdGVzPSdteUNvbXBvbmVudFNjb3BlLnNvbWVDb25maWdFeHByZXNzaW9uLiRhbmd1bGFydGljc1Byb3BlcnRpZXMnXG4gICAgaWYgKHRoaXMuYW5ndWxhcnRpY3NQcm9wZXJ0aWVzKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHByb3BlcnRpZXMsIHRoaXMuYW5ndWxhcnRpY3NQcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICB0aGlzLmFuZ3VsYXJ0aWNzMi5ldmVudFRyYWNrLm5leHQoe1xuICAgICAgYWN0aW9uLFxuICAgICAgcHJvcGVydGllc1xuICAgIH0pO1xuICB9XG5cbiAgLypwcml2YXRlIGlzQ29tbWFuZCgpIHtcbiAgICByZXR1cm4gWydhOicsICdidXR0b246JywgJ2J1dHRvbjpidXR0b24nLCAnYnV0dG9uOnN1Ym1pdCcsICdpbnB1dDpidXR0b24nLCAnaW5wdXQ6c3VibWl0J10uaW5kZXhPZihcbiAgICAgIGdldERPTSgpLnRhZ05hbWUodGhpcy5lbCkudG9Mb3dlckNhc2UoKSArICc6JyArIChnZXRET00oKS50eXBlKHRoaXMuZWwpIHx8ICcnKSkgPj0gMDtcbiAgfVxuXG4gIHByaXZhdGUgaW5mZXJFdmVudE5hbWUoKSB7XG4gICAgaWYgKHRoaXMuaXNDb21tYW5kKCkpIHJldHVybiBnZXRET00oKS5nZXRUZXh0KHRoaXMuZWwpIHx8IGdldERPTSgpLmdldFZhbHVlKHRoaXMuZWwpO1xuICAgIHJldHVybiBnZXRET00oKS5nZXRQcm9wZXJ0eSh0aGlzLmVsLCAnaWQnKSB8fCBnZXRET00oKS5nZXRQcm9wZXJ0eSh0aGlzLmVsLCAnbmFtZScpIHx8IGdldERPTSgpLnRhZ05hbWUodGhpcy5lbCk7XG4gIH0qL1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3RzbGludC1sb2FkZXIhLi9zcmMvY29yZS9hbmd1bGFydGljczJPbi50cyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV83MF9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQge1xuICBOZ01vZHVsZSxcbiAgTW9kdWxlV2l0aFByb3ZpZGVycyxcbiAgSW5qZWN0LFxuICBPcHRpb25hbCxcbiAgSW5qZWN0aW9uVG9rZW4sXG4gIFNraXBTZWxmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBBbmd1bGFydGljczIgfSBmcm9tICcuL2NvcmUvYW5ndWxhcnRpY3MyJztcbmltcG9ydCB7IEFuZ3VsYXJ0aWNzMk9uIH0gZnJvbSAnLi9jb3JlL2FuZ3VsYXJ0aWNzMk9uJztcblxuZXhwb3J0ICogZnJvbSAnLi9jb3JlL2FuZ3VsYXJ0aWNzMic7XG5leHBvcnQgKiBmcm9tICcuL2NvcmUvYW5ndWxhcnRpY3MyT24nO1xuZXhwb3J0ICogZnJvbSAnLi9wcm92aWRlcnMvaW5kZXgnO1xuXG5leHBvcnQgY29uc3QgQU5HVUxBUlRJQ1MyX0ZPUlJPT1RfR1VBUkQgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0FOR1VMQVJUSUNTMl9GT1JST09UX0dVQVJEJyk7XG5leHBvcnQgZnVuY3Rpb24gcHJvdmlkZUZvclJvb3RHdWFyZChhbmd1bGFydGljczI6IEFuZ3VsYXJ0aWNzMik6IGFueSB7XG4gIGlmIChhbmd1bGFydGljczIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQW5ndWxhcnRpY3MyTW9kdWxlLmZvclJvb3QoKSBjYWxsZWQgdHdpY2UuIExhenkgbG9hZGVkIG1vZHVsZXMgc2hvdWxkIHVzZSBBbmd1bGFydGljczJNb2R1bGUuZm9yQ2hpbGQoKSBpbnN0ZWFkLmApO1xuICB9XG5cbiAgcmV0dXJuICdndWFyZGVkJztcbn1cblxuQE5nTW9kdWxlKHtcbiAgZGVjbGFyYXRpb25zOiBbIEFuZ3VsYXJ0aWNzMk9uIF0sXG4gIGV4cG9ydHM6IFsgQW5ndWxhcnRpY3MyT24gXVxufSlcbmV4cG9ydCBjbGFzcyBBbmd1bGFydGljczJNb2R1bGUge1xuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBASW5qZWN0KEFOR1VMQVJUSUNTMl9GT1JST09UX0dVQVJEKSBndWFyZDogYW55KSB7fVxuXG4gIHN0YXRpYyBmb3JSb290KHByb3ZpZGVyczogQXJyYXk8YW55Pik6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xuICAgIHJldHVybiB7XG4gICAgICBuZ01vZHVsZTogQW5ndWxhcnRpY3MyTW9kdWxlLFxuICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBwcm92aWRlOiBBTkdVTEFSVElDUzJfRk9SUk9PVF9HVUFSRCxcbiAgICAgICAgICB1c2VGYWN0b3J5OiBwcm92aWRlRm9yUm9vdEd1YXJkLFxuICAgICAgICAgIGRlcHM6IFtbQW5ndWxhcnRpY3MyLCBuZXcgT3B0aW9uYWwoKSwgbmV3IFNraXBTZWxmKCldXVxuICAgICAgICB9LFxuICAgICAgICBBbmd1bGFydGljczIsXG4gICAgICAgIC4uLnByb3ZpZGVyc1xuICAgICAgXVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZm9yQ2hpbGQoKTogTW9kdWxlV2l0aFByb3ZpZGVycyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5nTW9kdWxlOiBBbmd1bGFydGljczJNb2R1bGUsXG4gICAgICBwcm92aWRlcnM6IFtdXG4gICAgfTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3RzbGludC1sb2FkZXIhLi9zcmMvaW5kZXgudHMiLCIvKiogQG5nMmFwaSBAbW9kdWxlIG5nMiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbmV4cG9ydCAqIGZyb20gXCIuL3Byb3ZpZGVyc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vdWlSb3V0ZXJOZ01vZHVsZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vdWlSb3V0ZXJDb25maWdcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2RpcmVjdGl2ZXMvZGlyZWN0aXZlc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vc3RhdGVidWlsZGVycy92aWV3c1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vc3RhdGVidWlsZGVycy9sYXp5TG9hZFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbGF6eUxvYWQvbGF6eUxvYWROZ01vZHVsZVwiO1xuZXhwb3J0ICogZnJvbSBcIkB1aXJvdXRlci9jb3JlXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvYW5ndWxhci9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnQocmVxdWlyZShcIi4vcGFyYW1cIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcGFyYW1UeXBlc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZVBhcmFtc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wYXJhbVR5cGVcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgcGF0aCAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3BhdGhOb2RlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3BhdGhGYWN0b3J5XCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9wYXRoL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQG1vZHVsZSByZXNvbHZlICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuX19leHBvcnQocmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3Jlc29sdmFibGVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcmVzb2x2ZUNvbnRleHRcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3Jlc29sdmUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0YXRlQnVpbGRlclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZU9iamVjdFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZU1hdGNoZXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3RhdGVRdWV1ZU1hbmFnZXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3RhdGVSZWdpc3RyeVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZVNlcnZpY2VcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdGFyZ2V0U3RhdGVcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIGhvb2tzICovIC8qKiAqL1xudmFyIHRyYW5zaXRpb25fMSA9IHJlcXVpcmUoXCIuLi90cmFuc2l0aW9uL3RyYW5zaXRpb25cIik7XG52YXIgcm91dGVyXzEgPSByZXF1aXJlKFwiLi4vcm91dGVyXCIpO1xuZnVuY3Rpb24gYWRkQ29yZVJlc29sdmFibGVzKHRyYW5zKSB7XG4gICAgdHJhbnMuYWRkUmVzb2x2YWJsZSh7IHRva2VuOiByb3V0ZXJfMS5VSVJvdXRlciwgZGVwczogW10sIHJlc29sdmVGbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnMucm91dGVyOyB9LCBkYXRhOiB0cmFucy5yb3V0ZXIgfSwgXCJcIik7XG4gICAgdHJhbnMuYWRkUmVzb2x2YWJsZSh7IHRva2VuOiB0cmFuc2l0aW9uXzEuVHJhbnNpdGlvbiwgZGVwczogW10sIHJlc29sdmVGbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnM7IH0sIGRhdGE6IHRyYW5zIH0sIFwiXCIpO1xuICAgIHRyYW5zLmFkZFJlc29sdmFibGUoeyB0b2tlbjogJyR0cmFuc2l0aW9uJCcsIGRlcHM6IFtdLCByZXNvbHZlRm46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zOyB9LCBkYXRhOiB0cmFucyB9LCBcIlwiKTtcbiAgICB0cmFucy5hZGRSZXNvbHZhYmxlKHsgdG9rZW46ICckc3RhdGVQYXJhbXMnLCBkZXBzOiBbXSwgcmVzb2x2ZUZuOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFucy5wYXJhbXMoKTsgfSwgZGF0YTogdHJhbnMucGFyYW1zKCkgfSwgXCJcIik7XG4gICAgdHJhbnMuZW50ZXJpbmcoKS5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB0cmFucy5hZGRSZXNvbHZhYmxlKHsgdG9rZW46ICckc3RhdGUkJywgZGVwczogW10sIHJlc29sdmVGbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RhdGU7IH0sIGRhdGE6IHN0YXRlIH0sIHN0YXRlKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucmVnaXN0ZXJBZGRDb3JlUmVzb2x2YWJsZXMgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25DcmVhdGUoe30sIGFkZENvcmVSZXNvbHZhYmxlcyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29yZVJlc29sdmFibGVzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9jb3JlUmVzb2x2YWJsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgaG9va3MgKi8gLyoqICovXG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XG52YXIgdGFyZ2V0U3RhdGVfMSA9IHJlcXVpcmUoXCIuLi9zdGF0ZS90YXJnZXRTdGF0ZVwiKTtcbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB0aGF0IHJlZGlyZWN0cyB0byBhIGRpZmZlcmVudCBzdGF0ZSBvciBwYXJhbXNcbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vblN0YXJ0KHsgdG86IChzdGF0ZSkgPT4gISFzdGF0ZS5yZWRpcmVjdFRvIH0sIHJlZGlyZWN0SG9vayk7YFxuICpcbiAqIFNlZSBbW1N0YXRlRGVjbGFyYXRpb24ucmVkaXJlY3RUb11dXG4gKi9cbnZhciByZWRpcmVjdFRvSG9vayA9IGZ1bmN0aW9uICh0cmFucykge1xuICAgIHZhciByZWRpcmVjdCA9IHRyYW5zLnRvKCkucmVkaXJlY3RUbztcbiAgICBpZiAoIXJlZGlyZWN0KVxuICAgICAgICByZXR1cm47XG4gICAgdmFyICRzdGF0ZSA9IHRyYW5zLnJvdXRlci5zdGF0ZVNlcnZpY2U7XG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0KHJlc3VsdCkge1xuICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIHRhcmdldFN0YXRlXzEuVGFyZ2V0U3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzU3RyaW5nKHJlc3VsdCkpXG4gICAgICAgICAgICByZXR1cm4gJHN0YXRlLnRhcmdldChyZXN1bHQsIHRyYW5zLnBhcmFtcygpLCB0cmFucy5vcHRpb25zKCkpO1xuICAgICAgICBpZiAocmVzdWx0WydzdGF0ZSddIHx8IHJlc3VsdFsncGFyYW1zJ10pXG4gICAgICAgICAgICByZXR1cm4gJHN0YXRlLnRhcmdldChyZXN1bHRbJ3N0YXRlJ10gfHwgdHJhbnMudG8oKSwgcmVzdWx0WydwYXJhbXMnXSB8fCB0cmFucy5wYXJhbXMoKSwgdHJhbnMub3B0aW9ucygpKTtcbiAgICB9XG4gICAgaWYgKHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKHJlZGlyZWN0KSkge1xuICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEud2hlbihyZWRpcmVjdCh0cmFucykpLnRoZW4oaGFuZGxlUmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZVJlc3VsdChyZWRpcmVjdCk7XG59O1xuZXhwb3J0cy5yZWdpc3RlclJlZGlyZWN0VG9Ib29rID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnQoeyB0bzogZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAhIXN0YXRlLnJlZGlyZWN0VG87IH0gfSwgcmVkaXJlY3RUb0hvb2spO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZGlyZWN0VG8uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL3JlZGlyZWN0VG8uanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBIGZhY3Rvcnkgd2hpY2ggY3JlYXRlcyBhbiBvbkVudGVyLCBvbkV4aXQgb3Igb25SZXRhaW4gdHJhbnNpdGlvbiBob29rIGZ1bmN0aW9uXG4gKlxuICogVGhlIHJldHVybmVkIGZ1bmN0aW9uIGludm9rZXMgdGhlIChmb3IgaW5zdGFuY2UpIHN0YXRlLm9uRW50ZXIgaG9vayB3aGVuIHRoZVxuICogc3RhdGUgaXMgYmVpbmcgZW50ZXJlZC5cbiAqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIG1ha2VFbnRlckV4aXRSZXRhaW5Ib29rKGhvb2tOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0cmFuc2l0aW9uLCBzdGF0ZSkge1xuICAgICAgICB2YXIgX3N0YXRlID0gc3RhdGUuJCRzdGF0ZSgpO1xuICAgICAgICB2YXIgaG9va0ZuID0gX3N0YXRlW2hvb2tOYW1lXTtcbiAgICAgICAgcmV0dXJuIGhvb2tGbih0cmFuc2l0aW9uLCBzdGF0ZSk7XG4gICAgfTtcbn1cbi8qKlxuICogVGhlIFtbVHJhbnNpdGlvblN0YXRlSG9va0ZuXV0gZm9yIG9uRXhpdFxuICpcbiAqIFdoZW4gdGhlIHN0YXRlIGlzIGJlaW5nIGV4aXRlZCwgdGhlIHN0YXRlJ3MgLm9uRXhpdCBmdW5jdGlvbiBpcyBpbnZva2VkLlxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uRXhpdCh7IGV4aXRpbmc6IChzdGF0ZSkgPT4gISFzdGF0ZS5vbkV4aXQgfSwgb25FeGl0SG9vayk7YFxuICpcbiAqIFNlZTogW1tJSG9va1JlZ2lzdHJ5Lm9uRXhpdF1dXG4gKi9cbnZhciBvbkV4aXRIb29rID0gbWFrZUVudGVyRXhpdFJldGFpbkhvb2soJ29uRXhpdCcpO1xuZXhwb3J0cy5yZWdpc3Rlck9uRXhpdEhvb2sgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25FeGl0KHsgZXhpdGluZzogZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAhIXN0YXRlLm9uRXhpdDsgfSB9LCBvbkV4aXRIb29rKTtcbn07XG4vKipcbiAqIFRoZSBbW1RyYW5zaXRpb25TdGF0ZUhvb2tGbl1dIGZvciBvblJldGFpblxuICpcbiAqIFdoZW4gdGhlIHN0YXRlIHdhcyBhbHJlYWR5IGVudGVyZWQsIGFuZCBpcyBub3QgYmVpbmcgZXhpdGVkIG9yIHJlLWVudGVyZWQsIHRoZSBzdGF0ZSdzIC5vblJldGFpbiBmdW5jdGlvbiBpcyBpbnZva2VkLlxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uUmV0YWluKHsgcmV0YWluZWQ6IChzdGF0ZSkgPT4gISFzdGF0ZS5vblJldGFpbiB9LCBvblJldGFpbkhvb2spO2BcbiAqXG4gKiBTZWU6IFtbSUhvb2tSZWdpc3RyeS5vblJldGFpbl1dXG4gKi9cbnZhciBvblJldGFpbkhvb2sgPSBtYWtlRW50ZXJFeGl0UmV0YWluSG9vaygnb25SZXRhaW4nKTtcbmV4cG9ydHMucmVnaXN0ZXJPblJldGFpbkhvb2sgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25SZXRhaW4oeyByZXRhaW5lZDogZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAhIXN0YXRlLm9uUmV0YWluOyB9IH0sIG9uUmV0YWluSG9vayk7XG59O1xuLyoqXG4gKiBUaGUgW1tUcmFuc2l0aW9uU3RhdGVIb29rRm5dXSBmb3Igb25FbnRlclxuICpcbiAqIFdoZW4gdGhlIHN0YXRlIGlzIGJlaW5nIGVudGVyZWQsIHRoZSBzdGF0ZSdzIC5vbkVudGVyIGZ1bmN0aW9uIGlzIGludm9rZWQuXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25FbnRlcih7IGVudGVyaW5nOiAoc3RhdGUpID0+ICEhc3RhdGUub25FbnRlciB9LCBvbkVudGVySG9vayk7YFxuICpcbiAqIFNlZTogW1tJSG9va1JlZ2lzdHJ5Lm9uRW50ZXJdXVxuICovXG52YXIgb25FbnRlckhvb2sgPSBtYWtlRW50ZXJFeGl0UmV0YWluSG9vaygnb25FbnRlcicpO1xuZXhwb3J0cy5yZWdpc3Rlck9uRW50ZXJIb29rID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uRW50ZXIoeyBlbnRlcmluZzogZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAhIXN0YXRlLm9uRW50ZXI7IH0gfSwgb25FbnRlckhvb2spO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uRW50ZXJFeGl0UmV0YWluLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9vbkVudGVyRXhpdFJldGFpbi5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQG1vZHVsZSBob29rcyAqL1xuLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciByZXNvbHZlQ29udGV4dF8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmUvcmVzb2x2ZUNvbnRleHRcIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB3aGljaCByZXNvbHZlcyBhbGwgRUFHRVIgUmVzb2x2YWJsZXMgaW4gdGhlIFRvIFBhdGhcbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vblN0YXJ0KHt9LCBlYWdlclJlc29sdmVQYXRoKTtgXG4gKlxuICogV2hlbiBhIFRyYW5zaXRpb24gc3RhcnRzLCB0aGlzIGhvb2sgcmVzb2x2ZXMgYWxsIHRoZSBFQUdFUiBSZXNvbHZhYmxlcywgd2hpY2ggdGhlIHRyYW5zaXRpb24gdGhlbiB3YWl0cyBmb3IuXG4gKlxuICogU2VlIFtbU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV1cbiAqL1xudmFyIGVhZ2VyUmVzb2x2ZVBhdGggPSBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICByZXR1cm4gbmV3IHJlc29sdmVDb250ZXh0XzEuUmVzb2x2ZUNvbnRleHQodHJhbnMudHJlZUNoYW5nZXMoKS50bylcbiAgICAgICAgLnJlc29sdmVQYXRoKFwiRUFHRVJcIiwgdHJhbnMpXG4gICAgICAgIC50aGVuKGNvbW1vbl8xLm5vb3ApO1xufTtcbmV4cG9ydHMucmVnaXN0ZXJFYWdlclJlc29sdmVQYXRoID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnQoe30sIGVhZ2VyUmVzb2x2ZVBhdGgsIHsgcHJpb3JpdHk6IDEwMDAgfSk7XG59O1xuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHdoaWNoIHJlc29sdmVzIGFsbCBMQVpZIFJlc29sdmFibGVzIGZvciB0aGUgc3RhdGUgKGFuZCBhbGwgaXRzIGFuY2VzdG9ycykgaW4gdGhlIFRvIFBhdGhcbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vbkVudGVyKHsgZW50ZXJpbmc6ICgpID0+IHRydWUgfSwgbGF6eVJlc29sdmVTdGF0ZSk7YFxuICpcbiAqIFdoZW4gYSBTdGF0ZSBpcyBiZWluZyBlbnRlcmVkLCB0aGlzIGhvb2sgcmVzb2x2ZXMgYWxsIHRoZSBSZXNvbHZhYmxlcyBmb3IgdGhpcyBzdGF0ZSwgd2hpY2ggdGhlIHRyYW5zaXRpb24gdGhlbiB3YWl0cyBmb3IuXG4gKlxuICogU2VlIFtbU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV1cbiAqL1xudmFyIGxhenlSZXNvbHZlU3RhdGUgPSBmdW5jdGlvbiAodHJhbnMsIHN0YXRlKSB7XG4gICAgcmV0dXJuIG5ldyByZXNvbHZlQ29udGV4dF8xLlJlc29sdmVDb250ZXh0KHRyYW5zLnRyZWVDaGFuZ2VzKCkudG8pXG4gICAgICAgIC5zdWJDb250ZXh0KHN0YXRlLiQkc3RhdGUoKSlcbiAgICAgICAgLnJlc29sdmVQYXRoKFwiTEFaWVwiLCB0cmFucylcbiAgICAgICAgLnRoZW4oY29tbW9uXzEubm9vcCk7XG59O1xuZXhwb3J0cy5yZWdpc3RlckxhenlSZXNvbHZlU3RhdGUgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25FbnRlcih7IGVudGVyaW5nOiBob2ZfMS52YWwodHJ1ZSkgfSwgbGF6eVJlc29sdmVTdGF0ZSwgeyBwcmlvcml0eTogMTAwMCB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9yZXNvbHZlLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIGhvb2tzICovIC8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB3aGljaCB3YWl0cyBmb3IgdGhlIHZpZXdzIHRvIGxvYWRcbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vblN0YXJ0KHt9LCBsb2FkRW50ZXJpbmdWaWV3cyk7YFxuICpcbiAqIEFsbG93cyB0aGUgdmlld3MgdG8gZG8gYXN5bmMgd29yayBpbiBbW1ZpZXdDb25maWcubG9hZF1dIGJlZm9yZSB0aGUgdHJhbnNpdGlvbiBjb250aW51ZXMuXG4gKiBJbiBhbmd1bGFyIDEsIHRoaXMgaW5jbHVkZXMgbG9hZGluZyB0aGUgdGVtcGxhdGVzLlxuICovXG52YXIgbG9hZEVudGVyaW5nVmlld3MgPSBmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICAgIHZhciAkcSA9IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxO1xuICAgIHZhciBlbnRlcmluZ1ZpZXdzID0gdHJhbnNpdGlvbi52aWV3cyhcImVudGVyaW5nXCIpO1xuICAgIGlmICghZW50ZXJpbmdWaWV3cy5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICByZXR1cm4gJHEuYWxsKGVudGVyaW5nVmlld3MubWFwKGZ1bmN0aW9uICh2aWV3KSB7IHJldHVybiAkcS53aGVuKHZpZXcubG9hZCgpKTsgfSkpLnRoZW4oY29tbW9uXzEubm9vcCk7XG59O1xuZXhwb3J0cy5yZWdpc3RlckxvYWRFbnRlcmluZ1ZpZXdzID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uRmluaXNoKHt9LCBsb2FkRW50ZXJpbmdWaWV3cyk7XG59O1xuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHdoaWNoIGFjdGl2YXRlcyB0aGUgbmV3IHZpZXdzIHdoZW4gYSB0cmFuc2l0aW9uIGlzIHN1Y2Nlc3NmdWwuXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25TdWNjZXNzKHt9LCBhY3RpdmF0ZVZpZXdzKTtgXG4gKlxuICogQWZ0ZXIgYSB0cmFuc2l0aW9uIGlzIGNvbXBsZXRlLCB0aGlzIGhvb2sgZGVhY3RpdmF0ZXMgdGhlIG9sZCB2aWV3cyBmcm9tIHRoZSBwcmV2aW91cyBzdGF0ZSxcbiAqIGFuZCBhY3RpdmF0ZXMgdGhlIG5ldyB2aWV3cyBmcm9tIHRoZSBkZXN0aW5hdGlvbiBzdGF0ZS5cbiAqXG4gKiBTZWUgW1tWaWV3U2VydmljZV1dXG4gKi9cbnZhciBhY3RpdmF0ZVZpZXdzID0gZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgICB2YXIgZW50ZXJpbmdWaWV3cyA9IHRyYW5zaXRpb24udmlld3MoXCJlbnRlcmluZ1wiKTtcbiAgICB2YXIgZXhpdGluZ1ZpZXdzID0gdHJhbnNpdGlvbi52aWV3cyhcImV4aXRpbmdcIik7XG4gICAgaWYgKCFlbnRlcmluZ1ZpZXdzLmxlbmd0aCAmJiAhZXhpdGluZ1ZpZXdzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciAkdmlldyA9IHRyYW5zaXRpb24ucm91dGVyLnZpZXdTZXJ2aWNlO1xuICAgIGV4aXRpbmdWaWV3cy5mb3JFYWNoKGZ1bmN0aW9uICh2YykgeyByZXR1cm4gJHZpZXcuZGVhY3RpdmF0ZVZpZXdDb25maWcodmMpOyB9KTtcbiAgICBlbnRlcmluZ1ZpZXdzLmZvckVhY2goZnVuY3Rpb24gKHZjKSB7IHJldHVybiAkdmlldy5hY3RpdmF0ZVZpZXdDb25maWcodmMpOyB9KTtcbiAgICAkdmlldy5zeW5jKCk7XG59O1xuZXhwb3J0cy5yZWdpc3RlckFjdGl2YXRlVmlld3MgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25TdWNjZXNzKHt9LCBhY3RpdmF0ZVZpZXdzKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3cy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3Mvdmlld3MuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gd2hpY2ggdXBkYXRlcyBnbG9iYWwgVUktUm91dGVyIHN0YXRlXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25CZWZvcmUoe30sIHVwZGF0ZUdsb2JhbFN0YXRlKTtgXG4gKlxuICogQmVmb3JlIGEgW1tUcmFuc2l0aW9uXV0gc3RhcnRzLCB1cGRhdGVzIHRoZSBnbG9iYWwgdmFsdWUgb2YgXCJ0aGUgY3VycmVudCB0cmFuc2l0aW9uXCIgKFtbR2xvYmFscy50cmFuc2l0aW9uXV0pLlxuICogQWZ0ZXIgYSBzdWNjZXNzZnVsIFtbVHJhbnNpdGlvbl1dLCB1cGRhdGVzIHRoZSBnbG9iYWwgdmFsdWVzIG9mIFwidGhlIGN1cnJlbnQgc3RhdGVcIlxuICogKFtbR2xvYmFscy5jdXJyZW50XV0gYW5kIFtbR2xvYmFscy4kY3VycmVudF1dKSBhbmQgXCJ0aGUgY3VycmVudCBwYXJhbSB2YWx1ZXNcIiAoW1tHbG9iYWxzLnBhcmFtc11dKS5cbiAqXG4gKiBTZWUgYWxzbyB0aGUgZGVwcmVjYXRlZCBwcm9wZXJ0aWVzOlxuICogW1tTdGF0ZVNlcnZpY2UudHJhbnNpdGlvbl1dLCBbW1N0YXRlU2VydmljZS5jdXJyZW50XV0sIFtbU3RhdGVTZXJ2aWNlLnBhcmFtc11dXG4gKi9cbnZhciB1cGRhdGVHbG9iYWxTdGF0ZSA9IGZ1bmN0aW9uICh0cmFucykge1xuICAgIHZhciBnbG9iYWxzID0gdHJhbnMucm91dGVyLmdsb2JhbHM7XG4gICAgdmFyIHRyYW5zaXRpb25TdWNjZXNzZnVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBnbG9iYWxzLnN1Y2Nlc3NmdWxUcmFuc2l0aW9ucy5lbnF1ZXVlKHRyYW5zKTtcbiAgICAgICAgZ2xvYmFscy4kY3VycmVudCA9IHRyYW5zLiR0bygpO1xuICAgICAgICBnbG9iYWxzLmN1cnJlbnQgPSBnbG9iYWxzLiRjdXJyZW50LnNlbGY7XG4gICAgICAgIGNvbW1vbl8xLmNvcHkodHJhbnMucGFyYW1zKCksIGdsb2JhbHMucGFyYW1zKTtcbiAgICB9O1xuICAgIHZhciBjbGVhckN1cnJlbnRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBEbyBub3QgY2xlYXIgZ2xvYmFscy50cmFuc2l0aW9uIGlmIGEgZGlmZmVyZW50IHRyYW5zaXRpb24gaGFzIHN0YXJ0ZWQgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgIGlmIChnbG9iYWxzLnRyYW5zaXRpb24gPT09IHRyYW5zKVxuICAgICAgICAgICAgZ2xvYmFscy50cmFuc2l0aW9uID0gbnVsbDtcbiAgICB9O1xuICAgIHRyYW5zLm9uU3VjY2Vzcyh7fSwgdHJhbnNpdGlvblN1Y2Nlc3NmdWwsIHsgcHJpb3JpdHk6IDEwMDAwIH0pO1xuICAgIHRyYW5zLnByb21pc2UudGhlbihjbGVhckN1cnJlbnRUcmFuc2l0aW9uLCBjbGVhckN1cnJlbnRUcmFuc2l0aW9uKTtcbn07XG5leHBvcnRzLnJlZ2lzdGVyVXBkYXRlR2xvYmFsU3RhdGUgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25DcmVhdGUoe30sIHVwZGF0ZUdsb2JhbFN0YXRlKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cGRhdGVHbG9iYWxzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy91cGRhdGVHbG9iYWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB3aGljaCB1cGRhdGVzIHRoZSBVUkwgYWZ0ZXIgYSBzdWNjZXNzZnVsIHRyYW5zaXRpb25cbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vblN1Y2Nlc3Moe30sIHVwZGF0ZVVybCk7YFxuICovXG52YXIgdXBkYXRlVXJsID0gZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRyYW5zaXRpb24ub3B0aW9ucygpO1xuICAgIHZhciAkc3RhdGUgPSB0cmFuc2l0aW9uLnJvdXRlci5zdGF0ZVNlcnZpY2U7XG4gICAgdmFyICR1cmxSb3V0ZXIgPSB0cmFuc2l0aW9uLnJvdXRlci51cmxSb3V0ZXI7XG4gICAgLy8gRG9udCB1cGRhdGUgdGhlIHVybCBpbiB0aGVzZSBzaXR1YXRpb25zOlxuICAgIC8vIFRoZSB0cmFuc2l0aW9uIHdhcyB0cmlnZ2VyZWQgYnkgYSBVUkwgc3luYyAob3B0aW9ucy5zb3VyY2UgPT09ICd1cmwnKVxuICAgIC8vIFRoZSB1c2VyIGRvZXNuJ3Qgd2FudCB0aGUgdXJsIHRvIHVwZGF0ZSAob3B0aW9ucy5sb2NhdGlvbiA9PT0gZmFsc2UpXG4gICAgLy8gVGhlIGRlc3RpbmF0aW9uIHN0YXRlLCBhbmQgYWxsIHBhcmVudHMgaGF2ZSBubyBuYXZpZ2FibGUgdXJsXG4gICAgaWYgKG9wdGlvbnMuc291cmNlICE9PSAndXJsJyAmJiBvcHRpb25zLmxvY2F0aW9uICYmICRzdGF0ZS4kY3VycmVudC5uYXZpZ2FibGUpIHtcbiAgICAgICAgdmFyIHVybE9wdGlvbnMgPSB7IHJlcGxhY2U6IG9wdGlvbnMubG9jYXRpb24gPT09ICdyZXBsYWNlJyB9O1xuICAgICAgICAkdXJsUm91dGVyLnB1c2goJHN0YXRlLiRjdXJyZW50Lm5hdmlnYWJsZS51cmwsICRzdGF0ZS5wYXJhbXMsIHVybE9wdGlvbnMpO1xuICAgIH1cbiAgICAkdXJsUm91dGVyLnVwZGF0ZSh0cnVlKTtcbn07XG5leHBvcnRzLnJlZ2lzdGVyVXBkYXRlVXJsID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uU3VjY2Vzcyh7fSwgdXBkYXRlVXJsLCB7IHByaW9yaXR5OiA5OTk5IH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvdXJsLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKiBAbW9kdWxlIGhvb2tzICovIC8qKiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRyYWNlXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3RyYWNlXCIpO1xudmFyIHJlamVjdEZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2l0aW9uL3JlamVjdEZhY3RvcnlcIik7XG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gdGhhdCBza2lwcyBhIHRyYW5zaXRpb24gaWYgaXQgc2hvdWxkIGJlIGlnbm9yZWRcbiAqXG4gKiBUaGlzIGhvb2sgaXMgaW52b2tlZCBhdCB0aGUgZW5kIG9mIHRoZSBvbkJlZm9yZSBwaGFzZS5cbiAqXG4gKiBJZiB0aGUgdHJhbnNpdGlvbiBzaG91bGQgYmUgaWdub3JlZCAoYmVjYXVzZSBubyBwYXJhbWV0ZXIgb3Igc3RhdGVzIGNoYW5nZWQpXG4gKiB0aGVuIHRoZSB0cmFuc2l0aW9uIGlzIGlnbm9yZWQgYW5kIG5vdCBwcm9jZXNzZWQuXG4gKi9cbmZ1bmN0aW9uIGlnbm9yZWRIb29rKHRyYW5zKSB7XG4gICAgdmFyIGlnbm9yZWRSZWFzb24gPSB0cmFucy5faWdub3JlZFJlYXNvbigpO1xuICAgIGlmICghaWdub3JlZFJlYXNvbilcbiAgICAgICAgcmV0dXJuO1xuICAgIHRyYWNlXzEudHJhY2UudHJhY2VUcmFuc2l0aW9uSWdub3JlZCh0cmFucyk7XG4gICAgdmFyIHBlbmRpbmcgPSB0cmFucy5yb3V0ZXIuZ2xvYmFscy50cmFuc2l0aW9uO1xuICAgIC8vIFRoZSB1c2VyIGNsaWNrZWQgYSBsaW5rIGdvaW5nIGJhY2sgdG8gdGhlICpjdXJyZW50IHN0YXRlKiAoJ0EnKVxuICAgIC8vIEhvd2V2ZXIsIHRoZXJlIGlzIGFsc28gYSBwZW5kaW5nIHRyYW5zaXRpb24gaW4gZmxpZ2h0ICh0byAnQicpXG4gICAgLy8gQWJvcnQgdGhlIHRyYW5zaXRpb24gdG8gJ0InIGJlY2F1c2UgdGhlIHVzZXIgbm93IHdhbnRzIHRvIGJlIGJhY2sgYXQgJ0EnLlxuICAgIGlmIChpZ25vcmVkUmVhc29uID09PSAnU2FtZUFzQ3VycmVudCcgJiYgcGVuZGluZykge1xuICAgICAgICBwZW5kaW5nLmFib3J0KCk7XG4gICAgfVxuICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmlnbm9yZWQoKS50b1Byb21pc2UoKTtcbn1cbmV4cG9ydHMucmVnaXN0ZXJJZ25vcmVkVHJhbnNpdGlvbkhvb2sgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25CZWZvcmUoe30sIGlnbm9yZWRIb29rLCB7IHByaW9yaXR5OiAtOTk5OSB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZ25vcmVkVHJhbnNpdGlvbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvaWdub3JlZFRyYW5zaXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuLyoqIEBtb2R1bGUgaG9va3MgKi8gLyoqICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gdGhhdCByZWplY3RzIHRoZSBUcmFuc2l0aW9uIGlmIGl0IGlzIGludmFsaWRcbiAqXG4gKiBUaGlzIGhvb2sgaXMgaW52b2tlZCBhdCB0aGUgZW5kIG9mIHRoZSBvbkJlZm9yZSBwaGFzZS5cbiAqIElmIHRoZSB0cmFuc2l0aW9uIGlzIGludmFsaWQgKGZvciBleGFtcGxlLCBwYXJhbSB2YWx1ZXMgZG8gbm90IHZhbGlkYXRlKVxuICogdGhlbiB0aGUgdHJhbnNpdGlvbiBpcyByZWplY3RlZC5cbiAqL1xuZnVuY3Rpb24gaW52YWxpZFRyYW5zaXRpb25Ib29rKHRyYW5zKSB7XG4gICAgaWYgKCF0cmFucy52YWxpZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0cmFucy5lcnJvcigpKTtcbiAgICB9XG59XG5leHBvcnRzLnJlZ2lzdGVySW52YWxpZFRyYW5zaXRpb25Ib29rID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uQmVmb3JlKHt9LCBpbnZhbGlkVHJhbnNpdGlvbkhvb2ssIHsgcHJpb3JpdHk6IC0xMDAwMCB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnZhbGlkVHJhbnNpdGlvbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvaW52YWxpZFRyYW5zaXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogIyBUcmFuc2l0aW9uIHN1YnN5c3RlbVxuICpcbiAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIEFQSXMgcmVsYXRlZCB0byBhIFRyYW5zaXRpb24uXG4gKlxuICogU2VlOlxuICogLSBbW1RyYW5zaXRpb25TZXJ2aWNlXV1cbiAqIC0gW1tUcmFuc2l0aW9uXV1cbiAqIC0gW1tIb29rRm5dXSwgW1tUcmFuc2l0aW9uSG9va0ZuXV0sIFtbVHJhbnNpdGlvblN0YXRlSG9va0ZuXV0sIFtbSG9va01hdGNoQ3JpdGVyaWFdXSwgW1tIb29rUmVzdWx0XV1cbiAqXG4gKiBAY29yZWFwaVxuICogQHByZWZlcnJlZFxuICogQG1vZHVsZSB0cmFuc2l0aW9uXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9pbnRlcmZhY2VcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vaG9va0J1aWxkZXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vaG9va1JlZ2lzdHJ5XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3JlamVjdEZhY3RvcnlcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdHJhbnNpdGlvblwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi90cmFuc2l0aW9uSG9va1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi90cmFuc2l0aW9uRXZlbnRUeXBlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3RyYW5zaXRpb25TZXJ2aWNlXCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi91cmxNYXRjaGVyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3VybE1hdGNoZXJGYWN0b3J5XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3VybFJvdXRlclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi91cmxSdWxlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3VybFNlcnZpY2VcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnQocmVxdWlyZShcIi4vdmlld1wiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmlldy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBtb2R1bGUgdmFuaWxsYVxuICovXG4vKiogKi9cbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3ZhbmlsbGEvaW5kZXhcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFuaWxsYS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS5qc1xuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnQocmVxdWlyZShcIi4vcVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9pbmplY3RvclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9iYXNlTG9jYXRpb25TZXJ2aWNlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2hhc2hMb2NhdGlvblNlcnZpY2VcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vbWVtb3J5TG9jYXRpb25TZXJ2aWNlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3B1c2hTdGF0ZUxvY2F0aW9uU2VydmljZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9tZW1vcnlMb2NhdGlvbkNvbmZpZ1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9icm93c2VyTG9jYXRpb25Db25maWdcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcGx1Z2luc1wiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSB2YW5pbGxhXG4gKi9cbi8qKiAqL1xudmFyIGJyb3dzZXJMb2NhdGlvbkNvbmZpZ18xID0gcmVxdWlyZShcIi4vYnJvd3NlckxvY2F0aW9uQ29uZmlnXCIpO1xudmFyIGhhc2hMb2NhdGlvblNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2hhc2hMb2NhdGlvblNlcnZpY2VcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIHB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vcHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlXCIpO1xudmFyIG1lbW9yeUxvY2F0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vbWVtb3J5TG9jYXRpb25TZXJ2aWNlXCIpO1xudmFyIG1lbW9yeUxvY2F0aW9uQ29uZmlnXzEgPSByZXF1aXJlKFwiLi9tZW1vcnlMb2NhdGlvbkNvbmZpZ1wiKTtcbnZhciBpbmplY3Rvcl8xID0gcmVxdWlyZShcIi4vaW5qZWN0b3JcIik7XG52YXIgcV8xID0gcmVxdWlyZShcIi4vcVwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xuZnVuY3Rpb24gc2VydmljZXNQbHVnaW4ocm91dGVyKSB7XG4gICAgY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yID0gaW5qZWN0b3JfMS4kaW5qZWN0b3I7XG4gICAgY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEgPSBxXzEuJHE7XG4gICAgcmV0dXJuIHsgbmFtZTogXCJ2YW5pbGxhLnNlcnZpY2VzXCIsICRxOiBxXzEuJHEsICRpbmplY3RvcjogaW5qZWN0b3JfMS4kaW5qZWN0b3IsIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0gfTtcbn1cbmV4cG9ydHMuc2VydmljZXNQbHVnaW4gPSBzZXJ2aWNlc1BsdWdpbjtcbi8qKiBBIGBVSVJvdXRlclBsdWdpbmAgdXNlcyB0aGUgYnJvd3NlciBoYXNoIHRvIGdldC9zZXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gKi9cbmV4cG9ydHMuaGFzaExvY2F0aW9uUGx1Z2luID0gdXRpbHNfMS5sb2NhdGlvblBsdWdpbkZhY3RvcnkoJ3ZhbmlsbGEuaGFzaEJhbmdMb2NhdGlvbicsIGZhbHNlLCBoYXNoTG9jYXRpb25TZXJ2aWNlXzEuSGFzaExvY2F0aW9uU2VydmljZSwgYnJvd3NlckxvY2F0aW9uQ29uZmlnXzEuQnJvd3NlckxvY2F0aW9uQ29uZmlnKTtcbi8qKiBBIGBVSVJvdXRlclBsdWdpbmAgdGhhdCBnZXRzL3NldHMgdGhlIGN1cnJlbnQgbG9jYXRpb24gdXNpbmcgdGhlIGJyb3dzZXIncyBgbG9jYXRpb25gIGFuZCBgaGlzdG9yeWAgYXBpcyAqL1xuZXhwb3J0cy5wdXNoU3RhdGVMb2NhdGlvblBsdWdpbiA9IHV0aWxzXzEubG9jYXRpb25QbHVnaW5GYWN0b3J5KFwidmFuaWxsYS5wdXNoU3RhdGVMb2NhdGlvblwiLCB0cnVlLCBwdXNoU3RhdGVMb2NhdGlvblNlcnZpY2VfMS5QdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UsIGJyb3dzZXJMb2NhdGlvbkNvbmZpZ18xLkJyb3dzZXJMb2NhdGlvbkNvbmZpZyk7XG4vKiogQSBgVUlSb3V0ZXJQbHVnaW5gIHRoYXQgZ2V0cy9zZXRzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGZyb20gYW4gaW4tbWVtb3J5IG9iamVjdCAqL1xuZXhwb3J0cy5tZW1vcnlMb2NhdGlvblBsdWdpbiA9IHV0aWxzXzEubG9jYXRpb25QbHVnaW5GYWN0b3J5KFwidmFuaWxsYS5tZW1vcnlMb2NhdGlvblwiLCBmYWxzZSwgbWVtb3J5TG9jYXRpb25TZXJ2aWNlXzEuTWVtb3J5TG9jYXRpb25TZXJ2aWNlLCBtZW1vcnlMb2NhdGlvbkNvbmZpZ18xLk1lbW9yeUxvY2F0aW9uQ29uZmlnKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbnMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvcGx1Z2lucy5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICMgQ29yZSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzXG4gKlxuICogVGhlIGNsYXNzZXMgYW5kIGludGVyZmFjZXMgdGhhdCBhcmUgY29yZSB0byB1aS1yb3V0ZXIgYW5kIGRvIG5vdCBiZWxvbmdcbiAqIHRvIGEgbW9yZSBzcGVjaWZpYyBzdWJzeXN0ZW0gKHN1Y2ggYXMgcmVzb2x2ZSkuXG4gKlxuICogQGNvcmVhcGlcbiAqIEBwcmVmZXJyZWRcbiAqIEBtb2R1bGUgY29yZVxuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBpbnRlcm5hbGFwaSAqL1xudmFyIFVJUm91dGVyUGx1Z2luQmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVSVJvdXRlclBsdWdpbkJhc2UoKSB7XG4gICAgfVxuICAgIFVJUm91dGVyUGx1Z2luQmFzZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChyb3V0ZXIpIHsgfTtcbiAgICByZXR1cm4gVUlSb3V0ZXJQbHVnaW5CYXNlO1xufSgpKTtcbmV4cG9ydHMuVUlSb3V0ZXJQbHVnaW5CYXNlID0gVUlSb3V0ZXJQbHVnaW5CYXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9pbnRlcmZhY2UuanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogTWVyZ2UgdHdvIGluamVjdG9yc1xuICpcbiAqIFRoaXMgY2xhc3MgaW1wbGVtZW50cyB0aGUgSW5qZWN0b3IgbmcyIGludGVyZmFjZSBidXQgZGVsZWdhdGVzXG4gKiB0byB0aGUgSW5qZWN0b3JzIHByb3ZpZGVkIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAqL1xudmFyIE1lcmdlSW5qZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lcmdlSW5qZWN0b3IoKSB7XG4gICAgICAgIHZhciBpbmplY3RvcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGluamVjdG9yc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmplY3RvcnMubGVuZ3RoIDwgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBhc3MgYXQgbGVhc3QgdHdvIGluamVjdG9yc1wiKTtcbiAgICAgICAgdGhpcy5pbmplY3RvcnMgPSBpbmplY3RvcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdG9rZW4gZnJvbSB0aGUgZmlyc3QgaW5qZWN0b3Igd2hpY2ggY29udGFpbnMgaXQuXG4gICAgICpcbiAgICAgKiBEZWxlZ2F0ZXMgdG8gdGhlIGZpcnN0IEluamVjdG9yLmdldCgpLlxuICAgICAqIElmIG5vdCBmb3VuZCwgdGhlbiBkZWxlZ2F0ZXMgdG8gdGhlIHNlY29uZCBJbmplY3RvciAoYW5kIHNvIGZvcnRoKS5cbiAgICAgKiBJZiBubyBJbmplY3RvciBjb250YWlucyB0aGUgdG9rZW4sIHJldHVybiB0aGUgYG5vdEZvdW5kVmFsdWVgLCBvciB0aHJvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b2tlbiB0aGUgREkgdG9rZW5cbiAgICAgKiBAcGFyYW0gbm90Rm91bmRWYWx1ZSB0aGUgdmFsdWUgdG8gcmV0dXJuIGlmIG5vbmUgb2YgdGhlIEluamVjdG9ycyBjb250YWlucyB0aGUgdG9rZW4uXG4gICAgICogQHJldHVybnMge2FueX0gdGhlIERJIHZhbHVlXG4gICAgICovXG4gICAgTWVyZ2VJbmplY3Rvci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmplY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLmluamVjdG9yc1tpXS5nZXQodG9rZW4sIE1lcmdlSW5qZWN0b3IuTk9UX0ZPVU5EKTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IE1lcmdlSW5qZWN0b3IuTk9UX0ZPVU5EKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMilcbiAgICAgICAgICAgIHJldHVybiBub3RGb3VuZFZhbHVlO1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgdGhlIERJIEluamVjdG9yIGVycm9yXG4gICAgICAgIHRoaXMuaW5qZWN0b3JzWzBdLmdldCh0b2tlbik7XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VJbmplY3Rvcjtcbn0oKSk7XG5leHBvcnQgeyBNZXJnZUluamVjdG9yIH07XG5NZXJnZUluamVjdG9yLk5PVF9GT1VORCA9IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VJbmplY3Rvci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvYW5ndWxhci9saWIvbWVyZ2VJbmplY3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzk1X187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyeGpzL0JlaGF2aW9yU3ViamVjdFwiXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfOTZfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJ4anMvb2JzZXJ2YWJsZS9vZlwiXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfOTdfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJ4anMvb2JzZXJ2YWJsZS9mcm9tUHJvbWlzZVwiXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfOThfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJ4anMvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0XCJcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV85OV9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicnhqcy9vcGVyYXRvci9zd2l0Y2hNYXBcIlxuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzEwMF9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicnhqcy9vcGVyYXRvci9tYXBcIlxuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xMDFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJ4anMvb3BlcmF0b3IvY29uY2F0XCJcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgKiBmcm9tIFwiLi91aS1yb3V0ZXItcnhcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9yeC9saWItZXNtL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIEBtb2R1bGUgcnggKi9cbi8qKiAqL1xuaW1wb3J0IFwicnhqcy9hZGQvb3BlcmF0b3IvbWVyZ2VNYXBcIjtcbmltcG9ydCBcInJ4anMvYWRkL29wZXJhdG9yL21hcFwiO1xuaW1wb3J0IHsgUmVwbGF5U3ViamVjdCB9IGZyb20gXCJyeGpzL1JlcGxheVN1YmplY3RcIjtcbi8qKiBBdWdtZW50cyBVSVJvdXRlckdsb2JhbHMgd2l0aCBvYnNlcnZhYmxlcyBmb3IgdHJhbnNpdGlvbiBzdGFydHMsIHN1Y2Nlc3NmdWwgdHJhbnNpdGlvbnMsIGFuZCBzdGF0ZSBwYXJhbWV0ZXJzICovXG52YXIgVUlSb3V0ZXJSeCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVUlSb3V0ZXJSeChyb3V0ZXIpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0B1aXJvdXRlci9yeCc7XG4gICAgICAgIHRoaXMuZGVyZWdpc3RlckZucyA9IFtdO1xuICAgICAgICB2YXIgc3RhcnQkID0gbmV3IFJlcGxheVN1YmplY3QoMSk7XG4gICAgICAgIHZhciBzdWNjZXNzJCA9IHN0YXJ0JC5tZXJnZU1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdDsgfSk7IH0pO1xuICAgICAgICB2YXIgcGFyYW1zJCA9IHN1Y2Nlc3MkLm1hcChmdW5jdGlvbiAodHJhbnNpdGlvbikgeyByZXR1cm4gdHJhbnNpdGlvbi5wYXJhbXMoKTsgfSk7XG4gICAgICAgIHZhciBzdGF0ZXMkID0gbmV3IFJlcGxheVN1YmplY3QoMSk7XG4gICAgICAgIGZ1bmN0aW9uIG9uU3RhdGVzQ2hhbmdlZEV2ZW50KGV2ZW50LCBzdGF0ZXMpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VFdmVudCA9IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGVzOiByb3V0ZXIuc3RhdGVSZWdpc3RyeS5nZXQoKSxcbiAgICAgICAgICAgICAgICByZWdpc3RlcmVkOiBbXSxcbiAgICAgICAgICAgICAgICBkZXJlZ2lzdGVyZWQ6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGV2ZW50KVxuICAgICAgICAgICAgICAgIGNoYW5nZUV2ZW50W2V2ZW50XSA9IHN0YXRlcztcbiAgICAgICAgICAgIHN0YXRlcyQubmV4dChjaGFuZ2VFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXJlZ2lzdGVyRm5zLnB1c2gocm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnQoe30sIGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7IHJldHVybiBzdGFydCQubmV4dCh0cmFuc2l0aW9uKTsgfSkpO1xuICAgICAgICB0aGlzLmRlcmVnaXN0ZXJGbnMucHVzaChyb3V0ZXIuc3RhdGVSZWdpc3RyeS5vblN0YXRlc0NoYW5nZWQob25TdGF0ZXNDaGFuZ2VkRXZlbnQpKTtcbiAgICAgICAgb25TdGF0ZXNDaGFuZ2VkRXZlbnQobnVsbCwgbnVsbCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocm91dGVyLmdsb2JhbHMsIHsgc3RhcnQkOiBzdGFydCQsIHN1Y2Nlc3MkOiBzdWNjZXNzJCwgcGFyYW1zJDogcGFyYW1zJCwgc3RhdGVzJDogc3RhdGVzJCB9KTtcbiAgICB9XG4gICAgVUlSb3V0ZXJSeC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXJlZ2lzdGVyRm5zLmZvckVhY2goZnVuY3Rpb24gKGRlcmVnaXN0ZXJGbikgeyByZXR1cm4gZGVyZWdpc3RlckZuKCk7IH0pO1xuICAgICAgICB0aGlzLmRlcmVnaXN0ZXJGbnMgPSBbXTtcbiAgICB9O1xuICAgIHJldHVybiBVSVJvdXRlclJ4O1xufSgpKTtcbmV4cG9ydCB7IFVJUm91dGVyUnggfTtcbmV4cG9ydCB2YXIgVUlSb3V0ZXJSeFBsdWdpbiA9IFVJUm91dGVyUng7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11aS1yb3V0ZXItcnguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL3J4L2xpYi1lc20vdWktcm91dGVyLXJ4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzEwNF9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicnhqcy9hZGQvb3BlcmF0b3IvbWVyZ2VNYXBcIlxuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xMDVfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJ4anMvYWRkL29wZXJhdG9yL21hcFwiXG4vLyBtb2R1bGUgaWQgPSAxMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbi8qKiBAbW9kdWxlIG5nMiAqL1xuLyoqICovXG5pbXBvcnQgeyBCYXNlTG9jYXRpb25TZXJ2aWNlcywgcGFyc2VVcmwgfSBmcm9tICdAdWlyb3V0ZXIvY29yZSc7XG4vKiogQSBgTG9jYXRpb25TZXJ2aWNlc2AgdGhhdCBkZWxlZ2F0ZXMgdG8gdGhlIEFuZ3VsYXIgTG9jYXRpb25TdHJhdGVneSAqL1xudmFyIE5nMkxvY2F0aW9uU2VydmljZXMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE5nMkxvY2F0aW9uU2VydmljZXMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmcyTG9jYXRpb25TZXJ2aWNlcyhyb3V0ZXIsIF9sb2NhdGlvblN0cmF0ZWd5LCBpc0Jyb3dzZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcm91dGVyLCBpc0Jyb3dzZXIpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9sb2NhdGlvblN0cmF0ZWd5ID0gX2xvY2F0aW9uU3RyYXRlZ3k7XG4gICAgICAgIF90aGlzLl9sb2NhdGlvblN0cmF0ZWd5Lm9uUG9wU3RhdGUoZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgaWYgKGV2dC50eXBlICE9PSAnaGFzaGNoYW5nZScpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbGlzdGVuZXIoZXZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTmcyTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUuX2dldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uU3RyYXRlZ3kucGF0aCh0cnVlKVxuICAgICAgICAgICAgLnJlcGxhY2UodGhpcy5fbG9jYXRpb25TdHJhdGVneS5nZXRCYXNlSHJlZigpLnJlcGxhY2UoL1xcLyQvLCAnJyksICcnKTtcbiAgICB9O1xuICAgIE5nMkxvY2F0aW9uU2VydmljZXMucHJvdG90eXBlLl9zZXQgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCB1cmwsIHJlcGxhY2UpIHtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VVcmwodXJsKSwgcGF0aCA9IF9hLnBhdGgsIHNlYXJjaCA9IF9hLnNlYXJjaCwgaGFzaCA9IF9hLmhhc2g7XG4gICAgICAgIHZhciB1cmxXaXRoSGFzaCA9IHBhdGggKyAoaGFzaCA/IFwiI1wiICsgaGFzaCA6IFwiXCIpO1xuICAgICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICAgICAgdGhpcy5fbG9jYXRpb25TdHJhdGVneS5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCB1cmxXaXRoSGFzaCwgc2VhcmNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2F0aW9uU3RyYXRlZ3kucHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgdXJsV2l0aEhhc2gsIHNlYXJjaCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5nMkxvY2F0aW9uU2VydmljZXMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMsIHJvdXRlcik7XG4gICAgfTtcbiAgICByZXR1cm4gTmcyTG9jYXRpb25TZXJ2aWNlcztcbn0oQmFzZUxvY2F0aW9uU2VydmljZXMpKTtcbmV4cG9ydCB7IE5nMkxvY2F0aW9uU2VydmljZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2F0aW9uU2VydmljZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvYW5ndWxhci9saWIvbG9jYXRpb24vbG9jYXRpb25TZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIEBtb2R1bGUgbmcyICovXG4vKiogKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBpcywgQnJvd3NlckxvY2F0aW9uQ29uZmlnIH0gZnJvbSBcIkB1aXJvdXRlci9jb3JlXCI7XG5pbXBvcnQgeyBQYXRoTG9jYXRpb25TdHJhdGVneSB9IGZyb20gXCJAYW5ndWxhci9jb21tb25cIjtcbnZhciBOZzJMb2NhdGlvbkNvbmZpZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTmcyTG9jYXRpb25Db25maWcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmcyTG9jYXRpb25Db25maWcocm91dGVyLCBfbG9jYXRpb25TdHJhdGVneSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByb3V0ZXIsIGlzKFBhdGhMb2NhdGlvblN0cmF0ZWd5KShfbG9jYXRpb25TdHJhdGVneSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9sb2NhdGlvblN0cmF0ZWd5ID0gX2xvY2F0aW9uU3RyYXRlZ3k7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTmcyTG9jYXRpb25Db25maWcucHJvdG90eXBlLmJhc2VIcmVmID0gZnVuY3Rpb24gKGhyZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uU3RyYXRlZ3kuZ2V0QmFzZUhyZWYoKTtcbiAgICB9O1xuICAgIHJldHVybiBOZzJMb2NhdGlvbkNvbmZpZztcbn0oQnJvd3NlckxvY2F0aW9uQ29uZmlnKSk7XG5leHBvcnQgeyBOZzJMb2NhdGlvbkNvbmZpZyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYXRpb25Db25maWcuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2FuZ3VsYXIvbGliL2xvY2F0aW9uL2xvY2F0aW9uQ29uZmlnLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzEwOF9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicnhqcy9hZGQvb3BlcmF0b3IvZmlsdGVyXCJcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgKiBmcm9tICcuL2JhaWR1L2FuZ3VsYXJ0aWNzMi1iYWlkdS1hbmFseXRpY3MnO1xuZXhwb3J0ICogZnJvbSAnLi9nYS9hbmd1bGFydGljczItZ2EnO1xuZXhwb3J0ICogZnJvbSAnLi9ndG0vYW5ndWxhcnRpY3MyLWd0bSc7XG5leHBvcnQgKiBmcm9tICcuL2tpc3NtZXRyaWNzL2FuZ3VsYXJ0aWNzMi1raXNzbWV0cmljcyc7XG5leHBvcnQgKiBmcm9tICcuL21peHBhbmVsL2FuZ3VsYXJ0aWNzMi1taXhwYW5lbCc7XG5leHBvcnQgKiBmcm9tICcuL3Bpd2lrL2FuZ3VsYXJ0aWNzMi1waXdpayc7XG5leHBvcnQgKiBmcm9tICcuL3NlZ21lbnQvYW5ndWxhcnRpY3MyLXNlZ21lbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9mYWNlYm9vay9hbmd1bGFydGljczItZmFjZWJvb2snO1xuZXhwb3J0ICogZnJvbSAnLi9hcHBpbnNpZ2h0cy9hbmd1bGFydGljczItYXBwaW5zaWdodHMnO1xuZXhwb3J0ICogZnJvbSAnLi9odWJzcG90L2FuZ3VsYXJ0aWNzMi1odWJzcG90JztcbmV4cG9ydCAqIGZyb20gJy4vYWRvYmVhbmFseXRpY3MvYW5ndWxhcnRpY3MyLWFkb2JlYW5hbHl0aWNzJztcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3RzbGludC1sb2FkZXIhLi9zcmMvcHJvdmlkZXJzL2luZGV4LnRzIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBBbmd1bGFydGljczIgfSBmcm9tICcuLi8uLi9jb3JlL2FuZ3VsYXJ0aWNzMic7XG5cbmRlY2xhcmUgdmFyIGhtdDogYW55O1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQW5ndWxhcnRpY3MyQmFpZHVBbmFseXRpY3Mge1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgYW5ndWxhcnRpY3MyOiBBbmd1bGFydGljczJcbiAgICApIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoaG10KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGhtdCA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG10LnB1c2goWydfIHNldEF1dG9QYWdldmlldycsIGZhbHNlXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFuZ3VsYXJ0aWNzMi5wYWdlVHJhY2suc3Vic2NyaWJlKCh4OiBhbnkpID0+IHRoaXMucGFnZVRyYWNrKHgucGF0aCkpO1xuXG4gICAgICAgIHRoaXMuYW5ndWxhcnRpY3MyLmV2ZW50VHJhY2suc3Vic2NyaWJlKCh4OiBhbnkpID0+IHRoaXMuZXZlbnRUcmFjayh4LmFjdGlvbiwgeC5wcm9wZXJ0aWVzKSk7XG5cbiAgICAgICAgdGhpcy5hbmd1bGFydGljczIuc2V0VXNlcm5hbWUuc3Vic2NyaWJlKCh4OiBzdHJpbmcpID0+IHRoaXMuc2V0VXNlcm5hbWUoeCkpO1xuXG4gICAgICAgIHRoaXMuYW5ndWxhcnRpY3MyLnNldFVzZXJQcm9wZXJ0aWVzLnN1YnNjcmliZSgoeDogYW55KSA9PiB0aGlzLnNldFVzZXJQcm9wZXJ0aWVzKHgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWdlIFRyYWNrIGluIEJhaWR1IEFuYWx5dGljc1xuICAgICAqIEBuYW1lIHBhZ2VUcmFja1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUmVxdWlyZWQgJ3BhdGgnIChzdHJpbmcpXG4gICAgICpcbiAgICAgKiBAbGluayBodHRwOi8vdG9uZ2ppLmJhaWR1LmNvbS9vcGVuL2FwaS9tb3JlP3A9cmVmX3RyYWNrUGFnZXZpZXdcbiAgICAgKlxuICAgICAqL1xuICAgIHBhZ2VUcmFjayhwYXRoOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBobXQgIT09ICd1bmRlZmluZWQnICYmIGhtdCkge1xuICAgICAgICAgICAgaG10LnB1c2goWydfdHJhY2tQYWdldmlldycsIHBhdGhdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYWNrIEV2ZW50IGluIEJhaWR1IEFuYWx5dGljc1xuICAgICAqIEBuYW1lIGV2ZW50VHJhY2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24gUmVxdWlyZWQgJ2FjdGlvbicgKHN0cmluZykgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIENvbXByaXNlZCBvZiB0aGUgbWFuZGF0b3J5IGZpZWxkICdjYXRlZ29yeScgKHN0cmluZyksICdvcHRfbGFiZWwnKHN0cmluZykgYW5kICdvcHRfdmFsdWUnIChzdHJpbmcpXG4gICAgICpcbiAgICAgKiBAbGluayBodHRwOi8vdG9uZ2ppLmJhaWR1LmNvbS9vcGVuL2FwaS9tb3JlP3A9cmVmX3RyYWNrRXZlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIGV2ZW50VHJhY2soYWN0aW9uOiBzdHJpbmcsIHByb3BlcnRpZXM6IGFueSkge1xuICAgICAgICAvL2JhaWR1IGFuYWx5dGljcyByZXF1aXJlcyBjYXRlZ29yeVxuICAgICAgICBpZiAoIXByb3BlcnRpZXMgfHwgIXByb3BlcnRpZXMuY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IHt9O1xuICAgICAgICAgICAgcHJvcGVydGllcy5jYXRlZ29yeSA9ICdFdmVudCc7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLm9wdF9sYWJlbCA9ICdkZWZhdWx0JztcbiAgICAgICAgICAgIHByb3BlcnRpZXMub3B0X3ZhbHVlID0gJ2RlZmF1bHQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBobXQgIT09ICd1bmRlZmluZWQnICYmIGhtdCkge1xuICAgICAgICAgICAgaG10LnB1c2goWydfdHJhY2tFdmVudCcsIHByb3BlcnRpZXMuY2F0ZWdvcnksIGFjdGlvbiwgcHJvcGVydGllcy5vcHRfbGFiZWwsIHByb3BlcnRpZXMub3B0X3ZhbHVlXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRVc2VybmFtZSh1c2VySWQ6IHN0cmluZykge1xuICAgICAgICAvLyBzZXQgZGVmYXVsdCBjdXN0b20gdmFyaWFibGVzIG5hbWUgdG8gJ2lkZW50aXR5JyBhbmQgJ3ZhbHVlJ1xuICAgICAgICBobXQucHVzaChbJ19zZXRDdXN0b21WYXInLCAxLCAnaWRlbnRpdHknLCB1c2VySWRdKTtcbiAgICB9XG5cbiAgICBzZXRVc2VyUHJvcGVydGllcyhwcm9wZXJ0aWVzOiBhbnkpIHtcbiAgICAgICAgaG10LnB1c2goWydfc2V0Q3VzdG9tVmFyJywgMiwgJ3VzZXInLCBKU09OLnN0cmluZ2lmeShwcm9wZXJ0aWVzKV0pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy90c2xpbnQtbG9hZGVyIS4vc3JjL3Byb3ZpZGVycy9iYWlkdS9hbmd1bGFydGljczItYmFpZHUtYW5hbHl0aWNzLnRzIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBBbmd1bGFydGljczIgfSBmcm9tICcuLi8uLi9jb3JlL2FuZ3VsYXJ0aWNzMic7XG5cbmRlY2xhcmUgdmFyIF9nYXE6IGFueTtcbmRlY2xhcmUgdmFyIGdhOiBhbnk7XG5kZWNsYXJlIHZhciBsb2NhdGlvbjogYW55O1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQW5ndWxhcnRpY3MyR29vZ2xlQW5hbHl0aWNzIHtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGFuZ3VsYXJ0aWNzMjogQW5ndWxhcnRpY3MyXG4gICkge1xuICAgIHRoaXMuYW5ndWxhcnRpY3MyLnNldHRpbmdzLnBhZ2VUcmFja2luZy50cmFja1JlbGF0aXZlUGF0aCA9IHRydWU7XG5cbiAgICAvLyBTZXQgdGhlIGRlZmF1bHQgc2V0dGluZ3MgZm9yIHRoaXMgbW9kdWxlXG4gICAgdGhpcy5hbmd1bGFydGljczIuc2V0dGluZ3MuZ2EgPSB7XG4gICAgICAvLyBhcnJheSBvZiBhZGRpdGlvbmFsIGFjY291bnQgbmFtZXMgKG9ubHkgd29ya3MgZm9yIGFuYWx5dGljc2pzKVxuICAgICAgYWRkaXRpb25hbEFjY291bnROYW1lczogW10sXG4gICAgICB1c2VySWQ6IG51bGxcbiAgICB9O1xuXG4gICAgdGhpcy5hbmd1bGFydGljczIucGFnZVRyYWNrLnN1YnNjcmliZSgoeDogYW55KSA9PiB0aGlzLnBhZ2VUcmFjayh4LnBhdGgpKTtcblxuICAgIHRoaXMuYW5ndWxhcnRpY3MyLmV2ZW50VHJhY2suc3Vic2NyaWJlKCh4OiBhbnkpID0+IHRoaXMuZXZlbnRUcmFjayh4LmFjdGlvbiwgeC5wcm9wZXJ0aWVzKSk7XG5cbiAgICB0aGlzLmFuZ3VsYXJ0aWNzMi5leGNlcHRpb25UcmFjay5zdWJzY3JpYmUoKHg6IGFueSkgPT4gdGhpcy5leGNlcHRpb25UcmFjayh4KSk7XG5cbiAgICB0aGlzLmFuZ3VsYXJ0aWNzMi5zZXRVc2VybmFtZS5zdWJzY3JpYmUoKHg6IHN0cmluZykgPT4gdGhpcy5zZXRVc2VybmFtZSh4KSk7XG5cbiAgICB0aGlzLmFuZ3VsYXJ0aWNzMi5zZXRVc2VyUHJvcGVydGllcy5zdWJzY3JpYmUoKHg6IGFueSkgPT4gdGhpcy5zZXRVc2VyUHJvcGVydGllcyh4KSk7XG5cbiAgICB0aGlzLmFuZ3VsYXJ0aWNzMi51c2VyVGltaW5ncy5zdWJzY3JpYmUoKHg6IGFueSkgPT4gdGhpcy51c2VyVGltaW5ncyh4KSk7XG4gIH1cblxuICBwYWdlVHJhY2socGF0aDogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBfZ2FxICE9PSAndW5kZWZpbmVkJyAmJiBfZ2FxKSB7XG4gICAgICBfZ2FxLnB1c2goWydfdHJhY2tQYWdldmlldycsIHBhdGhdKTtcbiAgICAgIGZvciAobGV0IGFjY291bnROYW1lIG9mIHRoaXMuYW5ndWxhcnRpY3MyLnNldHRpbmdzLmdhLmFkZGl0aW9uYWxBY2NvdW50TmFtZXMpIHtcbiAgICAgICAgX2dhcS5wdXNoKFthY2NvdW50TmFtZSArICcuX3RyYWNrUGFnZXZpZXcnLCBwYXRoXSk7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGdhICE9PSAndW5kZWZpbmVkJyAmJiBnYSkge1xuICAgICAgaWYgKHRoaXMuYW5ndWxhcnRpY3MyLnNldHRpbmdzLmdhLnVzZXJJZCkge1xuICAgICAgICBnYSgnc2V0JywgJyZ1aWQnLCB0aGlzLmFuZ3VsYXJ0aWNzMi5zZXR0aW5ncy5nYS51c2VySWQpO1xuICAgICAgfVxuICAgICAgZ2EoJ3NlbmQnLCAncGFnZXZpZXcnLCBwYXRoKTtcbiAgICAgIGZvciAobGV0IGFjY291bnROYW1lIG9mIHRoaXMuYW5ndWxhcnRpY3MyLnNldHRpbmdzLmdhLmFkZGl0aW9uYWxBY2NvdW50TmFtZXMpIHtcbiAgICAgICAgZ2EoYWNjb3VudE5hbWUgKyAnLnNlbmQnLCAncGFnZXZpZXcnLCBwYXRoKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYWNrIEV2ZW50IGluIEdBXG4gICAqIEBuYW1lIGV2ZW50VHJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvbiBSZXF1aXJlZCAnYWN0aW9uJyAoc3RyaW5nKSBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIENvbXByaXNlZCBvZiB0aGUgbWFuZGF0b3J5IGZpZWxkICdjYXRlZ29yeScgKHN0cmluZykgYW5kIG9wdGlvbmFsICBmaWVsZHMgJ2xhYmVsJyAoc3RyaW5nKSwgJ3ZhbHVlJyAoaW50ZWdlcikgYW5kICdub25pbnRlcmFjdGlvbicgKGJvb2xlYW4pXG4gICAqXG4gICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2FuYWx5dGljcy9kZXZndWlkZXMvY29sbGVjdGlvbi9nYWpzL2V2ZW50VHJhY2tlckd1aWRlI1NldHRpbmdVcEV2ZW50VHJhY2tpbmdcbiAgICpcbiAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vYW5hbHl0aWNzL2Rldmd1aWRlcy9jb2xsZWN0aW9uL2FuYWx5dGljc2pzL2V2ZW50c1xuICAgKi9cbiAgZXZlbnRUcmFjayhhY3Rpb246IHN0cmluZywgcHJvcGVydGllczogYW55KSB7XG4gICAgLy8gR29vZ2xlIEFuYWx5dGljcyByZXF1aXJlcyBhbiBFdmVudCBDYXRlZ29yeVxuICAgIGlmICghcHJvcGVydGllcyB8fCAhcHJvcGVydGllcy5jYXRlZ29yeSkge1xuICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XG4gICAgICBwcm9wZXJ0aWVzLmNhdGVnb3J5ID0gJ0V2ZW50JztcbiAgICB9XG4gICAgLy8gR0EgcmVxdWlyZXMgdGhhdCBldmVudFZhbHVlIGJlIGFuIGludGVnZXIsIHNlZTpcbiAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9hbmFseXRpY3MvZGV2Z3VpZGVzL2NvbGxlY3Rpb24vYW5hbHl0aWNzanMvZmllbGQtcmVmZXJlbmNlI2V2ZW50VmFsdWVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbHVpc2ZhcnphdGkvYW5ndWxhcnRpY3MvaXNzdWVzLzgxXG4gICAgaWYgKHByb3BlcnRpZXMudmFsdWUpIHtcbiAgICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChwcm9wZXJ0aWVzLnZhbHVlLCAxMCk7XG4gICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gaXNOYU4ocGFyc2VkKSA/IDAgOiBwYXJzZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBnYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBldmVudE9wdGlvbnMgPSB7XG4gICAgICAgIGV2ZW50Q2F0ZWdvcnk6IHByb3BlcnRpZXMuY2F0ZWdvcnksXG4gICAgICAgIGV2ZW50QWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGV2ZW50TGFiZWw6IHByb3BlcnRpZXMubGFiZWwsXG4gICAgICAgIGV2ZW50VmFsdWU6IHByb3BlcnRpZXMudmFsdWUsXG4gICAgICAgIG5vbkludGVyYWN0aW9uOiBwcm9wZXJ0aWVzLm5vbmludGVyYWN0aW9uLFxuICAgICAgICBwYWdlOiBwcm9wZXJ0aWVzLnBhZ2UgfHwgbG9jYXRpb24uaGFzaC5zdWJzdHJpbmcoMSkgfHwgbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHVzZXJJZDogdGhpcy5hbmd1bGFydGljczIuc2V0dGluZ3MuZ2EudXNlcklkLFxuICAgICAgICBoaXRDYWxsYmFjazogcHJvcGVydGllcy5oaXRDYWxsYmFja1xuICAgICAgfTtcblxuICAgICAgLy8gYWRkIGN1c3RvbSBkaW1lbnNpb25zIGFuZCBtZXRyaWNzXG4gICAgICB0aGlzLnNldERpbWVuc2lvbnNBbmRNZXRyaWNzKHByb3BlcnRpZXMpO1xuXG4gICAgICBpZiAodGhpcy5hbmd1bGFydGljczIuc2V0dGluZ3MuZ2EudHJhbnNwb3J0KSB7XG4gICAgICAgIGdhKCdzZW5kJywgJ2V2ZW50JywgZXZlbnRPcHRpb25zLCB7IHRyYW5zcG9ydDogdGhpcy5hbmd1bGFydGljczIuc2V0dGluZ3MuZ2EudHJhbnNwb3J0IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2EoJ3NlbmQnLCAnZXZlbnQnLCBldmVudE9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBhY2NvdW50TmFtZSBvZiB0aGlzLmFuZ3VsYXJ0aWNzMi5zZXR0aW5ncy5nYS5hZGRpdGlvbmFsQWNjb3VudE5hbWVzKSB7XG4gICAgICAgIGdhKGFjY291bnROYW1lICsgJy5zZW5kJywgJ2V2ZW50JywgZXZlbnRPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBfZ2FxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgX2dhcS5wdXNoKFsnX3RyYWNrRXZlbnQnLCBwcm9wZXJ0aWVzLmNhdGVnb3J5LCBhY3Rpb24sIHByb3BlcnRpZXMubGFiZWwsIHByb3BlcnRpZXMudmFsdWUsIHByb3BlcnRpZXMubm9uaW50ZXJhY3Rpb25dKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXhjZXB0aW9uIFRyYWNrIEV2ZW50IGluIEdBXG4gICAqIEBuYW1lIGV4Y2VwdGlvblRyYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIENvbXByaXNlZCBvZiB0aGUgb3B0aW9uYWwgZmllbGRzOlxuICAgKiAgICAgJ2ZhdGFsJyAoc3RyaW5nKSxcbiAgICogICAgICdkZXNjcmlwdGlvbicgKHN0cmluZylcbiAgICpcbiAgICogQGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2FuYWx5dGljcy9kZXZndWlkZXMvY29sbGVjdGlvbi9hbmFseXRpY3Nqcy9leGNlcHRpb25zXG4gICAqXG4gICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2FuYWx5dGljcy9kZXZndWlkZXMvY29sbGVjdGlvbi9hbmFseXRpY3Nqcy9ldmVudHNcbiAgICovXG4gIGV4Y2VwdGlvblRyYWNrKHByb3BlcnRpZXM6IGFueSkge1xuICAgIGlmIChwcm9wZXJ0aWVzLmZhdGFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdObyBcImZhdGFsXCIgcHJvdmlkZWQsIHNlbmRpbmcgd2l0aCBmYXRhbD10cnVlJyk7XG4gICAgICBwcm9wZXJ0aWVzLmZhdGFsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcm9wZXJ0aWVzLmV4RGVzY3JpcHRpb24gPSBwcm9wZXJ0aWVzLmRlc2NyaXB0aW9uO1xuXG4gICAgdmFyIGV2ZW50T3B0aW9ucyA9IHtcbiAgICAgIGV4RmF0YWw6IHByb3BlcnRpZXMuZmF0YWwsXG4gICAgICBleERlc2NyaXB0aW9uOiBwcm9wZXJ0aWVzLmRlc2NyaXB0aW9uXG4gICAgfTtcblxuICAgIGdhKCdzZW5kJywgJ2V4Y2VwdGlvbicsIGV2ZW50T3B0aW9ucyk7XG4gIH1cblxuICBzZXRVc2VybmFtZSh1c2VySWQ6IHN0cmluZykge1xuICAgIHRoaXMuYW5ndWxhcnRpY3MyLnNldHRpbmdzLmdhLnVzZXJJZCA9IHVzZXJJZDtcbiAgfVxuXG4gIHNldFVzZXJQcm9wZXJ0aWVzKHByb3BlcnRpZXM6IGFueSkge1xuICAgIHRoaXMuc2V0RGltZW5zaW9uc0FuZE1ldHJpY3MocHJvcGVydGllcyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlciBUaW1pbmdzIEV2ZW50IGluIEdBXG4gICAqIEBuYW1lIHVzZXJUaW1pbmdzXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIENvbXByaXNlZCBvZiB0aGUgbWFuZGF0b3J5IGZpZWxkczpcbiAgICogICAgICd0aW1pbmdDYXRlZ29yeScgKHN0cmluZyksXG4gICAqICAgICAndGltaW5nVmFyJyAoc3RyaW5nKSxcbiAgICogICAgICd0aW1pbmdWYWx1ZScgKG51bWJlcilcbiAgICogUHJvcGVydGllcyBjYW4gYWxzbyBoYXZlIHRoZSBvcHRpb25hbCBmaWVsZHM6XG4gICAqICAgICAndGltaW5nTGFiZWwnIChzdHJpbmcpXG4gICAqXG4gICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2FuYWx5dGljcy9kZXZndWlkZXMvY29sbGVjdGlvbi9hbmFseXRpY3Nqcy91c2VyLXRpbWluZ3NcbiAgICovXG4gIHVzZXJUaW1pbmdzKHByb3BlcnRpZXM6IGFueSkge1xuICAgIGlmICghcHJvcGVydGllcyB8fCAhcHJvcGVydGllcy50aW1pbmdDYXRlZ29yeSB8fCAhcHJvcGVydGllcy50aW1pbmdWYXIgfHwgIXByb3BlcnRpZXMudGltaW5nVmFsdWUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Byb3BlcnRpZXMgdGltaW5nQ2F0ZWdvcnksIHRpbWluZ1ZhciwgYW5kIHRpbWluZ1ZhbHVlIGFyZSByZXF1aXJlZCB0byBiZSBzZXQuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGdhKSB7XG4gICAgICBnYSgnc2VuZCcsICd0aW1pbmcnLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNldERpbWVuc2lvbnNBbmRNZXRyaWNzKHByb3BlcnRpZXM6IGFueSkge1xuICAgIGlmIChnYSkge1xuICAgICAgLy8gYWRkIGN1c3RvbSBkaW1lbnNpb25zIGFuZCBtZXRyaWNzXG4gICAgICBmb3IgKHZhciBpZHggPSAxOyBpZHggPD0gMjAwOyBpZHgrKykge1xuICAgICAgICBpZiAocHJvcGVydGllc1snZGltZW5zaW9uJyArIGlkeC50b1N0cmluZygpXSkge1xuICAgICAgICAgIGdhKCdzZXQnLCAnZGltZW5zaW9uJyArIGlkeC50b1N0cmluZygpLCBwcm9wZXJ0aWVzWydkaW1lbnNpb24nICsgaWR4LnRvU3RyaW5nKCldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnYSgnc2V0JywgJ2RpbWVuc2lvbicgKyBpZHgudG9TdHJpbmcoKSwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydGllc1snbWV0cmljJyArIGlkeC50b1N0cmluZygpXSkge1xuICAgICAgICAgIGdhKCdzZXQnLCAnbWV0cmljJyArIGlkeC50b1N0cmluZygpLCBwcm9wZXJ0aWVzWydtZXRyaWMnICsgaWR4LnRvU3RyaW5nKCldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnYSgnc2V0JywgJ21ldHJpYycgKyBpZHgudG9TdHJpbmcoKSwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3RzbGludC1sb2FkZXIhLi9zcmMvcHJvdmlkZXJzL2dhL2FuZ3VsYXJ0aWNzMi1nYS50cyIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQW5ndWxhcnRpY3MyIH0gZnJvbSAnLi4vLi4vY29yZS9hbmd1bGFydGljczInO1xuXG5kZWNsYXJlIHZhciBkYXRhTGF5ZXI6IGFueTtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEFuZ3VsYXJ0aWNzMkdvb2dsZVRhZ01hbmFnZXIge1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgYW5ndWxhcnRpY3MyOiBBbmd1bGFydGljczJcbiAgKSB7XG5cbiAgICAvLyBUaGUgZGF0YUxheWVyIG5lZWRzIHRvIGJlIGluaXRpYWxpemVkXG4gICAgaWYgKHR5cGVvZiBkYXRhTGF5ZXIgIT09ICd1bmRlZmluZWQnICYmIGRhdGFMYXllcikge1xuICAgICAgZGF0YUxheWVyID0gKDxhbnk+d2luZG93KS5kYXRhTGF5ZXIgPSAoPGFueT53aW5kb3cpLmRhdGFMYXllciB8fCBbXTtcbiAgICB9XG5cbiAgICB0aGlzLmFuZ3VsYXJ0aWNzMi5zZXR0aW5ncy5wYWdlVHJhY2tpbmcudHJhY2tSZWxhdGl2ZVBhdGggPSB0cnVlO1xuXG4gICAgLy8gU2V0IHRoZSBkZWZhdWx0IHNldHRpbmdzIGZvciB0aGlzIG1vZHVsZVxuICAgIHRoaXMuYW5ndWxhcnRpY3MyLnNldHRpbmdzLmd0bSA9IHtcbiAgICAgIHVzZXJJZDogbnVsbFxuICAgIH07XG5cbiAgICB0aGlzLmFuZ3VsYXJ0aWNzMi5wYWdlVHJhY2suc3Vic2NyaWJlKCh4OiBhbnkpID0+IHRoaXMucGFnZVRyYWNrKHgucGF0aCkpO1xuXG4gICAgdGhpcy5hbmd1bGFydGljczIuZXZlbnRUcmFjay5zdWJzY3JpYmUoKHg6IGFueSkgPT4gdGhpcy5ldmVudFRyYWNrKHguYWN0aW9uLCB4LnByb3BlcnRpZXMpKTtcblxuICAgIHRoaXMuYW5ndWxhcnRpY3MyLmV4Y2VwdGlvblRyYWNrLnN1YnNjcmliZSgoeDogYW55KSA9PiB0aGlzLmV4Y2VwdGlvblRyYWNrKHgpKTtcblxuICAgIHRoaXMuYW5ndWxhcnRpY3MyLnNldFVzZXJuYW1lLnN1YnNjcmliZSgoeDogc3RyaW5nKSA9PiB0aGlzLnNldFVzZXJuYW1lKHgpKTtcbiAgfVxuXG4gIHBhZ2VUcmFjayhwYXRoOiBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIGRhdGFMYXllciAhPT0gJ3VuZGVmaW5lZCcgJiYgZGF0YUxheWVyKSB7XG4gICAgICBkYXRhTGF5ZXIucHVzaCh7XG4gICAgICAgICdldmVudCc6ICdQYWdlIFZpZXcnLFxuICAgICAgICAnY29udGVudC1uYW1lJzogcGF0aCxcbiAgICAgICAgJ3VzZXJJZCc6IHRoaXMuYW5ndWxhcnRpY3MyLnNldHRpbmdzLmd0bS51c2VySWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGludGVyYWN0aW9ucyB0byB0aGUgZGF0YUxheWVyLCBpLmUuIGZvciBldmVudCB0cmFja2luZyBpbiBHb29nbGUgQW5hbHl0aWNzXG4gICAqIEBuYW1lIGV2ZW50VHJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvbiBSZXF1aXJlZCAnYWN0aW9uJyAoc3RyaW5nKSBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIENvbXByaXNlZCBvZiB0aGUgbWFuZGF0b3J5IGZpZWxkICdjYXRlZ29yeScgKHN0cmluZykgYW5kIG9wdGlvbmFsICBmaWVsZHMgJ2xhYmVsJyAoc3RyaW5nKSwgJ3ZhbHVlJyAoaW50ZWdlcikgYW5kICdub25pbnRlcmFjdGlvbicgKGJvb2xlYW4pXG4gICAqL1xuICBldmVudFRyYWNrKGFjdGlvbjogc3RyaW5nLCBwcm9wZXJ0aWVzOiBhbnkpIHtcblxuICAgIC8vIFNldCBhIGRlZmF1bHQgR1RNIGNhdGVnb3J5XG4gICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XG5cbiAgICBpZiAodHlwZW9mIGRhdGFMYXllciAhPT0gJ3VuZGVmaW5lZCcgJiYgZGF0YUxheWVyKSB7XG4gICAgICBkYXRhTGF5ZXIucHVzaCh7XG4gICAgICAgIGV2ZW50OiBwcm9wZXJ0aWVzLmV2ZW50IHx8ICdpbnRlcmFjdGlvbicsXG4gICAgICAgIHRhcmdldDogcHJvcGVydGllcy5jYXRlZ29yeSB8fCAnRXZlbnQnLFxuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbGFiZWw6IHByb3BlcnRpZXMubGFiZWwsXG4gICAgICAgIHZhbHVlOiBwcm9wZXJ0aWVzLnZhbHVlLFxuICAgICAgICBpbnRlcmFjdGlvblR5cGU6IHByb3BlcnRpZXMubm9uaW50ZXJhY3Rpb24sXG4gICAgICAgIHVzZXJJZDogdGhpcy5hbmd1bGFydGljczIuc2V0dGluZ3MuZ3RtLnVzZXJJZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4Y2VwdGlvbiBUcmFjayBFdmVudCBpbiBHVE1cbiAgICogQG5hbWUgZXhjZXB0aW9uVHJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgQ29tcHJpc2VkIG9mIHRoZSBtYW5kYXRvcnkgZmllbGRzICdhcHBJZCcgKHN0cmluZyksICdhcHBOYW1lJyAoc3RyaW5nKSBhbmQgJ2FwcFZlcnNpb24nIChzdHJpbmcpIGFuZFxuICAgKiBvcHRpb25hbCAgZmllbGRzICdmYXRhbCcgKGJvb2xlYW4pIGFuZCAnZGVzY3JpcHRpb24nIChzdHJpbmcpXG4gICAqL1xuICBleGNlcHRpb25UcmFjayhwcm9wZXJ0aWVzOiBhbnkpIHtcbiAgICBpZiAoISBwcm9wZXJ0aWVzIHx8ICEgcHJvcGVydGllcy5hcHBJZCB8fCAhIHByb3BlcnRpZXMuYXBwTmFtZSB8fCAhIHByb3BlcnRpZXMuYXBwVmVyc2lvbikge1xuICAgICAgY29uc29sZS5lcnJvcignTXVzdCBiZSBzZXR0ZWQgYXBwSWQsIGFwcE5hbWUgYW5kIGFwcFZlcnNpb24uJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnRpZXMuZmF0YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS5sb2coJ05vIFwiZmF0YWxcIiBwcm92aWRlZCwgc2VuZGluZyB3aXRoIGZhdGFsPXRydWUnKTtcbiAgICAgIHByb3BlcnRpZXMuZXhGYXRhbCA9IHRydWU7XG4gICAgfVxuXG4gICAgcHJvcGVydGllcy5leERlc2NyaXB0aW9uID0gcHJvcGVydGllcy5ldmVudCA/IHByb3BlcnRpZXMuZXZlbnQuc3RhY2sgOiBwcm9wZXJ0aWVzLmRlc2NyaXB0aW9uO1xuXG4gICAgdGhpcy5ldmVudFRyYWNrKGBFeGNlcHRpb24gdGhyb3duIGZvciAke3Byb3BlcnRpZXMuYXBwTmFtZX0gPCR7cHJvcGVydGllcy5hcHBJZH1AJHtwcm9wZXJ0aWVzLmFwcFZlcnNpb259PmAsIHtcbiAgICAgICdjYXRlZ29yeSc6ICdFeGNlcHRpb24nLFxuICAgICAgJ2xhYmVsJzogcHJvcGVydGllcy5leERlc2NyaXB0aW9uXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVzZXJJZCBmb3IgdXNlIHdpdGggVW5pdmVyc2FsIEFuYWx5dGljcyBVc2VyIElEIGZlYXR1cmVcbiAgICogQG5hbWUgc2V0VXNlcm5hbWVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBSZXF1aXJlZCAndXNlcklkJyB2YWx1ZSAoc3RyaW5nKSB1c2VkIHRvIGlkZW50aWZ5IHVzZXIgY3Jvc3MtZGV2aWNlIGluIEdvb2dsZSBBbmFseXRpY3NcbiAgICovXG4gIHNldFVzZXJuYW1lKHVzZXJJZDogc3RyaW5nKSB7XG4gICAgdGhpcy5hbmd1bGFydGljczIuc2V0dGluZ3MuZ3RtLnVzZXJJZCA9IHVzZXJJZDtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3RzbGludC1sb2FkZXIhLi9zcmMvcHJvdmlkZXJzL2d0bS9hbmd1bGFydGljczItZ3RtLnRzIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBBbmd1bGFydGljczIgfSBmcm9tICcuLi8uLi9jb3JlL2FuZ3VsYXJ0aWNzMic7XG5cbmRlY2xhcmUgdmFyIF9rbXE6IGFueTtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEFuZ3VsYXJ0aWNzMktpc3NtZXRyaWNzIHtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGFuZ3VsYXJ0aWNzMjogQW5ndWxhcnRpY3MyXG4gICkge1xuICAgIGlmICh0eXBlb2YgKF9rbXEpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgX2ttcSA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuYW5ndWxhcnRpY3MyLnBhZ2VUcmFjay5zdWJzY3JpYmUoKHg6IGFueSkgPT4gdGhpcy5wYWdlVHJhY2soeC5wYXRoLCB4LmxvY2F0aW9uKSk7XG5cbiAgICB0aGlzLmFuZ3VsYXJ0aWNzMi5ldmVudFRyYWNrLnN1YnNjcmliZSgoeDogYW55KSA9PiB0aGlzLmV2ZW50VHJhY2soeC5hY3Rpb24sIHgucHJvcGVydGllcykpO1xuXG4gICAgdGhpcy5hbmd1bGFydGljczIuc2V0VXNlcm5hbWUuc3Vic2NyaWJlKCh4OiBzdHJpbmcpID0+IHRoaXMuc2V0VXNlcm5hbWUoeCkpO1xuXG4gICAgdGhpcy5hbmd1bGFydGljczIuc2V0VXNlclByb3BlcnRpZXMuc3Vic2NyaWJlKCh4OiBhbnkpID0+IHRoaXMuc2V0VXNlclByb3BlcnRpZXMoeCkpO1xuICB9XG5cbiAgcGFnZVRyYWNrKHBhdGg6IHN0cmluZywgbG9jYXRpb246IGFueSkge1xuICAgIF9rbXEucHVzaChbJ3JlY29yZCcsICdQYWdldmlldycsIHsgJ1BhZ2UnOiBwYXRoIH1dKTtcbiAgfVxuXG4gIGV2ZW50VHJhY2soYWN0aW9uOiBzdHJpbmcsIHByb3BlcnRpZXM6IGFueSkge1xuICAgIF9rbXEucHVzaChbJ3JlY29yZCcsIGFjdGlvbiwgcHJvcGVydGllc10pO1xuICB9XG5cbiAgc2V0VXNlcm5hbWUodXNlcklkOiBzdHJpbmcpIHtcbiAgICBfa21xLnB1c2goWydpZGVudGlmeScsIHVzZXJJZF0pO1xuICB9XG5cbiAgc2V0VXNlclByb3BlcnRpZXMocHJvcGVydGllczogYW55KSB7XG4gICAgX2ttcS5wdXNoKFsnc2V0JywgcHJvcGVydGllc10pO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdHNsaW50LWxvYWRlciEuL3NyYy9wcm92aWRlcnMva2lzc21ldHJpY3MvYW5ndWxhcnRpY3MyLWtpc3NtZXRyaWNzLnRzIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBBbmd1bGFydGljczIgfSBmcm9tICcuLi8uLi9jb3JlL2FuZ3VsYXJ0aWNzMic7XG5cbmRlY2xhcmUgdmFyIG1peHBhbmVsOiBhbnk7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBbmd1bGFydGljczJNaXhwYW5lbCB7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBhbmd1bGFydGljczI6IEFuZ3VsYXJ0aWNzMlxuICApIHtcbiAgICB0aGlzLmFuZ3VsYXJ0aWNzMi5wYWdlVHJhY2suc3Vic2NyaWJlKCh4OiBhbnkpID0+IHRoaXMucGFnZVRyYWNrKHgucGF0aCwgeC5sb2NhdGlvbikpO1xuXG4gICAgdGhpcy5hbmd1bGFydGljczIuZXZlbnRUcmFjay5zdWJzY3JpYmUoKHg6IGFueSkgPT4gdGhpcy5ldmVudFRyYWNrKHguYWN0aW9uLCB4LnByb3BlcnRpZXMpKTtcblxuICAgIHRoaXMuYW5ndWxhcnRpY3MyLnNldFVzZXJuYW1lLnN1YnNjcmliZSgoeDogc3RyaW5nKSA9PiB0aGlzLnNldFVzZXJuYW1lKHgpKTtcblxuICAgIHRoaXMuYW5ndWxhcnRpY3MyLnNldFVzZXJQcm9wZXJ0aWVzLnN1YnNjcmliZSgoeDogYW55KSA9PiB0aGlzLnNldFVzZXJQcm9wZXJ0aWVzKHgpKTtcblxuICAgIHRoaXMuYW5ndWxhcnRpY3MyLnNldFVzZXJQcm9wZXJ0aWVzT25jZS5zdWJzY3JpYmUoKHg6IGFueSkgPT4gdGhpcy5zZXRVc2VyUHJvcGVydGllc09uY2UoeCkpO1xuXG4gICAgdGhpcy5hbmd1bGFydGljczIuc2V0U3VwZXJQcm9wZXJ0aWVzLnN1YnNjcmliZSgoeDogYW55KSA9PiB0aGlzLnNldFN1cGVyUHJvcGVydGllcyh4KSk7XG5cbiAgICB0aGlzLmFuZ3VsYXJ0aWNzMi5zZXRTdXBlclByb3BlcnRpZXNPbmNlLnN1YnNjcmliZSgoeDogYW55KSA9PiB0aGlzLnNldFN1cGVyUHJvcGVydGllc09uY2UoeCkpO1xuXG4gICAgdGhpcy5hbmd1bGFydGljczIuc2V0QWxpYXMuc3Vic2NyaWJlKCh4OiBzdHJpbmcpID0+IHRoaXMuc2V0QWxpYXMoeCkpO1xuICB9XG5cbiAgcGFnZVRyYWNrKHBhdGg6IHN0cmluZywgbG9jYXRpb246IGFueSkge1xuICAgIHRyeSB7XG4gICAgICBtaXhwYW5lbC50cmFjaygnUGFnZSBWaWV3ZWQnLCB7IHBhZ2U6IHBhdGggfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFJlZmVyZW5jZUVycm9yKSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV2ZW50VHJhY2soYWN0aW9uOiBzdHJpbmcsIHByb3BlcnRpZXM6IGFueSkge1xuICAgIHRyeSB7XG4gICAgICBtaXhwYW5lbC50cmFjayhhY3Rpb24sIHByb3BlcnRpZXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBSZWZlcmVuY2VFcnJvcikpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXRVc2VybmFtZSh1c2VySWQ6IHN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBtaXhwYW5lbC5pZGVudGlmeSh1c2VySWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBSZWZlcmVuY2VFcnJvcikpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXRVc2VyUHJvcGVydGllcyhwcm9wZXJ0aWVzOiBhbnkpIHtcbiAgICB0cnkge1xuICAgICAgbWl4cGFuZWwucGVvcGxlLnNldChwcm9wZXJ0aWVzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIShlIGluc3RhbmNlb2YgUmVmZXJlbmNlRXJyb3IpKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0VXNlclByb3BlcnRpZXNPbmNlKHByb3BlcnRpZXM6IGFueSkge1xuICAgIHRyeSB7XG4gICAgICBtaXhwYW5lbC5wZW9wbGUuc2V0X29uY2UocHJvcGVydGllcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFJlZmVyZW5jZUVycm9yKSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldFN1cGVyUHJvcGVydGllcyhwcm9wZXJ0aWVzOiBhbnkpIHtcbiAgICB0cnkge1xuICAgICAgbWl4cGFuZWwucmVnaXN0ZXIocHJvcGVydGllcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFJlZmVyZW5jZUVycm9yKSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldFN1cGVyUHJvcGVydGllc09uY2UocHJvcGVydGllczogYW55KSB7XG4gICAgdHJ5IHtcbiAgICAgIG1peHBhbmVsLnJlZ2lzdGVyX29uY2UocHJvcGVydGllcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFJlZmVyZW5jZUVycm9yKSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldEFsaWFzKGFsaWFzOiBhbnkpIHtcbiAgICB0cnkge1xuICAgICAgbWl4cGFuZWwuYWxpYXMoYWxpYXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBSZWZlcmVuY2VFcnJvcikpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy90c2xpbnQtbG9hZGVyIS4vc3JjL3Byb3ZpZGVycy9taXhwYW5lbC9hbmd1bGFydGljczItbWl4cGFuZWwudHMiLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEFuZ3VsYXJ0aWNzMiB9IGZyb20gJy4uLy4uL2NvcmUvYW5ndWxhcnRpY3MyJztcblxuZGVjbGFyZSB2YXIgX3BhcTogYW55O1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQW5ndWxhcnRpY3MyUGl3aWsge1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgYW5ndWxhcnRpY3MyOiBBbmd1bGFydGljczJcbiAgKSB7XG4gICAgaWYgKHR5cGVvZiAoX3BhcSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Bpd2lrIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIHRoaXMuYW5ndWxhcnRpY3MyLnBhZ2VUcmFjay5zdWJzY3JpYmUoKHg6IGFueSkgPT4gdGhpcy5wYWdlVHJhY2soeC5wYXRoLCB4LmxvY2F0aW9uKSk7XG5cbiAgICB0aGlzLmFuZ3VsYXJ0aWNzMi5ldmVudFRyYWNrLnN1YnNjcmliZSgoeDogYW55KSA9PiB0aGlzLmV2ZW50VHJhY2soeC5hY3Rpb24sIHgucHJvcGVydGllcykpO1xuXG4gICAgdGhpcy5hbmd1bGFydGljczIuc2V0VXNlcm5hbWUuc3Vic2NyaWJlKCh4OiBzdHJpbmcpID0+IHRoaXMuc2V0VXNlcm5hbWUoeCkpO1xuXG4gICAgdGhpcy5hbmd1bGFydGljczIuc2V0VXNlclByb3BlcnRpZXMuc3Vic2NyaWJlKCh4OiBhbnkpID0+IHRoaXMuc2V0VXNlclByb3BlcnRpZXMoeCkpO1xuXG4gIH1cblxuICBwYWdlVHJhY2socGF0aDogc3RyaW5nLCBsb2NhdGlvbjogYW55KSB7XG4gICAgdHJ5IHtcbiAgICAgIF9wYXEucHVzaChbJ3NldERvY3VtZW50VGl0bGUnLCB3aW5kb3cuZG9jdW1lbnQudGl0bGVdKTtcbiAgICAgIF9wYXEucHVzaChbJ3NldEN1c3RvbVVybCcsIHBhdGhdKTtcbiAgICAgIF9wYXEucHVzaChbJ3RyYWNrUGFnZVZpZXcnXSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFJlZmVyZW5jZUVycm9yKSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV2ZW50VHJhY2soYWN0aW9uOiBzdHJpbmcsIHByb3BlcnRpZXM6IGFueSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAocHJvcGVydGllcy52YWx1ZSkge1xuICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQocHJvcGVydGllcy52YWx1ZSwgMTApO1xuICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gaXNOYU4ocGFyc2VkKSA/IDAgOiBwYXJzZWQ7XG4gICAgICB9XG4gICAgICBfcGFxLnB1c2goWyd0cmFja0V2ZW50JywgcHJvcGVydGllcy5jYXRlZ29yeSwgYWN0aW9uLCBwcm9wZXJ0aWVzLmxhYmVsLCBwcm9wZXJ0aWVzLnZhbHVlXSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFJlZmVyZW5jZUVycm9yKSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldFVzZXJuYW1lKHVzZXJJZDogc3RyaW5nfGJvb2xlYW4pIHtcbiAgICB0cnkge1xuICAgICAgX3BhcS5wdXNoKFsnc2V0VXNlcklkJywgdXNlcklkXSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFJlZmVyZW5jZUVycm9yKSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGN1c3RvbSBkaW1lbnNpb25zIGlmIGF0IGxlYXN0IG9uZSBwcm9wZXJ0eSBoYXMgdGhlIGtleSBcImRpbWVuc2lvbjxuPlwiLFxuICAgKiBlLmcuIGRpbWVuc2lvbjEwLiBJZiB0aGVyZSBhcmUgY3VzdG9tIGRpbWVuc2lvbnMsIGFueSBvdGhlciBwcm9wZXJ0eSBpcyBpZ25vcmVkLlxuICAgKlxuICAgKiBJZiB0aGVyZSBhcmUgbm8gY3VzdG9tIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHByb3BlcnRpZXMgb2JqZWN0LCB0aGUgcHJvcGVydGllc1xuICAgKiBvYmplY3QgaXMgc2F2ZWQgYXMgYSBjdXN0b20gdmFyaWFibGUuXG4gICAqXG4gICAqIElmIGluIGRvdWJ0LCBwcmVmZXIgY3VzdG9tIGRpbWVuc2lvbnMuXG4gICAqIEBzZWUgaHR0cHM6Ly9waXdpay5vcmcvZG9jcy9jdXN0b20tdmFyaWFibGVzL1xuICAgKi9cbiAgc2V0VXNlclByb3BlcnRpZXMocHJvcGVydGllczogYW55KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSB0aGlzLnNldEN1c3RvbURpbWVuc2lvbnMocHJvcGVydGllcyk7XG4gICAgICBpZiAoZGltZW5zaW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgX3BhcS5wdXNoKFsnc2V0Q3VzdG9tVmFyaWFibGUnLCBwcm9wZXJ0aWVzXSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFJlZmVyZW5jZUVycm9yKSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0Q3VzdG9tRGltZW5zaW9ucyhwcm9wZXJ0aWVzOiBhbnkpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgZGltZW5zaW9uUmVnZXg6IFJlZ0V4cCA9IC9kaW1lbnNpb25bMS05XVxcZCovO1xuICAgIGNvbnN0IGRpbWVuc2lvbnMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5maWx0ZXIoa2V5ID0+IGRpbWVuc2lvblJlZ2V4LmV4ZWMoa2V5KSk7XG4gICAgZGltZW5zaW9ucy5mb3JFYWNoKGRpbWVuc2lvbiA9PiB7XG4gICAgICBjb25zdCBudW1iZXIgPSBOdW1iZXIoZGltZW5zaW9uLnN1YnN0cig5KSk7XG4gICAgICBfcGFxLnB1c2goWydzZXRDdXN0b21EaW1lbnNpb24nLCBudW1iZXIsIHByb3BlcnRpZXNbZGltZW5zaW9uXV0pO1xuICAgIH0pO1xuICAgIHJldHVybiBkaW1lbnNpb25zO1xuICB9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy90c2xpbnQtbG9hZGVyIS4vc3JjL3Byb3ZpZGVycy9waXdpay9hbmd1bGFydGljczItcGl3aWsudHMiLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEFuZ3VsYXJ0aWNzMiB9IGZyb20gJy4uLy4uL2NvcmUvYW5ndWxhcnRpY3MyJztcblxuZGVjbGFyZSB2YXIgYW5hbHl0aWNzOiBhbnk7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBbmd1bGFydGljczJTZWdtZW50IHtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGFuZ3VsYXJ0aWNzMjogQW5ndWxhcnRpY3MyXG4gICkge1xuICAgIHRoaXMuYW5ndWxhcnRpY3MyLnBhZ2VUcmFjay5zdWJzY3JpYmUoKHg6IGFueSkgPT4gdGhpcy5wYWdlVHJhY2soeC5wYXRoLCB4LmxvY2F0aW9uKSk7XG5cbiAgICB0aGlzLmFuZ3VsYXJ0aWNzMi5ldmVudFRyYWNrLnN1YnNjcmliZSgoeDogYW55KSA9PiB0aGlzLmV2ZW50VHJhY2soeC5hY3Rpb24sIHgucHJvcGVydGllcykpO1xuXG4gICAgdGhpcy5hbmd1bGFydGljczIuc2V0VXNlclByb3BlcnRpZXMuc3Vic2NyaWJlKCh4OiBhbnkpID0+IHRoaXMuc2V0VXNlclByb3BlcnRpZXMoeCkpO1xuXG4gICAgdGhpcy5hbmd1bGFydGljczIuc2V0VXNlclByb3BlcnRpZXNPbmNlLnN1YnNjcmliZSgoeDogYW55KSA9PiB0aGlzLnNldFVzZXJQcm9wZXJ0aWVzKHgpKTtcblxuICAgIHRoaXMuYW5ndWxhcnRpY3MyLnNldEFsaWFzLnN1YnNjcmliZSgoeDogc3RyaW5nKSA9PiB0aGlzLnNldEFsaWFzKHgpKTtcbiAgfVxuXG4gIC8vIGh0dHBzOi8vc2VnbWVudC5jb20vZG9jcy9saWJyYXJpZXMvYW5hbHl0aWNzLmpzLyNwYWdlXG4gIC8vIGFuYWx5dGljcy5wYWdlKFtjYXRlZ29yeV0sIFtuYW1lXSwgW3Byb3BlcnRpZXNdLCBbb3B0aW9uc10sIFtjYWxsYmFja10pO1xuICAvLyBUT0RPIDogU3VwcG9ydCBvcHRpb25hbCBwYXJhbWV0ZXJzIHdoZXJlIHRoZSBwYXJhbWV0ZXIgb3JkZXIgYW5kIHR5cGUgY2hhbmdlcyB0aGVpciBtZWFuaW5nXG4gIC8vIGUuZy5cbiAgLy8gKHN0cmluZykgaXMgKG5hbWUpXG4gIC8vIChzdHJpbmcsIHN0cmluZykgaXMgKGNhdGVnb3J5LCBuYW1lKVxuICAvLyAoc3RyaW5nLCBvYmplY3QpIGlzIChuYW1lLCBwcm9wZXJ0aWVzKVxuICBwYWdlVHJhY2socGF0aDogc3RyaW5nLCBsb2NhdGlvbjogYW55KSB7XG4gICAgdHJ5IHtcbiAgICAgIGFuYWx5dGljcy5wYWdlKHBhdGgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBSZWZlcmVuY2VFcnJvcikpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBodHRwczovL3NlZ21lbnQuY29tL2RvY3MvbGlicmFyaWVzL2FuYWx5dGljcy5qcy8jdHJhY2tcbiAgLy8gYW5hbHl0aWNzLnRyYWNrKGV2ZW50LCBbcHJvcGVydGllc10sIFtvcHRpb25zXSwgW2NhbGxiYWNrXSk7XG4gIGV2ZW50VHJhY2soYWN0aW9uOiBzdHJpbmcsIHByb3BlcnRpZXM6IGFueSkge1xuICAgIHRyeSB7XG4gICAgICBhbmFseXRpY3MudHJhY2soYWN0aW9uLCBwcm9wZXJ0aWVzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIShlIGluc3RhbmNlb2YgUmVmZXJlbmNlRXJyb3IpKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9zZWdtZW50LmNvbS9kb2NzL2xpYnJhcmllcy9hbmFseXRpY3MuanMvI2lkZW50aWZ5XG4gIC8vIGFuYWx5dGljcy5pZGVudGlmeShbdXNlcklkXSwgW3RyYWl0c10sIFtvcHRpb25zXSwgW2NhbGxiYWNrXSk7XG4gIHNldFVzZXJQcm9wZXJ0aWVzKHByb3BlcnRpZXM6IGFueSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAocHJvcGVydGllcy51c2VySWQpIHtcbiAgICAgICAgYW5hbHl0aWNzLmlkZW50aWZ5KHByb3BlcnRpZXMudXNlcklkLCBwcm9wZXJ0aWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuYWx5dGljcy5pZGVudGlmeShwcm9wZXJ0aWVzKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIShlIGluc3RhbmNlb2YgUmVmZXJlbmNlRXJyb3IpKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9zZWdtZW50LmNvbS9kb2NzL2xpYnJhcmllcy9hbmFseXRpY3MuanMvI2FsaWFzXG4gIC8vIGFuYWx5dGljcy5hbGlhcyh1c2VySWQsIHByZXZpb3VzSWQsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgc2V0QWxpYXMoYWxpYXM6IGFueSkge1xuICAgIHRyeSB7XG4gICAgICBhbmFseXRpY3MuYWxpYXMoYWxpYXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBSZWZlcmVuY2VFcnJvcikpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy90c2xpbnQtbG9hZGVyIS4vc3JjL3Byb3ZpZGVycy9zZWdtZW50L2FuZ3VsYXJ0aWNzMi1zZWdtZW50LnRzIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBBbmd1bGFydGljczIgfSBmcm9tICcuLi8uLi9jb3JlL2FuZ3VsYXJ0aWNzMic7XG5cbmRlY2xhcmUgY29uc3QgZmJxOiBGdW5jdGlvbjtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEFuZ3VsYXJ0aWNzMkZhY2Vib29rIHtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGFuZ3VsYXJ0aWNzMjogQW5ndWxhcnRpY3MyXG4gICkge1xuICAgIHRoaXMuYW5ndWxhcnRpY3MyLnNldHRpbmdzLnBhZ2VUcmFja2luZy50cmFja1JlbGF0aXZlUGF0aCA9IHRydWU7XG5cbiAgICB0aGlzLmFuZ3VsYXJ0aWNzMi5ldmVudFRyYWNrLnN1YnNjcmliZSgoeDogYW55KSA9PiB0aGlzLmV2ZW50VHJhY2soeC5hY3Rpb24sIHgucHJvcGVydGllcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgaW50ZXJhY3Rpb25zIHRvIHRoZSBQaXhlbCwgaS5lLiBmb3IgZXZlbnQgdHJhY2tpbmcgaW4gUGl4ZWxcbiAgICogQG5hbWUgZXZlbnRUcmFja1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uIFJlcXVpcmVkICdhY3Rpb24nIChzdHJpbmcpIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXNcbiAgICovXG4gIGV2ZW50VHJhY2soYWN0aW9uOiBzdHJpbmcsIHByb3BlcnRpZXM6IGFueSkge1xuICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IHt9O1xuXG4gICAgY29uc3QgZXZlbnRMaXN0ID0gW1xuICAgICAgJ1ZpZXdDb250ZW50JyxcbiAgICAgICdTZWFyY2gnLFxuICAgICAgJ0FkZFRvQ2FydCcsXG4gICAgICAnQWRkVG9XaXNobGlzdCcsXG4gICAgICAnSW5pdGlhdGVDaGVja291dCcsXG4gICAgICAnQWRkUGF5bWVudEluZm8nLFxuICAgICAgJ1B1cmNoYXNlJyxcbiAgICAgICdMZWFkJyxcbiAgICAgICdDb21wbGV0ZVJlZ2lzdHJhdGlvbidcbiAgICBdO1xuXG4gICBpZiAodHlwZW9mIGZicSAhPT0gJ3VuZGVmaW5lZCcgJiYgZmJxKSB7XG4gICAgICAgIGV2ZW50TGlzdC5pbmRleE9mKGFjdGlvbikgPT09IC0xID9cbiAgICAgICAgICAgZmJxKCd0cmFja0N1c3RvbScsIGFjdGlvbiwgcHJvcGVydGllcykgOlxuICAgICAgICAgICBmYnEoJ3RyYWNrJywgYWN0aW9uLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy90c2xpbnQtbG9hZGVyIS4vc3JjL3Byb3ZpZGVycy9mYWNlYm9vay9hbmd1bGFydGljczItZmFjZWJvb2sudHMiLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEFuZ3VsYXJ0aWNzMiB9IGZyb20gJy4uLy4uL2NvcmUvYW5ndWxhcnRpY3MyJztcblxuZGVjbGFyZSBjb25zdCBhcHBJbnNpZ2h0czogTWljcm9zb2Z0LkFwcGxpY2F0aW9uSW5zaWdodHMuSUFwcEluc2lnaHRzO1xuXG5pbXBvcnQgeyBUaXRsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgUm91dGVyLCBOYXZpZ2F0aW9uRW5kLCBOYXZpZ2F0aW9uU3RhcnQsIE5hdmlnYXRpb25FcnJvciB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBbmd1bGFydGljczJBcHBJbnNpZ2h0cyB7XG4gICAgbG9hZFN0YXJ0VGltZTogbnVtYmVyID0gbnVsbDtcbiAgICBsb2FkVGltZTogbnVtYmVyID0gbnVsbDtcblxuICAgIG1ldHJpY3M6IGFueSA9IG51bGw7XG4gICAgZGltZW5zaW9uczogYW55ID0gbnVsbDtcbiAgICBtZWFzdXJlbWVudHM6IGFueSA9IG51bGw7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFuZ3VsYXJ0aWNzMjogQW5ndWxhcnRpY3MyLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdGl0bGU6IFRpdGxlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgcm91dGVyOiBSb3V0ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoYXBwSW5zaWdodHMpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhcHBJbnNpZ2h0cyBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYW5ndWxhcnRpY3MyLnNldHRpbmdzLmFwcEluc2lnaHRzID0ge1xuICAgICAgICAgICAgdXNlcklkOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hbmd1bGFydGljczIucGFnZVRyYWNrLnN1YnNjcmliZSgoeDogYW55KSA9PiB0aGlzLnBhZ2VUcmFjayh4LnBhdGgpKTtcblxuICAgICAgICB0aGlzLmFuZ3VsYXJ0aWNzMi5ldmVudFRyYWNrLnN1YnNjcmliZSgoeDogYW55KSA9PiB0aGlzLmV2ZW50VHJhY2soeC5hY3Rpb24sIHgucHJvcGVydGllcykpO1xuXG4gICAgICAgIHRoaXMuYW5ndWxhcnRpY3MyLmV4Y2VwdGlvblRyYWNrLnN1YnNjcmliZSgoeDogYW55KSA9PiB0aGlzLmV4Y2VwdGlvblRyYWNrKHgpKTtcblxuICAgICAgICB0aGlzLmFuZ3VsYXJ0aWNzMi5zZXRVc2VybmFtZS5zdWJzY3JpYmUoKHg6IHN0cmluZykgPT4gdGhpcy5zZXRVc2VybmFtZSh4KSk7XG5cbiAgICAgICAgdGhpcy5hbmd1bGFydGljczIuc2V0VXNlclByb3BlcnRpZXMuc3Vic2NyaWJlKCh4OiBhbnkpID0+IHRoaXMuc2V0VXNlclByb3BlcnRpZXMoeCkpO1xuXG4gICAgICAgIHRoaXMucm91dGVyLmV2ZW50c1xuICAgICAgICAgICAgLmZpbHRlcihldmVudCA9PiBldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25TdGFydClcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZXZlbnQgPT4gdGhpcy5zdGFydFRpbWVyKCkpO1xuXG4gICAgICAgIHRoaXMucm91dGVyLmV2ZW50c1xuICAgICAgICAgICAgLmZpbHRlcihldmVudCA9PlxuICAgICAgICAgICAgICAgIChldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25FcnJvcikgfHxcbiAgICAgICAgICAgICAgICAoZXZlbnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRW5kKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnN1YnNjcmliZShlcnJvciA9PiB0aGlzLnN0b3BUaW1lcigpKTtcbiAgICB9XG5cbiAgICBzdGFydFRpbWVyKCkge1xuICAgICAgICB0aGlzLmxvYWRTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLmxvYWRUaW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICBzdG9wVGltZXIoKSB7XG4gICAgICAgIHRoaXMubG9hZFRpbWUgPSBEYXRlLm5vdygpIC0gdGhpcy5sb2FkU3RhcnRUaW1lO1xuICAgICAgICB0aGlzLmxvYWRTdGFydFRpbWUgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZ2UgVHJhY2sgaW4gQmFpZHUgQW5hbHl0aWNzXG4gICAgICogQG5hbWUgcGFnZVRyYWNrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBSZXF1aXJlZCAncGF0aCcgKHN0cmluZylcbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvQXBwbGljYXRpb25JbnNpZ2h0cy1KUy9ibG9iL21hc3Rlci9BUEktcmVmZXJlbmNlLm1kI3RyYWNrcGFnZXZpZXdcbiAgICAgKlxuICAgICAqL1xuICAgIHBhZ2VUcmFjayhwYXRoOiBzdHJpbmcpIHtcbiAgICAgICAgYXBwSW5zaWdodHMudHJhY2tQYWdlVmlldyhcbiAgICAgICAgICAgIHRoaXMudGl0bGUuZ2V0VGl0bGUoKSxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICB0aGlzLmRpbWVuc2lvbnMsXG4gICAgICAgICAgICB0aGlzLm1ldHJpY3MsXG4gICAgICAgICAgICB0aGlzLmxvYWRUaW1lXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9nIGEgdXNlciBhY3Rpb24gb3Igb3RoZXIgb2NjdXJyZW5jZS5cbiAgICAgKiBAcGFyYW0gICBuYW1lICAgIEEgc3RyaW5nIHRvIGlkZW50aWZ5IHRoaXMgZXZlbnQgaW4gdGhlIHBvcnRhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgIHByb3BlcnRpZXMgIG1hcFtzdHJpbmcsIHN0cmluZ10gLSBhZGRpdGlvbmFsIGRhdGEgdXNlZCB0byBmaWx0ZXIgZXZlbnRzIGFuZCBtZXRyaWNzIGluIHRoZSBwb3J0YWwuIERlZmF1bHRzIHRvIGVtcHR5LlxuICAgICAqXG4gICAgICogQGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvQXBwbGljYXRpb25JbnNpZ2h0cy1KUy9ibG9iL21hc3Rlci9BUEktcmVmZXJlbmNlLm1kI3RyYWNrZXZlbnRcbiAgICAgKi9cbiAgICBldmVudFRyYWNrKG5hbWU6IHN0cmluZywgcHJvcGVydGllczogYW55KSB7XG4gICAgICAgIGFwcEluc2lnaHRzLnRyYWNrRXZlbnQobmFtZSwgcHJvcGVydGllcywgdGhpcy5tZWFzdXJlbWVudHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4Y2VwdGlvbiBUcmFjayBFdmVudCBpbiBHQVxuICAgICAqIEBuYW1lIGV4Y2VwdGlvblRyYWNrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gcHJvcGVydGllcyBDb21wcmlzZWQgb2YgdGhlIG1hbmRhdG9yeSBmaWVsZHMgJ2FwcElkJyAoc3RyaW5nKSwgJ2FwcE5hbWUnIChzdHJpbmcpIGFuZCAnYXBwVmVyc2lvbicgKHN0cmluZykgYW5kXG4gICAgICogb3B0aW9uYWwgIGZpZWxkcyAnZmF0YWwnIChib29sZWFuKSBhbmQgJ2Rlc2NyaXB0aW9uJyAoc3RyaW5nKSwgZXJyb3JcbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvQXBwbGljYXRpb25JbnNpZ2h0cy1KUy9ibG9iL21hc3Rlci9BUEktcmVmZXJlbmNlLm1kI3RyYWNrZXhjZXB0aW9uXG4gICAgICovXG4gICAgZXhjZXB0aW9uVHJhY2socHJvcGVydGllczogYW55KSB7XG4gICAgICAgIGxldCBkZXNjcmlwdGlvbiA9IHByb3BlcnRpZXMuZXZlbnQgfHwgcHJvcGVydGllcy5kZXNjcmlwdGlvbiB8fCBwcm9wZXJ0aWVzO1xuXG4gICAgICAgIGFwcEluc2lnaHRzLnRyYWNrRXhjZXB0aW9uKGRlc2NyaXB0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VySWRcbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvQXBwbGljYXRpb25JbnNpZ2h0cy1KUy9ibG9iL21hc3Rlci9BUEktcmVmZXJlbmNlLm1kI3NldGF1dGhlbnRpY2F0ZWR1c2VyY29udGV4dFxuICAgICAqL1xuXG4gICAgc2V0VXNlcm5hbWUodXNlcklkOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5hbmd1bGFydGljczIuc2V0dGluZ3MuYXBwSW5zaWdodHMudXNlcklkID0gdXNlcklkO1xuICAgICAgICBhcHBJbnNpZ2h0cy5zZXRBdXRoZW50aWNhdGVkVXNlckNvbnRleHQodXNlcklkKTtcbiAgICB9XG5cbiAgICBzZXRVc2VyUHJvcGVydGllcyhwcm9wZXJ0aWVzOiBhbnkpIHtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMudXNlcklkKSB7XG4gICAgICAgICAgICB0aGlzLmFuZ3VsYXJ0aWNzMi5zZXR0aW5ncy5hcHBJbnNpZ2h0cy51c2VySWQgPSBwcm9wZXJ0aWVzLnVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmFjY291bnRJZCkge1xuICAgICAgICAgICAgYXBwSW5zaWdodHMuc2V0QXV0aGVudGljYXRlZFVzZXJDb250ZXh0KFxuICAgICAgICAgICAgICAgIHRoaXMuYW5ndWxhcnRpY3MyLnNldHRpbmdzLmFwcEluc2lnaHRzLnVzZXJJZCxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmFjY291bnRJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy90c2xpbnQtbG9hZGVyIS4vc3JjL3Byb3ZpZGVycy9hcHBpbnNpZ2h0cy9hbmd1bGFydGljczItYXBwaW5zaWdodHMudHMiLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEFuZ3VsYXJ0aWNzMiB9IGZyb20gJy4uLy4uL2NvcmUvYW5ndWxhcnRpY3MyJztcblxuZGVjbGFyZSB2YXIgX2hzcTogYW55O1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQW5ndWxhcnRpY3MySHVic3BvdCB7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBhbmd1bGFydGljczI6IEFuZ3VsYXJ0aWNzMlxuICApIHtcbiAgICBpZiAodHlwZW9mIF9oc3EgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBfaHNxID0gW107XG4gICAgfVxuXG4gICAgdGhpcy5hbmd1bGFydGljczIucGFnZVRyYWNrLnN1YnNjcmliZSgoeDogYW55KSA9PiB0aGlzLnBhZ2VUcmFjayh4LnBhdGgsIHgubG9jYXRpb24pKTtcblxuICAgIHRoaXMuYW5ndWxhcnRpY3MyLmV2ZW50VHJhY2suc3Vic2NyaWJlKCh4OiBhbnkpID0+IHRoaXMuZXZlbnRUcmFjayh4LmFjdGlvbiwgeC5wcm9wZXJ0aWVzKSk7XG5cbiAgICB0aGlzLmFuZ3VsYXJ0aWNzMi5zZXRVc2VyUHJvcGVydGllcy5zdWJzY3JpYmUoKHg6IGFueSkgPT4gdGhpcy5zZXRVc2VyUHJvcGVydGllcyh4KSk7XG4gIH1cblxuICBwYWdlVHJhY2socGF0aDogc3RyaW5nLCBsb2NhdGlvbjogYW55KSB7XG4gICAgaWYgKHR5cGVvZiBfaHNxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgX2hzcS5wdXNoKFsnc2V0UGF0aCcsIHBhdGhdKTtcbiAgICAgIF9oc3EucHVzaChbJ3RyYWNrUGFnZVZpZXcnXSk7XG4gICAgfVxuICB9XG5cbiAgZXZlbnRUcmFjayhhY3Rpb246IHN0cmluZywgcHJvcGVydGllczogYW55KSB7XG4gICAgaWYgKHR5cGVvZiBfaHNxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgX2hzcS5wdXNoKFsndHJhY2tFdmVudCcsIHByb3BlcnRpZXNdKTtcbiAgICB9XG4gIH1cblxuICBzZXRVc2VyUHJvcGVydGllcyhwcm9wZXJ0aWVzOiBhbnkpIHtcbiAgICBpZiAodHlwZW9mIF9oc3EgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBfaHNxLnB1c2goWydpZGVudGlmeScsIHByb3BlcnRpZXNdKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy90c2xpbnQtbG9hZGVyIS4vc3JjL3Byb3ZpZGVycy9odWJzcG90L2FuZ3VsYXJ0aWNzMi1odWJzcG90LnRzIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTG9jYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgQW5ndWxhcnRpY3MyIH0gZnJvbSAnLi4vLi4vY29yZS9hbmd1bGFydGljczInO1xuXG5kZWNsYXJlIHZhciBzOiBhbnk7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBbmd1bGFydGljczJBZG9iZUFuYWx5dGljcyB7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBhbmd1bGFydGljczI6IEFuZ3VsYXJ0aWNzMixcbiAgICBwcml2YXRlIGxvY2F0aW9uOiBMb2NhdGlvblxuICApIHtcbiAgICB0aGlzLmFuZ3VsYXJ0aWNzMi5zZXR0aW5ncy5wYWdlVHJhY2tpbmcudHJhY2tSZWxhdGl2ZVBhdGggPSB0cnVlO1xuXG4gICAgdGhpcy5hbmd1bGFydGljczIucGFnZVRyYWNrLnN1YnNjcmliZSgoeDogYW55KSA9PiB0aGlzLnBhZ2VUcmFjayh4LnBhdGgpKTtcblxuICAgIHRoaXMuYW5ndWxhcnRpY3MyLmV2ZW50VHJhY2suc3Vic2NyaWJlKCh4OiBhbnkpID0+IHRoaXMuZXZlbnRUcmFjayh4LmFjdGlvbiwgeC5wcm9wZXJ0aWVzKSk7XG5cbiAgICB0aGlzLmFuZ3VsYXJ0aWNzMi5zZXRVc2VyUHJvcGVydGllcy5zdWJzY3JpYmUoKHg6IGFueSkgPT4gdGhpcy5zZXRVc2VyUHJvcGVydGllcyh4KSk7XG4gIH1cblxuICBwYWdlVHJhY2socGF0aDogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBzICE9PSAndW5kZWZpbmVkJyAmJiBzKSB7XG4gICAgICBzLmNsZWFyVmFycygpO1xuICAgICAgcy50KHtwYWdlTmFtZTpwYXRofSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYWNrIEV2ZW50IGluIEFkb2JlIEFuYWx5dGljc1xuICAgKiBAbmFtZSBldmVudFRyYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24gUmVxdWlyZWQgJ2FjdGlvbicgKHN0cmluZykgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcGVydGllcyBDb21wcmlzZWQgb2YgdGhlIG1hbmRhdG9yeSBmaWVsZCAnY2F0ZWdvcnknIChzdHJpbmcpIGFuZCBvcHRpb25hbCAgZmllbGRzICdsYWJlbCcgKHN0cmluZyksICd2YWx1ZScgKGludGVnZXIpIGFuZCAnbm9uaW50ZXJhY3Rpb24nIChib29sZWFuKVxuICAgKlxuICAgKiBAbGluayBodHRwczovL21hcmtldGluZy5hZG9iZS5jb20vcmVzb3VyY2VzL2hlbHAvZW5fVVMvc2MvaW1wbGVtZW50L2pzX2ltcGxlbWVudGF0aW9uLmh0bWxcbiAgICovXG4gIGV2ZW50VHJhY2soYWN0aW9uOiBzdHJpbmcsIHByb3BlcnRpZXM6IGFueSkge1xuICAgIGlmICghcHJvcGVydGllcykge1xuICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzICE9PSAndW5kZWZpbmVkJyAmJiBzKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BlcnRpZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRoaXMuc2V0VXNlclByb3BlcnRpZXMocHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgIC8vIGlmIGxpbmtOYW1lIHByb3BlcnR5IGlzIHBhc3NlZCwgdXNlIHRoYXQ7IG90aGVyd2lzZSwgdGhlIGFjdGlvbiBpcyB0aGUgbGlua05hbWVcbiAgICAgICAgY29uc3QgbGlua05hbWUgPSAocHJvcGVydGllc1snbGlua05hbWUnXSkgPyBwcm9wZXJ0aWVzWydsaW5rTmFtZSddIDogYWN0aW9uO1xuICAgICAgICAvLyBub3RlIHRoYXQgJ3RoaXMnIHNob3VsZCByZWZlciB0aGUgbGluayBlbGVtZW50LCBidXQgd2UgY2FuJ3QgZ2V0IHRoYXQgaW4gdGhpcyBmdW5jdGlvbi4gZXhhbXBsZTpcbiAgICAgICAgLy8gPGEgaHJlZj1cImh0dHA6Ly9hbm90aGVyc2l0ZS5jb21cIiBvbmNsaWNrPVwicy50bCh0aGlzLCdlJywnQW5vdGhlclNpdGUnLG51bGwpXCI+XG4gICAgICAgIC8vIGlmIGRpc2FibGVEZWxheSBwcm9wZXJ0eSBpcyBwYXNzZWQsIHVzZSB0aGF0IHRvIHR1cm4gb2ZmL29uIHRoZSA1MDBtcyBkZWxheTsgb3RoZXJ3aXNlLCBpdCB1c2VzIHRoaXNcbiAgICAgICAgY29uc3QgZGlzYWJsZURlbGF5ID0gISFwcm9wZXJ0aWVzWydkaXNhYmxlRGVsYXknXSA/IHRydWUgOiB0aGlzO1xuICAgICAgICAvLyBpZiBhY3Rpb24gcHJvcGVydHkgaXMgcGFzc2VkLCB1c2UgdGhhdDsgb3RoZXJ3aXNlLCB0aGUgYWN0aW9uIHJlbWFpbnMgdW5jaGFuZ2VkXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzWydhY3Rpb24nXSkge1xuICAgICAgICAgIGFjdGlvbiA9IHByb3BlcnRpZXNbJ2FjdGlvbiddO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0UGFnZU5hbWUoKTtcblxuICAgICAgICBpZiAoYWN0aW9uLnRvVXBwZXJDYXNlKCkgPT09IFwiRE9XTkxPQURcIikge1xuICAgICAgICAgIHMudGwoZGlzYWJsZURlbGF5LCdkJyxsaW5rTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uLnRvVXBwZXJDYXNlKCkgPT09IFwiRVhJVFwiKSB7XG4gICAgICAgICAgcy50bChkaXNhYmxlRGVsYXksJ2UnLGxpbmtOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzLnRsKGRpc2FibGVEZWxheSwnbycsbGlua05hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRQYWdlTmFtZSgpIHtcbiAgICBjb25zdCBwYXRoID0gdGhpcy5sb2NhdGlvbi5wYXRoKHRydWUpO1xuICAgIGNvbnN0IGhhc2hOZHggPSBwYXRoLmluZGV4T2YoJyMnKTtcbiAgICBpZiAoaGFzaE5keCA+IDAgJiYgaGFzaE5keCA8IHBhdGgubGVuZ3RoKSB7XG4gICAgICBzLnBhZ2VOYW1lID0gcGF0aC5zdWJzdHJpbmcoaGFzaE5keCsxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcy5wYWdlTmFtZSA9IHBhdGg7XG4gICAgfVxuICB9XG5cbiAgc2V0VXNlclByb3BlcnRpZXMocHJvcGVydGllczogYW55KSB7XG4gICAgaWYgKHR5cGVvZiBzICE9PSAndW5kZWZpbmVkJyAmJiBzKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BlcnRpZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgc1trZXldID0gcHJvcGVydGllc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdHNsaW50LWxvYWRlciEuL3NyYy9wcm92aWRlcnMvYWRvYmVhbmFseXRpY3MvYW5ndWxhcnRpY3MyLWFkb2JlYW5hbHl0aWNzLnRzIl0sInNvdXJjZVJvb3QiOiIifQ==